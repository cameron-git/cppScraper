<!DOCTYPE html><html><head><link rel="stylesheet" href="style.css"></head><body><header><h1 class="entry-title singular-title" itemprop="headline">0.1 — Introduction to these tutorials</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Welcome!</h3><p>Welcome to the Learn C++ tutorials! Above all else, these tutorials aim to make learning C++ easy.</p><p>Unlike many other sites and books, these tutorials don’t assume you have any prior programming experience. We’ll teach you everything you need to know as you progress, with <em>lots</em> of examples along the way.</p><p>Whether you’re interested in learning C++ as a hobby or for professional development, you’re in the right place!</p><p></p><p style="clear:both"></p><br>A testimonial from reader Syam from Trinidad:<blockquote><p>It’s crazy how perfect this website explains C++ concepts and teaches programming. I read the book “Programming: Principles and Practice Using C++” [by Bjarne Stroustrup, the creator of C++] and it was rather confusing…. This website makes it clear the first time, and they explain everything you need to know. Somehow they know what I don’t know, and what I need to know. It’s almost like my future self went back in the past to teach me what mistakes I will make.</p></blockquote><br><h3>Lesson structure</h3><p>The lessons in this introductory chapter are aimed at giving you some context around what C++ is, how it came about, how programs work, and what software you need to install to create your own programs. You’ll even write your own first program.</p><p>Further chapters will explore different parts of the C++ language. In the first chapter (chapter 1), you’ll get a broad but shallow overview of many fundamental C++ concepts, so we can start writing some simple programs. Further chapters will explore those concepts in depth, or introduce new concepts.</p><p>Each chapter has a theme, with all of the sections underneath it being generally related to that theme. There is no suggested amount of time that you should spend with each lesson or chapter; progress through the material at a pace that is comfortable for you.</p><br><h3>Goals</h3><p>Before we get started, let’s cover a few important goals for these tutorials:</p><ul><li>Cover programming topics as well as C++. Traditional textbooks do a pretty good job of teaching the basics of a given programming language, but they often do not cover relevant programming topics that are incidental to the language. For example, books will omit sections on programming style, common pitfalls, debugging, good/bad programming practices, and testing. Consequently, by the time you finish the book, you may understand how to program in a language, but you might also have picked up bad habits that will come back to bite you later! One of the goals of these tutorials is to make sure that all of these incidental topics are covered along the way, in the sections where it naturally makes sense to discuss them. When you finish, you will not only know how to program in C++, you will know how NOT to program in C++, which is arguably as important.<p></p></li><li>Provide a lot of examples. Most people learn as much or more from following the examples as they do from reading the text. These tutorials will endeavor to provide plenty of clear, concise examples to show the application of concepts you are learning. We will also avoid (as much as possible) the twin evils: the <em>ellipses</em> (also known as <em>…</em>), where a necessary or non-obvious part of an example is omitted in the interest of space, and the <em>unexplained new concept</em>, where a new concept that is integral to the example is introduced without any mention of what it is or how it works. Both of these tend to lead to getting stuck.<p></p></li><li>Provide practice programs. The end of many lessons and sections will contain some exercises that you can attempt to answer on your own, along with solutions. You can compare your solution against ours to see what we did differently, or, if you get stuck, how we solved the problem. Then you can go back and refocus on the areas you need more work on.<p></p></li><li>Most importantly: have fun. Programming can be a lot of fun, and if you’re not generally having fun, you’re not in the right mindset to be programming. Tired or unhappy programmers make mistakes, and debugging code tends to take much longer than writing it correctly in the first place! Often you can save yourself some time by going to bed, getting a good night’s sleep, and coming back to a problem in the morning.</li></ul><br><h3>Getting the most out of these tutorials</h3><p>As you go through these tutorials, we recommend a number of practices to maximize your learning experience:</p><ul><li>Type in the examples <em>by hand</em> and compile them yourself. Do not copy and paste them! This will help you learn where you commonly make errors, as well as becoming familiar with compiler warnings and errors. Don’t just transcribe the programs mindlessly -- think about what each of the lines you are typing in does, and how it contributes to the overall program. If you encounter anything that you don’t understand, that’s something to investigate further.<p></p></li><li>As you make mistakes or find bugs in your programs, fix them. Try to solve your own problems before asking others for help. Learning how to find and fix errors is a key skill to successful programming. Don’t neglect learning how to use a debugger (we’ll explain how in a future chapter) -- it’s a key tool in figuring out where your programs are going wrong.<p></p></li><li>Experiment with the examples. Change numbers and text to see what happens. Modify the programs to do additional things (e.g. if a program adds two numbers, make it add three numbers). Try to find different ways to break the programs (if a program asks you to enter a number, try entering a letter instead and see what happens). You’ll learn more by modifying the examples than by simply following them.<p></p></li><li>Plan to spend some time with the quizzes. If you’re new to programming, you may find these challenging (and that’s normal, as your brain acclimates to the programming mindset). Don’t be discouraged if you don’t get the right answer the first time. You may need to try several different approaches before you find a path to success. It’s okay to look at the answer if you’re really stuck. Just make sure you understand how the provided answer works before proceeding.<p></p></li><li>Write your own short programs using the concepts you have learned. This will reinforce your learning and improve your retention.</li></ul><br><h3>Common site-related questions </h3><div class="cpp-note cpp-lightbluebackground"><h4>Q: How do I sign up for the site? How do I get a login?</h4><p>All parts of this site are accessible anonymously -- therefore, no user account or signup is needed!</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Q: Is there a PDF version of this site available for offline viewing?</h4><p>Unfortunately, there is not. The site is able to stay free for everyone because we’re ad-sponsored -- that model simply doesn’t work in PDF format. You are welcome to convert pages from this website into PDF (or any other) format for your own private use, so long as you do not distribute them.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Q: What should I do if I get stuck on a concept?</h4><p>If you don’t understand something or feel stuck:</p><ul><li>Read through the comments. Other readers may have encountered similar challenges.</li><li>Scan through the next lesson or two in the series -- your question may be answered there.</li><li>Use a search engine to see if your question (or error message) has been addressed elsewhere.</li><li>Ask your question on a site that is designed for programming Q&amp;A, like <a href="https://stackoverflow.com/">Stack Overflow</a>.</li></ul><p>If all else fails, skip the material you don’t understand, and come back to it later. You may find that something that was hard to understand is easier with the additional knowledge and context provided by other articles.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Q: What do I do if I forget what something means?</h4><p>Use the <a href="/learn-c-site-index/">Site index</a>. Look up any topics you want to know more about there, and you’ll find links to the lessons where that topic is discussed.</p></div><p></p><div class="cpp-note cpp-lightbluebackground"><h4>Q: Are there any similar sites for other languages?</h4><p>Nope. That would require being able to clone myself a few times.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Q: Can you do a dark mode for this site?</h4><p>Not easily, but you can! See <a href="https://darkreader.org/">darkreader.org</a>.</p></div><p>Finally, one small nag: This site is free because it is ad-supported. If you find yourself enjoying the lessons, please consider disabling your ad blocker.</p><p>Alright, let’s get on with it!</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">0.2 — Introduction to programming languages</h1></header><div class="entry-content" itemprop="articleBody"><p>Modern computers are incredibly fast, and getting faster all the time. However, computers also have some significant constraints: they only natively understand a limited set of commands, and must be told exactly what to do.</p><p>A <span class="cpp-definition">computer program</span> (also commonly called an <span class="cpp-definition">application</span>) is a set of instructions that the computer can perform in order to perform some task. The process of creating a program is called <span class="cpp-definition">programming</span>. Programmers typically create programs by producing <span class="cpp-definition">source code</span> (commonly shortened to <span class="cpp-definition">code</span>), which is a list of commands typed into one or more text files.</p><p>The collection of physical computer parts that make up a computer and execute programs is called the <span class="cpp-definition">hardware</span>. When a computer program is loaded into memory and the hardware sequentially executes each instruction, this is called <span class="cpp-definition">running</span> or <span class="cpp-definition">executing</span> the program.</p><br><h3>Machine Language</h3><p>A computer’s CPU is incapable of speaking C++. The limited set of instructions that a CPU can understand directly is called <span class="cpp-definition">machine code</span> (or <span class="cpp-definition">machine language</span> or an <span class="cpp-definition">instruction set</span>).</p><p>Here is a sample machine language instruction: <code>10110000 01100001</code></p><p>Back when computers were first invented, programmers had to write programs directly in machine language, which was a very difficult and time consuming thing to do.</p><p>How these instructions are organized is beyond the scope of this introduction, but it is interesting to note two things. First, each instruction is composed of a sequence of 1s and 0s. Each individual 0 or 1 is called a <span class="cpp-definition">binary digit</span>, or <span class="cpp-definition">bit</span> for short. The number of bits that make up a single command vary -- for example, some CPUs process instructions that are always 32 bits long, whereas some other CPUs (such as the x86 family, which you are likely using) have instructions that can be a variable length.</p><p>Second, each set of binary digits is interpreted by the CPU into a command to do a very specific job, such as <em>compare these two numbers</em>, or <em>put this number in that memory location</em>. However, because different CPUs have different instruction sets, instructions that were written for one CPU type could not be used on a CPU that didn’t share the same instruction set. This meant programs generally weren’t <span class="cpp-definition">portable</span> (usable without major rework) to different types of system, and had to be written all over again.</p><br><h3>Assembly Language</h3><p>Because machine language is so hard for humans to read and understand, assembly language was invented. In an assembly language, each instruction is identified by a short abbreviation (rather than a set of bits), and names and other numbers can be used.</p><p>Here is the same instruction as above in assembly language: <code>mov al, 061h</code></p><p>This makes assembly much easier to read and write than machine language. However, the CPU can not understand assembly language directly. Instead, the assembly program must be translated into machine language before it can be executed by the computer. This is done by using a program called an <span class="cpp-definition">assembler</span>. Programs written in assembly languages tend to be very fast, and assembly is still used today when speed is critical.</p><p>However, assembly still has some downsides. First, assembly languages still require a lot of instructions to do even simple tasks. While the individual instructions themselves are somewhat human readable, understanding what an entire program is doing can be challenging (it’s a bit like trying to understand a sentence by looking at each letter individually). Second, assembly language still isn’t very portable -- a program written in assembly for one CPU will likely not work on hardware that uses a different instruction set, and would have to be rewritten or extensively modified.</p><br><h3>High-level Languages</h3><p>To address the readability and portability concerns, new programming languages such as C, C++, Pascal (and later, languages such as Java, Javascript, and Perl) were developed. These languages are called <span class="cpp-definition">high level languages</span>, as they are designed to allow the programmer to write programs without having to be as concerned about what kind of computer the program will be run on.</p><p>Here is the same instruction as above in C/C++: <code>a = 97;</code></p><p>Much like assembly programs, programs written in high level languages must be translated into a format the computer can understand before they can be run. There are two primary ways this is done: compiling and interpreting.</p><p>A <span class="cpp-definition">compiler</span> is a program that reads source code and produces a stand-alone executable program that can then be run. Once your code has been turned into an executable, you do not need the compiler to run the program. In the beginning, compilers were primitive and produced slow, unoptimized code. However, over the years, compilers have become very good at producing fast, optimized code, and in some cases can do a better job than humans can in assembly language!</p><p>Here is a simplified representation of the compiling process:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/Compiling-min.png" alt="Example of compiling" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/Compiling-min.png"></div><p>Since C++ programs are generally compiled, we’ll explore compilers in more detail shortly.</p><p>An <span class="cpp-definition">interpreter</span> is a program that directly executes the instructions in the source code without requiring them to be compiled into an executable first. Interpreters tend to be more flexible than compilers, but are less efficient when running programs because the interpreting process needs to be done every time the program is run. This means the interpreter is needed every time the program is run.</p><p>Here is a simplified representation of the interpretation process:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/Interpreting-min.png" alt="Example of interpreting" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/Interpreting-min.png"></div><div class="cpp-note cpp-lightgraybackground"><h4>Optional reading</h4><p>A good comparison of the advantages of compilers vs interpreters can be found <a href="https://stackoverflow.com/a/38491646">here</a>.</p></div><p>Most languages can be compiled or interpreted, however, traditionally languages like C, C++, and Pascal are compiled, whereas “scripting” languages like Perl and Javascript tend to be interpreted. Some languages, like Java, use a mix of the two.</p><p>High level languages have many desirable properties.</p><p>First, high level languages are much easier to read and write because the commands are closer to natural language that we use every day. Second, high level languages require fewer instructions to perform the same task as lower level languages, making programs more concise and easier to understand. In C++ you can do something like <code>a = b * 2 + 5;</code> in one line. In assembly language, this would take 5 or 6 different instructions.</p><p>Third, programs can be compiled (or interpreted) for many different systems, and you don’t have to change the program to run on different CPUs (you just recompile for that CPU). As an example:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/Portability-min.png" alt="Example of portability" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/Portability-min.png"></div><p>There are two general exceptions to portability. The first is that many operating systems, such as Microsoft Windows, contain platform-specific capabilities that you can use in your code. These can make it much easier to write a program for a specific operating system, but at the expense of portability. In these tutorials, we will avoid any platform specific code.</p><p>Some compilers also support compiler-specific extensions -- if you use these, your programs won’t be able to be compiled by other compilers that don’t support the same extensions without modification. We’ll talk more about these later, once you’ve installed a compiler.</p><br><h3>Rules, Best practices, and warnings</h3><p>As we proceed through these tutorials, we’ll highlight many important points under the following three categories:</p><div class="cpp-note cpp-lightgreenbackground"><h4>Rule</h4><p>Rules are instructions that you <em>must</em> do, as required by the language. Failure to abide by a rule will generally result in your program not working.</p></div><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Best practices are things that you <em>should</em> do, because that way of doing things is generally considered a standard or highly recommended. That is, either everybody does it that way (and if you do otherwise, you’ll be doing something people don’t expect), or it is superior to the alternatives.</p></div><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Warnings are things that you <em>should not</em> do, because they will generally lead to unexpected results.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">0.3 — Introduction to C/C++</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Before C++, there was C</h3><p>The C language was developed in 1972 by Dennis Ritchie at Bell Telephone laboratories, primarily as a systems programming language (a language to write operating systems with). Ritchie’s primary goals were to produce a minimalistic language that was easy to compile, allowed efficient access to memory, produced efficient code, and was self-contained (not reliant on other programs). For a high-level language, it was designed to give the programmer a lot of control, while still encouraging platform (hardware and operating system) independence (that is, the code didn’t have to be rewritten for each platform).</p><p>C ended up being so efficient and flexible that in 1973, Ritchie and Ken Thompson rewrote most of the Unix operating system using C. Many previous operating systems had been written in assembly. Unlike assembly, which produces programs that can only run on specific CPUs, C has excellent portability, allowing Unix to be easily recompiled on many different types of computers and speeding its adoption. C and Unix had their fortunes tied together, and C’s popularity was in part tied to the success of Unix as an operating system.</p><p>In 1978, Brian Kernighan and Dennis Ritchie published a book called “The C Programming Language”. This book, which was commonly known as K&amp;R (after the authors’ last names), provided an informal specification for the language and became a de facto standard. When maximum portability was needed, programmers would stick to the recommendations in K&amp;R, because most compilers at the time were implemented to K&amp;R standards.</p><p>In 1983, the American National Standards Institute (ANSI) formed a committee to establish a formal standard for C. In 1989 (committees take forever to do anything), they finished, and released the C89 standard, more commonly known as ANSI C. In 1990 the International Organization for Standardization (ISO) adopted ANSI C (with a few minor modifications). This version of C became known as C90. Compilers eventually became ANSI C/C90 compliant, and programs desiring maximum portability were coded to this standard.</p><p>In 1999, the ANSI committee released a new version of C called C99. C99 adopted many features which had already made their way into compilers as extensions, or had been implemented in C++.</p><br><h3>C++</h3><p>C++ (pronounced see plus plus) was developed by Bjarne Stroustrup at Bell Labs as an extension to C, starting in 1979. C++ adds many new features to the C language, and is perhaps best thought of as a superset of C, though this is not strictly true (as C99 introduced a few features that do not exist in C++). C++’s claim to fame results primarily from the fact that it is an object-oriented language. As for what an “object” is and how it differs from traditional programming methods, well, we’ll cover that in later chapters.</p><p>C++ was standardized in 1998 by the ISO committee (this means the ISO standards committee approved a document describing the C++ language, to help ensure all compilers adhere to the same set of standards). A minor update to the language was released in 2003 (called C++03).</p><p>Four major updates to the C++ language (C++11, C++14, C++17, and C++20) have been made since then, each adding additional functionality. C++11 in particular added a huge number of new capabilities, and is widely considered to be the new baseline version of the language. Future upgrades to the language are expected every three or so years, with the feature set for C++23 already starting to be formulated.</p><p>Each new formal release of the language is called a <span class="cpp-definition">language standard</span> (or <span class="cpp-definition">language specification</span>). Standards are named after the year they are released in. For example, there is no C++15, because there was no new standard in 2015.</p><br><h3>C and C++’s philosophy</h3><p>The underlying design philosophy of C and C++ can be summed up as “trust the programmer” -- which is both wonderful and dangerous. C++ is designed to allow the programmer a high degree of freedom to do what they want. However, this also means the language often won’t stop you from doing things that don’t make sense, because it will assume you’re doing so for some reason it doesn’t understand. There are quite a few pitfalls that new programmers are likely to fall into if caught unaware. This is one of the primary reasons why knowing what you shouldn’t do in C/C++ is almost as important as knowing what you should do.</p><div class="cpp-note cpp-lightbluebackground"><h4>Q: What is C++ good at?</h4><p>C++ excels in situations where high performance and precise control over memory and other resources is needed. Here are a few common types of applications that most likely would be written in C++:</p><ul><li>Video games</li><li>Real-time systems (e.g. for transportation, manufacturing, etc…)</li><li>High-performance financial applications (e.g. high frequency trading)</li><li>Graphical applications and simulations</li><li>Productivity / office applications</li><li>Embedded software</li><li>Audio and video processing</li><li>Artificial intelligence and neural networks</li></ul></div><div class="cpp-note cpp-lightbluebackground"><h4>Q: Do I need to know C before I do these tutorials?</h4><p>Nope! It’s perfectly fine to start with C++, and we’ll teach you everything you need to know (including pitfalls to avoid) along the way.</p><p>Once you know C++, it should be pretty easy to learn standard C if you ever have the need. These days, C is mostly used for niche use cases: code that runs on embedded devices, when you need to interact with other languages that can only interface with C, etc… For most other cases, C++ is recommended.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">0.4 — Introduction to C++ development</h1></header><div class="entry-content" itemprop="articleBody"><p>Before we can write and execute our first C++ program, we need to understand in more detail how C++ programs get developed. Here is a graphic outlining a simplistic approach:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/Development-min.png?ezimgfmt=rs%3Adevice%2Frscb2-1" alt="The software development process" ezimgfmt="rs rscb2 src ng ngcb2" loading="eager" srcset="" sizes="" importance="high"></div><br><h3>Step 1: Define the problem that you would like to solve</h3><p>This is the “what” step, where you figure out what problem you are intending to solve. Coming up with the initial idea for what you would like to program can be the easiest step, or the hardest. But conceptually, it is the simplest. All you need is an idea that can be well defined, and you’re ready for the next step.</p><p>Here are a few examples:</p><ul><li>“I want to write a program that will allow me to enter many numbers, then calculates the average.”</li><li>“I want to write a program that generates a 2d maze and lets the user navigate through it. The user wins if they reach the end.”</li><li>“I want to write a program that reads in a file of stock prices and predicts whether the stock will go up or down.”</li></ul><br><h3>Step 2: Determine how you are going to solve the problem</h3><p>This is the “how” step, where you determine how you are going to solve the problem you came up with in step 1. It is also the step that is most neglected in software development. The crux of the issue is that there are many ways to solve a problem -- however, some of these solutions are good and some of them are bad. Too often, a programmer will get an idea, sit down, and immediately start coding a solution. This often generates a solution that falls into the bad category.</p><p>Typically, good solutions have the following characteristics:</p><ul><li>They are straightforward (not overly complicated or confusing).</li><li>They are well documented (especially around any assumptions being made or limitations).</li><li>They are built modularly, so parts can be reused or changed later without impacting other parts of the program.</li><li>They are robust, and can recover or give useful error messages when something unexpected happens.</li></ul><p>When you sit down and start coding right away, you’re typically thinking “I want to do &lt;something&gt;”, so you implement the solution that gets you there the fastest. This can lead to programs that are fragile, hard to change or extend later, or have lots of <span class="cpp-definition">bugs</span> (technical defects).</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>The term <em>bug</em> was first used by Thomas Edison back in the 1870s! However, the term was popularized in the 1940s when engineers found an actual moth stuck in the hardware of an early computer, causing a short circuit. Both the log book in which the error was reported and the moth are now part of the Smithsonian Museum of American History. It can be viewed <a href="https://americanhistory.si.edu/collections/search/object/nmah_334663">here</a>.</p></div><p>Studies have shown that only 20% of a programmer’s time is actually spent writing the initial program. The other 80% is spent on maintenance, which can consist of <span class="cpp-definition">debugging</span> (removing bugs), updates to cope with changes in the environment (e.g. to run on a new OS version), enhancements (minor changes to improve usability or capability), or internal improvements (to increase reliability or maintainability).</p><p>Consequently, it’s worth your time to spend a little extra time up front (before you start coding) thinking about the best way to tackle a problem, what assumptions you are making, and how you might plan for the future, in order to save yourself a lot of time and trouble down the road.</p><p>We’ll talk more about how to effectively design solutions to problems in a future lesson.</p><br><h3>Step 3: Write the program</h3><p>In order to write the program, we need two things: First, we need knowledge of a programming language -- that’s what these tutorials are for! Second, we need a text editor to write and save our written programs. The programs we write using C++ instructions are called <span class="cpp-definition">source code</span> (often shortened to just <span class="cpp-definition">code</span>). It’s possible to write a program using any text editor you want, even something as simple as Windows’ notepad or Unix’s vi or pico. However, we strongly urge you to use an editor that is designed for programming (called a <span class="cpp-definition">code editor</span>). Don’t worry if you don’t have one yet. We’ll cover how to install a code editor shortly.</p><p>A typical editor designed for coding has a few features that make programming much easier, including:</p><ol start="1"><li>Line numbering. Line numbering is useful when the compiler gives us an error, as a typical compiler error will state: <em>some error code/message, line 64</em>. Without an editor that shows line numbers, finding line 64 can be a real hassle.</li><li>Syntax highlighting and coloring. Syntax highlighting and coloring changes the color of various parts of your program to make it easier to identify the different components of your program. Here’s an example of a C++ program with both line numbering and syntax highlighting:</li></ol><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Colored text!";</code><code>    return 0;</code><code>}</code></pre><p>The examples we show in this tutorial will always have both line numbering and syntax highlighting to make them easier to follow.</p><ol start="3"><li>An unambiguous font. Non-programming fonts often make it hard to distinguish between the number 0 and the letter O, or between the number 1, the letter l (lower case L), and the letter I (upper case i). A good programming font will ensure these symbols are visually differentiated in order to ensure one isn’t accidentally used in place of the other. All code editors should have this enabled by default, but a standard text editor might not.</li></ol><p>The programs you write will typically be named <em>something.cpp</em>, where <em>something</em> is replaced with the name of your choosing for the program (e.g. calculator, hi-lo, etc…). The <em>.cpp</em> extension tells the compiler (and you) that this is a C++ source code file that contains C++ instructions. Note that some people use the extension .cc instead of .cpp, but we recommend you use .cpp.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Name your code files <em>something.cpp</em>, where <em>something</em> is a name of your choosing, and <em>.cpp</em> is the extension that indicates the file is a C++ source file.</p></div><p>Also note that many complex C++ programs have multiple .cpp files. Although most of the programs you will be creating initially will only have a single .cpp file, it is possible to write single programs that have tens or hundreds of .cpp files.</p><p>Once we’ve written our program, the next steps are to convert the source code into something that we can run, and then see whether it works! We’ll discuss those steps (4-7) in the next lesson.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">0.5 — Introduction to the compiler, linker, and libraries</h1></header><div class="entry-content" itemprop="articleBody"><p>Continuing our discussion of this diagram from the previous lesson (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-cpp-development/">0.4 -- Introduction to C++ development</a>):</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/Development-min.png?ezimgfmt=rs%3Adevice%2Frscb2-1" alt="The software development process" ezimgfmt="rs rscb2 src ng ngcb2" loading="eager" srcset="" sizes="" importance="high"></div><p>Let’s discuss steps 4-7.</p><br><h3>Step 4: Compiling your source code</h3><p>In order to compile a C++ program, we use a C++ compiler. The C++ compiler sequentially goes through each source code (.cpp) file in your program and does two important tasks:</p><p>First, it checks your code to make sure it follows the rules of the C++ language. If it does not, the compiler will give you an error (and the corresponding line number) to help pinpoint what needs fixing. The compilation process will also be aborted until the error is fixed.</p><p>Second, it translates your C++ source code into a machine language file called an <span class="cpp-definition">object file</span>. Object files are typically named <em>name.o</em> or <em>name.obj</em>, where <em>name</em> is the same name as the .cpp file it was produced from.</p><p>If your program had 3 .cpp files, the compiler would generate 3 object files:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/CompileSource-min.png" alt="The compilation process" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/CompileSource-min.png"></div><p>C++ compilers are available for many different operating systems. We will discuss installing a compiler shortly, so there is no need to do so now.</p><br><h3>Step 5: Linking object files and libraries</h3><p>After the compiler creates one or more object files, then another program called the <span class="cpp-definition">linker</span> kicks in. The job of the linker is three fold:</p><p>First, to take all the object files generated by the compiler and combine them into a single executable program.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/LinkingObjects-min.png" alt="The linking process" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/LinkingObjects-min.png"></div><p>Second, in addition to being able to link object files, the linker also is capable of linking library files. A <span class="cpp-definition">library file</span> is a collection of precompiled code that has been “packaged up” for reuse in other programs.</p><p>The C++ core language is actually fairly small and concise (and you’ll learn much of it in these tutorials). However, C++ also comes with an extensive library called the <span class="cpp-definition">C++ Standard Library</span> (usually shortened to <em>standard library</em>) that provides additional functionality that you can use in your programs. One of the most commonly used parts of the C++ standard library is the <em>iostream library</em>, which contains functionality for printing text on a monitor and getting keyboard input from a user. Almost every C++ program written utilizes the standard library in some form, so it’s very common for the standard library to get linked into your programs. Most linkers will automatically link in the standard library as soon as you use any part of it, so this generally isn’t something you need to worry about.</p><p>You can also optionally link in other libraries. For example, if you were going to write a program that played sounds, you probably would not want to write your own code to read in the sound files from disk, check to ensure they were valid, or figure out how to route the sound data to the operating system or hardware to play through the speaker -- that would be a lot of work! Instead, you’d probably download a library that already knew how to do those things, and use that. We’ll talk about how to link in libraries (and create your own!) in the appendix.</p><p>Third, the linker makes sure all cross-file dependencies are resolved properly. For example, if you define something in one .cpp file, and then use it in another .cpp file, the linker connects the two together. If the linker is unable to connect a reference to something with its definition, you’ll get a linker error, and the linking process will abort.</p><p>Once the linker is finished linking all the object files and libraries (assuming all goes well), you will have an executable file that you can then run!</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>For complex projects, some development environments use a <strong>makefile</strong>, which is a file that describes how to build a program (e.g. which files to compile and link, or otherwise process in various ways). Entire books have been written about how to write and maintain makefiles, and they can be an incredibly powerful tool. However, because makefiles are not part of the C++ core language, nor do you need to use them to proceed, we’ll not discuss them as part of this tutorial series.</p></div><br><h3>Steps 6 &amp; 7: Testing and Debugging</h3><p>This is the fun part (hopefully)! You are able to run your executable and see whether it produces the output you were expecting!</p><p>If your program runs but doesn’t work correctly, then it’s time for some debugging to figure out what’s wrong. We will discuss how to test your programs and how to debug them in more detail soon.</p><br><h3>Integrated development environments (IDEs)</h3><p>Note that steps 3, 4, 5, and 7 all involve software (editor, compiler, linker, debugger). While you can use separate programs for each of these activities, a software package known as an integrated development environment (IDE) bundles and integrates all of these features together. We’ll discuss IDEs, and install one, in the next section.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">0.6 — Installing an Integrated Development Environment (IDE)</h1></header><div class="entry-content" itemprop="articleBody"><p>An <span class="cpp-definition">Integrated Development Environment (IDE)</span> is a piece of software that contains all of the things you need to develop, compile, link, and debug your programs.</p><p>With a typical C++ IDE, you get a code editor that does line numbering and syntax highlighting. Many (but not all) IDEs include a C++ compiler and a linker, which the IDE will know how to interface with in order to convert your source code into an executable file. And when you need to debug your program, you can use the integrated debugger.</p><p>Furthermore, IDEs typically bundle a number of other helpful editing features, such as integrated help, name completion, auto-formatting, and sometimes a version control system. So while you could do all of these things separately, it’s much easier to install an IDE and have them all accessible from a single interface.</p><p>So let’s install one! The obvious next question is, “which one?”. Many IDEs are free (in price), and you can install multiple IDEs if you wish, so there’s no “wrong decision” to be made here. We’ll recommend a few of our favorites below.</p><p>If you have some other IDE in mind, that’s fine too. The concepts we show you in these tutorials should generally work for any decent modern IDE. However, various IDEs use different names, layouts, key mappings, etc… so you may have to do a bit of searching in your IDE to find the equivalent functionality.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>To get the most value of this tutorial, we recommend installing an IDE that comes with a C++17 capable compiler.</p><p>If you’re restricted to using a compiler that only supports C++14 or C++11 (due to educational or business constraints), most of the lessons and examples will still work. However, if you encounter a lesson that uses concepts from C++17 (or newer) and you’re using an older language compiler, you’ll have to skip it or translate it to your version, which may or may not be easy.</p><p>You should not be using any compiler that does not support at least C++11 (which is typically considered the modern minimum spec for C++).</p><p></p><p>We recommend installing the newest version of a compiler. If you can’t use the newest version, these are the absolute minimum compiler versions with C++17 support:</p><ul><li>GCC/G++ 7</li><li>clang++ 8</li><li>Visual Studio 2017 15.7</li></ul></div><br><h3>Visual Studio (for Windows)</h3><p>If you are developing on a Windows 10 machine, then we strongly recommend downloading <a href="https://www.visualstudio.com/downloads/">Visual Studio 2022 Community</a>.</p><p>Once you run the installer, you’ll eventually come to a screen that asks you what workload you’d like to install. Choose <em>Desktop development with C++</em>. If you do not do this, then C++ capabilities will not be available.</p><p>The default options selected on the right side of the screen should be fine, but please ensure that the <em>Windows 10 SDK</em> is selected.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/VS2019-Installer-min.png?ezimgfmt=rs%3Adevice%2Frscb2-1" alt="Visual Studio Workload" ezimgfmt="rs rscb2 src ng ngcb2" loading="eager" srcset="" sizes="" importance="high"></div><p>If disk space and/or download size are a challenge, then Microsoft still offers <a href="https://visualstudio.microsoft.com/vs/express/">Visual Studio Express 2017 for Windows Desktop</a>, which you can find towards the bottom of the page. Microsoft is no longer supporting this product and it doesn’t have many of the newer C++ language capabilities, so we only suggest it for users who can not install Visual Studio Community.</p><br><h3>Code::Blocks (for Linux or Windows)</h3><p>If you are developing on Linux (or you are developing on Windows but want to write programs that you can easily port to Linux), we recommend <a href="https://www.codeblocks.org/downloads/binaries/">Code::Blocks</a>. Code::Blocks is a free, open source, cross-platform IDE that will run on both Linux and Windows.</p><div class="cpp-note cpp-lightyellowbackground"><h4>For Windows users</h4><p>Make sure to get the version of Code::Blocks that has MinGW bundled (it should be the one whose filename ends in <em>mingw-setup.exe</em>). This will install MinGW, which includes a Windows port of the GCC C++ compiler:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/ide/CB-MinGWDownload-min.png" alt="Code::Blocks MinGW Windows download" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/ide/CB-MinGWDownload-min.png"></div></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Linux users</h4><p>Some Linux installations may be missing dependencies needed to run or compile programs with Code::Blocks.</p><p>Debian-based Linux users (such as those on Mint or Ubuntu) may need to install the <em>build-essential</em> package. To do so from the terminal command line, type: <code>sudo apt-get install build-essential</code>.</p><p>Arch Linux users may need to install the <em>base-devel</em> package.</p><p>Users on other Linux variants will need to determine what their equivalent package manager and packages are.</p></div><p>When you launch Code::Blocks for the first time, you may get a <em>Compilers auto-detection</em> dialog. If you do, make sure <em>GNU GCC Compiler</em> is set as the default compiler and then select the <em>OK</em> button.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/CompilersAutoDetection-min.png" alt="Compilers Auto Detection dialog" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/CompilersAutoDetection-min.png"></div><p></p><div class="cpp-note cpp-lightbluebackground"><h4>Q: What do I do if I get a "Can’t find compiler executable in your configured search paths for GNU GCC Compiler" error?</h4><p>Try the following:</p><ol><li>If you’re on Windows, make sure you’ve downloaded the version of Code::Blocks WITH MinGW. It’s the one with “mingw” in the name.</li><li>Try going to settings, compiler, and choose “reset to defaults”.</li><li>Try going to settings, compiler, toolchain executables tab, and make sure “Compiler’s installation directory” is set to the MinGW directory (e.g. C:\Program Files (x86)\CodeBlocks\MinGW).</li><li>Try doing a full uninstall, then reinstall.</li><li><a href="http://wiki.codeblocks.org/index.php/Installing_a_supported_compiler">Try a different compiler.</a></li></ol></div><br><h3>Mac OSX IDEs</h3><p>Popular Mac choices include <a href="https://developer.apple.com/xcode/">Xcode</a> (if it is available to you), or <a href="https://www.eclipse.org/">Eclipse</a>. Eclipse is not set up to use C++ by default, and you will need to install the optional C++ components.</p><p>Although Visual Studio for Mac has been released, as of Aug 2022 it does not support C++, so at this time we can not recommend it.</p><br><h3>Other compilers or platforms</h3><div class="cpp-note cpp-lightbluebackground"><h4>Q: Can I use a web-based compiler?</h4><p>Yes, for some things. While your IDE is downloading (or if you’re not sure you want to commit to installing one yet), you can continue this tutorial using a web-based compiler, such as the one at <a href="https://www.tutorialspoint.com/compile_cpp_online.php">TutorialsPoint</a>.</p><p>Web-based compilers are fine for dabbling and simple exercises. However, they are generally quite limited in functionality -- many won’t allow you to save projects, create executables, or effectively debug your programs. You’ll want to migrate to a full IDE when you can.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Q: Can I use a command-line compiler (e.g. g++ on Linux)?</h4><p>Yes, but we don’t recommend it for beginners. You’ll need to find your own editor and look up how to use it elsewhere. Using a command line debugger is not as easy as an integrated debugger, and will make debugging your programs more difficult.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Q: Can I use other code editors or IDEs, such as Eclipse, Sublime, Notepad++, or Visual Studio Code?</h4><p>Yes, but we don’t recommend it for beginners. There are many great code editors and IDEs that can be configured to support a wide variety of languages, and allow you to mix and match plugins to customize your experience however you like. However, many of these editors and IDEs require additional configuration to compile C++ programs, and there’s a lot that can go wrong during that process. For beginners, we recommend something that works out of the box, so you can spend more time learning to code and less time trying to figure out why your code editor isn’t working properly with your compiler or debugger.</p></div><br><h3>IDEs to avoid</h3><p>You should avoid the following IDEs altogether because they do not support at least C++11, do not support C++ at all, or are no longer actively supported or maintained:</p><ul><li>Borland Turbo C++ -- does not support C++11</li><li>Visual Studio for Mac -- does not support C++</li></ul><p>There is no good reason to use an outdated or unsupported compiler when lightweight, free alternatives that support modern C++ exist.</p><br><h3>When things go wrong (a.k.a. when IDE stands for “I don’t even…”)</h3><p>IDE installations seem to cause their fair share of problems. Installation might fail outright (or installation might work but the IDE will have problems when you try to use it due to a configuration issue). If you encounter such issues, try uninstalling the IDE (if it installed in the first place), reboot your machine, disable your antivirus or anti-malware temporarily, and try the installation again.</p><p>If you’re still encountering issues at this point, you have two options. The easier option is to try a different IDE. The other option is to fix the problem. Unfortunately, the causes of installation and configuration errors are varied and specific to the IDE software itself, and we’re unable to effectively advise on how to resolve such issues. In this case, we recommend copying the error message or problem you are having into your favorite search engine (such as Google or Duck Duck Go) and trying to find a forum post elsewhere from some poor soul who has inevitably encountered the same issue. Often there will be suggestions on things you can try to remedy the issue.</p><br><h3>Moving on</h3><p>Once your IDE is installed (which can be one of the hardest steps if things don’t go as expected), or if you’re temporarily proceeding with a web-based compiler, you are ready to write your first program!</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">0.7 — Compiling your first program</h1></header><div class="entry-content" itemprop="articleBody"><p>Before we can write our first program, we need to learn how to create new programs within our Integrated Development Environment (IDE). In this lesson, we’ll cover how to do that, and you’ll also compile and execute your first program!</p><br><h3>Projects</h3><p>To write a C++ program inside an IDE, we typically start by creating a new project (we’ll show you how to do this in a bit). A <span class="cpp-definition">project</span> is a container that holds all of your source code files, images, data files, etc… that are needed to produce an executable (or library, website, etc…) that you can run or use. The project also saves various IDE, compiler, and linker settings, as well as remembering where you left off, so that when you reopen the project later, the state of the IDE can be restored to wherever you left off. When you choose to compile your program, all of the .cpp files in the project will get compiled and linked.</p><p>Each project corresponds to one program. When you’re ready to create a second program, you’ll either need to create a new project, or overwrite the code in an existing project (if you don’t want to keep it). Project files are generally IDE specific, so a project created for one IDE will need to be recreated in a different IDE.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Create a new project for each new program you write.</p></div><br><h3>Console projects</h3><p>When you create a new project, you’ll generally be asked what type of project you want to create. All of the projects that we will create in this tutorial will be console projects. A <span class="cpp-definition">console project</span> means that we are going to create programs that can be run from the Windows, Linux, or Mac console.</p><p>Here’s a screenshot of the Windows console:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/WindowsCommandLine-min.png?ezimgfmt=rs%3Adevice%2Frscb2-1" alt="Windows console" ezimgfmt="rs rscb2 src ng ngcb2" loading="eager" srcset="" sizes="" importance="high"></div><p>By default, console applications have no graphical user interface (GUI), they print text to the console, read input from the keyboard, and are compiled into stand-alone executable files. This is perfect for learning C++, because it keeps the complexity to a minimum, and ensures things work on a wide variety of systems.</p><p>Don’t worry if you’ve never used a console before, or don’t know how to access it. We’ll compile and launch our programs through our IDEs (which will invoke the console when necessary).</p><br><h3>Workspaces / solutions</h3><p>When you create a new project for your program, many IDEs will automatically add your project to a “workspace” or a “solution” (the term varies by IDE). A workspace or solution is a container that can hold one or more related projects. For example, if you were writing a game and wanted to have a separate executable for single player and multiplayer, you’d need to create two projects. It wouldn’t make sense for both of these projects to be completely independent -- after all, they are part of the same game. Mostly likely, each would be configured as a separate project within a single workspace/solution.</p><p>Although you can add multiple projects to a single solution, we generally recommend creating a new workspace or solution for each program, especially while learning. It’s simpler and there’s less chance of something going wrong.</p><br><h3>Writing your first program</h3><p>Traditionally, the first program programmers write in a new language is the infamous <a href="https://en.wikipedia.org/wiki/Hello_world">hello world program</a>, and we aren’t going to deprive you of that experience! You’ll thank us later. Maybe.</p><br><h3>Creating a project in Visual Studio 2019 </h3><p>When you run Visual Studio 2019, you should see a dialog that looks like this:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/VS2019-GetStarted-min.png" alt="Visual Studio 2019 Get Started dialog" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/VS2019-GetStarted-min.png"></div><p>Select <em>Create a new project</em>.</p><p>You’ll then see a dialog that looks like this:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/VS2019-CreateNewProject-min.png" alt="Visual Studio 2019 Create New Project dialog" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/VS2019-CreateNewProject-min.png"></div><p>If you’ve already opened a prior project, you can access this dialog via the <em>File menu &gt; New &gt; Project</em>.</p><p>Select <em>Windows Desktop Wizard</em> and click <em>Next</em>. If you don’t see this, then you probably forgot to choose to install the <em>Desktop development with C++</em> workload when you installed Visual Studio. In that case, go back to lesson <a href="https://www.learncpp.com/cpp-tutorial/installing-an-integrated-development-environment-ide/">0.6 -- Installing an Integrated Development Environment (IDE)</a> and reinstall your Visual Studio as indicated (note: rather than doing a full reinstall, you can run the Visual Studio installer and modify your existing installation to add the C++ workload).</p><p>Next, you’ll see a dialog that looks like this:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/VS2019-ConfigureNewProject-min.png" alt="Visual Studio 2019 Configure New Project dialog" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/VS2019-ConfigureNewProject-min.png"></div><p>Replace the existing project name with <code>HelloWorld</code>.</p><p>It’s recommended that you also check the <em>Place solution and project in the same directory</em>, as this reduces the number of subdirectories that get created with each project.</p><p>Click <em>Create</em> to continue.</p><p>Finally, you’ll see one last dialog:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/VS2019-PrecompiledHeader-min.png" alt="Visual Studio 2019 Project options dialog" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/VS2019-PrecompiledHeader-min.png"></div><p>Make sure the <em>Application type</em> is set as <em>Console Application (.exe)</em> and that the <em>Precompiled Header</em> option is unselected. Then click <em>OK</em>.</p><p>You’ve now created a project! Jump down to the <a href="#visual_studio_solution_explorer">Visual Studio Solution Explorer</a> section below to continue.</p><div class="cpp-note cpp-lightbluebackground"><h4>Q: What are precompiled headers and why are we turning them off?</h4><p>In large projects (those with many code files), precompiled headers can improve compilation speed by avoiding some redundant compilation that tends to occur in larger projects.</p><p>However, precompiled headers require extra work to use, and for small projects (such as those you’ll create in our tutorials) make little to no difference in compilation times.</p><p>For this reason, we recommend turning precompiled headers off initially, and only enabling them later if and when you find your compilation times suffering.</p></div><br><h3>Creating a project in Visual Studio 2017 or older</h3><p>To create a new project in Visual Studio 2017 or older, go to the <em>File menu &gt; New &gt; Project</em>. A dialog box will pop up that looks something like this:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/VS2017-NewProject-min.png" alt="Visual Studio 2017 New Project dialog" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/VS2017-NewProject-min.png"></div><p>First, make sure <em>Visual C++</em> is listed on the left side. If you don’t see <em>Visual C++</em>, then you probably forgot to choose to install the <em>Desktop development with C++</em> workload when you installed Visual Studio. In that case, go back to lesson <a href="https://www.learncpp.com/cpp-tutorial/installing-an-integrated-development-environment-ide/">0.6 -- Installing an Integrated Development Environment (IDE)</a> and reinstall your Visual Studio as indicated (note: rather doing a full reinstall, you can run the Visual Studio installer and modify your existing install to add the C++ workload).</p><p>If you’re using Visual Studio 2017 v15.3 or newer, underneath <em>Visual C++</em>, select <em>Windows Desktop</em> and then select <em>Windows Desktop Wizard</em> in the main window.</p><p>If you don’t see <em>Windows Desktop</em> as an option, you’re probably using an older version of Visual Studio. That’s fine. Instead, choose <em>Win32</em> and then <em>Win32 Console Application</em> in the main window.</p><p>Down below, in the <em>Name</em> field, enter the name of your program (replace the existing name with <code>HelloWorld</code>). In the Location field, you can optionally select a different location for your project to be placed into. The default is fine for now.</p><p>Click <em>OK</em>. If you’re using an older version of Visual Studio, the Win32 Application Wizard will launch. Press <em>Next</em>.</p><p>At this point, you should see a wizard dialog that looks something like this (older versions of Visual Studio use a different style, but have most of the same options):</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/VS2017-DesktopWizard-min.png" alt="Visual Studio 2017 Desktop wizard" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/VS2017-DesktopWizard-min.png"></div><p>Make sure you uncheck <em>Precompiled Header</em>.</p><p>Then click <em>Ok</em> or <em>Finish</em>. Now your project is created!</p><br><h3>Visual Studio Solution Explorer </h3><p>On the left or right side of the window, you should see a window titled <em>Solution Explorer</em>. Inside this window, Visual Studio has created a solution for you (<em>Solution ‘HelloWorld’</em>). Within that, with the name in bold, is your new project (<em>HelloWorld</em>). Within the project, Visual Studio has created a number of files for you, including <em>HelloWorld.cpp</em> (underneath the <em>Source Files</em> tree item). You may also see some other .cpp or .h files, which you can ignore for now.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/VS2019-Initial-min.png" alt="Visual Studio 2019 initial windows" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/VS2019-Initial-min.png"></div><p>In the text editor, you will see that Visual Studio has already opened <em>HelloWorld.cpp</em> and created some code for you. Select and delete all of the code, and type/copy the following into your IDE:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Hello, world!";</code><code>	return 0;</code><code>}</code></pre><p>To compile your program, either press <em>F7</em> (if this doesn’t work, try <em>Ctrl-Shift-B</em>) or go to the <em>Build menu &gt; Build Solution</em>. If all goes well, you should see the following appear in the Output window:</p><pre>1&gt;------ Build started: Project: HelloWorld, Configuration: Debug Win32 ------
1&gt;HelloWorld.cpp
1&gt;HelloWorld.vcxproj -&gt; c:\users\alex\documents\visual studio 2017\Projects\HelloWorld\Debug\HelloWorld.exe
========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========
</pre><p>This means your compile was successful!</p><div class="cpp-note cpp-lightbluebackground"><h4>Q: I got error C1010 ("fatal error C1010: unexpected end of file while looking for precompiled header. Did you forget to add ‘#include "stdafx.h"’ to your source?"). What now?</h4><p>You forgot to turn off precompiled headers when you created your project. Recreate your project (as per the <a href="#creating_project_vs19">instructions above</a>) and make sure to disable precompiled headers.</p></div><p>To run your compiled program, press <em>Ctrl-F5</em>, or go to the <em>Debug menu</em> and choose <em>Start Without Debugging</em>. You will see the following:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/VC2005-Run-min.png" alt="Program run" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/VC2005-Run-min.png"></div><p>That is the result of your program! Congratulations, you’ve compiled and run your first program!</p><br><h3>Creating a project in Code::Blocks</h3><p>To create a new project, go to <em>File menu &gt; New &gt; Project</em>. A dialog box will pop up that looks like this:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/CB-Project-min.png" alt="Code::Blocks Project Dialog" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/CB-Project-min.png"></div><p>Select <em>Console application</em> and press the <em>Go (or Create)</em> button.</p><p>If you see a console application wizard dialog, press <em>Next</em>, make sure C++ is selected and press <em>Next</em> again.</p><p>Now you will be asked to name your project. Title the project <code>HelloWorld</code>. You can save it wherever you wish. On Windows, we recommend you to save it in a subdirectory of the C drive, such as <code>C:\CBProjects</code>.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/CB2017-Save-min.png" alt="Code::Blocks Save Project Dialog" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/CB2017-Save-min.png"></div><p>You may see another dialog asking you which configurations you want enabled. The defaults should be fine here, so select <em>Finish</em>.</p><p>Now your new project has been created.</p><p>On the left side of the screen, you should see a <em>Management</em> window, with the <em>Projects</em> tab selected. Inside that window, you’ll see a <em>Workspace</em> folder, with your <em>HelloWorld</em> project inside of it:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/CB-Closed-min.png" alt="Code::Blocks Workspace" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/CB-Closed-min.png"></div><p>Inside the <em>HelloWorld</em> project, expand the <em>Sources</em> folder, and double click on “main.cpp”. You will see that a hello world program has already been written for you!</p><p>Replace that one with the following:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Hello, world!";</code><code>	return 0;</code><code>}</code></pre><p>To build your project, press <em>Ctrl-F9</em>, or go to <em>Build menu &gt; Build</em>. If all goes well, you should see the following appear in the Build log window:</p><pre>-------------- Build: Debug in HelloWorld (compiler: GNU GCC Compiler)---------------
mingw32-g++.exe -Wall -fexceptions -g -std=c++14  -c C:\CBProjects\HelloWorld\main.cpp -o obj\Debug\main.o
mingw32-g++.exe  -o bin\Debug\HelloWorld.exe obj\Debug\main.o   
Output file is bin\Debug\HelloWorld.exe with size 1.51 MB
Process terminated with status 0 (0 minute(s), 0 second(s))
0 error(s), 0 warning(s) (0 minute(s), 0 second(s))
</pre><p>This means your compile was successful!</p><p>To run your compiled program, press <em>Ctrl-F10</em>, or go to <em>Build menu &gt; Run</em>. You will see something similar to the following:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/VC2005-Run-min.png" alt="Program run" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/VC2005-Run-min.png"></div><p>That is the result of your program!</p><div class="cpp-note cpp-lightyellowbackground"><h4>For Linux users</h4><p>Linux users may need to install the additional packages before Code::Blocks will compile. Please see the Code::Blocks installation instructions in lesson <a href="https://www.learncpp.com/cpp-tutorial/installing-an-integrated-development-environment-ide/">0.6 -- Installing an Integrated Development Environment (IDE)</a> for more info.</p></div><br><h3>If you’re using g++ on the command line</h3><p>In this case, you don’t need to create a project. Simply paste the following into a text file named HelloWorld.cpp and save your file:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Hello, world!";</code><code>	return 0;</code><code>}</code></pre><p>From the command line, type:</p><p><code>g++ -o HelloWorld HelloWorld.cpp</code></p><p>This will compile and link HelloWorld.cpp. To run it, type:</p><p><code>HelloWorld</code> (or possibly <code>./HelloWorld</code>), and you will see the output of your program.</p><br><h3>If you’re using other IDEs or a web-based compiler</h3><p>You will have to figure out how to do the following on your own:</p><ol start="1"><li>Create a console project (IDEs only)</li><li>Add a .cpp file to the project (IDEs only, if one isn’t auto-created for you)</li><li>Paste the following code into the file:</li></ol><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Hello, world!";</code><code>	return 0;</code><code>}</code></pre><ol start="4"><li>Compile the project</li><li>Run the project</li></ol><br><h3>If compiling fails</h3><p>It’s okay, take a deep breath. We can probably fix it. :)</p><p>First, look at the error message that the compiler gave you. Most often, it will contain a line number indicating which line was in error. Examine both that line and the lines around it, and make sure there are no typos or misspellings. Also make sure you’re not including line numbers in your code (your editor should be providing those).</p><p>Second, look at the Q&amp;A in lesson <a href="https://www.learncpp.com/cpp-tutorial/a-few-common-cpp-problems/">0.8 -- A few common C++ problems</a>, as your issue may be covered there.</p><p>Third, read the comments below the lesson containing the example you’re compiling -- someone may have encountered the same issue and provided a solution.</p><p>Finally, if all of the above fail, try searching for your error message on your favorite search engine. It’s likely someone else has encountered this issue before and figured out how to fix it.</p><br><h3>If your program runs but the console window flashes and closes immediately</h3><p>When a console program is run, the console window will open and any output from the program will be written into the console window.</p><p>When the program has finished running, most modern IDEs will keep the console open (until you press a key) so you can inspect the results of the program before continuing. However, some older IDEs will automatically close the console window when the program finishes running. This is generally not what you want.</p><p>If your IDE closes the console window automatically, the following two steps can be used to ensure the console pauses at end of the program.</p><p>First, add or ensure the following lines are near the top of your program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <limits></limits></code></pre><p>Second, add the following code at the end of the main() function (just before the return statement):</p><pre class="language-cpp line-numbers"><code>std::cin.clear(); // reset any error flags</code><code>std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // ignore any characters in the input buffer until we find a newline</std::streamsize></code><code>std::cin.get(); // get one more char from the user (waits for user to press enter)</code></pre><p>This will cause your program to wait for the user to press enter before continuing (you may have to press enter twice), which will give you time to examine your program’s output before your IDE closes the console window.</p><p>Other solutions, such as the commonly suggested <code>system("pause")</code> solution may only work on certain operating systems and should be avoided.</p><p>If the console window doesn’t open at all and your program doesn’t appear to be running, your anti-virus or anti-malware may also be blocking execution of the program. If that’s the case, try temporarily disabling your scanners and see if the problem resolves.</p><br><h3>What is the difference between the compile, build, rebuild, clean, and run/start options in my IDE?</h3><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-the-compiler-linker-and-libraries/">0.5 -- Introduction to the compiler, linker, and libraries</a>, we showed that to produce an executable that can be run, each code file in a program is compiled into an object file, and then the object files are linked into an executable.</p><p>When a code file is compiled, your IDE may cache the resulting object file. That way, if the program is compiled again in the future, any code file that hasn’t been modified doesn’t need to be recompiled -- the cached object file from last time can be reused. This can speed up compilation times significantly (at the cost of a little bit of disk space).</p><p>With that in mind, here’s what each of the options typically does:</p><ul><li><strong>Build</strong> compiles all <em>modified</em> code files in the project or workspace/solution, and then links the object files into an executable. If no code files have been modified since the last build, this option does nothing.</li><li><strong>Clean</strong> removes all cached objects and executables so the next time the project is built, all files will be recompiled and a new executable produced.</li><li><strong>Rebuild</strong> does a “clean”, followed by a “build”.</li><li><strong>Compile</strong> recompiles a single code file (regardless of whether it has been cached previously). This option does not invoke the linker or produce an executable.</li><li><strong>Run/start</strong> executes the executable from a prior build. Some IDEs (e.g. Visual Studio) will invoke a “build” before doing a “run” to ensure you are running the latest version of your code. Otherwise (e.g. Code::Blocks) will just execute the prior executable.</li></ul><p>Although we talk informally about “compiling” our programs, to actually compile our programs we will typically choose the “build” (or “run”) option in our IDE to do so.</p><br><h3>Conclusion</h3><p>Congratulations, you made it through the hardest part of this tutorial (installing the IDE and compiling your first program)!</p><p>Don’t worry if you don’t understand what the different lines in the Hello World program do. We’ll examine and explain each line in detail at the start of the next chapter.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">0.8 — A few common C++ problems</h1></header><div class="entry-content" itemprop="articleBody"><p>In this section, we’ll address some of the common issues that new programmers seem to run across with fairly high probability. This is not meant to be a comprehensive list of compilation or execution problems, but rather a pragmatic list of solutions to very basic issues. If you have any suggestions for other issues that might be added to this list, post them in the comments section below.</p><p block=""></p><br><h3>General run-time issues</h3><div class="cpp-note cpp-lightbluebackground"><h4>Q: When executing a program, the console window blinks and then closes immediately.</h4><p>First, add or ensure the following lines are near the top of your program (Visual Studio users, make sure these lines appear after #include “pch.h” or #include “stdafx.h”, if those exist):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <limits></limits></code></pre><p>Second, add the following code at the end of your main() function (right before the return statement):</p><pre class="language-cpp line-numbers"><code>std::cin.clear(); // reset any error flags</code><code>std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // ignore any characters in the input buffer until we find an enter character</std::streamsize></code><code>std::cin.get(); // get one more char from the user</code></pre><p>This will cause your program to wait for the user to press a key before continuing, which will give you time to examine your program’s output before your operating system closes the console window.</p><p>Other solutions, such as the commonly suggested system(“pause”) solution may only work on certain operating systems and should be avoided.</p><p>Older versions of Visual Studio may not pause when the program is run in <em>Start With Debugging (F5)</em> mode. Try running in <em>Start Without Debugging (Ctrl-F5)</em> mode.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Q: I ran my program and get a window but no output.</h4><p>Your virus scanner or anti-malware may be blocking execution. Try disabling it temporarily and see if that’s the issue.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Q: My program compiles but it isn’t working correctly. What do I do?</h4><p>Debug it! There are tips on how to diagnose and debug your programs later in chapter 3.</p></div><br><h3>General compile-time issues</h3><div class="cpp-note cpp-lightbluebackground"><h4>Q: When I compile my program, I get an error about unresolved external symbol _main or [email&nbsp;protected]</h4><p>This means your compiler can’t find your main() function. All programs must include a main() function.</p><p>There are a few things to check:<br>a) Does your code include a function named main?<br>b) Is main spelled correctly?<br>c) When you compile your program, do you see the file that contains function main() get compiled? If not, either move the main() function to one that is, or add the file to your project (see lesson <a href="https://www.learncpp.com/cpp-tutorial/programs-with-multiple-code-files/">2.8 -- Programs with multiple code files</a> for more information about how to do this).<br>d) Did you create a console project? Try creating a new console project.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Q: I’m trying to use C++11/14/17/XX functionality and it doesn’t work</h4><p>If your compiler is old, it may not support these more recent additions to the language. In that case, upgrade your compiler.</p><p>For modern IDEs/compilers, your compiler may be defaulting to an older language standard. We cover how to change your language standard in lesson <a href="https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-choosing-a-language-standard/">0.12 -- Configuring your compiler: Choosing a language standard</a>.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Q: When trying to use cin, cout, or endl, the compiler says cin, cout, or endl is an ‘undeclared identifier’</h4><p>First, make sure you have included the following line near the top of your file:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code></pre><p>Second, make sure each use of cin, cout, and endl are prefixed by “std::”. For example:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; "Hello world!" &lt;&lt; std::endl;</code></pre><p>If this doesn’t fix your issue, then it may be that your compiler is out of date, or the install is corrupted. Try reinstalling and/or upgrading to the latest version of your compiler.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Q: When trying to use endl to end a printed line, the compiler says end1 is an ‘undeclared identifier’</h4><p>Make sure you do not mistake the letter l (lower case L) in endl for the number 1. endl is all letters. Make sure your editor is using a font that makes clear the differences between the letter lower case L, upper case i, and the number 1. Also the letter capital o and the number zero can easily be confused in many non-programming fonts.</p></div><br><h3>Visual Studio issues</h3><div class="cpp-note cpp-lightbluebackground"><h4>Q: When compiling with Microsoft Visual C++, you get a C1010 fatal error, with an error message like "c:\vcprojects\test.cpp(263) :fatal error C1010: unexpected end of file while looking for precompiled header directive"</h4><p>This error occurs when the Microsoft Visual C++ compiler is set to use precompiled headers but one (or more) of your C++ code files does not #include “stdafx.h” or #include “pch.h” as the first line of the code file.</p><p>Our suggested fix is to turn off precompiled headers, which we show how to do in lesson <a href="https://www.learncpp.com/cpp-tutorial/compiling-your-first-program/">0.7 -- Compiling your first program</a>.</p><p>If you would like to keep precompiled headers turned on, to fix this problem, simply locate the file(s) producing the error (in the above error, test.cpp is the culprit), and add the following line at the very top of the file(s):</p><pre class="language-cpp line-numbers"><code>#include "pch.h"</code></pre><p>Older versions of Visual Studio use “stdafx.h” instead of “pch.h”, so if pch.h doesn’t resolve the issue, try stdafx.h.</p><p>Note that for programs with multiple files, every C++ code file needs to start with this line.</p><p>Alternatively, you can turn off precompiled headers.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Q: Visual Studio gives the following error: "1MSVCRTD.lib(exe_winmain.obj) : error LNK2019: unresolved external symbol [email&nbsp;protected] referenced in function "int __cdecl invoke_main(void)" ([email&nbsp;protected]@YAHXZ)"</h4><p>You’ve likely created a Windows graphical application rather than a console application. Recreate your project, and make sure to create it as a Windows (or Win32) <em>Console</em> project.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Q: When I compile my program, I get a warnings about "Cannot find or open the PDB file"</h4><p>This is a warning, not an error, so it shouldn’t impact your program. However, it is annoying. To fix it, go into the Debug menu -&gt; Options and Settings -&gt; Symbols, and check “Microsoft Symbol Server”.</p></div><br><h3>Something else</h3><div class="cpp-note cpp-lightbluebackground"><h4>Q: I have some other problem that I can’t figure out. How can I get an answer quickly?</h4><p>As you progress through the material, you’ll undoubtedly have questions or run into unexpected problems. What to do next depends on your problem. But in general, there are a few things you can try.</p><p>First, <strong>ask a search engine</strong>. Find a good way to phrase your question and do a search. If you are searching an error message, paste in the exact error message using quotes (exclude any filenames or line numbers). Odds are someone has already asked the same question and there is an answer waiting for you.</p><p>If that fails, <strong>ask on a Q&amp;A board</strong>. There are websites designed for programming questions and answers, like <a href="https://www.stackoverflow.com">Stack Overflow</a>. Try posting your question there. Remember to be thorough about what your problem is, and include all relevant information like what OS you’re on and what IDE you’re using.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">0.9 — Configuring your compiler: Build configurations</h1></header><div class="entry-content" itemprop="articleBody"><p>A <span class="cpp-definition">build configuration</span> (also called a <span class="cpp-definition">build target</span>) is a collection of project settings that determines how your IDE will build your project. The build configuration typically includes things like what the executable will be named, what directories the IDE will look in for other code and library files, whether to keep or strip out debugging information, how much to have the compiler optimize your program, etc… Generally, you will want to leave these settings at their default values unless you have a specific reason to change something.</p><p>When you create a new project in your IDE, most IDEs will set up two different build configurations for you: a release configuration, and a debug configuration.</p><p>The <span class="cpp-definition">debug configuration</span> is designed to help you debug your program, and is generally the one you will use when writing your programs. This configuration turns off all optimizations, and includes debugging information, which makes your programs larger and slower, but much easier to debug. The debug configuration is usually selected as the active configuration by default. We’ll talk more about debugging techniques in a later lesson.</p><p>The <span class="cpp-definition">release configuration</span> is designed to be used when releasing your program to the public. This version is typically optimized for size and performance, and doesn’t contain the extra debugging information. Because the release configuration includes all optimizations, this mode is also useful for testing the performance of your code (which we’ll show you how to do later in the tutorial series).</p><p>When the <em>Hello World</em> program (from lesson <a href="https://www.learncpp.com/cpp-tutorial/compiling-your-first-program/">0.7 -- Compiling your first program</a>) was built using Visual Studio, the executable produced in the debug configuration was 65kb, whereas the executable built in the release version was 12kb. The difference is largely due to the extra debugging information kept in the debug build.</p><p>Although you can create your own custom build configurations, you’ll rarely have a reason to unless you want to compare two builds made using different compiler settings.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use the <em>debug</em> build configuration when developing your programs. When you’re ready to release your executable to others, or want to test performance, use the <em>release</em> build configuration.</p></div><br><h3>Switching between build configurations</h3><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>There are multiple ways to switch between <em>debug</em> and <em>release</em> in Visual Studio. The easiest way is to set your selection directly from the <em>Solution Configurations</em> dropdown in the <em>Standard Toolbar Options</em>:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/VS-BuildTarget-min.png" alt="VS Solution Configurations Dropdown" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/VS-BuildTarget-min.png"></div><p>Set it to <em>Debug</em> for now.</p><p>You can also access the configuration manager dialog by selecting <em>Build menu &gt; Configuration Manager</em>, and change the <em>active solution configuration</em>.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>In Code::Blocks, you should see an item called <em>Build Target</em> in the <em>Compiler toolbar</em>:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/CB-BuildTarget-min.png" alt="Code::Blocks Build Target Dropdown" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/CB-BuildTarget-min.png"></div><p>Set it to <em>Debug</em> for now.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">0.10 — Configuring your compiler: Compiler extensions</h1></header><div class="entry-content" itemprop="articleBody"><p>The C++ standard defines rules about how programs should behave in specific circumstances. And in most cases, compilers will follow these rules. However, many compilers implement their own changes to the language, often to enhance compatibility with other versions of the language (e.g. C99), or for historical reasons. These compiler-specific behaviors are called <span class="cpp-definition">compiler extensions</span>.</p><p>Writing a program that makes use of a compiler extension allows you to write programs that are incompatible with the C++ standard. Programs using non-standard extensions generally will not compile on other compilers (that don’t support those same extensions), or if they do, they may not run correctly.</p><p>Frustratingly, compiler extensions are often enabled by default. This is particularly damaging for new learners, who may think some behavior that works is part of official C++ standard, when in fact their compiler is simply over-permissive.</p><p>Because compiler extensions are never necessary, and cause your programs to be non-compliant with C++ standards, we recommend turning compiler extensions off.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Disable compiler extensions to ensure your programs (and coding practices) remain compliant with C++ standards and will work on any system.</p></div><br><h3>Disabling compiler extensions</h3><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>To disable compiler extensions, right click on your project name in the <em>Solution Explorer</em> window, then choose <em>Properties</em>:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/VS-SolutionExplorerProperties-min.png?ezimgfmt=rs%3Adevice%2Frscb2-1" alt="Solution Explorer Properties" ezimgfmt="rs rscb2 src ng ngcb2" loading="eager" srcset="" sizes="" importance="high"></div><p>From the <em>Project</em> dialog, first make sure the <em>Configuration</em> field is set to <em>All Configurations</em>.</p><p>Then, click <em>C/C++ &gt; Language tab</em>, and set <em>Conformance mode</em> to <em>Yes (/permissive-)</em>.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/VS-DisableExtensions-min.png?ezimgfmt=rs%3Adevice%2Frscb2-1" alt="Disable Language Extensions" ezimgfmt="rs rscb2 src ng ngcb2" loading="eager" srcset="" sizes="" importance="high"></div></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>Disable compiler extensions via <em>Settings menu &gt; Compiler &gt; Compiler flags tab</em>, then find and check the <em>-pedantic-errors</em> option.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/CB-Pedantic-min.png" alt="Disable Language Extensions" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/CB-Pedantic-min.png"></div></div><div class="cpp-note cpp-lightyellowbackground"><h4>For GCC/G++ users</h4><p>You can disable compiler extensions by adding the <em>-pedantic-errors</em> flag to the compile command line.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>Xcode users can refer to <a href="https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-compiler-extensions/comment-page-1/#comment-446983">Rory’s comment</a>, who kindly provided instructions.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>A reminder</h4><p>These settings are applied on a per-project basis. You need to set them every time you create a new project, or create a template project with those settings once and use that to create new projects.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">0.11 — Configuring your compiler: Warning and error levels</h1></header><div class="entry-content" itemprop="articleBody"><p>When you write your programs, the compiler will check to ensure you’ve followed the rules of the C++ language (assuming you’ve turned off compiler extensions, as per lesson <a href="https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-compiler-extensions/">0.10 -- Configuring your compiler: Compiler extensions</a>).</p><p>If you have done something that definitively violates the rules of the language, during compilation the compiler will emit an <span class="cpp-definition">error</span>, providing both line number containing the error, and some text about what was expected vs what was found. The actual error may be on that line, or on a preceding line. Once you’ve identified and fixed the erroneous line(s) of code, you can try compiling again.</p><p>In other cases, the compiler may find code that seems like it might be in error, but the compiler can’t be sure (remember the motto: “trust the programmer”). In such cases, the compiler may opt to issue a <span class="cpp-definition">warning</span>. Warnings do not halt compilation, but are notices to the programmer that something seems amiss.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Don’t let warnings pile up. Resolve them as you encounter them (as if they were errors). Otherwise a warning about a serious issue may be lost amongst warnings about non-serious issues.</p></div><p>In most cases, warnings can be resolved either by fixing the issue the warning is pointing out, or by rewriting the line of code generating the warning in such a way that the warning is no longer generated.</p><p>In rare cases, it may be necessary to explicitly tell the compiler to not generate a particular warning for the line of code in question. C++ does not support an official way to do this, but many individual compilers (including Visual Studio and GCC) offer solutions (via non-portable #pragma directives) to temporarily disable warnings.</p><br><h3>Increasing your warning levels</h3><p>By default, most compilers will only generate warnings about the most obvious issues. However, you can request your compiler be more assertive about providing warnings for things it finds strange.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Turn your warning levels up to the maximum, especially while you are learning. It will help you identify possible issues.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>To increase your warning levels, right click on your project name in the <em>Solution Explorer</em> window, then choose <em>Properties</em>:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/VS-SolutionExplorerProperties-min.png?ezimgfmt=rs%3Adevice%2Frscb2-1" alt="Solution Explorer Properties" ezimgfmt="rs rscb2 src ng ngcb2" loading="eager" srcset="" sizes="" importance="high"></div><p>From the <em>Project</em> dialog, first make sure the <em>Configuration</em> field is set to <em>All Configurations</em>.</p><p>Then select <em>C/C++ &gt; General tab</em> and set <em>Warning level</em> to <em>Level4 (/W4)</em>:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/VS-EnableAllWarnings-min.png" alt="Enable Level 4 Warnings" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/VS-EnableAllWarnings-min.png"></div><p>Note: Do not choose <em>EnableAllWarnings (/Wall)</em> or you will be buried in warnings generated by the C++ standard library.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>From <em>Settings menu &gt; Compiler &gt; Compiler settings tab</em>, find and check the options that correlate with <em>-Wall</em>, <em>-Weffc++</em>, and <em>-Wextra</em>:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/CB-EnableAllWarnings-min.png" alt="Enable All Warnings" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/CB-EnableAllWarnings-min.png"></div><p>Then go to the <em>Other compiler options tab</em>, and add <em>-Wsign-conversion</em> to the text edit area:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/CB-OtherCompilerFlags-min.png" alt="Add -Wsign-conversion" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/CB-OtherCompilerFlags-min.png"></div><p>Note: The <em>-Werror</em> parameter is explained below.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For GCC/G++ users</h4><p>Add the following flags to your command line: <em>-Wall -Weffc++ -Wextra -Wsign-conversion</em></p></div><br><h3>Treat warnings as errors</h3><p>It is also possible to tell your compiler to treat all warnings as if they were errors (in which case, the compiler will halt compilation if it finds any warnings). This is a good way to enforce the recommendation that you should fix all warnings (if you lack self-discipline, which most of us do).</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Enable “Treat warnings as errors”. This will force you to resolve all issues causing warnings.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>To treat warnings as errors, right click on your project name in the <em>Solution Explorer</em> window, then choose <em>Properties</em>:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/VS-SolutionExplorerProperties-min.png?ezimgfmt=rs%3Adevice%2Frscb2-1" alt="Solution Explorer Properties" ezimgfmt="rs rscb2 src ng ngcb2" loading="eager" srcset="" sizes="" importance="high"></div><p>From the <em>Project</em> dialog, first make sure the <em>Configuration</em> field is set to <em>All Configurations</em>.</p><p>Then select <em>C/C++ &gt; General tab</em> and set <em>Treat Warnings As Errors</em> to <em>Yes (/WX)</em>.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/VS-WarningsAsErrors-min.png" alt="Treat warnings as errors" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/VS-WarningsAsErrors-min.png"></div></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>From <em>Settings menu &gt; Compiler &gt; Other compiler options tab</em>, add <em>-Werror</em> to the text edit area:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/CB-OtherCompilerFlags-min.png" alt="Add -Werror" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/CB-OtherCompilerFlags-min.png"></div></div><div class="cpp-note cpp-lightyellowbackground"><h4>For GCC/G++ users</h4><p>Add the following flag to your command line: <em>-Werror</em></p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">0.12 — Configuring your compiler: Choosing a language standard</h1></header><div class="entry-content" itemprop="articleBody"><p>With many different versions of C++ available (C++98, C++03, C++11, C++14, C++17, C++20, etc…) how does your compiler know which one to use? Generally, a compiler will pick a standard to default to (typically <em>not</em> the most recent language standard).</p><p>If you wish to use a different language standard (and you probably will), you’ll have to configure your IDE/compiler to do so.</p><br><h3>Code names for in-progress language standards</h3><p>Finalized language standards are named after the years in which they are finalized (e.g. C++17 was finalized in 2017).</p><p>However, when a new language standard is being agreed upon, it’s not clear in what year the finalization will take place. Consequently, in-progress language standards are given code names, which are then replaced by the actual names upon finalization of the standard. For example, <em>C++11</em> was called <em>c++1x</em> while it was being worked on. You may still see the code names used in places (especially for upcoming version of the language standard, which won’t have a final name yet).</p><p>Here’s a mapping of code names to the final names:</p><ul><li>c++1x = C++11</li><li>c++1y = C++14</li><li>c++1z = C++17</li><li>c++2a = C++20</li><li>c++2b = C++23</li></ul><p>For example, if you see <code>c++1z</code>, this is synonymous with the C++17 language standard.</p><br><h3>Which language standard should you choose? </h3><p>In professional environments, it’s common to choose a language standard that is one or two versions back from the latest standard (e.g. now that C++20 is out, that means C++14 or C++17). This is typically done to ensure the compiler makers have had a chance to resolve defects, and so that best practices for new features are well understood. Where relevant, this also helps ensure better cross-platform compatibility, as compilers on some platforms may not provide full support for newer language standards immediately.</p><p>For personal projects and while learning, there is little downside to choosing the latest finalized standard (as of the time of writing, currently C++20).</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>This website currently targets the C++17 standard, meaning our lessons and examples assume your compiler is C++17 capable. Some C++20 content is optionally available for those with C++20 compatible compilers.</p><p>To take full advantage of all the lesson content, we recommend using the C++20 language standard if your compiler supports it. Using the C++17 language standard will also provide a good experience.</p><p>If your compiler doesn’t support C++17, we recommend upgrading to one that does. If this is not possible for some reason, you will need to skip some newer content, and alter some examples so that they will compile. This should not impact your overall experience too heavily (especially in the early lessons).</p><p>C++14 is the minimum language standard for a decent experience on this site.</p></div><p>There’s an example at the end of this lesson which you can use to test if you set up your compiler to use C++17 correctly.</p><br><h3>Setting a language standard in Visual Studio</h3><p>As of the time of writing, Visual Studio 2022 defaults to C++14 capabilities, which does not allow for the use of newer features introduced in C++17 and C++20.</p><p>To use these newer features, you’ll need to enable a newer language standard. Unfortunately, there is currently no way to do this globally -- you must do so on a project-by-project basis.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>With Visual Studio, you will need to reselect your language standard every time you create a new project.</p></div><p>To select a language standard, open your project, then go to <em>Project menu &gt; (Your application’s Name)</em> Properties, then open <em>Configuration Properties &gt; C/C++ &gt; Language</em>.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/VS2019-Project-Language-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/VS2019-Project-Language-min.png"></div><p>First, make sure the <em>Configuration</em> is set to “All Configurations”.</p><p>From there, you can set the <em>C++ Language Standard</em> to the version of C++ you wish to use.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>We recommend choosing the latest standard “ISO C++ Latest (/std:c++latest)”, which as of the time of writing is the setting for C++20 support.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>For more information on Visual Studio language standard settings, Microsoft has a <a href="https://docs.microsoft.com/en-us/cpp/build/reference/std-specify-language-standard-version?view=msvc-160">Visual Studio language standard reference document</a>.</p></div><br><h3>Setting a language standard in Code::Blocks</h3><p>Code::Blocks may default to a pre-C++11 language standard. You’ll definitely want to check and ensure a more modern language standard is enabled.</p><p>The good news is that Code::Blocks allows setting your language standard globally, so you can set it once (rather than per-project). To do so, go to <em>Settings menu &gt; Compiler…</em>:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/CB-SettingsCompiler-min.png" alt="Code::Blocks Settings > Compiler" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/CB-SettingsCompiler-min.png"></div><p>Then find the checkboxes labeled <em>Have g++ follow the C++XX ISO C++ language standard [-std=c++XX]</em>, where XX is some number (e.g. 20, 17, etc…) representing a language standard:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter0/CB-C++11-min.png" alt="Code::Blocks C++11 setting" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter0/CB-C++11-min.png"></div><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>If C++20 or C++17 appears in this list, select the one that represents the latest ISO standard (e.g. select <em>Have g++ follow the C++20 ISO language standard</em>). If you see GNU standards in this list as well, ignore them.</p></div><p>If you do not see C++20 or C++17 in this list, upgrade to the latest version of Code::Blocks.</p><p>If upgrading to the latest version is not possible for some reason, your version of Code::Blocks may have support for upcoming (or just released) versions of C++. If so, these will be labeled <em>Have g++ follow the coming C++XX (aka C++YY) ISO C++ language standard [-std=c++XX]</em> (see the blue box above). Select the latest version from this list.</p><br><h3>Setting a language standard in g++</h3><div class="cpp-note cpp-lightyellowbackground"><h4>For GCC/G++ users</h4><p>For GCC/G++, you can pass compiler flags -std=c++11, -std=c++14, -std=c++17, or -std=c++20 to enable C++11/14/17/20 support respectively. If you have GCC 8 or 9, you’ll need to use -std=c++2a for C++20 support instead.</p></div><br><h3>Testing your compiler for C++17 compatibility </h3><p>After enabling the C++17 language standard (or higher), you should be able to compile the following code without any warnings or errors.</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code>#include <tuple></tuple></code><code>#include <type_traits></type_traits></code><code></code><code>namespace a::b::c</code><code>{</code><code>    inline constexpr std::string_view str{ "hello" };</code><code>}</code><code></code><code>template <class... t=""></class...></code><code>std::tuple<std::size_t, std::common_type_t<t...="">&gt; sum(T... args)</std::size_t,></code><code>{</code><code>    return { sizeof...(T), (args + ...) };</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    auto [iNumbers, iSum]{ sum(1, 2, 3) };</code><code>    std::cout &lt;&lt; a::b::c::str &lt;&lt; ' ' &lt;&lt; iNumbers &lt;&lt; ' ' &lt;&lt; iSum &lt;&lt; '\n';</code><code></code><code>    std::array arr{ 1, 2, 3 };</code><code></code><code>    std::cout &lt;&lt; std::size(arr) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>If you can’t compile this code, you either haven’t enabled C++17, or your compiler doesn’t fully support C++17. In the latter case, please install the latest version of your IDE/compiler, as described in lesson <a href="https://www.learncpp.com/cpp-tutorial/installing-an-integrated-development-environment-ide/">0.6 -- Installing an Integrated Development Environment (IDE)</a>.</p><br><h3>Exporting your configuration</h3><p>Having to reselect all of your settings options every time you create a new project is burdensome. Fortunately, most IDEs provide a way to export your settings. This is typically done by creating a new project template with the settings you want, and then selecting that project template when you create a new project.</p><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>In Visual Studio, this option is available via Project -&gt; Export Template. Select “Project template”, add a name and optional description (e.g. C++20 console application), and then click “Finish”.</p><p>Next time you create a new project, you’ll see this template show up in your list of project templates.</p><p>Once you create a new project with this template, it may not open any files. You can open up your .cpp file in the Solution Explorer window by going to Solution -&gt; &lt;Project Name&gt; -&gt; Source Files -&gt; &lt;template name&gt;.cpp.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>In Code::Blocks, choose File -&gt; Save project as template. Give your template a title, and save.</p><p>When you create a new project, you will find this template under the “User templates” option.</p></div><br><h3>Where can I view the C++ standards document?</h3><p>Each C++ language standard is described by a <span class="cpp-definition">standards document</span>, which is a formal technical document that is the authoritative source for the rules and requirements of a given language standard. The standards document is not designed for learning -- rather, it’s designed for compiler writers to be able to implement new language standards accurately. You will occasionally see people quoting the standards document when explaining how something works.</p><p>The approved C++ standards document for a given language standard is not available for free. There is a link to purchase the latest standard <a href="https://isocpp.org/std/the-standard">here</a>.</p><p>When a new language standard is being developed, draft standards documents are published for review.<br>These drafts <em>are</em> available online for free. The last draft standard before the approved standard is generally close enough to the official standard to use for informal purposes. You can find the draft standards <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/standards">here</a>.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">1.1 — Statements and the structure of a program</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Chapter introduction</h3><p>Welcome to the first primary chapter of these C++ tutorials!</p><p>In this chapter, we’ll take a first look at a number of topics that are essential to every C++ program. Because there are quite a few topics to cover, we’ll cover most at a fairly shallow level (just enough to get by). The goal of this chapter is to help you understand how basic C++ programs are constructed. By the end of the chapter, you will be able to write your own simple programs.</p><p>In future chapters, we’ll revisit the majority of these topics and explore them in more detail. We’ll also introduce new concepts that build on top of these.</p><p>In order to keep the lesson lengths manageable, topics may be split over several subsequent lessons. If you feel like some important concept isn’t covered in a lesson, it’s possible that it’s covered in the next lesson.</p><br><h3>Statements</h3><p>A computer program is a sequence of instructions that tell the computer what to do. A <span class="cpp-definition">statement</span> is a type of instruction that causes the program to <em>perform some action</em>.</p><p>Statements are by far the most common type of instruction in a C++ program. This is because they are the smallest independent unit of computation in the C++ language. In that regard, they act much like sentences do in natural language. When we want to convey an idea to another person, we typically write or speak in sentences (not in random words or syllables). In C++, when we want to have our program do something, we typically write statements.</p><p>Most (but not all) statements in C++ end in a semicolon. If you see a line that ends in a semicolon, it’s probably a statement.</p><p>In a high-level language such as C++, a single statement may compile into many machine language instructions.</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>There are many different kinds of statements in C++:</p><ol><li>Declaration statements</li><li>Jump statements</li><li>Expression statements</li><li>Compound statements</li><li>Selection statements (conditionals)</li><li>Iteration statements (loops)</li><li>Try blocks</li></ol><p>By the time you’re through with this tutorial series, you’ll understand what all of these are!</p></div><br><h3>Functions and the main function</h3><p>In C++, statements are typically grouped into units called functions. A <span class="cpp-definition">function</span> is a collection of statements that get executed sequentially (in order, from top to bottom). As you learn to write your own programs, you’ll be able to create your own functions and mix and match statements in any way you please (we’ll show how in a future lesson).</p><div class="cpp-note cpp-lightgreenbackground"><h4>Rule</h4><p>Every C++ program must have a special function named <span class="cpp-definition">main</span> (all lower case letters). When the program is run, the statements inside of <em>main</em> are executed in sequential order.</p></div><p>Programs typically terminate (finish running) after the last statement inside function <em>main</em> has been executed (though programs may abort early in some circumstances, or do some cleanup afterwards).</p><p>Functions are typically written to do a specific job. For example, a function named “max” might contain statements that figures out which of two numbers is larger. A function named “calculateGrade” might calculate a student’s grade from a set of test scores. We will talk a lot more about functions soon, as they are the most commonly used organizing tool in a program.</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>When discussing functions, it’s fairly common shorthand to append a pair of parenthesis to the end of the function’s name. For example, if you see the term <em>main()</em> or <em>doSomething()</em>, this is shorthand for functions named <em>main</em> or <em>doSomething</em> respectively. This helps differentiate functions from other things with names (such as variables) without having to write the word “function” each time.</p></div><br><h3>Dissecting Hello world!</h3><p>Now that you have a brief understanding of what statements and functions are, let’s return to our “Hello world” program and take a high-level look at what each line does in more detail.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>   std::cout &lt;&lt; "Hello world!";</code><code>   return 0;</code><code>}</code></pre><p>Line 1 is a special type of line called a preprocessor directive. This preprocessor directive indicates that we would like to use the contents of the iostream library, which is the part of the C++ standard library that allows us to read and write text from/to the console. We need this line in order to use std::cout on line 5. Excluding this line would result in a compile error on line 5, as the compiler wouldn’t otherwise know what std::cout is.</p><p>Line 2 is blank, and is ignored by the compiler. This line exists only to help make the program more readable to humans (by separating the #include preprocessor directive and the subsequent parts of the program).</p><p>Line 3 tells the compiler that we’re going to write (define) a function called <em>main</em>. As you learned above, every C++ program must have a <em>main</em> function or it will fail to link.</p><p>Lines 4 and 7 tell the compiler which lines are part of the <em>main</em> function. Everything between the opening curly brace on line 4 and the closing curly brace on line 7 is considered part of the <em>main</em> function. This is called the function body.</p><p>Line 5 is the first statement within function <em>main</em>, and is the first statement that will execute when we run our program. <em>std::cout</em> (which stands for “character output”) and the <code>&lt;&lt;</code> operator allow us to send letters or numbers to the console to be output. In this case, we’re sending it the text “Hello world!”, which will be output to the console. This statement creates the visible output of the program.</p><p>Line 6 is a return statement. When an executable program finishes running, the program sends a value back to the operating system in order to indicate whether it ran successfully or not. This particular return statement returns the value of 0 to the operating system, which means “everything went okay!”. This is the last statement in the program that executes.</p><p>All of the programs we write will follow this general template, or a variation on it.</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>If parts (or all) of the above explanation are confusing, that’s to be expected at this point. This was just to provide a quick overview. Subsequent lessons will dig into all of the above topics, with plenty of additional explanation and examples.</p></div><p>You can compile and run this program yourself, and you will see that it outputs the following to the console:</p><pre>Hello world!
</pre><p>If you run into issues compiling or executing this program, check out lesson <a href="https://www.learncpp.com/cpp-tutorial/a-few-common-cpp-problems/">0.8 -- A few common C++ problems</a>.</p><br><h3>Syntax and syntax errors</h3><p>In English, sentences are constructed according to specific grammatical rules that you probably learned in English class in school. For example, normal sentences end in a period. The rules that govern how sentences are constructed in a language is called <span class="cpp-definition">syntax</span>. If you forget the period and run two sentences together, this is a violation of the English language syntax.</p><p>C++ has a syntax too: rules about how your programs must be constructed in order to be considered valid. When you compile your program, the compiler is responsible for making sure your program follows the basic syntax of the C++ language. If you violate a rule, the compiler will complain when you try to compile your program, and issue you a <span class="cpp-definition">syntax error</span>.</p><p>Let’s see what happens if we omit the semicolon on line 5 of the “Hello world” program, like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>   std::cout &lt;&lt; "Hello world!"</code><code>   return 0;</code><code>}</code></pre><p>Feel free to compile this ill-formed program yourself.</p><p>Visual Studio produces the following error (your compiler may generate an error message with different wording):</p><pre>c:\vcprojects\test1.cpp(6): error C2143: syntax error : missing ';' before 'return'</pre><p>This is telling you that you have a syntax error on line 6: the compiler was expecting a semicolon before the return statement, but it didn’t find one. Although the compiler will tell you which line of code it was compiling when it encountered the syntax error, the omission may actually be on a previous line. In this case, the error is actually at the end of line 5 (the compiler didn’t discover the issue until line 6).</p><p>Syntax errors are common when writing a program. Fortunately, they’re typically straightforward to find and fix, as the compiler will generally point you right at them. Compilation of a program will only complete once all syntax errors are resolved.</p><p>You can try deleting characters or even whole lines from the “Hello world” program to see different kinds of errors that get generated. Try restoring the missing semicolon at the end of line 5, and then deleting lines 1, 3, or 4 and see what happens.</p><br><h3>Quiz time</h3><p>The following quiz is meant to reinforce your understanding of the material presented above.</p><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>What is a statement?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>A statement is an instruction in a computer program that tells the computer to perform an action.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>What is a function?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>A function is a collection of statements that executes sequentially.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>What is the name of the function that all programs must have?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>main</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #4</p><p>When a program is run, where does execution start?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><p>Execution starts with the first statement inside the <em>main</em> function.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #5</p><p>What symbol are statements in C++ often ended with?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><p>The semicolon (<code>;</code>)</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #6</p><p>What is a syntax error?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><p>A syntax error is a compiler error that occurs at compile-time when your program violates the grammar rules of the C++ language.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #7</p><p>What is the C++ Standard Library?</p><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">Hint: Review lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-the-compiler-linker-and-libraries/">0.5 -- Introduction to the compiler, linker, and libraries</a></div><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none"><p>A library file is a collection of precompiled code that has been “packaged up” for reuse in other programs. The C++ Standard Library is a library that ships with C++. It contains additional functionality to use in your programs.</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">1.2 — Comments</h1></header><div class="entry-content" itemprop="articleBody"><p>A <span class="cpp-definition">comment</span> is a programmer-readable note that is inserted directly into the source code of the program. Comments are ignored by the compiler and are for the programmer’s use only.</p><p>In C++ there are two different styles of comments, both of which serve the same purpose: to help programmers document the code in some way.</p><br><h3>Single-line comments</h3><p>The <code>//</code> symbol begins a C++ single-line comment, which tells the compiler to ignore everything from the <em>//</em> symbol to the end of the line. For example:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; "Hello world!"; // Everything from here to the end of the line is ignored</code></pre><p>Typically, the single-line comment is used to make a quick comment about a single line of code.</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; "Hello world!\n"; // std::cout lives in the iostream library</code><code>std::cout &lt;&lt; "It is very nice to meet you!\n"; // these comments make the code hard to read</code><code>std::cout &lt;&lt; "Yeah!\n"; // especially when lines are different lengths</code></pre><p>Having comments to the right of a line can make both the code and the comment hard to read, particularly if the line is long. If the lines are fairly short, the comments can simply be aligned (usually to a tab stop), like so:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; "Hello world!\n";                 // std::cout lives in the iostream library</code><code>std::cout &lt;&lt; "It is very nice to meet you!\n"; // this is much easier to read</code><code>std::cout &lt;&lt; "Yeah!\n";                        // don't you think so?</code></pre><p>However, if the lines are long, placing comments to the right can make your lines really long. In that case, single-line comments are often placed above the line it is commenting:</p><pre class="language-cpp line-numbers"><code>// std::cout lives in the iostream library</code><code>std::cout &lt;&lt; "Hello world!\n";</code><code></code><code>// this is much easier to read</code><code>std::cout &lt;&lt; "It is very nice to meet you!\n";</code><code></code><code>// don't you think so?</code><code>std::cout &lt;&lt; "Yeah!\n";</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>The statements above represent one of our first encounters with snippets of code. Because snippets aren’t full programs, they aren’t able to be compiled by themselves. Rather, they exist to demonstrate specific concepts in a concise manner.</p><p>If you would like to compile a snippet, you’ll need to turn it into a full program in order for it to compile. Typically, that program will look something like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    // Replace this line with the snippet of code you'd like to compile</code><code></code><code>    return 0;</code><code>}</code></pre></div><br><h3>Multi-line comments</h3><p>The <code>/*</code> and <code>*/</code> pair of symbols denotes a C-style multi-line comment. Everything in between the symbols is ignored.</p><pre class="language-cpp line-numbers"><code>/* This is a multi-line comment.</code><code>   This line will be ignored.</code><code>   So will this one. */</code></pre><p>Since everything between the symbols is ignored, you will sometimes see programmers “beautify” their multi-line comments:</p><pre class="language-cpp line-numbers"><code>/* This is a multi-line comment.</code><code> * the matching asterisks to the left</code><code> * can make this easier to read</code><code> */</code></pre><p>Multi-line style comments can not be nested. Consequently, the following will have unexpected results:</p><pre class="language-cpp line-numbers"><code>/* This is a multi-line /* comment */ this is not inside the comment */</code><code>// The above comment ends at the first */, not the second */</code></pre><p>When the compiler tries to compile this, it will ignore everything from the first <em>/*</em> to the first */. Since “<em>this is not inside the comment */</em>” is not considered part of the comment, the compiler will try to compile it. That will inevitably result in a compile error.</p><p>This is one place where using a syntax highlighter can be really useful, as the different coloring for comment should make clear what’s considered part of the comment vs not.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Don’t use multi-line comments inside other multi-line comments. Wrapping single-line comments inside a multi-line comment is okay.</p></div><br><h3>Proper use of comments</h3><p>Typically, comments should be used for three things. First, for a given library, program, or function, comments are best used to describe <em>what</em> the library, program, or function, does. These are typically placed at the top of the file or library, or immediately preceding the function. For example:</p><pre class="language-cpp line-numbers"><code>// This program calculates the student's final grade based on their test and homework scores.</code></pre><pre class="language-cpp line-numbers"><code>// This function uses Newton's method to approximate the root of a given equation.</code></pre><pre class="language-cpp line-numbers"><code>// The following lines generate a random item based on rarity, level, and a weight factor.</code></pre><p>All of these comments give the reader a good idea of what the library, program, or function is trying to accomplish without having to look at the actual code. The user (possibly someone else, or you if you’re trying to reuse code you’ve previously written) can tell at a glance whether the code is relevant to what he or she is trying to accomplish. This is particularly important when working as part of a team, where not everybody will be familiar with all of the code.</p><p>Second, <em>within</em> a library, program, or function described above, comments can be used to describe <em>how</em> the code is going to accomplish its goal.</p><pre class="language-cpp line-numbers"><code>/* To calculate the final grade, we sum all the weighted midterm and homework scores</code><code>    and then divide by the number of scores to assign a percentage, which is</code><code>    used to calculate a letter grade. */</code></pre><pre class="language-cpp line-numbers"><code>// To generate a random item, we're going to do the following:</code><code>// 1) Put all of the items of the desired rarity on a list</code><code>// 2) Calculate a probability for each item based on level and weight factor</code><code>// 3) Choose a random number</code><code>// 4) Figure out which item that random number corresponds to</code><code>// 5) Return the appropriate item</code></pre><p>These comments give the user an idea of how the code is going to accomplish its goal without having to understand what each individual line of code does.</p><p>Third, at the statement level, comments should be used to describe <em>why</em> the code is doing something. A bad statement comment explains <em>what</em> the code is doing. If you ever write code that is so complex that needs a comment to explain <em>what</em> a statement is doing, you probably need to rewrite your statement, not comment it.</p><p>Here are some examples of bad line comments and good statement comments.</p><p>Bad comment:</p><pre class="language-cpp line-numbers"><code>// Set sight range to 0</code><code>sight = 0;</code></pre><p>Reason: We already can see that sight is being set to 0 by looking at the statement</p><p>Good comment:</p><pre class="language-cpp line-numbers"><code>// The player just drank a potion of blindness and can not see anything</code><code>sight = 0;</code></pre><p>Reason: Now we know why the player’s sight is being set to 0</p><p>Bad comment:</p><pre class="language-cpp line-numbers"><code>// Calculate the cost of the items</code><code>cost = quantity * 2 * storePrice;</code></pre><p>Reason: We can see that this is a cost calculation, but why is quantity multiplied by 2?</p><p>Good comment:</p><pre class="language-cpp line-numbers"><code>// We need to multiply quantity by 2 here because they are bought in pairs</code><code>cost = quantity * 2 * storePrice;</code></pre><p>Reason: Now we know why this formula makes sense.</p><p>Programmers often have to make a tough decision between solving a problem one way, or solving it another way. Comments are a great way to remind yourself (or tell somebody else) the reason you made one decision instead of another.</p><p>Good comments:</p><pre class="language-cpp line-numbers"><code>// We decided to use a linked list instead of an array because</code><code>// arrays do insertion too slowly.</code></pre><pre class="language-cpp line-numbers"><code>// We're going to use Newton's method to find the root of a number because</code><code>// there is no deterministic way to solve these equations.</code></pre><p>Finally, comments should be written in a way that makes sense to someone who has no idea what the code does. It is often the case that a programmer will say “It’s obvious what this does! There’s no way I’ll forget about this”. Guess what? It’s <em>not</em> obvious, and you <em>will</em> be amazed how quickly you forget. :) You (or someone else) will thank you later for writing down the what, how, and why of your code in human language. Reading individual lines of code is easy. Understanding what goal they are meant to accomplish is not.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Comment your code liberally, and write your comments as if speaking to someone who has no idea what the code does. Don’t assume you’ll remember why you made specific choices.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>Throughout the rest of this tutorial series, we’ll use comments inside code blocks to draw your attention to specific things, or help illustrate how things work (while ensuring the programs still compile). Astute readers will note that by the above standards, most of these comments are horrible. :) As you read through the rest of the tutorials, keep in mind that the comments are serving an intentional educational purpose, not trying to demonstrate what good comments look like.</p></div><br><h3>Commenting out code</h3><p>Converting one or more lines of code into a comment is called <span class="cpp-definition">commenting out</span> your code. This provides a convenient way to (temporarily) exclude parts of your code from being included in your compiled program.</p><p>To comment out a single line of code, simply use the // style comment to turn a line of code into a comment temporarily:</p><p>Uncommented out:</p><pre class="language-cpp line-numbers"><code>    std::cout &lt;&lt; 1;</code></pre><p>Commented out:</p><pre class="language-cpp line-numbers"><code>//    std::cout &lt;&lt; 1;</code></pre><p>To comment out a block of code, use // on multiple lines of code, or the /* */ style comment to turn the block of code into a comment temporarily.</p><p>Uncommented out:</p><pre class="language-cpp line-numbers"><code>    std::cout &lt;&lt; 1;</code><code>    std::cout &lt;&lt; 2;</code><code>    std::cout &lt;&lt; 3;</code></pre><p>Commented out:</p><pre class="language-cpp line-numbers"><code>//    std::cout &lt;&lt; 1;</code><code>//    std::cout &lt;&lt; 2;</code><code>//    std::cout &lt;&lt; 3;</code></pre><p>or</p><pre class="language-cpp line-numbers"><code>/*</code><code>    std::cout &lt;&lt; 1;</code><code>    std::cout &lt;&lt; 2;</code><code>    std::cout &lt;&lt; 3;</code><code>*/</code></pre><p>There are quite a few reasons you might want to do this:</p><ol start="1"><li>You’re working on a new piece of code that won’t compile yet, and you need to run the program. The compiler won’t let you compile the code if there are compiler errors. Commenting out the code that won’t compile will allow the program to compile so you can run it. When you’re ready, you can uncomment the code, and continue working on it.</li><li>You’ve written new code that compiles but doesn’t work correctly, and you don’t have time to fix it until later. Commenting out the broken code will ensure the broken code doesn’t execute and cause problems until you can fix it.</li><li>To find the source of an error. If a program isn’t producing the desired results (or is crashing), it can sometimes be useful to disable parts of your code to see if you can isolate what’s causing it to not work correctly. If you comment out one or more lines of code, and your program starts working as expected (or stops crashing), odds are whatever you last commented out was part of the problem. You can then investigate why those lines of code are causing the problem.</li><li>You want to replace one piece of code with another piece of code. Instead of just deleting the original code, you can comment it out and leave it there for reference until you’re sure your new code works properly. Once you are sure your new code is working, you can remove the old commented out code. If you can’t get your new code to work, you can always delete the new code and uncomment the old code to revert to what you had before.</li></ol><p>Commenting out code is a common thing to do while developing, so many IDEs provide support for commenting out a highlighted section of code. How you access this functionality varies by IDE.</p><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>You can comment or uncomment a selection via Edit menu &gt; Advanced &gt; Comment Selection (or Uncomment Selection).</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>You can comment or uncomment a selection via Edit menu &gt; Comment (or Uncomment, or Toggle comment, or any of the other comment tools).</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>If you always use single line comments for your normal comments, then you can always use multi-line comments to comment out your code without conflict. If you use multi-line comments to document your code, then commenting-out code using comments can become more challenging.</p><p>If you do need to comment out a code block that contains multi-line comments, you can also consider using the <code>#if 0</code> preprocessor directive, which we discuss in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-the-preprocessor/#if0">2.10 -- Introduction to the preprocessor</a>.</p></div><br><h3>Summary</h3><ul><li>At the library, program, or function level, use comments to describe <em>what</em>.</li><li>Inside the library, program, or function, use comments to describe <em>how</em>.</li><li>At the statement level, use comments to describe <em>why</em>.</li></ul></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">1.3 — Introduction to objects and variables</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Data</h3><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/statements-and-the-structure-of-a-program/">1.1 -- Statements and the structure of a program</a>, you learned that the majority of instructions in a program are statements, and that functions are groups of statements that execute sequentially. The statements inside the function perform actions that (hopefully) generate whatever result the program was designed to produce.</p><p>But how do programs actually produce results? They do so by manipulating (reading, changing, and writing) data. In computing, <span class="cpp-definition">data</span> is any information that can be moved, processed, or stored by a computer.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Programs are collections of instructions that manipulate data to produce a desired result.</p></div><p>A program can acquire data to work with in many ways: from a file or database, over a network, from the user providing input on a keyboard, or from the programmer putting data directly into the source code of the program itself. In the “Hello world” program from the aforementioned lesson, the text “Hello world!” was inserted directly into the source code of the program, providing data for the program to use. The program then manipulates this data by sending it to the monitor to be displayed.</p><p>Data on a computer is typically stored in a format that is efficient for storage or processing (and is thus not human readable). Thus, when the “Hello World” program is compiled, the text “Hello world!” is converted into a more efficient format for the program to use (binary, which we’ll discuss in a future lesson).</p><br><h3>Objects and variables</h3><p>All computers have memory, called <span class="cpp-definition">RAM</span> (short for random access memory), that is available for your programs to use. You can think of RAM as a series of numbered mailboxes that can each be used to hold a piece of data while the program is running. A single piece of data, stored in memory somewhere, is called a <span class="cpp-definition">value</span>.</p><p>In some older programming languages (like Apple Basic), you could directly access these mailboxes (a statement could say something like <em>go get the value stored in mailbox number 7532</em>).</p><p>In C++, direct memory access is discouraged. Instead, we access memory indirectly through an object. An <span class="cpp-definition">object</span> is a region of storage (usually memory) that has a value and other associated properties (that we’ll cover in future lessons). How the compiler and operating system work to assign memory to objects is beyond the scope of this lesson. But the key point here is that rather than say <em>go get the value stored in mailbox number 7532</em>, we can say, <em>go get the value stored by this object</em>. This means we can focus on using objects to store and retrieve values, and not have to worry about where in memory they’re actually being placed.</p><p>Objects can be named or unnamed (anonymous). A named object is called a <span class="cpp-definition">variable</span>, and the name of the object is called an <span class="cpp-definition">identifier</span>. In our programs, most of the objects we create and use will be variables.</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>In general programming, the term <em>object</em> typically refers to an unnamed object in memory, a variable, or a function. In C++, the term <em>object</em> has a narrower definition that excludes functions.</p></div><br><h3>Variable instantiation</h3><p>In order to create a variable, we use a special kind of declaration statement called a <span class="cpp-definition">definition</span> (we’ll clarify the difference between a declaration and definition later).</p><p>Here’s an example of defining a variable named x:</p><pre class="language-cpp line-numbers"><code>int x; // define a variable named x, of type int</code></pre><p>At compile time, when the compiler sees this statement, it makes a note to itself that we are defining a variable, giving it the name <em>x</em>, and that it is of type <em>int</em> (more on types in a moment). From that point forward (with some limitations that we’ll talk about in a future lesson), whenever the compiler sees the identifier <em>x</em>, it will know that we’re referencing this variable.</p><p>When the program is run (called <span class="cpp-definition">runtime</span>), the variable will be instantiated. <span class="cpp-definition">Instantiation</span> is a fancy word that means the object will be created and assigned a memory address. Variables must be instantiated before they can be used to store values. For the sake of example, let’s say that variable <em>x</em> is instantiated at memory location 140. Whenever the program uses variable x, it will access the value in memory location 140. An instantiated object is sometimes also called an <span class="cpp-definition">instance</span>.</p><br><h3>Data types</h3><p>So far, we’ve covered that variables are a named region of storage that can store a data value (how exactly data is stored is a topic for a future lesson). A <span class="cpp-definition">data type</span> (more commonly just called a <span class="cpp-definition">type</span>) tells the compiler what type of value (e.g. a number, a letter, text, etc…) the variable will store.</p><p>In the above example, our variable <em>x</em> was given type <em>int</em>, which means variable x will represent an integer value. An <span class="cpp-definition">integer</span> is a number that can be written without a fractional component, such as 4, 27, 0, -2, or -12. For short, we can say that <em>x</em> is an <em>integer variable</em>.</p><p>In C++, the type of a variable must be known at <span class="cpp-definition">compile-time</span> (when the program is compiled), and that type can not be changed without recompiling the program. This means an integer variable can only hold integer values. If you want to store some other kind of value, you’ll need to use a different variable.</p><p>Integers are just one of many types that C++ supports out of the box. For illustrative purposes, here’s another example of defining a variable using data type <em>double</em>:</p><pre class="language-cpp line-numbers"><code>double width; // define a variable named width, of type double</code></pre><p>C++ also allows you to create your own user-defined types. This is something we’ll do a lot of in future lessons, and it’s part of what makes C++ powerful.</p><p>For these introductory chapters, we’ll stick with integer variables because they are conceptually simple, but we’ll explore many of the other types C++ has to offer soon.</p><br><h3>Defining multiple variables</h3><p>It is possible to define multiple variables <em>of the same type</em> in a single statement by separating the names with a comma. The following 2 snippets of code are effectively the same:</p><pre class="language-cpp line-numbers"><code>int a;</code><code>int b;</code></pre><p>is the same as:</p><pre class="language-cpp line-numbers"><code>int a, b;</code></pre><p>When defining multiple variables this way, there are two common mistakes that new programmers tend to make (neither serious, since the compiler will catch these and ask you to fix them):</p><p>The first mistake is giving each variable a type when defining variables in sequence.</p><pre class="language-cpp line-numbers"><code>int a, int b; // wrong (compiler error)</code><code></code><code>int a, b; // correct</code></pre><p>The second mistake is to try to define variables of different types in the same statement, which is not allowed. Variables of different types must be defined in separate statements.</p><pre class="language-cpp line-numbers"><code>int a, double b; // wrong (compiler error)</code><code></code><code>int a; double b; // correct (but not recommended)</code><code></code><code>// correct and recommended (easier to read)</code><code>int a;</code><code>double b;</code></pre><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Although the language allows you to do so, avoid defining multiple variables of the same type in a single statement. Instead, define each variable in a separate statement on its own line (and then use a single-line comment to document what it is used for).</p></div><br><h3>Summary</h3><p>In C++, we use variables to access memory. Variables have an identifier, a type, and a value (and some other attributes that aren’t relevant here). A variable’s type is used to determine how the value in memory should be interpreted.</p><p>In the next lesson, we’ll look at how to give values to our variables and how to actually use them.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>What is data?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>Data is any information that can be moved, processed, or stored by a computer.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>What is a value?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>A value is a single piece of data stored in memory.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>What is a variable?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>A variable is a named region of memory.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #4</p><p>What is an identifier?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><p>An identifier is the name that a variable is accessed by.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #5</p><p>What is a type?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><p>A type tells the program how to interpret a value in memory.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #6</p><p>What is an integer?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><p>An integer is a number that can be written without a fractional component.</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">1.4 — Variable assignment and initialization</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-objects-and-variables/">1.3 -- Introduction to objects and variables</a>), we covered how to define a variable that we can use to store values. In this lesson, we’ll explore how to actually put values into variables and use those values.</p><p>As a reminder, here’s a short snippet that first allocates a single integer variable named <em>x</em>, then allocates two more integer variables named <em>y</em> and <em>z</em>:</p><pre class="language-cpp line-numbers"><code>int x; // define an integer variable named x</code><code>int y, z; // define two integer variables, named y and z</code></pre><br><h3>Variable assignment</h3><p>After a variable has been defined, you can give it a value (in a separate statement) using the <em>= operator</em>. This process is called <span class="cpp-definition">copy assignment</span> (or just <span class="cpp-definition">assignment</span>) for short.</p><pre class="language-cpp line-numbers"><code>int width; // define an integer variable named width</code><code>width = 5; // copy assignment of value 5 into variable width</code><code></code><code>// variable width now has value 5</code></pre><p>Copy assignment is named such because it copies the value on the right-hand side of the <em>= operator</em> to the variable on the left-hand side of the operator. The <em>= operator</em> is called the <span class="cpp-definition">assignment operator</span>.</p><p>Here’s an example where we use assignment twice:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	int width;</code><code>	width = 5; // copy assignment of value 5 into variable width</code><code></code><code>	// variable width now has value 5</code><code></code><code>	width = 7; // change value stored in variable width to 7</code><code></code><code>	// variable width now has value 7</code><code></code><code>	return 0;</code><code>}</code></pre><p>When we assign value 7 to variable <em>width</em>, the value 5 that was there previously is overwritten. Normal variables can only hold one value at a time.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>One of the most common mistakes that new programmers make is to confuse the assignment operator (<code>=</code>) with the equality operator (<code>==</code>). Assignment (<code>=</code>) is used to assign a value to a variable. Equality (<code>==</code>) is used to test whether two operands are equal in value.</p></div><br><h3>Initialization</h3><p>One downside of assignment is that it requires at least two statements: one to define the variable, and one to assign the value.</p><p>These two steps can be combined. When a variable is defined, you can also provide an initial value for the variable at the same time. This is called <span class="cpp-definition">initialization</span>. The value used to initialize a variable is called an <span class="cpp-definition">initializer</span>.</p><p>Initialization in C++ is surprisingly complex, so we’ll present a simplified view here.</p><p>There are 4 basic ways to initialize variables in C++:</p><pre class="language-cpp line-numbers"><code>int a; // no initializer</code><code>int b = 5; // initializer after equals sign</code><code>int c( 6 ); // initializer in parenthesis</code><code>int d { 7 }; // initializer in braces</code></pre><p>You may see the above forms written with different spacing (e.g. <code>int d{7};</code>). Whether you use extra spaces for readability or not is a matter of personal preference.</p><br><h3>Default initialization</h3><p>When no initialization value is provided (such as for variable <em>a</em> above), this is called <span class="cpp-definition">default initialization</span>. In most cases, default initialization leaves a variable with an indeterminate value. We’ll cover this case further in lesson (<a href="https://www.learncpp.com/cpp-tutorial/uninitialized-variables-and-undefined-behavior/">1.6 -- Uninitialized variables and undefined behavior</a>).</p><br><h3>Copy initialization</h3><p>When an initializer is provided after an equals sign, this is called <span class="cpp-definition">copy initialization</span>. Copy initialization was inherited from the C language.</p><pre class="language-cpp line-numbers"><code>int width = 5; // copy initialization of value 5 into variable width</code></pre><p>Much like copy assignment, this copies the value on the right-hand side of the equals to the variable being created on the left-hand side. In the above snippet, variable <code>width</code> will be initialized with value <code>5</code>.</p><p>Copy initialization is not used much in modern C++. However, you may still see it in older code, or in code written by developers who learned C first.</p><br><h3>Direct initialization</h3><p>When an initializer is provided inside parenthesis, this is called <span class="cpp-definition">direct initialization</span>.</p><pre class="language-cpp line-numbers"><code>int width( 5 ); // direct initialization of value 5 into variable width</code></pre><p>Direct initialization was initially introduced to allow for more efficient initialization of complex objects (those with class types, which we’ll cover in a future chapter). However, like copy initialization, direct initialization is not used much in modern C++ (except for one specific case that we’ll cover when we get to it).</p><br><h3>Brace initialization</h3><p>The modern way to initialize objects in C++ is to use a form of initialization that makes use of curly braces: <span class="cpp-definition">brace initialization</span> (also called <span class="cpp-definition">uniform initialization</span> or <span class="cpp-definition">list initialization</span>).</p><p>Brace initialization comes in three forms:</p><pre class="language-cpp line-numbers"><code>int width { 5 }; // direct brace initialization of value 5 into variable width (preferred)</code><code>int height = { 6 }; // copy brace initialization of value 6 into variable height</code><code>int depth {}; // value initialization (see next section)</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>Prior to the introduction of brace initialization, some types of initialization required using copy initialization, and other types of initialization required using direct initialization. Brace initialization was introduced to provide a more consistent initialization syntax (which is why it is sometimes called “uniform initialization”) that works in most cases. Additionally, brace initialization provides a way to initialize objects with a list of values (which is why it is sometimes called “list initialization”).</p></div><p>Brace initialization has an added benefit: it disallows “narrowing conversions”. This means that if you try to brace initialize a variable using a value that the variable can not safely hold, the compiler will produce an error. For example:</p><pre class="language-cpp line-numbers"><code>int width { 4.5 }; // error: a number with a fractional value can't fit into an int</code></pre><p>In the above snippet, we’re trying to assign a number (4.5) that has a fractional part (the .5 part) to an integer variable (which can only hold numbers without fractional parts).</p><p>Copy and direct initialization would simply drop the fractional part, resulting in the initialization of value 4 into variable <em>width</em> (your compiler may produce a warning about this, since losing data is rarely desired). However, with brace initialization, the compiler will generate an error instead, forcing you to remedy this issue before proceeding.</p><p>Conversions that can be done without potential data loss are allowed.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Favor initialization using braces whenever possible.</p></div><br><h3>Value initialization and zero initialization</h3><p>When a variable is initialized with empty braces, <span class="cpp-definition">value initialization</span> takes place. In most cases, <span class="cpp-definition">value initialization</span> will initialize the variable to zero (or empty, if that’s more appropriate for a given type). In such cases where zeroing occurs, this is called <span class="cpp-definition">zero initialization</span>.</p><pre class="language-cpp line-numbers"><code>int width {}; // zero initialization to value 0</code></pre><div class="cpp-note cpp-lightbluebackground"><h4>Q: When should I initialize with { 0 } vs {}?</h4><p>Use an explicit initialization value if you’re actually using that value.</p><pre class="language-cpp line-numbers"><code>int x { 0 }; // explicit initialization to value 0</code><code>std::cout &lt;&lt; x; // we're using that zero value</code></pre><p>Use value initialization if the value is temporary and will be replaced.</p><pre class="language-cpp line-numbers"><code>int x {}; // value initialization</code><code>std::cin &gt;&gt; x; // we're immediately replacing that value</code></pre></div><br><h3>Initialize your variables</h3><p>Initialize your variables upon creation. You may eventually find cases where you want to ignore this advice for a specific reason (e.g. a performance critical section of code that uses a lot of variables), and that’s okay, as long the choice is made deliberately.</p><p>For more discussion on this topic, Bjarne Stroustrup (creator of C++) and Herb Sutter (C++ expert) make this recommendation themselves <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es20-always-initialize-an-object">here</a>.</p><p>We explore what happens if you try to use a variable that doesn’t have a well-defined value in lesson <a href="https://www.learncpp.com/cpp-tutorial/uninitialized-variables-and-undefined-behavior/">1.6 -- Uninitialized variables and undefined behavior</a>.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Initialize your variables upon creation.</p></div><br><h3>Initializing multiple variables</h3><p>In the last section, we noted that it is possible to define multiple variables <em>of the same type</em> in a single statement by separating the names with a comma:</p><pre class="language-cpp line-numbers"><code>int a, b;</code></pre><p>We also noted that best practice is to avoid this syntax altogether. However, since you may encounter other code that uses this style, it’s still useful to talk a little bit more about it, if for no other reason than to reinforce some of the reasons you should be avoiding it.</p><p>You can initialize multiple variables defined on the same line:</p><pre class="language-cpp line-numbers"><code>int a = 5, b = 6; // copy initialization</code><code>int c( 7 ), d( 8 ); // direct initialization</code><code>int e { 9 }, f { 10 }; // brace initialization (preferred)</code></pre><p>Unfortunately, there’s a common pitfall here that can occur when the programmer mistakenly tries to initialize both variables by using one initialization statement:</p><pre class="language-cpp line-numbers"><code>int a, b = 5; // wrong (a is not initialized!)</code><code></code><code>int a = 5, b = 5; // correct</code></pre><p>In the top statement, variable “a” will be left uninitialized, and the compiler may or may not complain. If it doesn’t, this is a great way to have your program intermittently crash or produce sporadic results. We’ll talk more about what happens if you use uninitialized variables shortly.</p><p>The best way to remember that this is wrong is to consider the case of direct initialization or brace initialization:</p><pre class="language-cpp line-numbers"><code>int a, b( 5 );</code><code>int c, d{ 5 };</code></pre><p>Because the parenthesis or braces are typically placed right next to the variable name, this makes it seem a little more clear that the value 5 is only being used to initialize variable <em>b</em> and <em>d</em>, not <em>a</em> or <em>c</em>.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>What is the difference between initialization and assignment?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>Initialization gives a variable an initial value at the point when it is created. Assignment gives a variable a value at some point after the variable is created.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>What form of initialization should you be using?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>Direct brace initialization.</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">1.5 — Introduction to iostream: cout, cin, and endl</h1></header><div class="entry-content" itemprop="articleBody"><p>In this lesson, we’ll talk more about std::cout, which we used in our <em>Hello world!</em> program to output the text <em>Hello world!</em> to the console. We’ll also explore how to get input from the user, which we will use to make our programs more interactive.</p><br><h3>The input/output library</h3><p>The <span class="cpp-definition">input/output library</span> (io library) is part of the C++ standard library that deals with basic input and output. We’ll use the functionality in this library to get input from the keyboard and output data to the console. The <em>io</em> part of <em>iostream</em> stands for <em>input/output</em>.</p><p>To use the functionality defined within the <em>iostream</em> library, we need to include the <em>iostream</em> header at the top of any code file that uses the content defined in <em>iostream</em>, like so:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// rest of code that uses iostream functionality here</code></pre><br><h3>std::cout</h3><p>The <em>iostream</em> library contains a few predefined variables for us to use. One of the most useful is <span class="cpp-definition">std::cout</span>, which allows us to send data to the console to be printed as text. <em>cout</em> stands for “character output”.</p><p>As a reminder, here’s our <em>Hello world</em> program:</p><pre class="language-cpp line-numbers"><code>#include <iostream> // for std::cout</iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Hello world!"; // print Hello world! to console</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this program, we have included <em>iostream</em> so that we have access to <em>std::cout</em>. Inside our <em>main</em> function, we use <em>std::cout</em>, along with the <span class="cpp-definition">insertion operator (<code>&lt;&lt;</code>)</span>, to send the text <em>Hello world!</em> to the console to be printed.</p><p><em>std::cout</em> can not only print text, it can also print numbers:</p><pre class="language-cpp line-numbers"><code>#include <iostream> // for std::cout</iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; 4; // print 4 to console</code><code></code><code>    return 0;</code><code>}</code></pre><p>This produces the result:</p><pre>4
</pre><p>It can also be used to print the value of variables:</p><pre class="language-cpp line-numbers"><code>#include <iostream> // for std::cout</iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 }; // define integer variable x, initialized with value 5</code><code>    std::cout &lt;&lt; x; // print value of x (5) to console</code><code>    return 0;</code><code>}</code></pre><p>This produces the result:</p><pre>5
</pre><p>To print more than one thing on the same line, the insertion operator (<code>&lt;&lt;</code>) can be used multiple times in a single statement to concatenate (link together) multiple pieces of output. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream> // for std::cout</iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Hello" &lt;&lt; " world!";</code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>Hello world!
</pre><p>Here’s another example where we print both text and the value of a variable in the same statement:</p><pre class="language-cpp line-numbers"><code>#include <iostream> // for std::cout</iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    std::cout &lt;&lt; "x is equal to: " &lt;&lt; x;</code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>x is equal to: 5
</pre><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We discuss what the <em>std::</em> prefix actually does in lesson <a href="https://www.learncpp.com/cpp-tutorial/naming-collisions-and-an-introduction-to-namespaces/">2.9 -- Naming collisions and an introduction to namespaces</a>.</p></div><br><h3>std::endl</h3><p>What would you expect this program to print?</p><pre class="language-cpp line-numbers"><code>#include <iostream> // for std::cout</iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Hi!";</code><code>    std::cout &lt;&lt; "My name is Alex.";</code><code>    return 0;</code><code>}</code></pre><p>You might be surprised at the result:</p><pre>Hi!My name is Alex.
</pre><p>Separate output statements don’t result in separate lines of output on the console.</p><p>If we want to print separate lines of output to the console, we need to tell the console when to move the cursor to the next line.</p><p>One way to do that is to use <em>std::endl</em>. When output with <em>std::cout</em>, <em>std::endl</em> prints a newline character to the console (causing the cursor to go to the start of the next line). In this context, <em>endl</em> stands for “end line”.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream> // for std::cout and std::endl</iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Hi!" &lt;&lt; std::endl; // std::endl will cause the cursor to move to the next line of the console</code><code>    std::cout &lt;&lt; "My name is Alex." &lt;&lt; std::endl;</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>Hi!
My name is Alex.
</pre><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>In the above program, the second <em>std::endl</em> isn’t technically necessary, since the program ends immediately afterward. However, it serves a few useful purposes.</p><p>First, it helps indicate that the line of output is a “complete thought” (as opposed to partial output that is completed somewhere later in the code). In this sense, it functions similarly to using a period in standard English.</p><p>Second, it positions the cursor on the next line, so that if we later add additional lines of output (e.g. have the program say “bye!”), those lines will appear where we expect (rather then appended to the prior line of output).</p><p>Third, after running an executable from the command line, some operating systems do not output a new line before showing the command prompt again. If our program does not end with the cursor on a new line, the command prompt may appear appended to the prior line of output, rather than at the start of a new line as the user would expect.</p></div><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Output a newline whenever a line of output is complete.</p></div><br><h3>std::endl vs ‘\n’</h3><p>Using std::endl can be a bit inefficient, as it actually does two jobs: it moves the cursor to the next line, and it makes sure that the output shows up on the screen immediately (this is called <span class="cpp-definition">flushing</span> the output). When writing text to the console using std::cout, std::cout often flushes output anyway (and if it doesn’t, it usually doesn’t matter), so having std::endl perform a flush is rarely important.</p><p>Because of this, use of the ‘\n’ character is typically preferred instead. The ‘\n’ character moves the cursor to the next line, but doesn’t request a flush, so it will perform better in cases where a flush would not otherwise happen. The ‘\n’ character also tends to be easier to read since it’s both shorter and can be embedded into existing text.</p><p>Here’s an example that uses ‘\n’ in two different ways:</p><pre class="language-cpp line-numbers"><code>#include <iostream> // for std::cout</iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    std::cout &lt;&lt; "x is equal to: " &lt;&lt; x &lt;&lt; '\n'; // Using '\n' standalone</code><code>    std::cout &lt;&lt; "And that's all, folks!\n"; // Using '\n' embedded into a double-quoted piece of text (note: no single quotes when used this way)</code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>x is equal to: 5
And that's all, folks!
</pre><p>Note that when ‘\n’ is used by itself to move the cursor to the next line, the single quotes are needed. When embedded into text that is already double-quoted, the single quotes aren’t needed.</p><p>We’ll cover what ‘\n’ is in more detail when we get to the lesson on chars (<a href="https://www.learncpp.com/cpp-tutorial/chars/">4.11 -- Chars</a>).</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Prefer ‘\n’ over std::endl when outputting text to the console.</p></div><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>‘\n’ uses a backslash (as do all special characters in C++), not a forward slash. Using a forward slash (e.g. ‘/n’) instead may result in unexpected behavior.</p></div><br><h3>std::cin</h3><p><code>std::cin</code> is another predefined variable that is defined in the <code>iostream</code> library. Whereas <code>std::cout</code> prints data to the console using the insertion operator (<code>&lt;&lt;</code>), <code>std::cin</code> (which stands for “character input”) reads input from keyboard using the <span class="cpp-definition">extraction operator (<code>&gt;&gt;</code>)</span>. The input must be stored in a variable to be used.</p><pre class="language-cpp line-numbers"><code>#include <iostream>  // for std::cout and std::cin</iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number: "; // ask user for a number</code><code></code><code>    int x{ }; // define variable x to hold user input (and zero-initialize it)</code><code>    std::cin &gt;&gt; x; // get number from keyboard and store it in variable x</code><code></code><code>    std::cout &lt;&lt; "You entered " &lt;&lt; x &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>Try compiling this program and running it for yourself. When you run the program, line 5 will print “Enter a number: “. When the code gets to line 8, your program will wait for you to enter input. Once you enter a number (and press enter), the number you enter will be assigned to variable <em>x</em>. Finally, on line 10, the program will print “You entered ” followed by the number you just entered.</p><p>For example (I entered 4):</p><pre>Enter a number: 4
You entered 4
</pre><p>This is an easy way to get keyboard input from the user, and we will use it in many of our examples going forward. Note that you don’t need to use ‘\n’ when accepting input, as the user will need to press the <em>enter</em> key to have their input accepted, and this will move the cursor to the next line.</p><p>If your screen closes immediately after entering a number, please see lesson <a href="https://www.learncpp.com/cpp-tutorial/a-few-common-cpp-problems/">0.8 -- A few common C++ problems</a> for a solution.</p><p>Just like it is possible to output more than one bit of text in a single line, it is also possible to input more than one value on a single line:</p><pre class="language-cpp line-numbers"><code>#include <iostream>  // for std::cout and std::cin</iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter two numbers separated by a space: ";</code><code></code><code>    int x{ }; // define variable x to hold user input (and zero-initialize it)</code><code>    int y{ }; // define variable y to hold user input (and zero-initialize it)</code><code>    std::cin &gt;&gt; x &gt;&gt; y; // get two numbers and store in variable x and y respectively</code><code></code><code>    std::cout &lt;&lt; "You entered " &lt;&lt; x &lt;&lt; " and " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This produces the output:</p><pre>Enter two numbers separated by a space: 5 6
You entered 5 and 6
</pre><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>There’s some debate over whether it’s necessary to initialize a variable immediately before you give it a user provided value via another source (e.g. std::cin), since the user-provided value will just overwrite the initialization value. In line with our previous recommendation that variables should always be initialized, best practice is to initialize the variable first.</p></div><p>We’ll discuss how <em>std::cin</em> handles invalid input in a future lesson (<a href="https://www.learncpp.com/cpp-tutorial/stdcin-and-handling-invalid-input/">7.16 -- std::cin and handling invalid input</a>).</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>The C++ I/O library does not provide a way to accept keyboard input without the user having to press <em>enter</em>. If this is something you desire, you’ll have to use a third party library. For console applications, we’d recommend <a href="https://pdcurses.org/">pdcurses</a>, <a href="https://github.com/ArthurSonzogni/FTXUI">FXTUI</a>, or <a href="https://github.com/jupyter-xeus/cpp-terminal">cpp-terminal</a>. Many graphical user libraries have their own functions to do this kind of thing.</p></div><br><h3>Summary</h3><p>New programmers often mix up std::cin, std::cout, the insertion operator (<code>&lt;&lt;</code>) and the extraction operator (<code>&gt;&gt;</code>). Here’s an easy way to remember:</p><ul><li><code>std::cin</code> and <code>std::cout</code> always go on the left-hand side of the statement.</li><li><code>std::cout</code> is used to output a value (cout = character output)</li><li><code>std::cin</code> is used to get an input value (cin = character input)</li><li><code>&lt;&lt;</code> is used with std::cout, and shows the direction that data is moving (if <code>std::cout</code> represents the console, the output data is moving from the variable to the console). <code>std::cout &lt;&lt; 4</code> moves the value of 4 to the console</li><li><code>&gt;&gt;</code> is used with <code>std::cin</code>, and shows the direction that data is moving (if std::cin represents the keyboard, the input data is moving from the keyboard to the variable). <code>std::cin &gt;&gt; x</code> moves the value the user entered from the keyboard into x</li></ul><p>We’ll talk more about operators in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-literals-and-operators/">1.9 -- Introduction to literals and operators</a>.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Consider the following program that we used above:</p><pre class="language-cpp line-numbers"><code>#include <iostream>  // for std::cout and std::cin</iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number: "; // ask user for a number</code><code>    int x{}; // define variable x to hold user input</code><code>    std::cin &gt;&gt; x; // get number from keyboard and store it in variable x</code><code>    std::cout &lt;&lt; "You entered " &lt;&lt; x &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>The program expects you to enter an integer value, as the variable x that the user input will be put into is an integer variable.</p><p>Run this program multiple times and describe what happens when you enter the following types of input instead:</p><p>a) A letter, such as <em>h</em></p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>x is 0.</p></div><p>b) A number with a fractional component. Try numbers with fractional components less than 0.5 and greater than 0.5 (e.g. <em>3.2</em> and <em>3.7</em>).</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>The fractional component is dropped.</p></div><p>c) A small negative integer, such as <em>-3</em></p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>This works fine.</p></div><p>d) A word, such as <em>Hello</em></p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><p>x is 0.</p></div><p>e) A really big number (at least 3 billion)</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><p>You are most likely to get the number 2147483647. This happens because x can only hold numbers up to a certain size. If you enter a value larger than the largest number x can hold, it will be set to the largest number that x can hold (which is probably 2147483647, but might be different on your system). We discuss this further in lesson <a href="https://www.learncpp.com/cpp-tutorial/signed-integers/">4.4 -- Signed integers</a>.</p></div><p>f) A small number followed by some letters, such as <em>123abc</em></p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><p>x gets the numeric value (e.g. 123). We’ll cover this case in more detail in lesson <a href="https://www.learncpp.com/cpp-tutorial/stdcin-and-handling-invalid-input/">7.16 -- std::cin and handling invalid input</a>.</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">1.6 — Uninitialized variables and undefined behavior</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Uninitialized variables</h3><p>Unlike some programming languages, C/C++ does not initialize most variables to a given value (such as zero) automatically. Thus when a variable is given a memory address to use to store data, the default value of that variable is whatever (garbage) value happens to already be in that memory address! A variable that has not been given a known value (usually through initialization or assignment) is called an <span class="cpp-definition">uninitialized variable</span>.</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>Many readers expect the terms “initialized” and “uninitialized” to be strict opposites, but they aren’t quite! Initialization means the object was provided with an initial value at the point of definition. Uninitialized means the object has not been given a known value (through any means, including assignment). Therefore, an object that is not initialized but is then assigned a value is no longer <em>uninitialized</em> (because it has been given a known value).</p><p>To recap:</p><ul><li>Initialization = The object is given a known value at the point of definition.</li><li>Assignment = The object is given a known value beyond the point of definition.</li><li>Uninitialized = The object has not been given a known value yet.</li></ul></div><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>This lack of initialization is a performance optimization inherited from C, back when computers were slow. Imagine a case where you were going to read in 100,000 values from a file. In such case, you might create 100,000 variables, then fill them with data from the file.</p><p>If C++ initialized all of those variables with default values upon creation, this would result in 100,000 initializations (which would be slow), and for little benefit (since you’re overwriting those values anyway).</p><p>For now, you should always initialize your variables because the cost of doing so is miniscule compared to the benefit. Once you are more comfortable with the language, there may be certain cases where you omit the initialization for optimization purposes. But this should always be done selectively and intentionally.</p></div><p>Using the values of uninitialized variables can lead to unexpected results. Consider the following short program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    // define an integer variable named x</code><code>    int x; // this variable is uninitialized because we haven't given it a value</code><code>    </code><code>    // print the value of x to the screen</code><code>    std::cout &lt;&lt; x; // who knows what we'll get, because x is uninitialized</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this case, the computer will assign some unused memory to <em>x</em>. It will then send the value residing in that memory location to <em>std::cout</em>, which will print the value (interpreted as an integer). But what value will it print? The answer is “who knows!”, and the answer may (or may not) change every time you run the program. When the author ran this program in Visual Studio, <em>std::cout</em> printed the value <code>7177728</code> one time, and <code>5277592</code> the next. Feel free to compile and run the program yourself (your computer won’t explode).</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Some compilers, such as Visual Studio, <em>will</em> initialize the contents of memory to some preset value when you’re using a debug build configuration. This will not happen when using a release build configuration. Therefore, if you want to run the above program yourself, make sure you’re using a <em>release build configuration</em> (see lesson <a href="https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-build-configurations/">0.9 -- Configuring your compiler: Build configurations</a> for a reminder on how to do that). For example, if you run the above program in a Visual Studio debug configuration, it will consistently print -858993460, because that’s the value (interpreted as an integer) that Visual Studio initializes memory with in debug configurations.</p></div><p>Most modern compilers will attempt to detect if a variable is being used without being given a value. If they are able to detect this, they will generally issue a compile-time warning or error. For example, compiling the above program on Visual Studio produced the following warning:</p><p><code>c:\VCprojects\test\test.cpp(11) : warning C4700: uninitialized local variable 'x' used</code></p><p>If your compiler won’t let you compile and run the above program (e.g. because it treats the issue as an error), here is a possible solution to get around this issue:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void doNothing(int&amp;) // Don't worry about what &amp; is for now, we're just using it to trick the compiler into thinking variable x is used</code><code>{</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    // define an integer variable named x</code><code>    int x; // this variable is uninitialized</code><code></code><code>    doNothing(x); // make the compiler think we're assigning a value to this variable</code><code></code><code>    // print the value of x to the screen (who knows what we'll get, because x is uninitialized)</code><code>    std::cout &lt;&lt; x;</code><code></code><code>    return 0;</code><code>}</code></pre><p>Using uninitialized variables is one of the most common mistakes that novice programmers make, and unfortunately, it can also be one of the most challenging to debug (because the program may run fine anyway if the uninitialized variable happened to get assigned to a spot of memory that had a reasonable value in it, like 0).</p><p>This is the primary reason for the “always initialize your variables” best practice.</p><br><h3>Undefined behavior</h3><p>Using the value from an uninitialized variable is our first example of undefined behavior. <span class="cpp-definition">Undefined behavior</span> (often abbreviated UB) is the result of executing code whose behavior is not well defined by the C++ language. In this case, the C++ language doesn’t have any rules determining what happens if you use the value of a variable that has not been given a known value. Consequently, if you actually do this, undefined behavior will result.</p><p>Code implementing undefined behavior may exhibit <em>any</em> of the following symptoms:</p><ul><li>Your program produces different results every time it is run.</li><li>Your program consistently produces the same incorrect result.</li><li>Your program behaves inconsistently (sometimes produces the correct result, sometimes not).</li><li>Your program seems like its working but produces incorrect results later in the program.</li><li>Your program crashes, either immediately or later.</li><li>Your program works on some compilers but not others.</li><li>Your program works until you change some other seemingly unrelated code.</li></ul><p>Or, your code may actually produce the correct behavior anyway. The nature of undefined behavior is that you never quite know what you’re going to get, whether you’ll get it every time, and whether that behavior will change when you make other changes.</p><p>C++ contains many cases that can result in undefined behavior if you’re not careful. We’ll point these out in future lessons whenever we encounter them. Take note of where these cases are and make sure you avoid them.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Rule</h4><p>Take care to avoid all situations that result in undefined behavior, such as using uninitialized variables.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>One of the most common types of comment we get from readers says, “You said I couldn’t do X, but I did it anyway and my program works! Why?”.</p><p>There are two common answers. The most common answer is that your program is actually exhibiting undefined behavior, but that undefined behavior just happens to be producing the result you wanted anyway… for now. Tomorrow (or on another compiler or machine) it might not.</p><p>Alternatively, sometimes compiler authors take liberties with the language requirements when those requirements may be more restrictive than needed. For example, the standard may say, “you must do X before Y”, but a compiler author may feel that’s unnecessary, and make Y work even if you don’t do X first. This shouldn’t affect the operation of correctly written programs, but may cause incorrectly written programs to work anyway. So an alternate answer to the above question is that your compiler may simply be not following the standard! It happens. You can avoid much of this by making sure you’ve turned compiler extensions off, as described in lesson <a href="https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-compiler-extensions/">0.10 -- Configuring your compiler: Compiler extensions</a>.</p></div><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>What is an uninitialized variable? Why should you avoid using them?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>An uninitialized variable is a variable that has not been given a value by the program (generally through initialization or assignment). Using the value stored in an uninitialized variable will result in undefined behavior.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>What is undefined behavior, and what can happen if you do something that exhibits undefined behavior?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>Undefined behavior is the result of executing code whose behavior is not well defined by the language. The result can be almost anything, including something that behaves correctly.</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">1.7 — Keywords and naming identifiers</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Keywords</h3><p>C++ reserves a set of 92 words (as of C++20) for its own use. These words are called <strong>keywords</strong> (or reserved words), and each of these keywords has a special meaning within the C++ language.</p><p>Here is a list of all the C++ keywords (through C++20):</p><p style="clear:both"></p><p></p><style>#wid{-moz-column-width:200px;-webkit-column-width:200px;column-width:200px;-webkit-column-rule:1px solid #000;-moz-column-rule:1px solid #000;column-rule:1px solid #000}</style><div id="wid" style="border-style:solid;border-width:1px;padding:4px"><ul style="list-style:none;margin:0"><li>alignas</li><li>alignof</li><li>and</li><li>and_eq</li><li>asm</li><li>auto</li><li>bitand</li><li>bitor</li><li>bool</li><li>break</li><li>case</li><li>catch</li><li>char</li><li>char8_t (since C++20)</li><li>char16_t</li><li>char32_t</li><li>class</li><li>compl</li><li>concept (since C++20)</li><li>const</li><li>consteval (since C++20)</li><li>constexpr</li><li>constinit (since C++20)</li><li>const_cast</li><li>continue</li><li>co_await (since C++20)</li><li>co_return (since C++20)</li><li>co_yield (since C++20)</li><li>decltype</li><li>default</li><li>delete</li><li>do</li><li>double</li><li>dynamic_cast</li><li>else</li><li>enum</li><li>explicit</li><li>export</li><li>extern</li><li>false</li><li>float</li><li>for</li><li>friend</li><li>goto</li><li>if</li><li>inline</li><li>int</li><li>long</li><li>mutable</li><li>namespace</li><li>new</li><li>noexcept</li><li>not</li><li>not_eq</li><li>nullptr</li><li>operator</li><li>or</li><li>or_eq</li><li>private</li><li>protected</li><li>public</li><li>register</li><li>reinterpret_cast</li><li>requires (since C++20)</li><li>return</li><li>short</li><li>signed</li><li>sizeof</li><li>static</li><li>static_assert</li><li>static_cast</li><li>struct</li><li>switch</li><li>template</li><li>this</li><li>thread_local</li><li>throw</li><li>true</li><li>try</li><li>typedef</li><li>typeid</li><li>typename</li><li>union</li><li>unsigned</li><li>using</li><li>virtual</li><li>void</li><li>volatile</li><li>wchar_t</li><li>while</li><li>xor</li><li>xor_eq</li></ul></div><p>The keywords marked (C++20) were added in C++20. If your compiler is not C++20 compliant (or does have C++20 functionality, but it’s turned off by default), these keywords may not be functional.</p><p>C++ also defines special identifiers: <em>override</em>, <em>final</em>, <em>import</em>, and <em>module</em>. These have a specific meaning when used in certain contexts but are not reserved.</p><p>You have already run across some of these keywords, including <em>int</em> and <em>return</em>. Along with a set of operators, these keywords and special identifiers define the entire language of C++ (preprocessor commands excluded). Because keywords and special identifiers have special meaning, your IDEs will likely change the text color of these words to make them stand out from other identifiers.</p><p>By the time you are done with this tutorial series, you will understand what almost all of these words do!</p><br><h3>Identifier naming rules </h3><p>As a reminder, the name of a variable (or function, type, or other kind of item) is called an identifier. C++ gives you a lot of flexibility to name identifiers as you wish. However, there are a few rules that must be followed when naming identifiers:</p><ul><li>The identifier can not be a keyword. Keywords are reserved.</li><li>The identifier can only be composed of letters (lower or upper case), numbers, and the underscore character. That means the name can not contain symbols (except the underscore) nor whitespace (spaces or tabs).</li><li>The identifier must begin with a letter (lower or upper case) or an underscore. It can not start with a number.</li><li>C++ is case sensitive, and thus distinguishes between lower and upper case letters. <code>nvalue</code> is different than <code>nValue</code> is different than <code>NVALUE</code>.</li></ul><br><h3>Identifier naming best practices</h3><p>Now that you know how you <em>can</em> name a variable, let’s talk about how you <em>should</em> name a variable (or function).</p><p>First, it is a convention in C++ that variable names should begin with a lowercase letter. If the variable name is one word, the whole thing should be written in lowercase letters.</p><pre class="language-cpp line-numbers"><code>int value; // correct</code><code></code><code>int Value; // incorrect (should start with lower case letter)</code><code>int VALUE; // incorrect (should start with lower case letter)</code><code>int VaLuE; // incorrect (see your psychiatrist) ;)</code></pre><p>Most often, function names are also started with a lowercase letter (though there’s some disagreement on this point). We’ll follow this convention, since function <em>main</em> (which all programs must have) starts with a lowercase letter, as do all of the functions in the C++ standard library.</p><p>Identifier names that start with a capital letter are typically used for user-defined types (such as structs, classes, and enumerations, all of which we will cover later).</p><p>If the variable or function name is multi-word, there are two common conventions: words separated by underscores, called snake_case, or intercapped (sometimes called camelCase, since the capital letters stick up like the humps on a camel).</p><pre class="language-cpp line-numbers"><code>int my_variable_name; // correct (separated by underscores/snake_case)</code><code>int my_function_name(); // correct (separated by underscores/snake_case)</code><code></code><code>int myVariableName; // correct (intercapped/CamelCase)</code><code>int myFunctionName(); // correct (intercapped/CamelCase)</code><code></code><code>int my variable name; // invalid (whitespace not allowed)</code><code>int my function name(); // invalid (whitespace not allowed) </code><code></code><code>int MyVariableName; // valid but incorrect (should start with lower case letter)</code><code>int MyFunctionName(); // valid but incorrect (should start with lower case letter)</code></pre><p>In this tutorial, we will typically use the intercapped approach because it’s easier to read (it’s easy to mistake an underscore for a space in dense blocks of code). But it’s common to see either -- the C++ standard library uses the underscore method for both variables and functions. Sometimes you’ll see a mix of the two: underscores used for variables and intercaps used for functions.</p><p>It’s worth noting that if you’re working in someone else’s code, it’s generally considered better to match the style of the code you are working in than to rigidly follow the naming conventions laid out above.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>When working in an existing program, use the conventions of that program (even if they don’t conform to modern best practices). Use modern best practices when you’re writing new programs.</p></div><p>Second, you should avoid naming your identifiers starting with an underscore, as these names are typically reserved for OS, library, and/or compiler use.</p><p>Third, your identifiers should make clear what the value they are holding means (particularly if the units aren’t obvious). Identifiers should be named in a way that would help someone who has no idea what your code does be able to figure it out as quickly as possible. In 3 months, when you look at your program again, you’ll have forgotten how it works, and you’ll thank yourself for picking variable names that make sense.</p><p>However, giving a trivial variable an overly complex name impedes overall understanding of what the program is doing almost as much as giving a widely used identifier an inadequate name. Therefore, a good rule of thumb is to make the length of an identifier proportional to how widely it is used. An identifier with a trivial use can have a short name (e.g. such as <em>i</em>). An identifier that is used more broadly (e.g. a function that is called from many different places in a program) should have a longer and more descriptive name (e.g. instead of <em>open</em>, try <em>openFileOnDisk</em>).</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td>int ccount</td><td>Bad</td><td>What does the c before “count” stand for?</td></tr><tr><td>int customerCount</td><td>Good</td><td>Clear what we’re counting</td></tr><tr><td>int i</td><td>Either</td><td>Okay if use is trivial, bad otherwise</td></tr><tr><td>int index</td><td>Either</td><td>Okay if obvious what we’re indexing</td></tr><tr><td>int totalScore</td><td>Either</td><td>Okay if there’s only one thing being scored, otherwise too ambiguous</td></tr><tr><td>int _count</td><td>Bad</td><td>Do not start names with underscore</td></tr><tr><td>int count</td><td>Either</td><td>Okay if obvious what we’re counting</td></tr><tr><td>int data</td><td>Bad</td><td>What kind of data?</td></tr><tr><td>int time</td><td>Bad</td><td>Is this in seconds, minutes, or hours?</td></tr><tr><td>int minutesElapsed</td><td>Good</td><td>Descriptive</td></tr><tr><td>int value1, value2</td><td>Either</td><td>Can be hard to differentiate between the two</td></tr><tr><td>int numApples</td><td>Good</td><td>Descriptive</td></tr><tr><td>int monstersKilled</td><td>Good</td><td>Descriptive</td></tr><tr><td>int x, y</td><td>Either</td><td>Okay if use is trivial, bad otherwise</td></tr></tbody></table></div><p>In any case, avoid abbreviations. Although they reduce the time you need to write your code, they make your code harder to read. Even if the abbreviation is unambiguous, it takes the reader a moment to figure out what you meant. Code is read more often than it is written, the time you saved while writing the code is time that every reader, including the future you, wastes when reading it. If you’re looking to write code faster, use your editor’s auto-complete feature.</p><p>Finally, a clarifying comment can go a long way. For example, say we’ve declared a variable named <em>numberOfChars</em> that is supposed to store the number of characters in a piece of text. Does the text “Hello World!” have 10, 11, or 12 characters? It depends on whether we’re including whitespace or punctuation. Rather than naming the variable <em>numberOfCharsIncludingWhitespaceAndPunctuation</em>, which is rather lengthy, a well placed comment on the declaration line should help the user figure it out:</p><pre class="language-cpp line-numbers"><code>// holds number of chars in a piece of text -- including whitespace and punctuation!</code><code>int numberOfChars;</code></pre><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Based on how you <em>should</em> name a variable, indicate whether each variable name is correct (follows convention), incorrect (does not follow convention), or invalid (will not compile), and why.</p><p>int sum {}; // assume it’s obvious what we’re summing<br><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>Correct.</p></div><p>int _apples {};<br><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>Incorrect -- variable names should not start with an underscore.</p></div><p>int VALUE {};<br><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>Incorrect -- variable names should start with a lower case letter.</p></div><p>int my variable name {};<br><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><p>Invalid -- variable names can not contain spaces.</p></div><p>int TotalCustomers {};<br><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><p>Incorrect -- variable names should start with a lower case letter.</p></div><p>int void {};<br><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><p>Invalid -- void is a keyword.</p></div><p>int numFruit {};<br><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none"><p>Correct.</p></div><p>int 3some {};<br><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_7'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_7" style="display:none"><p>Invalid -- variable names can not start with a number.</p></div><p>int meters_of_pipe {};<br><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_8'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_8" style="display:none"><p>Correct.</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">1.8 — Whitespace and basic formatting</h1></header><div class="entry-content" itemprop="articleBody"><p><span class="cpp-definition">Whitespace</span> is a term that refers to characters that are used for formatting purposes. In C++, this refers primarily to spaces, tabs, and newlines. The C++ compiler generally ignores whitespace, with a few minor exceptions (when processing text literals). For this reason, we say that C++ is a whitespace-independent language.</p><p>Consequently, the following statements all do the exact same thing:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; "Hello world!";</code><code></code><code>std::cout               &lt;&lt;            "Hello world!";</code><code></code><code>		std::cout &lt;&lt; 		"Hello world!";</code><code></code><code>std::cout</code><code>	&lt;&lt; "Hello world!";</code></pre><p>Even the last statement that is split over two lines compiles just fine.</p><p>The following functions all do the same thing:</p><pre class="language-cpp line-numbers"><code>int add(int x, int y) { return x + y; }</code><code></code><code>int add(int x, int y) {</code><code>    return x + y; }</code><code></code><code>int add(int x, int y)</code><code>{    return x + y; }</code><code></code><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code></pre><p>One exception where the C++ compiler <em>does</em> pay attention to whitespace is inside quoted text, such as <code>"Hello world!"</code>.</p><pre>"Hello world!"</pre><p>is different than:</p><pre>"Hello     world!"</pre><p>and each prints out exactly as you’d expect.</p><p>Newlines are not allowed in quoted text:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; "Hello</code><code>     world!"; // Not allowed!</code></pre><p>Quoted text separated by nothing but whitespace (spaces, tabs, or newlines) will be concatenated:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; "Hello "</code><code>     "world!"; // prints "Hello world!"</code></pre><p>Another exception where the C++ compiler pays attention to whitespace is with // comments. Single-line comments only last to the end of the line. Thus doing something like this will get you in trouble:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; "Hello world!"; // Here is a single-line comment</code><code>this is not part of the comment</code></pre><br><h3>Basic formatting</h3><p>Unlike some other languages, C++ does not enforce any kind of formatting restrictions on the programmer (remember, trust the programmer!). Many different methods of formatting C++ programs have been developed throughout the years, and you will find disagreement on which ones are best. Our basic rule of thumb is that the best styles are the ones that produce the most readable code, and provide the most consistency.</p><p>Here are our recommendations for basic formatting:</p><ol start="1"><li>It’s fine to use either tabs or spaces for indentation (most IDEs have a setting where you can convert a tab press into the appropriate number of spaces). Developers who prefer spaces tend to do so because it makes the formatting self-describing -- code that is spaced using spaces will always look correct regardless of editor. Proponents of using tabs wonder why you wouldn’t use the character designed to do indentation for indentation, especially as you can set the width to whatever your preference is. There’s no right answer here -- and debating it is like arguing whether cake or pie is better. It ultimately comes down to personal preference.</li></ol><p>Either way, we recommend you set your tabs to 4 spaces worth of indentation. Some IDEs default to 3 spaces of indentation, which is fine too.</p><ol start="2"><li>There are two acceptable styles for function braces.</li></ol><p>The Google C++ style guide recommends putting the opening curly brace on the same line as the statement:</p><pre class="language-cpp line-numbers"><code>int main() {</code><code>}</code></pre><p>The justification for this is that it reduces the amount of vertical whitespace (you aren’t devoting an entire line to nothing but the opening curly brace), so you can fit more code on a screen. More code on a screen makes the program easier to understand.</p><p>However, we prefer the common alternative, where the opening brace appears on its own line:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>}</code></pre><p>This enhances readability, and is less error prone since your brace pairs should always be indented at the same level. If you get a compiler error due to a brace mismatch, it’s very easy to see where.</p><ol start="3"><li>Each statement within curly braces should start one tab in from the opening brace of the function it belongs to. For example:</li></ol><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Hello world!\n"; // tabbed in one tab (4 spaces)</code><code>    std::cout &lt;&lt; "Nice to meet you.\n"; // tabbed in one tab (4 spaces)</code><code>}</code></pre><ol start="4"><li>Lines should not be too long. Typically, 80 characters is the maximum length a line should be. If a line is going to be longer, it should be split (at a reasonable spot) into multiple lines. This can be done by indenting each subsequent line with an extra tab, or if the lines are similar, by aligning it with the line above (whichever is easier to read).</li></ol><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "This is a really, really, really, really, really, really, really, " </code><code>        "really long line\n"; // one extra indentation for continuation line</code><code></code><code>    std::cout &lt;&lt; "This is another really, really, really, really, really, really, really, "</code><code>                 "really long line\n"; // text aligned with the previous line for continuation line</code><code></code><code>    std::cout &lt;&lt; "This one is short\n";</code><code>}</code></pre><p>This makes your lines easier to read. On modern wide-screen monitors, it also allows you to place two windows with similar code side by side and compare them more easily.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Your lines should be no longer than 80 chars in length.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>Many editors have a built-in feature (or plugin/extension) that will show a line (called a “column guide”) at a given column (e.g. at 80 characters), so you can easily see when your lines are getting too long. To see if your editor supports this, do a search on your editor’s name + “Column guide”.</p></div><ol start="5"><li>If a long line is split with an operator (eg. &lt;&lt; or +), the operator should be placed at the beginning of the next line, not the end of the current line</li></ol><pre class="language-cpp line-numbers"><code>    std::cout &lt;&lt; 3 + 4</code><code>        + 5 + 6</code><code>        * 7 * 8;</code></pre><p>This helps make it clearer that subsequent lines are continuations of the previous lines, and allows you to align the operators on the left, which makes for easier reading.</p><ol start="6"><li>Use whitespace to make your code easier to read by aligning values or comments or adding spacing between blocks of code.</li></ol><p>Harder to read:</p><pre class="language-cpp line-numbers"><code>cost = 57;</code><code>pricePerItem = 24;</code><code>value = 5;</code><code>numberOfItems = 17;</code></pre><p>Easier to read:</p><pre class="language-cpp line-numbers"><code>cost          = 57;</code><code>pricePerItem  = 24;</code><code>value         = 5;</code><code>numberOfItems = 17;</code></pre><p>Harder to read:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; "Hello world!\n"; // cout lives in the iostream library</code><code>std::cout &lt;&lt; "It is very nice to meet you!\n"; // these comments make the code hard to read</code><code>std::cout &lt;&lt; "Yeah!\n"; // especially when lines are different lengths</code></pre><p>Easier to read:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; "Hello world!\n";                  // cout lives in the iostream library</code><code>std::cout &lt;&lt; "It is very nice to meet you!\n";  // these comments are easier to read</code><code>std::cout &lt;&lt; "Yeah!\n";                         // especially when all lined up</code></pre><p>Harder to read:</p><pre class="language-cpp line-numbers"><code>// cout lives in the iostream library</code><code>std::cout &lt;&lt; "Hello world!\n";</code><code>// these comments make the code hard to read</code><code>std::cout &lt;&lt; "It is very nice to meet you!\n";</code><code>// especially when all bunched together</code><code>std::cout &lt;&lt; "Yeah!\n";</code></pre><p>Easier to read:</p><pre class="language-cpp line-numbers"><code>// cout lives in the iostream library</code><code>std::cout &lt;&lt; "Hello world!\n";</code><code></code><code>// these comments are easier to read</code><code>std::cout &lt;&lt; "It is very nice to meet you!\n";</code><code></code><code>// when separated by whitespace</code><code>std::cout &lt;&lt; "Yeah!\n";</code></pre><p>We will follow these conventions throughout this tutorial, and they will become second nature to you. As we introduce new topics to you, we will introduce new style recommendations to go with those features.</p><p>Ultimately, C++ gives you the power to choose whichever style you are most comfortable with, or think is best. However, we highly recommend you utilize the same style that we use for our examples. It has been battle tested by thousands of programmers over billions of lines of code, and is optimized for success. One exception: If you are working in someone else’s code base, adopt their styles. It’s better to favor consistency than your preferences.</p><br><h3>Automatic formatting</h3><p>Most modern IDEs will help you format your code as you type it in (e.g. when you create a function, the IDE will automatically indent the statements inside the function body).</p><p>However, as you add or remove code, or change the IDE’s default formatting, or paste in a block of code that has different formatting, the formatting can get messed up. Fixing the formatting for part or all of a file can be a headache. Fortunately, modern IDEs typically contain an automatic formatting feature that will reformat either a selection (highlighted with your mouse) or an entire file.</p><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>In Visual Studio, the automatic formatting options can be found under <em>Edit &gt; Advanced &gt; Format Document</em> and <em>Edit &gt; Advanced &gt; Format Selection</em>.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>In Code::Blocks, the automatic formatting options can be found under <em>Right mouse click &gt; Format use AStyle</em>.</p></div><p>For easier access, we recommend adding a keyboard shortcut to auto-format the active file.</p><p>There are also external tools that can be used to automatically format code. <a href="https://clang.llvm.org/docs/ClangFormat.html">clang-format</a> is a popular one.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Using the automatic formatting feature is highly recommended to keep your code’s formatting style consistent.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">1.9 — Introduction to literals and operators</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Literals</h3><p>Consider the following two statements:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; "Hello world!";</code><code>int x{ 5 };</code></pre><p>What are <em>“Hello world!”</em> and <em>5</em>? They are literals. A <span class="cpp-definition">literal</span> (also known as a <span class="cpp-definition">literal constant</span>) is a fixed value that has been inserted directly into the source code.</p><p>Literals and variables both have a value (and a type). However, the value of a literal is fixed and can’t be changed (hence it being called a constant), whereas the value of a variable can be changed through initialization and assignment.</p><br><h3>Operators</h3><p>In mathematics, an <span class="cpp-definition">operation</span> is a mathematical calculation involving zero or more input values (called <span class="cpp-definition">operands</span>) that produces a new value (called an output value). The specific operation to be performed is denoted by a construct (typically a symbol or pair of symbols) called an <span class="cpp-definition">operator</span>.</p><p>For example, as children we all learn that <em>2 + 3</em> equals <em>5</em>. In this case, the literals <em>2</em> and <em>3</em> are the operands, and the symbol <em>+</em> is the operator that tells us to apply mathematical addition on the operands to produce the new value <em>5</em>.</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>For reasons that will become clear when we discuss operators in more detail, for operators that are symbols, it is common nomenclature to append the operator’s symbol to the word <em>operator</em>.</p><p>For example, the plus operator would be written <em>operator+</em>, and the extraction operator would be written <em>operator&gt;&gt;</em>.</p></div><p>You are likely already quite familiar with standard arithmetic operators from common usage in mathematics, including addition (+), subtraction (-), multiplication (*), and division (/). In C++, assignment (=) is an operator as well, as are &lt;&lt;; (insertion), &gt;&gt; (extraction), and == (equality). While most operators have symbols for names (e.g. +, or ==), there are also a number of operators that are words (e.g. new, delete, and throw).</p><p>The number of operands that an operator takes as input is called the operator’s <em>arity</em> (almost nobody knows what this word means, so don’t drop it in a conversation and expect anybody to have any idea what you’re talking about). Operators in C++ come in four different <em>arities</em>:</p><p><strong>Unary</strong> operators act on one operand. An example of a unary operator is the <em>- operator</em>. For example, given <code>-5</code>, <em>operator-</em> takes literal operand <em>5</em> and flips its sign to produce new output value <em>-5</em>.</p><p><strong>Binary</strong> operators act on two operands (known as <em>left</em> and <em>right</em>). An example of a binary operator is the <em>+ operator</em>. For example, given <code>3 + 4</code>, <em>operator+</em> takes the left operand (3) and the right operand (4) and applies mathematical addition to produce new output value <em>7</em>. The insertion (&lt;&lt;) and extraction (&gt;&gt;) operators are binary operators, taking std::cout or std::cin on the left side, and the value to output or variable to input to on the right side.</p><p><strong>Ternary</strong> operators act on three operands. There is only one of these in C++ (the conditional operator), which we’ll cover later.</p><p><strong>Nullary</strong> operators act on zero operands. There is also only one of these in C++ (the throw operator), which we’ll also cover later.</p><p>Note that some operators have more than one meaning depending on how they are used. For example, <em>operator-</em> has two contexts. It can be used in unary form to invert a number’s sign (e.g. to convert 5 to -5, or vice versa), or it can be used in binary form to do subtraction (e.g. 4 - 3).</p><br><h3>Chaining operators</h3><p>Operators can be chained together such that the output of one operator can be used as the input for another operator. For example, given the following: <em>2 * 3 + 4</em>, the multiplication operator goes first, and converts left operand <em>2</em> and right operand <em>3</em> into new value <em>6</em> (which becomes the left operand for the plus operator). Next, the plus operator executes, and converts left operand <em>6</em> and right operand <em>4</em> into new value 10.</p><p>We’ll talk more about the order in which operators execute when we do a deep dive into the topic of operators. For now, it’s enough to know that the arithmetic operators execute in the same order as they do in standard mathematics: Parenthesis first, then Exponents, then Multiplication &amp; Division, then Addition &amp; Subtraction. This ordering is sometimes abbreviated <em>PEMDAS</em>, or expanded to the mnemonic “Please Excuse My Dear Aunt Sally”.</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>In some countries, PEMDAS is taught as PEDMAS, BEDMAS, BODMAS, or BIDMAS instead.</p></div><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>For each of the following, indicate what output they produce:</p><p>a)</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; 3 + 4;</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none">7</div><p>b)</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; 3 + 4 - 5;</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none">2</div><p>c)</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; 2 + 3 * 4;</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><ol start="14"><li>Multiplication goes before addition, so 3 * 4 goes first, producing the result 12. 2 + 12 is 14.</li></ol></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">1.10 — Introduction to expressions</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Expressions</h3><p>Consider the following series of statements:</p><pre class="language-cpp line-numbers"><code>// five() is a function that returns the value 5</code><code>int five()</code><code>{</code><code>    return 5;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int a{ 2 };             // initialize variable a with literal value 2</code><code>    int b{ 2 + 3 };         // initialize variable b with computed value 5</code><code>    int c{ (2 * 3) + 4 };   // initialize variable c with computed value 10</code><code>    int d{ b };             // initialize variable d with variable value 5</code><code>    int e{ five() };        // initialize variable e with function return value 5</code><code></code><code>    return 0;</code><code>}</code></pre><p>Each of these statements defines a new variable and initializes it with a value. Note that the initializers shown above make use of a variety of different constructs: literals, variables, operators, and function calls. Somehow, C++ is converting all of these different things into a single value that can then be used as the initialization value for the variable.</p><p>What do all of these have in common? They make use of an expression.</p><p>An <span class="cpp-definition">expression</span> is a combination of literals, variables, operators, and function calls that calculates a single value. The process of executing an expression is called <span class="cpp-definition">evaluation</span>, and the single value produced is called the <span class="cpp-definition">result</span> of the expression.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>While most expressions are used to calculate a value, expressions can also identify an object (which can be evaluated to get the value held by the object) or a function (which can be called to get the value returned by the function). We talk more about this in lesson <a href="https://www.learncpp.com/cpp-tutorial/value-categories-lvalues-and-rvalues/">9.2 -- Value categories (lvalues and rvalues)</a>.</p><p>For now, we’ll assume all expressions calculate values.</p></div><p>When an expression is evaluated, each of the terms inside the expression are evaluated, until a single value remains. Here are some examples of different kinds of expressions, with comments indicating how they evaluate:</p><pre class="language-cpp line-numbers"><code>2               // 2 is a literal that evaluates to value 2</code><code>"Hello world!"  // "Hello world!" is a literal that evaluates to text "Hello world!"</code><code>x               // x is a variable that evaluates to the value of x</code><code>2 + 3           // operator+ combines values 2 and 3 to produce value 5</code><code>x = 2 + 3       // 2 + 3 evaluates to value 5, which is then assigned to variable x</code><code>std::cout &lt;&lt; x  // x evaluates to the value of x, which is then printed to the console</code><code>five()          // evaluates to the return value of function five()</code></pre><p>As you can see, literals evaluate to their own values. Variables evaluate to the value of the variable. We haven’t covered function calls yet, but in the context of an expression, function calls evaluate to whatever value the function returns. And operators (such as operator+) let us combine multiple values together to produce a new value.</p><p>Note that expressions do not end in a semicolon, and cannot be compiled by themselves. For example, if you were to try compiling the expression <code>x = 5</code>, your compiler would complain (probably about a missing semicolon). Rather, expressions are always evaluated as part of statements.</p><p>For example, take this statement:</p><pre class="language-cpp line-numbers"><code>int x{ 2 + 3 }; // 2 + 3 is an expression that has no semicolon -- the semicolon is at the end of the statement containing the expression</code></pre><p>If you were to break this statement down into its syntax, it would look like this:</p><pre class="language-cpp line-numbers"><code>type identifier { expression };</code></pre><p><em>Type</em> could be any valid type (we chose <em>int</em>). <em>Identifier</em> could be any valid name (we chose <em>x</em>). And <em>expression</em> could be any valid expression (we chose <code>2 + 3</code>, which uses two literals and an operator).</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Wherever you can use a single value in C++, you can use a value-producing expression instead, and the expression will be evaluated to produce a single value.</p></div><br><h3>Expression statements</h3><p>Certain expressions (like <code>x = 5</code>) are useful by themselves (in this case, to assign the value <code>5</code> to the variable <code>x</code>). However, we mentioned above that expressions cannot be executed by themselves -- they must exist as part of a statement. So how can we use such expressions?</p><p>Fortunately, it’s easy to convert any expression into an equivalent statement (called an expression statement). An <span class="cpp-definition">expression statement</span> is a statement that consists of an expression followed by a semicolon. When the statement is executed, the expression will be evaluated.</p><p>Thus, we can take any expression (such as <code>x = 5</code>), and turn it into an expression statement (<code>x = 5;</code>) that will compile.</p><p>The result of an expression statement is discarded before the next statement is executed.</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>An expression whose result is discarded is called a <span class="cpp-definition">discarded-value expression</span>). Expression statements are by far the most common type of discarded-value expressions.</p><p>Other discarded-value expressions include the left operand of the comma operator, and any expression that is cast to type <code>void</code>.</p></div><br><h3>Useless expression statements</h3><p>We can also make expression statements that compile but have no effect. For example, the expression statement (<code>2 * 3;</code>) is a expression statement whose expression evaluates to the result value of <em>6</em>, which is then discarded. While syntactically valid, such expression statements are useless. Some compilers (such as gcc and Clang) will produce warnings if they can detect that an expression statement is useless.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>What is the difference between a statement and an expression?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>Statements are used when we want the program to perform an action. Expressions are used when we want the program to calculate a value.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>Indicate whether each of the following lines are <em>statements that do not contain expressions</em>, <em>statements that contain expressions</em>, or are <em>expression statements</em>.</p><p>a)</p><pre class="language-cpp line-numbers"><code>int x;</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>Statement does not contain an expression (this is just a variable definition).</p></div><p>b)</p><pre class="language-cpp line-numbers"><code>int x = 5;</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>Statement contains an expression (The right hand side of the equals sign is an expression containing a single value, but the rest of the statement isn’t an expression).</p></div><p>c)</p><pre class="language-cpp line-numbers"><code>x = 5;</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><p>Expression statement (the entire statement is an expression, terminated by a semicolon).</p></div><p>d)</p><pre class="language-cpp line-numbers"><code>foo(); // foo is a function</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><p>Expression statement.</p></div><p>e) Extra credit:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; x; // Hint: operator&lt;&lt; is a binary operator.</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><p>If operator&lt;&lt; is a binary operator, then std::cout must be the left-hand operand, and x must be the right-hand operand. Since that’s the entire statement, this must be an expression statement.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>Determine what values the following program outputs. Do not compile this program. Just work through it line by line in your head.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; 2 + 3 &lt;&lt; '\n';</code><code>	</code><code>	int x{ 6 };</code><code>	int y{ x - 2 };</code><code>	std::cout &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>	int z{ };</code><code>	z = x;</code><code>	std::cout &lt;&lt; z - x &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none"><pre>5
4
0
</pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">1.11 — Developing your first program</h1></header><div class="entry-content" itemprop="articleBody"><p>The preceding lessons have introduced a lot of terminology and concepts that we’ll use in just about every program we create. In this lesson, we’ll walk through the process of integrating this knowledge into our first simple program.</p><br><h3>Multiply by 2</h3><p>First, let’s create a program that asks the user to enter an integer, waits for them to input an integer, then tells them what 2 times that number is. The program should produce the following output (assume I entered 4 as input):</p><pre>Enter an integer: 4
Double that number is: 8
</pre><p>How do we tackle this? In steps.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>New programmers often try to write an entire program all at once, and then get overwhelmed when it produces a lot of errors. A better strategy is to add one piece at a time, make sure it compiles, and test it. Then when you’re sure it’s working, move on to the next piece.</p></div><p>We’ll leverage that strategy here. As we go through each step, type (don’t copy/paste) each program into your compiler, compile, and run it.</p><p>First, create a new console project.</p><p>Now let’s start with some basic scaffolding. We know we’re going to need a main() function (since all C++ programs must have one), so if your IDE didn’t create a blank one when you created a new project, let’s create one:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	return 0;</code><code>}</code></pre><p>We know we’re going to need to output text to the console, and get text from the user’s keyboard, so we need to include iostream for access to std::cout and std::cin.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	return 0;</code><code>}</code></pre><p>Now let’s tell the user that we need them to enter an integer:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Enter an integer: ";</code><code></code><code>	return 0;</code><code>}</code></pre><p>At this point, your program should produce this result:</p><pre>Enter an integer:
</pre><p>and then terminate.</p><p>Next, we’re going to get the user’s input. We’ll use std::cin and <code>operator&gt;&gt;</code> to get the user’s input. But we also need to define a variable to store that input for use later.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main() // note: this program has an error somewhere</code><code>{</code><code>	std::cout &lt;&lt; "Enter an integer: ";</code><code></code><code>	int num{ }; // define variable num as an integer variable</code><code>	std::cin &lt;&lt; num; // get integer value from user's keyboard</code><code></code><code>	return 0;</code><code>}</code></pre><p>Time to compile our changes… and…</p><p>Uh oh! Here’s what the author got on Visual Studio 2017:</p><pre>1&gt;------ Build started: Project: Double, Configuration: Release Win32 ------
1&gt;Double.cpp
1&gt;c:\vcprojects\double\double.cpp(8): error C2678: binary '&lt;&lt;': no operator found which takes a left-hand operand of type 'std::istream' (or there is no acceptable conversion)
1&gt;c:\vcprojects\double\double.cpp: note: could be 'built-in C++ operator&lt;&lt;(bool, int)'
1&gt;c:\vcprojects\double\double.cpp: note: while trying to match the argument list '(std::istream, int)'
1&gt;Done building project "Double.vcxproj" -- FAILED.
========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========
</pre><p>We ran into a compile error!</p><p>First, since the program compiled before we made this latest update, and doesn’t compile now, the error <em>must</em> be in the code we just added (lines 7 and 8). That significantly reduces the amount of code we have to scan to find the error. Line 7 is pretty straightforward (just a variable definition), so the error probably isn’t there. That leaves line 8 as the likely culprit.</p><p>Second, this error message isn’t very easy to read. But let’s pick apart some key elements: The compiler is telling us it ran into the error on line 8. That means the actual error is probably on line 8, or possibly the preceding line, which reinforces our previous assessment. Next, the compiler is telling you that it couldn’t find a ‘&lt;&lt;‘ operator that has a left-hand operand of type std::istream (which is the type of std::cin). Put another way, operator&lt;&lt; doesn’t know what to do with std::cin, so the error must be either with our use of std::cin or our use of operator&lt;&lt;.</p><p>See the error now? If you don’t, take a moment and see if you can find it.</p><p>Here’s the program that contains the corrected code:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Enter an integer: ";</code><code></code><code>	int num{ };</code><code>	std::cin &gt;&gt; num; // std::cin uses operator &gt;&gt;, not operator &lt;<!--</code--></code><code></code><code>	return 0;</code><code>}</code></pre><p>Now the program will compile, and we can test it. The program will wait for you to enter a number, so let’s enter 4. The output should look like this:</p><pre>Enter an integer: 4
</pre><p>Almost there! Last step is to double the number.</p><p>Once we finish this last step, our program will compile and run successfully, producing the desired output.</p><p>There are (at least) 3 ways we can go about this. Let’s go from worst to best.</p><br><h3>The not-good solution</h3><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// worst version</code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Enter an integer: ";</code><code></code><code>	int num{ };</code><code>	std::cin &gt;&gt; num;</code><code></code><code>	num = num * 2; // double num's value, then assign that value back to num</code><code></code><code>	std::cout &lt;&lt; "Double that number is: " &lt;&lt; num &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>In this solution, we use an expression to multiply <em>num</em> by 2, and then assign that value back to <em>num</em>. From that point forward, <em>num</em> will contain our doubled number.</p><p>Why this is a bad solution:</p><ul><li>Before the assignment statement, num contains the user’s input. After the assignment, it contains a different value. That’s confusing.</li><li>We overwrote the user’s input by assigning a new value to the input variable, so if we wanted to extend our program to do something else with that input value later (e.g. triple the user’s input), it’s already been lost.</li></ul><br><h3>The mostly-good solution</h3><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// less-bad version</code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Enter an integer: ";</code><code></code><code>	int num{ };</code><code>	std::cin &gt;&gt; num;</code><code></code><code>	int doublenum{ num * 2 }; // define a new variable and initialize it with num * 2</code><code>	std::cout &lt;&lt; "Double that number is: " &lt;&lt; doublenum &lt;&lt; '\n'; // then print the value of that variable here</code><code></code><code>	return 0;</code><code>}</code></pre><p>This solution is pretty straightforward to read and understand, and resolves both of the problems encountered in the worst solution.</p><p>The primary downside here is that we’re defining a new variable (which adds complexity) to store a value we only use once. We can do better.</p><br><h3>The preferred solution</h3><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// preferred version</code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Enter an integer: ";</code><code></code><code>	int num{ };</code><code>	std::cin &gt;&gt; num;</code><code></code><code>	std::cout &lt;&lt; "Double that number is: " &lt;&lt;  num * 2 &lt;&lt; '\n'; // use an expression to multiply num * 2 at the point where we are going to print it</code><code></code><code>	return 0;</code><code>}</code></pre><p>This is the preferred solution of the bunch. When std::cout executes, the expression <em>num * 2</em> will get evaluated, and the result will be double <em>num</em>‘s value. That value will get printed. The value in <em>num</em> itself will not be altered, so we can use it again later if we wish.</p><p>This version is our reference solution.</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>The first and primary goal of programming is to make your program work. A program that doesn’t work isn’t useful regardless of how well it’s written.</p><p>However, there’s a saying I’m fond of: “You have to write a program once to know how you should have written it the first time.” This speaks to the fact that the best solution often isn’t obvious, and that our first solutions to problems are usually not as good as they could be.</p><p>When we’re focused on figuring out how to make our programs work, it doesn’t make a lot of sense to invest a lot of time into code we don’t even know if we’ll keep. So we take shortcuts. We skip things like error handling and comments. We sprinkle debugging code throughout our solution to help us diagnose issues and find errors. We learn as we go -- things we thought might work don’t work after all, and we have to backtrack and try another approach.</p><p>The end result is that our initial solutions often aren’t well structured, robust (error-proof), readable, or concise. So once your program is working, your job really isn’t done (unless the program is a one-off/throwaway). The next step is to cleanup your code. This involves things like: removing (or commenting out) temporary/debugging code, adding comments, handling error cases, formatting your code, and ensuring best practices are followed. And even then, your program may not be as simple as it could be -- perhaps there is redundant logic that can be consolidated, or multiple statements that can be combined, or variables that aren’t needed, or a thousand other little things that could be simplified. Too often new programmers focus on optimizing for performance when they should be optimizing for maintainability.</p><p>Very few of the solutions presented in these tutorials came out great the first time. Rather, they’re the result of continual refinement until nothing else could be found to improve. And in many cases, readers still find plenty of other things to suggest as improvements!</p><p>All of this is really to say: don’t be frustrated if/when your solutions don’t come out wonderfully optimized right out of your brain. That’s normal. Perfection in programming is an iterative process (one requiring repeated passes).</p></div><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>One more thing: You may be thinking, “C++ has so many rules and concepts. How do I remember all of this stuff?”.</p><p>Short answer: You don’t. C++ is one part using what you know, and two parts looking up how to do the rest.</p><p>As you read through this site for the first time, focus less on memorizing specifics, and more on understanding what’s possible. Then, when you have a need to implement something in a program you’re writing, you can come back here (or to a reference site) and refresh yourself on how to do so.</p></div><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Modify the solution to the “best solution” program above so that it outputs like this (assuming user input 4):</p><pre>Enter an integer: 4
Double 4 is: 8
Triple 4 is: 12
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Enter an integer: ";</code><code></code><code>	int num{ };</code><code>	std::cin &gt;&gt; num;</code><code></code><code>	std::cout &lt;&lt; "Double " &lt;&lt; num &lt;&lt; " is: " &lt;&lt; num * 2 &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; "Triple " &lt;&lt; num &lt;&lt; " is: " &lt;&lt; num * 3 &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">1.x — Chapter 1 summary and quiz</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Chapter Review</h3><p>A <span class="cpp-definition">statement</span> is a type of instruction that causes the program to perform some action. Statements are often terminated by a semicolon.</p><p>A <span class="cpp-definition">function</span> is a collection of statements that execute sequentially. Every C++ program must include a special function named <em>main</em>. When you run your program, execution starts at the top of the <em>main</em> function.</p><p>The rules that govern how elements of the C++ language are constructed is called a <span class="cpp-definition">syntax</span>. A <span class="cpp-definition">syntax error</span> occurs when you violate the grammatical rules of the language.</p><p><span class="cpp-definition">Comments</span> allow the programmer to leave notes in the code. C++ supports two types of comments. Line comments start with a <code>//</code> and run to the end of the line. Block comments start with a <code>/*</code> and go to the paired <code>*/</code> symbol. Don’t nest comments.</p><p>You can use comments to temporarily disable lines or sections of code. This is called commenting out your code.</p><p><span class="cpp-definition">Data</span> is any sequence of symbols that can be interpreted to mean something. A single piece of data, stored somewhere in memory is called a <span class="cpp-definition">value</span>.</p><p>A variable is a named piece of memory that we can use to store values. A variable’s name is called an <span class="cpp-definition">identifier</span>. In order to create a variable, we use a statement called a <span class="cpp-definition">definition statement</span>. When the program is run, each defined variable is <span class="cpp-definition">instantiated</span>, which means it is assigned a memory address.</p><p>A <span class="cpp-definition">data type</span> tells the compiler how to interpret a piece of data into a meaningful value. An <span class="cpp-definition">integer</span> is a number that can be written without a fractional component, such as 4, 27, 0, -2, or -12.</p><p><span class="cpp-definition">Copy assignment</span> (via operator=) can be used to assign an already created variable a value.</p><p><span class="cpp-definition">Initialization</span> can be used to give a variable a value at the point of creation. C++ supports 3 types of initialization:</p><ul><li>Copy initialization.</li><li>Direct initialization (also called parenthesis initialization).</li><li>Brace initialization (also called uniform initialization or list initialization).</li></ul><p>You should prefer brace initialization over the other initialization forms, and prefer initialization over assignment.</p><p>Although you can define multiple variables in a single statement, it’s better to define and initialize each variable on its own line, in a separate statement.</p><p><span class="cpp-definition">std::cout</span> and operator&lt;&lt; allow us to output an expression to the console as text. <span class="cpp-definition">std::endl</span> outputs a new line character, forcing the console cursor to move to the next line. <span class="cpp-definition">std::cin</span> and operator&gt;&gt; allow us to get a value from the keyboard.</p><p>A variable that has not been given a value is called an <span class="cpp-definition">uninitialized variable</span>. Trying to get the value of an uninitialized variable will result in <span class="cpp-definition">undefined behavior</span>, which can manifest in any number of ways.</p><p>C++ reserves a set of names called <span class="cpp-definition">keywords</span>. These have special meaning within the language and may not be used as variable names.</p><p>A <span class="cpp-definition">literal constant</span> is a fixed value inserted directly into the source code. Examples are 5 and “Hello world!”.</p><p>An <span class="cpp-definition">operation</span> is a mathematical calculation involving zero or more input values, called <span class="cpp-definition">operands</span>. The specific operation to be performed is denoted by the provided <span class="cpp-definition">operator</span>. The result of an operation produces an output value.</p><p><span class="cpp-definition">Unary</span> operators take one operand. <span class="cpp-definition">Binary</span> operators take two operands, often called left and right. <span class="cpp-definition">Ternary</span> operators take three operands.</p><p>An <span class="cpp-definition">expression</span> is a combination of literals, variables, operators, and function calls that are evaluated to produce a single output value. The calculation of this output value is called <span class="cpp-definition">evaluation</span>. The value produced is the <span class="cpp-definition">result</span> of the expression.</p><p>An <span class="cpp-definition">expression statement</span> is an expression that has been turned into a statement by placing a semicolon at the end of the expression.</p><p>Programming is hard, and your programs will rarely come out perfect (or close to it) the first time. Get your programs working first, then refine them into something great.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>What is the difference between initialization and assignment?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none">Initialization provides a variable with an initial value (at the point of creation). Assignment gives a variable a new value after the variable has already been defined.</div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>When does undefined behavior occur? What are the consequences of undefined behavior?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none">Undefined behavior occurs when the programmer does something that is ill-specified by the C++ language. The consequences could be almost anything, from crashing to producing the wrong answer to working correctly anyway.</div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>Write a program that asks the user to enter a number, and then enter a second number. The program should tell the user what the result of adding and subtracting the two numbers is.</p><p>The output of the program should match the following (assuming inputs of 6 and 4):</p><pre>Enter an integer: 6
Enter another integer: 4
6 + 4 is 10.
6 - 4 is 2.
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Enter an integer: ";</code><code>	int x{};</code><code>	std::cin &gt;&gt; x;</code><code></code><code>	std::cout &lt;&lt; "Enter another integer: ";</code><code>	int y{};</code><code>	std::cin &gt;&gt; y;</code><code></code><code>	std::cout &lt;&lt; x &lt;&lt; " + " &lt;&lt; y &lt;&lt; " is " &lt;&lt; x + y &lt;&lt; ".\n";</code><code>	std::cout &lt;&lt; x &lt;&lt; " - " &lt;&lt; y &lt;&lt; " is " &lt;&lt; x - y &lt;&lt; ".\n";</code><code></code><code>	return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">2.1 — Introduction to functions</h1></header><div class="entry-content" itemprop="articleBody"><p>In the last chapter, we defined a function as a collection of statements that execute sequentially. While that is certainly true, that definition doesn’t provide much insight into why functions are useful. Let’s update our definition: A <span class="cpp-definition">function</span> is a reusable sequence of statements designed to do a particular job.</p><p>You already know that every executable program must have a function named <em>main</em> (which is where the program starts execution when it is run). However, as programs start to get longer and longer, putting all the code inside the <em>main</em> function becomes increasingly hard to manage. Functions provide a way for us to split our programs into small, modular chunks that are easier to organize, test, and use. Most programs use many functions. The C++ standard library comes with plenty of already-written functions for you to use -- however, it’s just as common to write your own. Functions that you write yourself are called <span class="cpp-definition">user-defined functions</span>.</p><p>Consider a case that might occur in real life: you’re reading a book, when you remember you need to make a phone call. You put a bookmark in your book, make the phone call, and when you are done with the phone call, you return to the place you bookmarked and continue your book precisely where you left off.</p><p>C++ programs can work the same way. A program will be executing statements sequentially inside one function when it encounters a function call. A <span class="cpp-definition">function call</span> is an expression that tells the CPU to interrupt the current function and execute another function. The CPU “puts a bookmark” at the current point of execution, and then <span class="cpp-definition">calls</span> (executes) the function named in the function call. When the called function ends, the CPU returns back to the point it bookmarked, and resumes execution.</p><p>The function initiating the function call is called the <span class="cpp-definition">caller</span>, and the function being called is the <span class="cpp-definition">callee</span> or <span class="cpp-definition">called</span> function.</p><br><h3>An example of a user-defined function</h3><p>First, let’s start with the most basic syntax to define a user-defined function. For the next few lessons, all user-defined functions will take the following form:</p><pre class="language-cpp line-numbers"><code>return-type identifier() // This is the function header (tells the compiler about the existence of the function)</code><code>{</code><code>    // This is the function body (tells the compiler what the function does)</code><code>}</code></pre><p>The first line is informally called the <span class="cpp-definition">function header</span>, and it tells the compiler about the existence of a function, what the function is called, and some other information that we’ll cover in future lessons (like the return type and parameter types).</p><ul><li>In this lesson, we’ll use a <em>return-type</em> of <em>int</em> (for function <em>main()</em>) or <em>void</em> (otherwise). We’ll talk more about return types and return values in the next lesson (<a href="https://www.learncpp.com/cpp-tutorial/function-return-values-value-returning-functions/">2.2 -- Function return values (value-returning functions)</a>). For now, you can ignore these.</li><li>Just like variables have names, so do user-defined functions. The <em>identifier</em> is the name of your user-defined function.</li><li>The parentheses after the identifier tell the compiler that we’re defining a function.</li></ul><p>The curly braces and statements in-between are called the <span class="cpp-definition">function body</span>. This is where the statements that determine what your function does will go.</p><p>Here is a sample program that shows how a new function is defined and called:</p><pre class="language-cpp line-numbers"><code>#include <iostream> // for std::cout</iostream></code><code></code><code>// Definition of user-defined function doPrint()</code><code>void doPrint() // doPrint() is the called function in this example</code><code>{</code><code>    std::cout &lt;&lt; "In doPrint()\n";</code><code>}</code><code></code><code>// Definition of function main()</code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Starting main()\n";</code><code>    doPrint(); // Interrupt main() by making a function call to doPrint().  main() is the caller.</code><code>    std::cout &lt;&lt; "Ending main()\n"; // this statement is executed after doPrint() ends</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program produces the following output:</p><pre>Starting main()
In doPrint()
Ending main()
</pre><p>This program begins execution at the top of function <em>main</em>, and the first line to be executed prints <code>Starting main()</code>.</p><p>The second line in <em>main</em> is a function call to the function <em>doPrint</em>. We call function <em>doPrint</em> by appending a pair of parentheses to the function name like such: <code>doPrint()</code>. Note that if you forget the parentheses, your program may not compile (and if it does, the function will not be called).</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Don’t forget to include parentheses () after the function’s name when making a function call.</p></div><p>Because a function call was made, execution of statements in <em>main</em> is suspended, and execution jumps to the top of called function <em>doPrint</em>. The first (and only) line in <em>doPrint</em> prints <code>In doPrint()</code>. When <em>doPrint</em> terminates, execution returns back to the caller (here: function <em>main</em>) and resumes from the point where it left off. Consequently, the next statement executed in <em>main</em> prints <code>Ending main()</code>.</p><br><h3>Calling functions more than once</h3><p>One useful thing about functions is that they can be called more than once. Here’s a program that demonstrates this:</p><pre class="language-cpp line-numbers"><code>#include <iostream> // for std::cout</iostream></code><code></code><code>void doPrint()</code><code>{</code><code>    std::cout &lt;&lt; "In doPrint()\n";</code><code>}</code><code></code><code>// Definition of function main()</code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Starting main()\n";</code><code>    doPrint(); // doPrint() called for the first time</code><code>    doPrint(); // doPrint() called for the second time</code><code>    std::cout &lt;&lt; "Ending main()\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program produces the following output:</p><pre>Starting main()
In doPrint()
In doPrint()
Ending main()
</pre><p>Since <em>doPrint</em> gets called twice by <em>main</em>, <em>doPrint</em> executes twice, and <em>In doPrint()</em> gets printed twice (once for each call).</p><br><h3>Functions calling functions calling functions</h3><p>You’ve already seen that function <em>main</em> can call another function (such as function <em>doPrint</em> in the example above). Any function can call any other function. In the following program, function <em>main</em> calls function <em>doA</em>, which calls function <em>doB</em>:</p><pre class="language-cpp line-numbers"><code>#include <iostream> // for std::cout</iostream></code><code></code><code>void doB()</code><code>{</code><code>    std::cout &lt;&lt; "In doB()\n";</code><code>}</code><code></code><code></code><code>void doA()</code><code>{</code><code>    std::cout &lt;&lt; "Starting doA()\n";</code><code></code><code>    doB();</code><code></code><code>    std::cout &lt;&lt; "Ending doA()\n";</code><code>}</code><code></code><code>// Definition of function main()</code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Starting main()\n";</code><code></code><code>    doA();</code><code></code><code>    std::cout &lt;&lt; "Ending main()\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program produces the following output:</p><pre>Starting main()
Starting doA()
In doB()
Ending doA()
Ending main()
</pre><br><h3>Nested functions are not supported</h3><p>Unlike some other programming languages, in C++, functions cannot be defined inside other functions. The following program is not legal:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    void foo() // Illegal: this function is nested inside function main()</code><code>    {</code><code>        std::cout &lt;&lt; "foo!\n";</code><code>    }</code><code></code><code>    foo(); // function call to foo()</code><code>    return 0;</code><code>}</code></pre><p>The proper way to write the above program is:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void foo() // no longer inside of main()</code><code>{</code><code>    std::cout &lt;&lt; "foo!\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    foo();</code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>“foo” is a meaningless word that is often used as a placeholder name for a function or variable when the name is unimportant to the demonstration of some concept. Such words are called <a href="https://en.wikipedia.org/wiki/Metasyntactic_variable">metasyntactic variables</a> (though in common language they’re often called “placeholder names” since nobody can remember the term “metasyntactic variable”). Other common metasyntactic variables in C++ include “bar”, “baz”, and 3-letter words that end in “oo”, such as “goo”, “moo”, and “boo”).</p><p>For those interested in etymology (how words evolve), <a href="https://datatracker.ietf.org/doc/html/rfc3092">RFC 3092</a> is an interesting read.</p></div><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>In a function definition, what are the curly braces and statements in-between called?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none">The function body</div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>What does the following program print? Do not compile this program, just trace the code yourself.</p><pre class="language-cpp line-numbers"><code>#include <iostream> // for std::cout</iostream></code><code></code><code>void doB()</code><code>{</code><code>    std::cout &lt;&lt; "In doB()\n";</code><code>}</code><code></code><code>void doA()</code><code>{</code><code>    std::cout &lt;&lt; "In doA()\n";</code><code></code><code>    doB();</code><code>}</code><code></code><code>// Definition of function main()</code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Starting main()\n";</code><code></code><code>    doA();</code><code>    doB();</code><code></code><code>    std::cout &lt;&lt; "Ending main()\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>Starting main()<br>In doA()<br>In doB()<br>In doB()<br>Ending main()</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">2.2 — Function return values (value-returning functions)</h1></header><div class="entry-content" itemprop="articleBody"><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	// get a value from the user</code><code>	std::cout &lt;&lt; "Enter an integer: ";</code><code>	int num{};</code><code>	std::cin &gt;&gt; num;</code><code></code><code>	// print the value doubled</code><code>	std::cout &lt;&lt; num &lt;&lt; " doubled is: " &lt;&lt; num * 2 &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This program is composed of two conceptual parts: First, we get a value from the user. Then we tell the user what double that value is.</p><p>Although this program is trivial enough that we don’t need to break it into multiple functions, what if we wanted to? Getting an integer value from the user is a well-defined job that we want our program to do, so it would make a good candidate for a function.</p><p>So let’s write a program to do this:</p><pre class="language-cpp line-numbers"><code>// This program doesn't work</code><code>#include <iostream></iostream></code><code></code><code>void getValueFromUser()</code><code>{</code><code> 	std::cout &lt;&lt; "Enter an integer: ";</code><code>	int input{};</code><code>	std::cin &gt;&gt; input;  </code><code>}</code><code></code><code>int main()</code><code>{</code><code>	getValueFromUser(); // Ask user for input</code><code></code><code>	int num{}; // How do we get the value from getValueFromUser() and use it to initialize this variable?</code><code></code><code>	std::cout &lt;&lt; num &lt;&lt; " doubled is: " &lt;&lt; num * 2 &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>While this program is a good attempt at a solution, it doesn’t quite work.</p><p>When function <code>getValueFromUser</code> is called, the user is asked to enter an integer as expected. But the value they enter is lost when <code>getValueFromUser</code> terminates and control returns to <code>main</code>. Variable <code>num</code> never gets initialized with the value the user entered, and so the program always prints the answer <code>0</code>.</p><p>What we’re missing is some way for <code>getValueFromUser</code> to return the value the user entered back to <code>main</code> so that <code>main</code> can make use of that data.</p><br><h3>Return values</h3><p>When you write a user-defined function, you get to determine whether your function will return a value back to the caller or not. To return a value back to the caller, two things are needed.</p><p>First, your function has to indicate what type of value will be returned. This is done by setting the function’s <span class="cpp-definition">return type</span>, which is the type that is defined before the function’s name. In the example above, function <code>getValueFromUser</code> has a return type of <code>void</code> (meaning no value will be returned to the caller), and function <code>main</code> has a return type of <code>int</code> (meaning a value of type <code>int</code> will be returned to the caller). Note that this doesn’t determine what specific value is returned -- it only determines what <em>type</em> of value will be returned.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We explore functions that return <code>void</code> further in the next lesson (<a href="https://www.learncpp.com/cpp-tutorial/void-functions-non-value-returning-functions/">2.3 -- Void functions (non-value returning functions)</a>).</p></div><p>Second, inside the function that will return a value, we use a <span class="cpp-definition">return statement</span> to indicate the specific value being returned to the caller. The specific value returned from a function is called the <span class="cpp-definition">return value</span>. When the return statement is executed, the function exits immediately, and the return value is copied from the function back to the caller. This process is called <span class="cpp-definition">return by value</span>.</p><p>Let’s take a look at a simple function that returns an integer value, and a sample program that calls it:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// int is the return type</code><code>// A return type of int means the function will return some integer value to the caller (the specific value is not specified here)</code><code>int returnFive()</code><code>{</code><code>    // the return statement indicates the specific value that will be returned</code><code>    return 5; // return the specific value 5 back to the caller</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; returnFive() &lt;&lt; '\n'; // prints 5</code><code>    std::cout &lt;&lt; returnFive() + 2 &lt;&lt; '\n'; // prints 7</code><code></code><code>    returnFive(); // okay: the value 5 is returned, but is ignored since main() doesn't do anything with it</code><code></code><code>    return 0;</code><code>}</code></pre><p>When run, this program prints:</p><pre>5
7
</pre><p>Execution starts at the top of <code>main</code>. In the first statement, the function call to <code>returnFive</code> is evaluated, which results in function <code>returnFive</code> being called. Function <code>returnFive</code> returns the specific value of <code>5</code> back to the caller, which is then printed to the console via <code>std::cout</code>.</p><p>In the second function call, the function call to <code>returnFive</code> is evaluated, which results in function <code>returnFive</code> being called again. Function <code>returnFive</code> returns the value of <code>5</code> back to the caller. The expression <code>5 + 2</code> is evaluated to produce the result <code>7</code>, which is then printed to the console via <code>std::cout</code>.</p><p>In the third statement, function <code>returnFive</code> is called again, resulting in the value <code>5</code> being returned back to the caller. However, function <code>main</code> does nothing with the return value, so nothing further happens (the return value is ignored).</p><p>Note: Return values will not be printed unless the caller sends them to the console via <code>std::cout</code>. In the last case above, the return value is not sent to <code>std::cout</code>, so nothing is printed.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>When a called function returns a value, the caller may decide to use that value in an expression or statement (e.g. by assigning it to a variable, or sending it to <code>std::cout</code>) or ignore it (by doing nothing else).</p></div><br><h3>Fixing our challenge program</h3><p>With this in mind, we can fix the program we presented at the top of the lesson:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getValueFromUser() // this function now returns an integer value</code><code>{</code><code> 	std::cout &lt;&lt; "Enter an integer: ";</code><code>	int input{};</code><code>	std::cin &gt;&gt; input;  </code><code></code><code>	return input; // return the value the user entered back to the caller</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int num { getValueFromUser() }; // initialize num with the return value of getValueFromUser()</code><code></code><code>	std::cout &lt;&lt; num &lt;&lt; " doubled is: " &lt;&lt; num * 2 &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>When this program executes, the first statement in <code>main</code> will create an <code>int</code> variable named <code>num</code>. When the program goes to initialize <code>num</code>, it will see that there is a function call to <code>getValueFromUser()</code>, so it will go execute that function. Function <code>getValueFromUser</code>, asks the user to enter a value, and then it returns that value back to the caller (<code>main</code>). This return value is used as the initialization value for variable <code>num</code>.</p><p>Compile this program yourself and run it a few times to prove to yourself that it works.</p><br><h3>Revisiting main()</h3><p>You now have the conceptual tools to understand how the <code>main</code> function actually works. When the program is executed, the operating system makes a function call to <code>main</code>. Execution then jumps to the top of <code>main</code>. The statements in <code>main</code> are executed sequentially. Finally, <code>main</code> returns an integer value (usually <code>0</code>), and your program terminates. The return value from <code>main</code> is sometimes called a <span class="cpp-definition">status code</span> (also sometimes called an <span class="cpp-definition">exit code</span>, or rarely a <span class="cpp-definition">return code</span>), as it is used to indicate whether the program ran successfully or not.</p><p>By definition, a status code of <code>0</code> means the program executed successfully.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Your <code>main</code> function should return the value <code>0</code> if the program ran normally.</p></div><p>A non-zero status code is often used to indicate failure (and while this works fine on most operating systems, strictly speaking, it’s not guaranteed to be portable).</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>The C++ standard only defines the meaning of 3 status codes: 0, EXIT_SUCCESS, and EXIT_FAILURE. 0 and EXIT_SUCCESS both mean the program executed successfully. EXIT_FAILURE means the program did not execute successfully.</p><p>EXIT_SUCCESS and EXIT_FAILURE are defined in the &lt;cstdlib&gt; header:</p><pre class="language-cpp line-numbers"><code>#include <cstdlib> // for EXIT_SUCCESS and EXIT_FAILURE</cstdlib></code><code></code><code>int main()</code><code>{</code><code>    return EXIT_SUCCESS;</code><code>}</code></pre><p>If you want to maximize portability, you should only use 0 or EXIT_SUCCESS to indicate a successful termination, or EXIT_FAILURE to indicate an unsuccessful termination.</p></div><p>C++ disallows calling the <code>main</code> function explicitly.</p><p>For now, you should also define your <code>main</code> function at the bottom of your code file, below other functions.</p><br><h3>A value-returning function that does not return a value will produce undefined behavior</h3><p>A function that returns a value is called a <span class="cpp-definition">value-returning function</span>. A function is value-returning if the return type is anything other than <code>void</code>.</p><p>A value-returning function <em>must</em> return a value of that type (using a return statement), otherwise undefined behavior will result.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We discuss undefined behavior in lesson <a href="https://www.learncpp.com/cpp-tutorial/uninitialized-variables-and-undefined-behavior/">1.6 -- Uninitialized variables and undefined behavior</a>.</p></div><p>Here’s an example of a function that produces undefined behavior:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getValueFromUser() // this function returns an integer value</code><code>{</code><code> 	std::cout &lt;&lt; "Enter an integer: ";</code><code>	int input{};</code><code>	std::cin &gt;&gt; input;</code><code></code><code>	// note: no return statement</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int num { getValueFromUser() }; // initialize num with the return value of getValueFromUser()</code><code></code><code>	std::cout &lt;&lt; num &lt;&lt; " doubled is: " &lt;&lt; num * 2 &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>A modern compiler should generate a warning because <code>getValueFromUser</code> is defined as returning an <code>int</code> but no return statement is provided. Running such a program would produce undefined behavior, because <code>getValueFromUser()</code> is a value-returning function that does not return a value.</p><p>In most cases, compilers will detect if you’ve forgotten to return a value. However, in some complicated cases, the compiler may not be able to properly determine whether your function returns a value or not in all cases, so you should not rely on this.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Make sure your functions with non-void return types return a value in all cases.</p><p>Failure to return a value from a value-returning function will cause undefined behavior.</p></div><br><h3>Function main will implicitly return 0 if no return statement is provided</h3><p>The only exception to the rule that a value-returning function must return a value via a return statement is for function <code>main()</code>. The function <code>main()</code> will implicitly return the value <code>0</code> if no return statement is provided. That said, it is best practice to explicitly return a value from <code>main</code>, both to show your intent, and for consistency with other functions (which will not let you omit the return value).</p><br><h3>Functions can only return a single value</h3><p>A value-returning function can only return a single value back to the caller each time it is called.</p><p>Note that the value provided in a return statement doesn’t need to be literal -- it can be the result of any valid expression, including a variable or even a call to another function that returns a value. In the <code>getValueFromUser()</code> example above, we returned a variable <code>input</code>, which held the number the user input.</p><p>There are various ways to work around the limitation of functions only being able to return a single value, which we’ll cover in future lessons.</p><br><h3>The function author can decide what the return value means</h3><p>The meaning of the value returned by a function is determined by the function’s author. Some functions use return values as status codes, to indicate whether they succeeded or failed. Other functions return a calculated or selected value. Other functions return nothing (we’ll see examples of these in the next lesson).</p><p>Because of the wide variety of possibilities here, it’s a good idea to document your function with a comment indicating what the return values mean. For example:</p><pre class="language-cpp line-numbers"><code>// Function asks user to enter a value</code><code>// Return value is the integer entered by the user from the keyboard</code><code>int getValueFromUser()</code><code>{</code><code> 	std::cout &lt;&lt; "Enter an integer: ";</code><code>	int input{};</code><code>	std::cin &gt;&gt; input;  </code><code></code><code>	return input; // return the value the user entered back to the caller</code><code>}</code></pre><br><h3>Reusing functions</h3><p>Now we can illustrate a good case for function reuse. Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	int x{};</code><code>	std::cout &lt;&lt; "Enter an integer: ";</code><code>	std::cin &gt;&gt; x; </code><code></code><code>	int y{};</code><code>	std::cout &lt;&lt; "Enter an integer: ";</code><code>	std::cin &gt;&gt; y; </code><code></code><code>	std::cout &lt;&lt; x &lt;&lt; " + " &lt;&lt; y &lt;&lt; " = " &lt;&lt; x + y &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>While this program works, it’s a little redundant. In fact, this program violates one of the central tenets of good programming: <span class="cpp-definition">Don’t Repeat Yourself</span> (often abbreviated <span class="cpp-definition">DRY</span>).</p><p>Why is repeated code bad? If we wanted to change the text “Enter an integer:” to something else, we’d have to update it in two locations. And what if we wanted to initialize 10 variables instead of 2? That would be a lot of redundant code (making our programs longer and harder to understand), and a lot of room for typos to creep in.</p><p>Let’s update this program to use our <code>getValueFromUser</code> function that we developed above:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getValueFromUser()</code><code>{</code><code> 	std::cout &lt;&lt; "Enter an integer: ";</code><code>	int input{};</code><code>	std::cin &gt;&gt; input;  </code><code></code><code>	return input;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x{ getValueFromUser() }; // first call to getValueFromUser</code><code>    int y{ getValueFromUser() }; // second call to getValueFromUser</code><code></code><code>    std::cout &lt;&lt; x &lt;&lt; " + " &lt;&lt; y &lt;&lt; " = " &lt;&lt; x + y &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program produces the following output:</p><pre>Enter an integer: 5
Enter an integer: 7
5 + 7 = 12
</pre><p>In this program, we call <code>getValueFromUser</code> twice, once to initialize variable <code>x</code>, and once to initialize variable <code>y</code>. That saves us from duplicating the code to get user input, and reduces the odds of making a mistake. Once we know <code>getValueFromUser</code> works, we can call it as many times as we desire.</p><p>This is the essence of modular programming: the ability to write a function, test it, ensure that it works, and then know that we can reuse it as many times as we want and it will continue to work (so long as we don’t modify the function -- at which point we’ll have to retest it).</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Follow the DRY best practice: “don’t repeat yourself”. If you need to do something more than once, consider how to modify your code to remove as much redundancy as possible. Variables can be used to store the results of calculations that need to be used more than once (so we don’t have to repeat the calculation). Functions can be used to define a sequence of statements we want to execute more than once. And loops (which we’ll cover in a later chapter) can be used to execute a statement more than once.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>The opposite of DRY is WET (“Write everything twice”).</p></div><br><h3>Conclusion</h3><p class="cpp-quiz-question" style="clear:both">Question #1</p><p>Inspect the following programs and state what they output, or whether they will not compile.</p><p>1a)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int return7()</code><code>{</code><code>    return 7;</code><code>}</code><code></code><code>int return9()</code><code>{</code><code>    return 9;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; return7() + return9() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none">This program prints the number 16.</div><p>1b)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int return7()</code><code>{</code><code>    return 7;</code><code></code><code>    int return9()</code><code>    {</code><code>        return 9;</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; return7() + return9() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none">This program will not compile. Nested functions are not allowed.</div><p>1c)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int return7()</code><code>{</code><code>    return 7;</code><code>}</code><code></code><code>int return9()</code><code>{</code><code>    return 9;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    return7();</code><code>    return9();</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none">This program compiles but does not produce any output. The return values from the functions are not used for anything (and are thus discarded).</div><p>1d)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getNumbers()</code><code>{</code><code>    return 5;</code><code>    return 7;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; getNumbers() &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; getNumbers() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none">This program prints 5 twice (on separate lines). Both times when function getNumbers() is called, the value 5 is returned. When the return 5 statement is executed, the function is exited immediately, so the return 7 statement never executes.</div><p>1e)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int return 5()</code><code>{</code><code>    return 5;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; return 5() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none">This program will not compile because the function has an invalid name. We talked about naming rules in lesson <a href="https://www.learncpp.com/cpp-tutorial/keywords-and-naming-identifiers/#rules">1.7 -- Keywords and naming identifiers</a>.</div><p>1f) Extra credit:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int returnFive()</code><code>{</code><code>    return 5;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; returnFive &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none">This program will compile, but the function will not be called because the function call is missing parentheses. What actually gets output depends on the compiler.</div><p class="cpp-quiz-question cpp-topline" style="clear:both">Question #2</p><p>What does “DRY” stand for, and why is it a useful practice to follow?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none">DRY stands for “Don’t Repeat Yourself”. It is a practice that involves writing your code in such a way so as to minimize redundancy. This makes your programs more concise, less error prone, and more maintainable.</div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">2.3 — Void functions (non-value returning functions)</h1></header><div class="entry-content" itemprop="articleBody"><p>In a prior lesson (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-functions/">2.1 -- Introduction to functions</a>), we indicated that the syntax for a function definition looks like this:</p><pre>return-type identifier() // identifier replaced with the name of your function
{
// Your code here
}
</pre><p>Although we showed examples of functions that had return-type <code>void</code>, we did not discuss what this meant. In this lesson, we’ll explore functions with a return type of <code>void</code>.</p><br><h3>Void return values</h3><p>Functions are not required to return a value back to the caller. To tell the compiler that a function does not return a value, a return type of <span class="cpp-definition">void</span> is used. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// void means the function does not return a value to the caller</code><code>void printHi()</code><code>{</code><code>    std::cout &lt;&lt; "Hi" &lt;&lt; '\n';</code><code></code><code>    // This function does not return a value so no return statement is needed</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printHi(); // okay: function printHi() is called, no value is returned</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, the <code>printHi</code> function has a useful behavior (it prints “Hi”) but it doesn’t need to return anything back to the caller. Therefore, <code>printHi</code> is given a <code>void</code> return type.</p><p>When <code>main</code> calls <code>printHi</code>, the code in <code>printHi</code> executes, and “Hi” is printed. At the end of <code>printHi</code>, control returns to <code>main</code> and the program proceeds.</p><p>A function that does not return a value is called a <span class="cpp-definition">non-value returning function</span> (or a <span class="cpp-definition">void function</span>).</p><br><h3>Void functions don’t need a return statement</h3><p>A void function will automatically return to the caller at the end of the function. No return statement is required.</p><p>A return statement (with no return value) can be used in a void function -- such a statement will cause the function to return to the caller at the point where the return statement is executed. This is the same thing that happens at the end of the function anyway. Consequently, putting an empty return statement at the end of a void function is redundant:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// void means the function does not return a value to the caller</code><code>void printHi()</code><code>{</code><code>    std::cout &lt;&lt; "Hi" &lt;&lt; '\n';</code><code></code><code>    return; // tell compiler to return to the caller -- this is redundant since this will happen anyway!</code><code>} // function will return to caller here</code><code></code><code>int main()</code><code>{</code><code>    printHi();</code><code></code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Do not put a return statement at the end of a non-value returning function.</p></div><br><h3>Void functions can’t be used in expression that require a value</h3><p>Some types of expressions require values. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; 5; // ok: 5 is a literal value that we're sending to the console to be printed</code><code>    std::cout &lt;&lt; ;  // compile error: no value provided</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above program, the value to be printed needs to be provided on the right-side of the <code>std::cout &lt;&lt;</code>. If no value is provided, the compiler will produce a syntax error. Since the second call to <code>std::cout</code> does not provide a value to be printed, this causes an error.</p><p>Now consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// void means the function does not return a value to the caller</code><code>void printHi()</code><code>{</code><code>    std::cout &lt;&lt; "Hi" &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printHi(); // okay: function printHi() is called, no value is returned</code><code></code><code>    std::cout &lt;&lt; printHi(); // compile error</code><code></code><code>    return 0;</code><code>}</code></pre><p>The first call to <code>printHi()</code> is called in a context that does not require a value. Since the function doesn’t return a value, this is fine.</p><p>The second function call to function <code>printHi()</code> won’t even compile. Function <code>printHi</code> has a <code>void</code> return type, meaning it doesn’t return a value. However, this statement is trying to send the return value of <code>printHi</code> to <code>std::cout</code> to be printed. <code>std::cout</code> doesn’t know how to handle this (what value would it output?). Consequently, the compiler will flag this as an error. You’ll need to comment out this line of code in order to make your code compile.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>Some statements require values to be provided, and others don’t.</p><p>When we call a function by itself (e.g. the first <code>printHi()</code> in the above example), we’re calling a function for its behavior, not its return value. In this case, we can call either a non-value returning function, or we can call a value-returning function and just ignore the return value.</p><p>When we call a function in a context that requires a value (e.g. <code>std::cout</code>), a value must be provided. In such a context, we can only call value-returning functions.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// Function that does not return a value</code><code>void returnNothing()</code><code>{</code><code>}</code><code></code><code>// Function that returns a value</code><code>int returnFive()</code><code>{</code><code>    return 5;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    // When calling a function by itself, no value is required</code><code>    returnNothing(); // ok: we can call a function that does not return a value</code><code>    returnFive();    // ok: we can call a function that returns a value, and ignore that return value</code><code></code><code>    // When calling a function in a context that requires a value (like std::cout)</code><code>    std::cout &lt;&lt; returnFive();    // ok: we can call a function that returns a value, and the value will be used</code><code>    std::cout &lt;&lt; returnNothing(); // compile error: we can't call a function that returns void in this context</code><code></code><code>    return 0;</code><code>}</code></pre></div><br><h3>Returning a value from a void function is a compile error</h3><p>Trying to return a value from a non-value returning function will result in a compilation error:</p><pre class="language-cpp line-numbers"><code>void printHi() // This function is non-value returning</code><code>{</code><code>    std::cout &lt;&lt; "In printHi()" &lt;&lt; '\n';</code><code></code><code>    return 5; // compile error: we're trying to return a value</code><code>}</code></pre><br><h3>Early returns</h3><p>A return statement that is not the last statement in a function is called an <span class="cpp-definition">early return</span>. Such a statement will cause the function to return to the caller when the return statement is executed (before the function would otherwise return to the caller, hence, “early”).</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print() // note: void return type</code><code>{</code><code>    std::cout &lt;&lt; "A";</code><code></code><code>    return; // the function will return to the caller here (note: no return value)</code><code></code><code>    std::cout &lt;&lt; "B"; // this will never be printed</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    print();</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, when <code>print()</code> executes, it will first print “A”. Then the return statement executes, and control returns back to the caller (<code>main</code>). “B” is never printed because the statement never executes.</p><p>Early returns can be used in value-returning functions too:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int print() // note: return type of int</code><code>{</code><code>    std::cout &lt;&lt; "A";</code><code>    return 5; // the function will return to the caller here</code><code>    std::cout &lt;&lt; "B"; // this will never be printed</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; print(); // print() returns value 5, which will be print to the console</code><code></code><code>    return 0;</code><code>}</code></pre><p>The above program prints the following:</p><pre>A5
</pre><p>First, <code>print()</code> is called. The first statement in <code>print()</code> prints “A”. Then the return statement is executed, returning the value of <code>5</code> back to the caller. This return value is also printed. The statement <code>std::cout &lt;&lt; "B"</code> is never executed because the function has returned to the caller prior to that point.</p><p>Historically, early returns were frowned upon. However, in modern programming they are more accepted, particularly when they can be used to make a function simpler, or are used to abort a function early due to some error condition.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We discuss the debate over early returns in lesson <a href="https://www.learncpp.com/cpp-tutorial/break-and-continue/">7.10 -- Break and continue</a></p></div><br><h3>Quiz time</h3><p class="cpp-quiz-question" style="clear:both">Question #1</p><p>Inspect the following programs and state what they output, or whether they will not compile.</p><p>1a)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printA()</code><code>{</code><code>    std::cout &lt;&lt; "A\n";</code><code>}</code><code></code><code>void printB()</code><code>{</code><code>    std::cout &lt;&lt; "B\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printA();</code><code>    printB();</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none">This program prints the letters A and B on separate lines.</div><p>1b)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printA()</code><code>{</code><code>    std::cout &lt;&lt; "A\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; printA() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none">This program does not compile. Function <code>printA()</code> returns <code>void</code>, which can’t be sent to <code>std::cout</code> to be printed. This will produce a compile error.</div><p class="cpp-quiz-question cpp-topline" style="clear:both">Question #2</p><p>What is an early return, and what is its behavior?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none">An early return is a return statement that occurs before the last line of a function. It causes the function to return to the caller immediately.</div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">2.4 — Introduction to function parameters and arguments</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson, we learned that we could have a function return a value back to the function’s caller. We used that to create a modular <em>getValueFromUser</em> function that we used in this program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getValueFromUser()</code><code>{</code><code> 	std::cout &lt;&lt; "Enter an integer: ";</code><code>	int input{};</code><code>	std::cin &gt;&gt; input;  </code><code></code><code>	return input;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int num { getValueFromUser() };</code><code></code><code>	std::cout &lt;&lt; num &lt;&lt; " doubled is: " &lt;&lt; num * 2 &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>However, what if we wanted to put the output line into its own function as well? You might try something like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getValueFromUser()</code><code>{</code><code> 	std::cout &lt;&lt; "Enter an integer: ";</code><code>	int input{};</code><code>	std::cin &gt;&gt; input;  </code><code></code><code>	return input;</code><code>}</code><code></code><code>// This function won't compile</code><code>void printDouble()</code><code>{</code><code>	std::cout &lt;&lt; num &lt;&lt; " doubled is: " &lt;&lt; num * 2 &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int num { getValueFromUser() };</code><code></code><code>	printDouble();</code><code></code><code>	return 0;</code><code>}</code></pre><p>This won’t compile, because function <em>printDouble</em> doesn’t know what identifier <em>num</em> is. You might try defining num as a variable inside function printDouble():</p><pre class="language-cpp line-numbers"><code>void printDouble()</code><code>{</code><code>	int num{}; // we added this line</code><code>	std::cout &lt;&lt; num &lt;&lt; " doubled is: " &lt;&lt; num * 2 &lt;&lt; '\n';</code><code>}</code></pre><p>While this addresses the compiler error and makes the program compile-able, the program still doesn’t work correctly (it always prints “0 doubled is: 0”). The core of the problem here is that function <em>printDouble</em> doesn’t have a way to access the value the user entered.</p><p>We need some way to pass the value of variable <em>num</em> to function <em>printDouble</em> so that <em>printDouble</em> can use that value in the function body.</p><br><h3>Function parameters and arguments</h3><p>In many cases, it is useful to be able to pass information <em>to</em> a function being called, so that the function has data to work with. For example, if we wanted to write a function to add two numbers, we need some way to tell the function which two numbers to add when we call it. Otherwise, how would the function know what to add? We do that via function parameters and arguments.</p><p>A <span class="cpp-definition">function parameter</span> is a variable used in a function. Function parameters work almost identically to variables defined inside the function, but with one difference: they are always initialized with a value provided by the caller of the function.</p><p>Function parameters are defined in the function header by placing them in between the parenthesis after the function name, with multiple parameters being separated by commas.</p><p>Here are some examples of functions with different numbers of parameters:</p><pre class="language-cpp line-numbers"><code>// This function takes no parameters</code><code>// It does not rely on the caller for anything</code><code>void doPrint()</code><code>{</code><code>    std::cout &lt;&lt; "In doPrint()\n";</code><code>}</code><code></code><code>// This function takes one integer parameter named x</code><code>// The caller will supply the value of x</code><code>void printValue(int x)</code><code>{</code><code>    std::cout &lt;&lt; x  &lt;&lt; '\n';</code><code>}</code><code></code><code>// This function has two integer parameters, one named x, and one named y</code><code>// The caller will supply the value of both x and y</code><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code></pre><p>An <span class="cpp-definition">argument</span> is a value that is passed <em>from</em> the caller <em>to</em> the function when a function call is made:</p><pre class="language-cpp line-numbers"><code>doPrint(); // this call has no arguments</code><code>printValue(6); // 6 is the argument passed to function printValue()</code><code>add(2, 3); // 2 and 3 are the arguments passed to function add()</code></pre><p>Note that multiple arguments are also separated by commas.</p><br><h3>How parameters and arguments work together</h3><p>When a function is called, all of the parameters of the function are created as variables, and the value of each of the arguments is <em>copied</em> into the matching parameter. This process is called <span class="cpp-definition">pass by value</span>.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// This function has two integer parameters, one named x, and one named y</code><code>// The values of x and y are passed in by the caller</code><code>void printValues(int x, int y)</code><code>{</code><code>    std::cout &lt;&lt; x &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; y &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printValues(6, 7); // This function call has two arguments, 6 and 7</code><code></code><code>    return 0;</code><code>}</code></pre><p>When function <em>printValues</em> is called with arguments <em>6</em> and <em>7</em>, <em>printValues</em>‘s parameter <em>x</em> is created and initialized with the value of <em>6</em>, and <em>printValues</em>‘s parameter <em>y</em> is created and initialized with the value of <em>7</em>.</p><p>This results in the output:</p><pre>6
7
</pre><p>Note that the number of arguments must generally match the number of function parameters, or the compiler will throw an error. The argument passed to a function can be any valid expression (as the argument is essentially just an initializer for the parameter, and initializers can be any valid expression).</p><br><h3>Fixing our challenge program</h3><p>We now have the tool we need to fix the program we presented at the top of the lesson:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getValueFromUser()</code><code>{</code><code> 	std::cout &lt;&lt; "Enter an integer: ";</code><code>	int input{};</code><code>	std::cin &gt;&gt; input;  </code><code></code><code>	return input;</code><code>}</code><code></code><code>void printDouble(int value) // This function now has an integer parameter</code><code>{</code><code>	std::cout &lt;&lt; value &lt;&lt; " doubled is: " &lt;&lt; value * 2 &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int num { getValueFromUser() };</code><code></code><code>	printDouble(num);</code><code></code><code>	return 0;</code><code>}</code></pre><p>In this program, variable <em>num</em> is first initialized with the value entered by the user. Then, function <em>printDouble</em> is called, and the value of argument <em>num</em> is copied into the <em>value</em> parameter of function <em>printDouble</em>. Function <em>printDouble</em> then uses the value of parameter <em>value</em>.</p><br><h3>Using return values as arguments</h3><p>In the above problem, we can see that variable <em>num</em> is only used once, to transport the return value of function <em>getValueFromUser</em> to the argument of the call to function <em>printDouble</em>.</p><p>We can simplify the above example slightly as follows:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getValueFromUser()</code><code>{</code><code> 	std::cout &lt;&lt; "Enter an integer: ";</code><code>	int input{};</code><code>	std::cin &gt;&gt; input;  </code><code></code><code>	return input;</code><code>}</code><code></code><code>void printDouble(int value)</code><code>{</code><code>	std::cout &lt;&lt; value &lt;&lt; " doubled is: " &lt;&lt; value * 2 &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	printDouble(getValueFromUser());</code><code></code><code>	return 0;</code><code>}</code></pre><p>Now, we’re using the return value of function <em>getValueFromUser</em> directly as an argument to function <em>printDouble</em>!</p><p>Although this program is more concise (and makes it clear that the value read by the user will be used for nothing else), you may also find this “compact syntax” a bit hard to read. If you’re more comfortable sticking with the version that uses the variable instead, that’s fine.</p><br><h3>How parameters and return values work together</h3><p>By using both parameters and a return value, we can create functions that take data as input, do some calculation with it, and return the value to the caller.</p><p>Here is an example of a very simple function that adds two numbers together and returns the result to the caller:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// add() takes two integers as parameters, and returns the result of their sum</code><code>// The values of x and y are determined by the function that calls add()</code><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code><code></code><code>// main takes no parameters</code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; add(4, 5) &lt;&lt; '\n'; // Arguments 4 and 5 are passed to function add()</code><code>    return 0;</code><code>}</code></pre><p>Execution starts at the top of <em>main</em>. When <code>add(4, 5)</code> is evaluated, function <em>add</em> is called, with parameter <em>x</em> being initialized with value <em>4</em>, and parameter <em>y</em> being initialized with value <em>5</em>.</p><p>The <em>return statement</em> in function <em>add</em> evaluates <em>x + y</em> to produce the value <em>9</em>, which is then returned back to <em>main</em>. This value of <em>9</em> is then sent to <em>std::cout</em> to be printed on the console.</p><p>Output:</p><pre>9
</pre><p>In pictorial format:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter2/ParametersReturn.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter2/ParametersReturn.png"></div><br><h3>More examples</h3><p>Let’s take a look at some more function calls:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code><code></code><code>int multiply(int z, int w)</code><code>{</code><code>    return z * w;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; add(4, 5) &lt;&lt; '\n'; // within add() x=4, y=5, so x+y=9</code><code>    std::cout &lt;&lt; add(1 + 2, 3 * 4) &lt;&lt; '\n'; // within add() x=3, y=12, so x+y=15</code><code></code><code>    int a{ 5 };</code><code>    std::cout &lt;&lt; add(a, a) &lt;&lt; '\n'; // evaluates (5 + 5)</code><code></code><code>    std::cout &lt;&lt; add(1, multiply(2, 3)) &lt;&lt; '\n'; // evaluates 1 + (2 * 3)</code><code>    std::cout &lt;&lt; add(1, add(2, 3)) &lt;&lt; '\n'; // evaluates 1 + (2 + 3)</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program produces the output:</p><pre>9
15
10
7
6
</pre><p>The first statement is straightforward.</p><p>In the second statement, the arguments are expressions that get evaluated before being passed. In this case, <em>1 + 2</em> evaluates to <em>3</em>, so <em>3</em> is copied to parameter <em>x</em>. <em>3 * 4</em> evaluates to <em>12</em>, so <em>12</em> is copied to parameter <em>y</em>. <em>add(3, 12)</em> resolves to <em>15</em>.</p><p>The next pair of statements is relatively easy as well:</p><pre class="language-cpp line-numbers"><code>    int a{ 5 };</code><code>    std::cout &lt;&lt; add(a, a) &lt;&lt; '\n'; // evaluates (5 + 5)</code></pre><p>In this case, <em>add()</em> is called where the value of <em>a</em> is copied into both parameters <em>x</em> and <em>y</em>. Since <em>a</em> has value <em>5</em>, <em>add(a, a)</em> = <em>add(5, 5)</em>, which resolves to value <em>10</em>.</p><p>Let’s take a look at the first tricky statement in the bunch:</p><pre class="language-cpp line-numbers"><code>    std::cout &lt;&lt; add(1, multiply(2, 3)) &lt;&lt; '\n'; // evaluates 1 + (2 * 3)</code></pre><p>When the function <em>add</em> is executed, the program needs to determine what the values for parameters <em>x</em> and <em>y</em> are. <em>x</em> is simple since we just passed it the integer <em>1</em>. To get a value for parameter <em>y</em>, it needs to evaluate <em>multiply(2, 3)</em> first. The program calls <em>multiply</em> and initializes <em>z</em> = <em>2</em> and <em>w</em> = <em>3</em>, so <em>multiply(2, 3)</em> returns the integer value <em>6</em>. That return value of <em>6</em> can now be used to initialize the <em>y</em> parameter of the <em>add</em> function. <em>add(1, 6)</em> returns the integer <em>7</em>, which is then passed to std::cout for printing.</p><p>Put less verbosely:<br><em>add(1, multiply(2, 3))</em> evaluates to <em>add(1, 6)</em> evaluates to <em>7</em></p><p>The following statement looks tricky because one of the arguments given to <em>add</em> is another call to <em>add</em>.</p><pre class="language-cpp line-numbers"><code>    std::cout &lt;&lt; add(1, add(2, 3)) &lt;&lt; '\n'; // evaluates 1 + (2 + 3)</code></pre><p>But this case works exactly the same as the prior case. add(2, 3) resolves first, resulting in the return value of <em>5</em>. Now it can resolve add(1, 5), which evaluates to the value <em>6</em>, which is passed to std::cout for printing.</p><p>Less verbosely:<br><em>add(1, add(2, 3))</em> evaluates to <em>add(1, 5)</em> =&gt; evaluates to <em>6</em></p><br><h3>Conclusion</h3><p>Function parameters and return values are the key mechanisms by which functions can be written in a reusable way, as it allows us to write functions that can perform tasks and return retrieved or calculated results back to the caller without knowing what the specific inputs or outputs are ahead of time.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>What’s wrong with this program fragment?</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void multiply(int x, int y)</code><code>{</code><code>    return x * y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; multiply(4, 5) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none">multiply() has a return type of void, meaning it is a non-value returning function. Since the function is trying to return a value (via a return statement), this function will produce a compiler error. The return type should be int.</div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>What two things are wrong with this program fragment?</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int multiply(int x, int y)</code><code>{</code><code>    int product{ x * y };</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; multiply(4) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none">Problem 1: main() passes one argument to multiply(), but multiply() requires two parameters. Problem 2: multiply() doesn’t have a return statement.</div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>What value does the following program print?</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y, int z)</code><code>{</code><code>    return x + y + z;</code><code>}</code><code></code><code>int multiply(int x, int y)</code><code>{</code><code>    return x * y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; multiply(add(1, 2, 3), 4) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none">multiply is called where x = add(1, 2, 3), and y = 4. First, the CPU resolves x = add(1, 2, 3), which returns 1 + 2 + 3, or x = 6. multiply(6, 4) = 24, which is the answer.</div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #4</p><p>Write a function called doubleNumber() that takes one integer parameter. The function should return double the value of the parameter.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><pre class="language-cpp line-numbers"><code>int doubleNumber(int x)</code><code>{</code><code>    return 2 * x;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #5</p><ol start="5"><li>Write a complete program that reads an integer from the user, doubles it using the doubleNumber() function you wrote in the previous quiz question, and then prints the doubled value out to the console.</li></ol><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int doubleNumber(int x)</code><code>{</code><code>    return 2 * x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code>    std::cout &lt;&lt; doubleNumber(x) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>Note: You may come up with other (similar) solutions. There are often many ways to do the same thing in C++.</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">2.5 — Introduction to local scope</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Local variables</h3><p>Function parameters, as well as variables defined inside the function body, are called <span class="cpp-definition">local variables</span> (as opposed to global variables, which we’ll discuss in a future chapter).</p><pre class="language-cpp line-numbers"><code>int add(int x, int y) // function parameters x and y are local variables</code><code>{</code><code>    int z{ x + y }; // z is a local variable too</code><code></code><code>    return z;</code><code>}</code></pre><p>In this lesson, we’ll take a look at some properties of local variables in more detail.</p><br><h3>Local variable lifetime</h3><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-objects-and-variables/">1.3 -- Introduction to objects and variables</a>, we discussed how a variable definition such as <code>int x;</code> causes the variable to be instantiated (created) when this statement is executed. Function parameters are created and initialized when the function is entered, and variables within the function body are created and initialized at the point of definition.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>int add(int x, int y) // x and y created and initialized here</code><code>{ </code><code>    int z{ x + y }; // z created and initialized here</code><code></code><code>    return z;</code><code>}</code></pre><p>The natural follow-up question is, “so when is an instantiated variable destroyed?”. Local variables are destroyed in the opposite order of creation at the end of the set of curly braces in which it is defined (or for a function parameter, at the end of the function).</p><pre class="language-cpp line-numbers"><code>int add(int x, int y)</code><code>{ </code><code>    int z{ x + y };</code><code></code><code>    return z;</code><code>} // z, y, and x destroyed here</code></pre><p>Much like a person’s lifetime is defined to be the time between their birth and death, an object’s <span class="cpp-definition">lifetime</span> is defined to be the time between its creation and destruction. Note that variable creation and destruction happen when the program is running (called runtime), not at compile time. Therefore, lifetime is a runtime property.</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>The above rules around creation, initialization, and destruction are guarantees. That is, objects must be created and initialized no later than the point of definition, and destroyed no earlier than the end of the set of the curly braces in which they are defined (or, for function parameters, at the end of the function).</p><p>In actuality, the C++ specification gives compilers a lot of flexibility to determine when local variables are created and destroyed. Objects may be created earlier, or destroyed later for optimization purposes. Most often, local variables are created when the function is entered, and destroyed in the opposite order of creation when the function is exited. We’ll discuss this in more detail in a future lesson, when we talk about the call stack.</p></div><p>Here’s a slightly more complex program demonstrating the lifetime of a variable named <em>x</em>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void doSomething()</code><code>{</code><code>    std::cout &lt;&lt; "Hello!\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x{ 0 }; // x's lifetime begins here</code><code></code><code>    doSomething(); // x is still alive during this function call</code><code></code><code>    return 0;</code><code>} // x's lifetime ends here</code></pre><p>In the above program, x’s lifetime runs from the point of definition to the end of function <em>main</em>. This includes the time spent during the execution of function <em>doSomething</em>.</p><br><h3>Local scope</h3><p>An identifier’s <span class="cpp-definition">scope</span> determines where the identifier can be accessed within the source code. When an identifier can be accessed, we say it is <span class="cpp-definition">in scope</span>. When an identifier can not be accessed, we say it is <span class="cpp-definition">out of scope</span>. Scope is a compile-time property, and trying to use an identifier when it is not in scope will result in a compile error.</p><p>A local variable’s scope begins at the point of variable definition, and stops at the end of the set of curly braces in which it is defined (or for function parameters, at the end of the function). This ensures variables can not be used before the point of definition (even if the compiler opts to create them before then). Local variables defined in one function are also not in scope in other functions that are called.</p><p>Here’s a program demonstrating the scope of a variable named <em>x</em>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// x is not in scope anywhere in this function</code><code>void doSomething()</code><code>{</code><code>    std::cout &lt;&lt; "Hello!\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    // x can not be used here because it's not in scope yet</code><code></code><code>    int x{ 0 }; // x enters scope here and can now be used within this function</code><code></code><code>    doSomething();</code><code></code><code>    return 0;</code><code>} // x goes out of scope here and can no longer be used</code></pre><p>In the above program, variable <em>x</em> enters scope at the point of definition and goes out of scope at the end of the <em>main</em> function. Note that variable <em>x</em> is not in scope anywhere inside of function <em>doSomething()</em>. The fact that function <em>main</em> calls function <em>doSomething</em> is irrelevant in this context.</p><br><h3>“Out of scope” vs “going out of scope”</h3><p>The terms “out of scope” and “going out of scope” can be confusing to new programmers.</p><p>An identifier is “out of scope” anywhere it can not be accessed within the code. In the example above, the identifier <code>x</code> is in-scope from its point of definition to the end of the <code>main()</code> function. The identifier is out-of-scope outside of that code region.</p><p>The term “going out of scope” is typically applied to objects rather than identifiers. We say an object “goes out of scope” at the end of the scope (the end curly brace) in which the object was instantiated. In the example above, the object named <code>x</code> “goes out of scope” at the end of the function <code>main()</code>.</p><p>A local variable’s lifetime ends at the point where it “goes out of scope”, so local variables are destroyed at this point.</p><p>Note that not all types of variables are destroyed when they “go out of scope”. We’ll see examples of these in future lessons.</p><br><h3>Another example</h3><p>Here’s a slightly more complex example. Remember, lifetime is a runtime property, and scope is a compile-time property, so although we are talking about both in the same program, they are enforced at different points.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y) // x and y are created and enter scope here</code><code>{</code><code>    // x and y are visible/usable within this function only</code><code>    return x + y;</code><code>} // y and x go out of scope and are destroyed here</code><code></code><code>int main()</code><code>{</code><code>    int a{ 5 }; // a is created, initialized, and enters scope here</code><code>    int b{ 6 }; // b is created, initialized, and enters scope here</code><code></code><code>    // a and b are usable within this function only</code><code>    std::cout &lt;&lt; add(a, b) &lt;&lt; '\n'; // calls function add() with x=5 and y=6</code><code></code><code>    return 0;</code><code>} // b and a go out of scope and are destroyed here</code></pre><p>Parameters <em>x</em> and <em>y</em> are created when the <em>add</em> function is called, can only be seen/used within function <em>add</em>, and are destroyed at the end of <em>add</em>. Variables <em>a</em> and <em>b</em> are created within function <em>main</em>, can only be seen/used within function <em>main</em>, and are destroyed at the end of <em>main</em>.</p><p>To enhance your understanding of how all this fits together, let’s trace through this program in a little more detail. The following happens, in order:</p><ul><li>execution starts at the top of <em>main</em></li><li><em>main</em>‘s variable <em>a</em> is created and given value <em>5</em></li><li><em>main</em>‘s variable <em>b</em> is created and given value <em>6</em></li><li>function <em>add</em> is called with values <em>5</em> and <em>6</em> for arguments</li><li><em>add</em>‘s variable <em>x</em> is created and initialized with value <em>5</em></li><li><em>add</em>‘s variable <em>y</em> is created and initialized with value <em>6</em></li><li><em>operator+</em> evaluates expression <em>x + y</em> to produce the value <em>11</em></li><li><em>add</em> copies the value <em>11</em> back to caller <em>main</em></li><li><em>add</em>‘s <em>y</em> and <em>x</em> are destroyed</li><li><em>main</em> prints 11 to the console</li><li><em>main</em> returns <em>0</em> to the operating system</li><li><em>main</em>‘s <em>b</em> and <em>a</em> are destroyed</li></ul><p>And we’re done.</p><p>Note that if function <em>add</em> were to be called twice, parameters <em>x</em> and <em>y</em> would be created and destroyed twice -- once for each call. In a program with lots of functions and function calls, variables are created and destroyed often.</p><br><h3>Functional separation</h3><p>In the above example, it’s easy to see that variables <em>a</em> and <em>b</em> are different variables from <em>x</em> and <em>y</em>.</p><p>Now consider the following similar program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y) // add's x and y are created and enter scope here</code><code>{</code><code>    // add's x and y are visible/usable within this function only</code><code>    return x + y;</code><code>} // add's y and x go out of scope and are destroyed here</code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 }; // main's x is created, initialized, and enters scope here</code><code>    int y{ 6 }; // main's y is created, initialized, and enters scope here</code><code></code><code>    // main's x and y are usable within this function only</code><code>    std::cout &lt;&lt; add(x, y) &lt;&lt; '\n'; // calls function add() with x=5 and y=6</code><code></code><code>    return 0;</code><code>} // main's y and x go out of scope and are destroyed here</code></pre><p>In this example, all we’ve done is change the names of variables <em>a</em> and <em>b</em> inside of function <em>main</em> to <em>x</em> and <em>y</em>. This program compiles and runs identically, even though functions <em>main</em> and <em>add</em> both have variables named <em>x</em> and <em>y</em>. Why does this work?</p><p>First, we need to recognize that even though functions <em>main</em> and <em>add</em> both have variables named <em>x</em> and <em>y</em>, these variables are distinct. The <em>x</em> and <em>y</em> in function <em>main</em> have nothing to do with the <em>x</em> and <em>y</em> in function <em>add</em> -- they just happen to share the same names.</p><p>Second, when inside of function <em>main</em>, the names <em>x</em> and <em>y</em> refer to main’s locally scoped variables <em>x</em> and <em>y</em>. Those variables can only be seen (and used) inside of <em>main</em>. Similarly, when inside function <em>add</em>, the names <em>x</em> and <em>y</em> refer to function parameters <em>x</em> and <em>y</em>, which can only be seen (and used) inside of <em>add</em>.</p><p>In short, neither <em>add</em> nor <em>main</em> know that the other function has variables with the same names. Because the scopes don’t overlap, it’s always clear to the compiler which <em>x</em> and <em>y</em> are being referred to at any time.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Names used for function parameters or variables declared in a function body are only visible within the function that declares them. This means local variables within a function can be named without regard for the names of variables in other functions. This helps keep functions independent.</p></div><p>We’ll talk more about local scope, and other kinds of scope, in a future chapter.</p><br><h3>Where to define local variables</h3><p>Local variables inside the function body should be defined as close to their first use as reasonable:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Enter an integer: ";</code><code>	int x{}; // x defined here</code><code>	std::cin &gt;&gt; x; // and used here</code><code></code><code>	std::cout &lt;&lt; "Enter another integer: ";</code><code>	int y{}; // y defined here</code><code>	std::cin &gt;&gt; y; // and used here</code><code></code><code>	int sum{ x + y }; // sum defined here</code><code>	std::cout &lt;&lt; "The sum is: " &lt;&lt; sum &lt;&lt; '\n'; // and used here</code><code></code><code>	return 0;</code><code>}</code></pre><p>In the above example, each variable is defined just before it is first used. There’s no need to be strict about this -- if you prefer to swap lines 5 and 6, that’s fine.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Define your local variables as close to their first use as reasonable.</p></div><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>What does the following program print?</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void doIt(int x)</code><code>{</code><code>    int y{ 4 };</code><code>    std::cout &lt;&lt; "doIt: x = " &lt;&lt; x &lt;&lt; " y = " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>    x = 3;</code><code>    std::cout &lt;&lt; "doIt: x = " &lt;&lt; x &lt;&lt; " y = " &lt;&lt; y &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x{ 1 };</code><code>    int y{ 2 };</code><code></code><code>    std::cout &lt;&lt; "main: x = " &lt;&lt; x &lt;&lt; " y = " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>    doIt(x);</code><code></code><code>    std::cout &lt;&lt; "main: x = " &lt;&lt; x &lt;&lt; " y = " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre>main: x = 1 y = 2
doIt: x = 1 y = 4
doIt: x = 3 y = 4
main: x = 1 y = 2
</pre><p>Here’s what happens in this program:</p><ul><li>execution starts at the top of <em>main</em></li><li><em>main</em>‘s variable <em>x</em> is created and initialized with value <em>1</em></li><li><em>main</em>‘s variable <em>y</em> is created and initialized with value <em>2</em></li><li><em>std::cout</em> prints <em>main: x = 1 y = 2</em></li><li><em>doIt</em> is called with argument <em>1</em></li><li><em>doIt</em>‘s parameter <em>x</em> is created and initialized with value <em>1</em></li><li><em>doIt</em>’s variable <em>y</em> is created and initialized with value <em>4</em></li><li><em>doIt</em> prints <em>doIt: x = 1 y = 4</em></li><li><em>doIt</em>‘s variable <em>x</em> is assigned the new value <em>3</em></li><li><em>std::cout</em> prints <em>doIt: x = 3 y = 4</em></li><li><em>doIt</em>‘s <em>y</em> and <em>x</em> are destroyed</li><li><em>std::cout</em> prints <em>main: x = 1 y = 2</em></li><li><em>main</em> returns <em>0</em> to the operating system</li><li><em>main</em>‘s <em>y</em> and <em>x</em> are destroyed</li></ul><p>Note that even though <em>doIt</em>‘s variables <em>x</em> and <em>y</em> had their values initialized or assigned to something different than <em>main</em>‘s, <em>main</em>‘s <em>x</em> and <em>y</em> were unaffected because they are different variables.</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">2.6 — Why functions are useful, and how to use them effectively</h1></header><div class="entry-content" itemprop="articleBody"><p>Now that we’ve covered what functions are and some of their basic capabilities, let’s take a closer look at why they’re useful.</p><br><h3>Why use functions?</h3><p>New programmers often ask, “Can’t we just put all the code inside the <em>main</em> function?” For simple programs, you absolutely can. However, functions provide a number of benefits that make them extremely useful in programs of non-trivial length or complexity.</p><ul><li><u>Organization</u> -- As programs grow in complexity, having all the code live inside the main() function becomes increasingly complicated. A function is almost like a mini-program that we can write separately from the main program, without having to think about the rest of the program while we write it. This allows us to reduce a complicated program into smaller, more manageable chunks, which reduces the overall complexity of our program.</li><li><u>Reusability</u> -- Once a function is written, it can be called multiple times from within the program. This avoids duplicated code (“Don’t Repeat Yourself”) and minimizes the probability of copy/paste errors. Functions can also be shared with other programs, reducing the amount of code that has to be written from scratch (and retested) each time.</li><li><u>Testing</u> -- Because functions reduce code redundancy, there’s less code to test in the first place. Also because functions are self-contained, once we’ve tested a function to ensure it works, we don’t need to test it again unless we change it. This reduces the amount of code we have to test at one time, making it much easier to find bugs (or avoid them in the first place).</li><li><u>Extensibility</u> -- When we need to extend our program to handle a case it didn’t handle before, functions allow us to make the change in one place and have that change take effect every time the function is called.</li><li><u>Abstraction</u> -- In order to use a function, you only need to know its name, inputs, outputs, and where it lives. You don’t need to know how it works, or what other code it’s dependent upon to use it. This lowers the amount of knowledge required to use other people’s code (including everything in the standard library).</li></ul><p>Although it doesn’t look like it, every time you use operator&lt;&lt; or operator&gt;&gt; to do input or output, you’re using a function provided by the standard library that meets all of the above criteria.</p><p><strong>Effectively using functions</strong></p><p>One of the biggest challenges new programmers encounter (besides learning the language) is understanding when and how to use functions effectively. Here are a few basic guidelines for writing functions:</p><ul><li>Groups of statements that appear more than once in a program should generally be made into a function. For example, if we’re reading input from the user multiple times in the same way, that’s a great candidate for a function. If we output something in the same way in multiple places, that’s also a great candidate for a function.</li><li>Code that has a well-defined set of inputs and outputs is a good candidate for a function, (particularly if it is complicated). For example, if we have a list of items that we want to sort, the code to do the sorting would make a great function, even if it’s only done once. The input is the unsorted list, and the output is the sorted list. Another good prospective function would be code that simulates the roll of a 6-sided dice. Your current program might only use that in one place, but if you turn it into a function, it’s ready to be reused if you later extend your program or in a future program.</li><li>A function should generally perform one (and only one) task.</li><li>When a function becomes too long, too complicated, or hard to understand, it can be split into multiple sub-functions. This is called <span class="cpp-definition">refactoring</span>. We talk more about refactoring in lesson <a href="https://www.learncpp.com/cpp-tutorial/finding-issues-before-they-become-problems/">3.10 -- Finding issues before they become problems</a>.</li></ul><p>Typically, when learning C++, you will write a lot of programs that involve 3 subtasks:</p><ol><li>Reading inputs from the user</li><li>Calculating a value from the inputs</li><li>Printing the calculated value</li></ol><p>For trivial programs (e.g. less than 20 lines of code), some or all of these can be done in function <em>main</em>. However, for longer programs (or just for practice) each of these is a good candidate for an individual function.</p><p>New programmers often combine calculating a value and printing the calculated value into a single function. However, this violates the “one task” rule of thumb for functions. A function that calculates a value should return the value to the caller and let the caller decide what to do with the calculated value (such as call another function to print the value).</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">2.7 — Forward declarations and definitions</h1></header><div class="entry-content" itemprop="articleBody"><p>Take a look at this seemingly innocent sample program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "The sum of 3 and 4 is: " &lt;&lt; add(3, 4) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code><code></code><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code></pre><p>You would expect this program to produce the result:</p><pre>The sum of 3 and 4 is: 7
</pre><p>But in fact, it doesn’t compile at all! Visual Studio produces the following compile error:</p><pre>add.cpp(5) : error C3861: 'add': identifier not found
</pre><p>The reason this program doesn’t compile is because the compiler compiles the contents of code files sequentially. When the compiler reaches the function call to <em>add</em> on line 5 of <em>main</em>, it doesn’t know what <em>add</em> is, because we haven’t defined <em>add</em> until line 9! That produces the error, <em>identifier not found</em>.</p><p>Older versions of Visual Studio would produce an additional error:</p><pre>add.cpp(9) : error C2365: 'add'; : redefinition; previous definition was 'formerly unknown identifier'
</pre><p>This is somewhat misleading, given that <em>add</em> wasn’t ever defined in the first place. Despite this, it’s useful to generally note that it is fairly common for a single error to produce many redundant or related errors or warnings.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>When addressing compile errors in your programs, always resolve the first error produced first and then compile again.</p></div><p>To fix this problem, we need to address the fact that the compiler doesn’t know what add is. There are two common ways to address the issue.</p><br><h3>Option 1: Reorder the function definitions</h3><p>One way to address the issue is to reorder the function definitions so <em>add</em> is defined before <em>main</em>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "The sum of 3 and 4 is: " &lt;&lt; add(3, 4) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>That way, by the time <em>main</em> calls <em>add</em>, the compiler will already know what <em>add</em> is. Because this is such a simple program, this change is relatively easy to do. However, in a larger program, it can be tedious trying to figure out which functions call which other functions (and in what order) so they can be declared sequentially.</p><p>Furthermore, this option is not always possible. Let’s say we’re writing a program that has two functions <em>A</em> and <em>B</em>. If function <em>A</em> calls function <em>B</em>, and function <em>B</em> calls function <em>A</em>, then there’s no way to order the functions in a way that will make the compiler happy. If you define <em>A</em> first, the compiler will complain it doesn’t know what <em>B</em> is. If you define <em>B</em> first, the compiler will complain that it doesn’t know what <em>A</em> is.</p><br><h3>Option 2: Use a forward declaration</h3><p>We can also fix this by using a forward declaration.</p><p>A <span class="cpp-definition">forward declaration</span> allows us to tell the compiler about the existence of an identifier <em>before</em> actually defining the identifier.</p><p>In the case of functions, this allows us to tell the compiler about the existence of a function before we define the function’s body. This way, when the compiler encounters a call to the function, it’ll understand that we’re making a function call, and can check to ensure we’re calling the function correctly, even if it doesn’t yet know how or where the function is defined.</p><p>To write a forward declaration for a function, we use a <span class="cpp-definition">function declaration</span> statement (also called a <span class="cpp-definition">function prototype</span>). The function declaration consists of the function header (the function’s return type, name, and parameter types), terminated with a semicolon. The function body is not included in the declaration.</p><p>Here’s a function declaration for the <em>add</em> function:</p><pre class="language-cpp line-numbers"><code>int add(int x, int y); // function declaration includes return type, name, parameters, and semicolon.  No function body!</code></pre><p>Now, here’s our original program that didn’t compile, using a function declaration as a forward declaration for function <em>add</em>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y); // forward declaration of add() (using a function declaration)</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "The sum of 3 and 4 is: " &lt;&lt; add(3, 4) &lt;&lt; '\n'; // this works because we forward declared add() above</code><code>    return 0;</code><code>}</code><code></code><code>int add(int x, int y) // even though the body of add() isn't defined until here</code><code>{</code><code>    return x + y;</code><code>}</code></pre><p>Now when the compiler reaches the call to <em>add</em> in main, it will know what <em>add</em> looks like (a function that takes two integer parameters and returns an integer), and it won’t complain.</p><p>It is worth noting that function declarations do not need to specify the names of the parameters. In the above code, you can also forward declare your function like this:</p><pre class="language-cpp line-numbers"><code>int add(int, int); // valid function declaration</code></pre><p>However, we prefer to name our parameters (using the same names as the actual function), because it allows you to understand what the function parameters are just by looking at the declaration.<br>Otherwise, you’ll have to locate the function definition.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Keep the parameter names in your function declarations.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>You can easily create function declarations by copy/pasting your function’s header and adding a semicolon.</p></div><br><h3>Forgetting the function body</h3><p>New programmers often wonder what happens if they forward declare a function but do not define it.</p><p>The answer is: it depends. If a forward declaration is made, but the function is never called, the program will compile and run fine. However, if a forward declaration is made and the function is called, but the program never defines the function, the program will compile okay, but the linker will complain that it can’t resolve the function call.</p><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y); // forward declaration of add()</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "The sum of 3 and 4 is: " &lt;&lt; add(3, 4) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code><code></code><code>// note: No definition for function add</code></pre><p>In this program, we forward declare <em>add</em>, and we call <em>add</em>, but we never define <em>add</em> anywhere. When we try and compile this program, Visual Studio produces the following message:</p><pre>Compiling...
add.cpp
Linking...
add.obj : error LNK2001: unresolved external symbol "int __cdecl add(int,int)" (<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5e613f3a3a1e">[email&nbsp;protected]</a>@<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="217860696969617b">[email&nbsp;protected]</a>)
add.exe : fatal error LNK1120: 1 unresolved externals
</pre><p>As you can see, the program compiled okay, but it failed at the link stage because <em>int add(int, int)</em> was never defined.</p><br><h3>Other types of forward declarations</h3><p>Forward declarations are most often used with functions. However, forward declarations can also be used with other identifiers in C++, such as variables and user-defined types. Variables and user-defined types have a different syntax for forward declaration, so we’ll cover these in future lessons.</p><br><h3>Declarations vs. definitions</h3><p>In C++, you’ll frequently hear the words “declaration” and “definition” used, and often interchangeably. What do they mean? You now have enough fundamental knowledge to understand the difference between the two.</p><p>A <span class="cpp-definition">definition</span> actually implements (for functions or types) or instantiates (for variables) the identifier. Here are some examples of definitions:</p><pre class="language-cpp line-numbers"><code>int add(int x, int y) // implements function add()</code><code>{</code><code>    int z{ x + y }; // instantiates variable z</code><code></code><code>    return z;</code><code>}</code></pre><p>A definition is needed to satisfy the <em>linker</em>. If you use an identifier without providing a definition, the linker will error.</p><p>The <span class="cpp-definition">one definition rule</span> (or ODR for short) is a well-known rule in C++. The ODR has three parts:</p><ol><li>Within a given <em>file</em>, a function, variable, type, or template can only have one definition.</li><li>Within a given <em>program</em>, a variable or normal function can only have one definition. This distinction is made because programs can have more than one file (we’ll cover this in the next lesson).</li><li>Types, templates, inline functions, and inline variables are allowed to have identical definitions in different files. We haven’t covered what most of these things are yet, so don’t worry about this for now -- we’ll bring it back up when it’s relevant.</li></ol><p>Violating part 1 of the ODR will cause the compiler to issue a redefinition error. Violating ODR part 2 will likely cause the linker to issue a redefinition error. Violating ODR part 3 will cause undefined behavior.</p><p>Here’s an example of a violation of part 1:</p><pre class="language-cpp line-numbers"><code>int add(int x, int y)</code><code>{</code><code>     return x + y;</code><code>}</code><code></code><code>int add(int x, int y) // violation of ODR, we've already defined function add</code><code>{</code><code>     return x + y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x;</code><code>    int x; // violation of ODR, we've already defined x</code><code>}</code></pre><p>Because the above program violates ODR part 1, this causes the Visual Studio compiler to issue the following compile errors:</p><pre>project3.cpp(9): error C2084: function 'int add(int,int)' already has a body
project3.cpp(3): note: see previous definition of 'add'
project3.cpp(16): error C2086: 'int x': redefinition
project3.cpp(15): note: see declaration of 'x'
</pre><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>Functions that share an identifier but have different parameters are considered to be distinct functions. We discuss this further in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-function-overloading/">8.9 -- Introduction to function overloading</a></p></div><p>A <span class="cpp-definition">declaration</span> is a statement that tells the <em>compiler</em> about the existence of an identifier and its type information. Here are some examples of declarations:</p><pre class="language-cpp line-numbers"><code>int add(int x, int y); // tells the compiler about a function named "add" that takes two int parameters and returns an int.  No body!</code><code>int x; // tells the compiler about an integer variable named x</code></pre><p>A declaration is all that is needed to satisfy the compiler. This is why we can use a forward declaration to tell the compiler about an identifier that isn’t actually defined until later.</p><p>In C++, all definitions also serve as declarations. This is why <em>int x</em> appears in our examples for both definitions and declarations. Since <em>int x</em> is a definition, it’s a declaration too. In most cases, a definition serves our purposes, as it satisfies both the compiler and linker. We only need to provide an explicit declaration when we want to use an identifier before it has been defined.</p><p>While it is true that all definitions are declarations, the converse is not true: not all declarations are definitions. An example of this is the function declaration -- it satisfies the compiler, but not the linker. These declarations that aren’t definitions are called <span class="cpp-definition">pure declarations</span>. Other types of pure declarations include forward declarations for variables and type declarations (you will encounter these in future lessons, no need to worry about them now).</p><p>The ODR doesn’t apply to pure declarations (it’s the <em>one definition rule</em>, not the <em>one declaration rule</em>), so you can have as many pure declarations for an identifier as you desire (although having more than one is redundant).</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>In common language, the term “declaration” is typically used to mean “a pure declaration”, and “definition” is used to mean “a definition that also serves as a declaration”. Thus, we’d typically call <em>int x;</em> a definition, even though it is both a definition and a declaration.</p></div><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>What is a function prototype?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>A function prototype is a declaration statement that includes a function’s name, return type, and parameters. It does not include the function body.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>What is a forward declaration?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>A forward declaration tells the compiler that an identifier exists before it is actually defined.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>How do we declare a forward declaration for functions?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>For functions, a function declaration/prototype serves as a forward declaration.</p><p>Other types of identifiers (e.g. variables and user-defined types) have a different syntax for forward declaration.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #4</p><p>Write the function declaration for this function (use the preferred form with names):</p><pre class="language-cpp line-numbers"><code>int doMath(int first, int second, int third, int fourth)</code><code>{</code><code>     return first + second * third / fourth;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><pre class="language-cpp line-numbers"><code>// Do not forget the semicolon on the end, since these are statements.</code><code>int doMath(int first, int second, int third, int fourth);</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #5</p><p>For each of the following programs, state whether they fail to compile, fail to link, fail both, or compile and link successfully. If you are not sure, try compiling them!</p><p>a)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>int add(int x, int y);</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "3 + 4 + 5 = " &lt;&lt; add(3, 4, 5) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code><code></code><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none">Doesn’t compile. The compiler will complain that the add() called in main() does not have the same number of parameters as the one that was forward declared.</div><p>b)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>int add(int x, int y);</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "3 + 4 + 5 = " &lt;&lt; add(3, 4, 5) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code><code></code><code>int add(int x, int y, int z)</code><code>{</code><code>    return x + y + z;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none">Doesn’t compile. The compiler will complain that it can’t find a matching add() function that takes 3 arguments, because the add() function that was forward declared only takes 2 arguments.</div><p>c)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>int add(int x, int y);</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "3 + 4 = " &lt;&lt; add(3, 4) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code><code></code><code>int add(int x, int y, int z)</code><code>{</code><code>    return x + y + z;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none">Doesn’t link. The compiler will match the forward declaration of add to the function call to add() in main(). However, no add() function that takes two parameters was ever implemented (we only implemented one that took 3 parameters), so the linker will complain.</div><p>d)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>int add(int x, int y, int z);</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "3 + 4 + 5 = " &lt;&lt; add(3, 4, 5) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code><code></code><code>int add(int x, int y, int z)</code><code>{</code><code>    return x + y + z;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_7'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_7" style="display:none">Compiles and links. The function call to add() matches the forward declaration, the implemented function also matches.</div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">2.8 — Programs with multiple code files</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Adding files to your project</h3><p>As programs get larger, it is common to split them into multiple files for organizational or reusability purposes. One advantage of working with an IDE is that they make working with multiple files much easier. You already know how to create and compile single-file projects. Adding new files to existing projects is very easy.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>When you add new code files to your project, give them a .cpp extension.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>In Visual Studio, right click on the <em>Source Files</em> folder (or the project name) in the Solution Explorer window, and choose <em>Add &gt; New Item…</em>.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter2/VS-AddNewItem1.png?ezimgfmt=rs%3Adevice%2Frscb2-1" alt="" ezimgfmt="rs rscb2 src ng ngcb2" loading="eager" srcset="" sizes="" importance="high"></div><p>Make sure you have <em>C++ File (.cpp)</em> selected. Give the new file a name, and it will be added to your project.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter2/VS-AddNewItem2.png?ezimgfmt=rs%3Adevice%2Frscb2-1" alt="" ezimgfmt="rs rscb2 src ng ngcb2" loading="eager" srcset="" sizes="" importance="high"></div><p>Note: If you create a new file from the <em>File menu</em> instead of from your project in the Solution Explorer, the new file won’t be added to your project automatically. You’ll have to add it to the project manually. To do so, right click on <em>Source Files</em> in the <em>Solution Explorer</em>, choose <em>Add &gt; Existing Item</em>, and then select your file.</p><p>Now when you compile your program, you should see the compiler list the name of your file as it compiles it.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>In Code::Blocks, go to the <em>File menu</em> and choose <em>New &gt; File…</em>.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter2/CB-AddNewItem1.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter2/CB-AddNewItem1.png"></div><p>In the <em>New from template</em> dialog, select <em>C/C++ source</em> and click <em>Go</em>.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter2/CB-AddNewItem2.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter2/CB-AddNewItem2.png"></div><p>You may or may not see a <em>welcome to the C/C++ source file wizard</em> dialog at this point. If you do, click <em>Next</em>.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter2/CB-AddNewItem3.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter2/CB-AddNewItem3.png"></div><p>On the next page of the wizard, select “C++” and click <em>Next</em>.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter2/CB-AddNewItem4.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter2/CB-AddNewItem4.png"></div><p>Now give the new file a name (don’t forget the .cpp extension), and click the <em>All</em> button to ensure all build targets are selected. Finally, select <em>finish</em>.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter2/CB-AddNewItem5.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter2/CB-AddNewItem5.png"></div><p>Now when you compile your program, you should see the compiler list the name of your file as it compiles it.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For GCC/G++ users</h4><p>From the command line, you can create the additional file yourself, using your favorite editor, and give it a name. When you compile your program, you’ll need to include all of the relevant code files on the compile line. For example: <em>g++ main.cpp add.cpp -o main</em>, where <em>main.cpp</em> and <em>add.cpp</em> are the names of your code files, and <em>main</em> is the name of the output file.</p></div><br><h3>A multi-file example</h3><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/forward-declarations/">2.7 -- Forward declarations and definitions</a>, we took a look at a single-file program that wouldn’t compile:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "The sum of 3 and 4 is: " &lt;&lt; add(3, 4) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code><code></code><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code></pre><p>When the compiler reaches the function call to <em>add</em> on line 5 of <em>main</em>, it doesn’t know what <em>add</em> is, because we haven’t defined <em>add</em> until line 9! Our solution to this was to either reorder the functions (placing <em>add</em> first) or use a forward declaration for <em>add</em>.</p><p>Now let’s take a look at a similar multi-file program:</p><p>add.cpp:</p><pre class="language-cpp line-numbers"><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "The sum of 3 and 4 is: " &lt;&lt; add(3, 4) &lt;&lt; '\n'; // compile error</code><code>    return 0;</code><code>}</code></pre><p>Your compiler may decide to compile either <em>add.cpp</em> or <em>main.cpp</em> first. Either way, <em>main.cpp</em> will fail to compile, giving the same compiler error as the previous example:</p><pre>main.cpp(5) : error C3861: 'add': identifier not found
</pre><p>The reason is exactly the same as well: when the compiler reaches line 5 of <em>main.cpp</em>, it doesn’t know what identifier <em>add</em> is.</p><p>Remember, the compiler compiles each file individually. It does not know about the contents of other code files, or remember anything it has seen from previously compiled code files. So even though the compiler may have seen the definition of function <em>add</em> previously (if it compiled <em>add.cpp</em> first), it doesn’t remember.</p><p>This limited visibility and short memory is intentional, so that files may have functions or variables that have the same names without conflicting with each other. We’ll explore an example of such a conflict in the next lesson.</p><p>Our options for a solution here are the same as before: place the definition of function <em>add</em> before function <em>main</em>, or satisfy the compiler with a forward declaration. In this case, because function <em>add</em> is in another file, the reordering option isn’t possible.</p><p>The solution here is to use a forward declaration:</p><p>main.cpp (with forward declaration):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y); // needed so main.cpp knows that add() is a function defined elsewhere</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "The sum of 3 and 4 is: " &lt;&lt; add(3, 4) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>add.cpp (stays the same):</p><pre class="language-cpp line-numbers"><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code></pre><p>Now, when the compiler is compiling <em>main.cpp</em>, it will know what identifier <em>add</em> is and be satisfied. The linker will connect the function call to <em>add</em> in <em>main.cpp</em> to the definition of function <em>add</em> in <em>add.cpp</em>.</p><p>Using this method, we can give files access to functions that live in another file.</p><p>Try compiling <em>add.cpp</em> and the <em>main.cpp</em> with the forward declaration for yourself. If you get a linker error, make sure you’ve added <em>add.cpp</em> to your project or compilation line properly.</p><br><h3>Something went wrong!</h3><p>There are plenty of things that can go wrong the first time you try to work with multiple files. If you tried the above example and ran into an error, check the following:</p><ol start="1"><li>If you get a compiler error about <em>add</em> not being defined in <em>main</em>, you probably forgot the forward declaration for function <em>add</em> in <em>main.cpp</em>.</li><li>If you get a linker error about <em>add</em> not being defined, e.g.</li></ol><pre>unresolved external symbol "int __cdecl add(int,int)" (<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6956080d0d29">[email&nbsp;protected]</a>@<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="174e565f5f5f574d">[email&nbsp;protected]</a>) referenced in function _main</pre><p>2a. …the most likely reason is that <em>add.cpp</em> is not added to your project correctly. When you compile, you should see the compiler list both <em>main.cpp</em> and <em>add.cpp</em>. If you only see <em>main.cpp</em>, then <em>add.cpp</em> definitely isn’t getting compiled. If you’re using Visual Studio or Code::Blocks, you should see <em>add.cpp</em> listed in the Solution Explorer/project pane on the left or right side of the IDE. If you don’t, right click on your project, and add the file, then try compiling again. If you’re compiling on the command line, don’t forget to include both <em>main.cpp</em> and <em>add.cpp</em> in your compile command.</p><p>2b. …it’s possible that you added <em>add.cpp</em> to the wrong project.</p><p>2c. …it’s possible that the file is set to not compile or link. Check the file properties and ensure the file is configured to be compiled/linked. In Code::Blocks, compile and link are separate checkboxes that should be checked. In Visual Studio, there’s an “exclude from build” option that should be set to “no” or left blank.</p><ol start="3"><li>Do <em>not</em> <em>#include “add.cpp”</em> from <em>main.cpp</em>. This will cause the preprocessor to insert the contents of <em>add.cpp</em> directly into <em>main.cpp</em> instead of treating them as separate files.</li></ol><br><h3>Summary</h3><p>When the compiler compiles a multi-file program, it may compile the files in any order. Additionally, it compiles each file individually, with no knowledge of what is in other files.</p><p>We will begin working with multiple files a lot once we get into object-oriented programming, so now’s as good a time as any to make sure you understand how to add and compile multiple file projects.</p><p>Reminder: Whenever you create a new code (.cpp) file, you will need to add it to your project so that it gets compiled.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Split the following program into two files (main.cpp, and input.cpp). Main.cpp should have the main function, and input.cpp should have the getInteger function.</p><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">Hint: Don’t forget that you’ll need a forward declaration in main.cpp for function getInteger().</div><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getInteger()</code><code>{</code><code>	std::cout &lt;&lt; "Enter an integer: ";</code><code>	int x{};</code><code>	std::cin &gt;&gt; x;</code><code>	return x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int x{ getInteger() };</code><code>	int y{ getInteger() };</code><code></code><code>	std::cout &lt;&lt; x &lt;&lt; " + " &lt;&lt; y &lt;&lt; " is " &lt;&lt; x + y &lt;&lt; '\n';</code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>input.cpp:</p><pre class="language-cpp line-numbers"><code>#include <iostream> // we need iostream since we use it in this file</iostream></code><code></code><code>int getInteger()</code><code>{</code><code>	std::cout &lt;&lt; "Enter an integer: ";</code><code>	int x{};</code><code>	std::cin &gt;&gt; x;</code><code>	return x;</code><code>}</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include <iostream> // we need iostream here too since we use it in this file as well</iostream></code><code></code><code>int getInteger(); // forward declaration for function getInteger</code><code></code><code>int main()</code><code>{</code><code>	int x{ getInteger() };</code><code>	int y{ getInteger() };</code><code></code><code>	std::cout &lt;&lt; x &lt;&lt; " + " &lt;&lt; y &lt;&lt; " is " &lt;&lt; x + y &lt;&lt; '\n';</code><code>	return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">2.9 — Naming collisions and an introduction to namespaces</h1></header><div class="entry-content" itemprop="articleBody"><p>Let’s say you are driving to a friend’s house for the first time, and the address given to you is 245 Front Street in Mill City. Upon reaching Mill City, you take out your map, only to discover that Mill City actually has two different Front Streets across town from each other! Which one would you go to? Unless there were some additional clue to help you decide (e.g. you remember his house is near the river) you’d have to call your friend and ask for more information. Because this would be confusing and inefficient (particularly for your mailman), in most countries, all street names and house addresses within a city are required to be unique.</p><p>Similarly, C++ requires that all identifiers be non-ambiguous. If two identical identifiers are introduced into the same program in a way that the compiler or linker can’t tell them apart, the compiler or linker will produce an error. This error is generally referred to as a <span class="cpp-definition">naming collision</span> (or <span class="cpp-definition">naming conflict</span>).</p><p>If the colliding identifiers are introduced into the same file, the result will be a compiler error. If the colliding identifiers are introduced into separate files belonging to the same program, the result will be a linker error.</p><br><h3>An example of a naming collision</h3><p>a.cpp:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void myFcn(int x)</code><code>{</code><code>    std::cout &lt;&lt; x;</code><code>}</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void myFcn(int x)</code><code>{</code><code>    std::cout &lt;&lt; 2 * x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    return 0;</code><code>}</code></pre><p>When the compiler compiles this program, it will compile <em>a.cpp</em> and <em>main.cpp</em> independently, and each file will compile with no problems.</p><p>However, when the linker executes, it will link all the definitions in <em>a.cpp</em> and <em>main.cpp</em> together, and discover conflicting definitions for function <em>myFcn</em>. The linker will then abort with an error. Note that this error occurs even though <em>myFcn</em> is never called!</p><p>Most naming collisions occur in two cases:</p><ol start="1"><li>Two (or more) identically named functions (or global variables) are introduced into separate files belonging to the same program. This will result in a linker error, as shown above.</li><li>Two (or more) identically named functions (or global variables) are introduced into the same file. This will result in a compiler error.</li></ol><p>As programs get larger and use more identifiers, the odds of a naming collision being introduced increases significantly. The good news is that C++ provides plenty of mechanisms for avoiding naming collisions. Local scope, which keeps local variables defined inside functions from conflicting with each other, is one such mechanism. But local scope doesn’t work for function names. So how do we keep function names from conflicting with each other?</p><br><h3>What is a namespace?</h3><p>Back to our address analogy for a moment, having two Front Streets was only problematic because those streets existed within the same city. On the other hand, if you had to deliver mail to two addresses, one at 209 Front Street in Mill City, and another address at 417 Front Street in Jonesville, there would be no confusion about where to go. Put another way, cities provide groupings that allow us to disambiguate addresses that might otherwise conflict with each other. Namespaces act like the cities do in this analogy.</p><p>A <span class="cpp-definition">namespace</span> is a region that allows you to declare names inside of it for the purpose of disambiguation. The namespace provides a scope region (called <span class="cpp-definition">namespace scope</span>) to the names declared inside of it -- which simply means that any name declared inside the namespace won’t be mistaken for identical names in other scopes.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>A name declared in a namespace won’t be mistaken for an identical name declared in another scope.</p></div><p>Within a namespace, all names must be unique, otherwise a naming collision will result.</p><p>Namespaces are often used to group related identifiers in a large project to help ensure they don’t inadvertently collide with other identifiers. For example, if you put all your math functions in a namespace called <em>math</em>, then your math functions won’t collide with identically named functions outside the <em>math</em> namespace.</p><p>We’ll talk about how to create your own namespaces in a future lesson.</p><br><h3>The global namespace</h3><p>In C++, any name that is not defined inside a class, function, or a namespace is considered to be part of an implicitly defined namespace called the <span class="cpp-definition">global namespace</span> (sometimes also called <span class="cpp-definition">the global scope</span>).</p><p>In the example at the top of the lesson, functions main() and both versions of myFcn() are defined inside the global namespace. The naming collision encountered in the example happens because both versions of myFcn() end up inside the global namespace, which violates the rule that all names in the namespace must be unique.</p><p>Only declarations and definition statements can appear in the global namespace. This means we can define variables in the global namespace, though this should generally be avoided (we cover global variables in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-global-variables/">6.4 -- Introduction to global variables</a>). This also means that other types of statements (such as expression statements) cannot be placed in the global namespace (initializers for global variables being an exception):</p><pre class="language-cpp line-numbers"><code>#include <iostream> // handled by preprocessor</iostream></code><code></code><code>// All of the following statements are part of the global namespace</code><code>void foo();    // okay: function forward declaration in the global namespace</code><code>int x;         // compiles but strongly discouraged: uninitialized variable definition in the global namespace</code><code>int y { 5 };   // compiles but discouraged: variable definition with initializer in the global namespace</code><code>x = 5;         // compile error: executable statements are not allowed in the global namespace</code><code></code><code>int main()     // okay: function definition in the global namespace</code><code>{</code><code>    return 0;</code><code>}</code><code></code><code>void goo();    // okay: another function forward declaration in the global namespace</code></pre><br><h3>The std namespace</h3><p>When C++ was originally designed, all of the identifiers in the C++ standard library (including std::cin and std::cout) were available to be used without the <em>std::</em> prefix (they were part of the global namespace). However, this meant that any identifier in the standard library could potentially conflict with any name you picked for your own identifiers (also defined in the global namespace). Code that was working might suddenly have a naming conflict when you #included a new file from the standard library. Or worse, programs that would compile under one version of C++ might not compile under a future version of C++, as new identifiers introduced into the standard library could have a naming conflict with already written code. So C++ moved all of the functionality in the standard library into a namespace named “std” (short for standard).</p><p>It turns out that <em>std::cout</em>‘s name isn’t really <em>std::cout</em>. It’s actually just <em>cout</em>, and <em>std</em> is the name of the namespace that identifier <em>cout</em> is part of. Because <em>cout</em> is defined in the <em>std</em> namespace, the name <em>cout</em> won’t conflict with any objects or functions named <em>cout</em> that we create in the global namespace.</p><p>Similarly, when accessing an identifier that is defined in a namespace (e.g. <em>std::cout</em>) , you need to tell the compiler that we’re looking for an identifier defined inside the namespace (<em>std</em>).</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>When you use an identifier that is defined inside a namespace (such as the <em>std</em> namespace), you have to tell the compiler that the identifier lives inside the namespace.</p></div><p>There are a few different ways to do this.</p><br><h3>Explicit namespace qualifier std::</h3><p>The most straightforward way to tell the compiler that we want to use <em>cout</em> from the <em>std</em> namespace is by explicitly using the <em>std::</em> prefix. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Hello world!"; // when we say cout, we mean the cout defined in the std namespace</code><code>    return 0;</code><code>}</code></pre><p>The :: symbol is an operator called the <span class="cpp-definition">scope resolution operator</span>. The identifier to the left of the :: symbol identifies the namespace that the name to the right of the :: symbol is contained within. If no identifier to the left of the :: symbol is provided, the global namespace is assumed.</p><p>So when we say <em>std::cout</em>, we’re saying “the <em>cout</em> that lives in namespace <em>std</em>“.</p><p>This is the safest way to use <em>cout</em>, because there’s no ambiguity about which <em>cout</em> we’re referencing (the one in the <em>std</em> namespace).</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use explicit namespace prefixes to access identifiers defined in a namespace.</p></div><p>When an identifier includes a namespace prefix, the identifier is called a <span class="cpp-definition">qualified name</span>.</p><br><h3>Using namespace std (and why to avoid it)</h3><p>Another way to access identifiers inside a namespace is to use a <em>using directive</em> statement. Here’s our original “Hello world” program with a <em>using directive</em>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>using namespace std; // this is a using directive that allows us to access names in the std namespace with no namespace prefix</code><code></code><code>int main()</code><code>{</code><code>    cout &lt;&lt; "Hello world!";</code><code>    return 0;</code><code>}</code></pre><p>A <span class="cpp-definition">using directive</span> allows us to access the names in a namespace without using a namespace prefix. So in the above example, when the compiler goes to determine what identifier <em>cout</em> is, it will match with <em>std::cout</em>, which, because of the using directive, is accessible as just <em>cout</em>.</p><p>Many texts, tutorials, and even some IDEs recommend or use a using-directive at the top of the program. However, used in this way, this is a bad practice, and highly discouraged.</p><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream> // imports the declaration of std::cout</iostream></code><code></code><code>using namespace std; // makes std::cout accessible as "cout"</code><code> </code><code>int cout() // defines our own "cout" function in the global namespace</code><code>{</code><code>    return 5;</code><code>}</code><code> </code><code>int main()</code><code>{</code><code>    cout &lt;&lt; "Hello, world!"; // Compile error!  Which cout do we want here?  The one in the std namespace or the one we defined above?</code><code> </code><code>    return 0;</code><code>}</code></pre><p>The above program doesn’t compile, because the compiler now can’t tell whether we want the <em>cout</em> function that we defined, or the <em>cout</em> that is defined inside the <em>std</em> namespace.</p><p>When using a using-directive in this manner, <em>any</em> identifier we define may conflict with <em>any</em> identically named identifier in the <em>std</em> namespace. Even worse, while an identifier name may not conflict today, it may conflict with new identifiers added to the std namespace in future language revisions. This was the whole point of moving all of the identifiers in the standard library into the <em>std</em> namespace in the first place!</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Avoid using-directives (such as <em>using namespace std;</em>) at the top of your program or in header files. They violate the reason why namespaces were added in the first place.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We talk more about using-declarations and using-directives (and how to use them responsibly) in lesson <a href="https://www.learncpp.com/cpp-tutorial/using-declarations-and-using-directives/">6.12 -- Using declarations and using directives</a>.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">2.10 — Introduction to the preprocessor</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Translation and the preprocessor</h3><p>When you compile your code, you might expect that the compiler compiles the code exactly as you’ve written it. This actually isn’t the case.</p><p>Prior to compilation, the code file goes through a phase known as <span class="cpp-definition">translation</span>. Many things happen in the translation phase to get your code ready to be compiled (if you’re curious, you can find a list of translation phases <a href="https://en.cppreference.com/w/cpp/language/translation_phases">here</a>). A code file with translations applied to it is called a <span class="cpp-definition">translation unit</span>.</p><p>The most noteworthy of the translation phases involves the preprocessor. The <span class="cpp-definition">preprocessor</span> is best thought of as a separate program that manipulates the text in each code file.</p><p>When the preprocessor runs, it scans through the code file (from top to bottom), looking for preprocessor directives. <span class="cpp-definition">Preprocessor directives</span> (often just called <em>directives</em>) are instructions that start with a <em>#</em> symbol and end with a newline (NOT a semicolon). These directives tell the preprocessor to perform certain text manipulation tasks. Note that the preprocessor does not understand C++ syntax -- instead, the directives have their own syntax (which in some cases resembles C++ syntax, and in other cases, not so much).</p><p>The output of the preprocessor goes through several more translation phases, and then is compiled. Note that the preprocessor does not modify the original code files in any way -- rather, all text changes made by the preprocessor happen either temporarily in-memory or using temporary files each time the code file is compiled.</p><p>In this lesson, we’ll discuss what some of the most common preprocessor directives do.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p><code>Using directives</code> (introduced in lesson <a href="https://www.learncpp.com/cpp-tutorial/naming-collisions-and-an-introduction-to-namespaces/">2.9 -- Naming collisions and an introduction to namespaces</a>) are not preprocessor directives (and thus are not processed by the preprocessor). So while the term <code>directive</code> <em>usually</em> means a <code>preprocessor directive</code>, this is not always the case.</p></div><br><h3>Includes</h3><p>You’ve already seen the <em>#include</em> directive in action (generally to #include &lt;iostream&gt;). When you <em>#include</em> a file, the preprocessor replaces the #include directive with the contents of the included file. The included contents are then preprocessed (along with the rest of the file), and then compiled.</p><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Hello, world!";</code><code>    return 0;</code><code>}</code></pre><p>When the preprocessor runs on this program, the preprocessor will replace <code>#include <iostream></iostream></code> with the preprocessed contents of the file named “iostream”.</p><p>Since <em>#include</em> is almost exclusively used to include header files, we’ll discuss <em>#include</em> in more detail in the next lesson (when we discuss header files in more detail).</p><br><h3>Macro defines</h3><p>The <em>#define</em> directive can be used to create a macro. In C++, a <span class="cpp-definition">macro</span> is a rule that defines how input text is converted into replacement output text.</p><p>There are two basic types of macros: <em>object-like macros</em>, and <em>function-like macros</em>.</p><p><em>Function-like macros</em> act like functions, and serve a similar purpose. We will not discuss them here, because their use is generally considered dangerous, and almost anything they can do can be done by a normal function.</p><p><em>Object-like macros</em> can be defined in one of two ways:</p><pre>#define identifier
#define identifier substitution_text
</pre><p>The top definition has no substitution text, whereas the bottom one does. Because these are preprocessor directives (not statements), note that neither form ends with a semicolon.</p><br><h3>Object-like macros with substitution text</h3><p>When the preprocessor encounters this directive, any further occurrence of the identifier is replaced by <em>substitution_text</em>. The identifier is traditionally typed in all capital letters, using underscores to represent spaces.</p><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>#define MY_NAME "Alex"</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "My name is: " &lt;&lt; MY_NAME;</code><code></code><code>    return 0;</code><code>}</code></pre><p>The preprocessor converts the above into the following:</p><pre class="language-cpp line-numbers"><code>// The contents of iostream are inserted here</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "My name is: " &lt;&lt; "Alex";</code><code></code><code>    return 0;</code><code>}</code></pre><p>Which, when run, prints the output <code>My name is: Alex</code>.</p><p>Object-like macros with substitution text were used (in C) as a way to assign names to literals. This is no longer necessary, as better methods are available in C++. Object-like macros with substitution text should generally now only be seen in legacy code.</p><p>We recommend avoiding these kinds of macros altogether, as there are better ways to do this kind of thing. We discuss this more in lesson <a href="https://www.learncpp.com/cpp-tutorial/const-variables-and-symbolic-constants/">4.13 -- Const variables and symbolic constants</a>.</p><br><h3>Object-like macros without substitution text</h3><p><em>Object-like macros</em> can also be defined without substitution text.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#define USE_YEN</code></pre><p>Macros of this form work like you might expect: any further occurrence of the identifier is removed and replaced by nothing!</p><p>This might seem pretty useless, and it <em>is useless</em> for doing text substitution. However, that’s not what this form of the directive is generally used for. We’ll discuss the uses of this form in just a moment.</p><p>Unlike object-like macros with substitution text, macros of this form are generally considered acceptable to use.</p><br><h3>Conditional compilation</h3><p>The <em>conditional compilation</em> preprocessor directives allow you to specify under what conditions something will or won’t compile. There are quite a few different conditional compilation directives, but we’ll only cover the three that are used by far the most here: <em>#ifdef</em>, <em>#ifndef</em>, and <em>#endif</em>.</p><p>The <em>#ifdef</em> preprocessor directive allows the preprocessor to check whether an identifier has been previously <em>#define</em>d. If so, the code between the <em>#ifdef</em> and matching <em>#endif</em> is compiled. If not, the code is ignored.</p><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>#define PRINT_JOE</code><code></code><code>int main()</code><code>{</code><code>#ifdef PRINT_JOE</code><code>    std::cout &lt;&lt; "Joe\n"; // will be compiled since PRINT_JOE is defined</code><code>#endif</code><code></code><code>#ifdef PRINT_BOB</code><code>    std::cout &lt;&lt; "Bob\n"; // will be ignored since PRINT_BOB is not defined</code><code>#endif</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because PRINT_JOE has been #defined, the line <code>std::cout &lt;&lt; "Joe\n"</code> will be compiled. Because PRINT_BOB has not been #defined, the line <code>std::cout &lt;&lt; "Bob\n"</code> will be ignored.</p><p><em>#ifndef</em> is the opposite of <em>#ifdef</em>, in that it allows you to check whether an identifier has <em>NOT</em> been <em>#define</em>d yet.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>#ifndef PRINT_BOB</code><code>    std::cout &lt;&lt; "Bob\n";</code><code>#endif</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints “Bob”, because PRINT_BOB was never <em>#define</em>d.</p><p>In place of <code>#ifdef PRINT_BOB</code> and <code>#ifndef PRINT_BOB</code>, you’ll also see <code>#if defined(PRINT_BOB)</code> and <code>#if !defined(PRINT_BOB)</code>. These do the same, but use a slightly more C++-style syntax.</p><br><h3>#if 0 </h3><p>One more common use of conditional compilation involves using <em>#if 0</em> to exclude a block of code from being compiled (as if it were inside a comment block):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Joe\n";</code><code></code><code>#if 0 // Don't compile anything starting here</code><code>    std::cout &lt;&lt; "Bob\n";</code><code>    std::cout &lt;&lt; "Steve\n";</code><code>#endif // until this point</code><code></code><code>    return 0;</code><code>}</code></pre><p>The above code only prints “Joe”, because “Bob” and “Steve” were inside an <em>#if 0</em> block that the preprocessor will exclude from compilation.</p><p>This also provides a convenient way to “comment out” code that contains multi-line comments (which can’t be commented out using another multi-line comment due to multi-line comments being non-nestable):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Joe\n";</code><code></code><code>#if 0 // Don't compile anything starting here</code><code>    std::cout &lt;&lt; "Bob\n";</code><code>    /* Some</code><code>     * multi-line</code><code>     * comment here</code><code>     */</code><code>    std::cout &lt;&lt; "Steve\n";</code><code>#endif // until this point</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>Object-like macros don’t affect other preprocessor directives</h3><p>Now you might be wondering:</p><pre class="language-cpp line-numbers"><code>#define PRINT_JOE</code><code></code><code>#ifdef PRINT_JOE</code><code>// ...</code></pre><p>Since we defined <em>PRINT_JOE</em> to be nothing, how come the preprocessor didn’t replace <em>PRINT_JOE</em> in <em>#ifdef PRINT_JOE</em> with nothing?</p><p>Macros only cause text substitution for normal code. Other preprocessor commands are ignored. Consequently, the <em>PRINT_JOE</em> in <em>#ifdef PRINT_JOE</em> is left alone.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#define FOO 9 // Here's a macro substitution</code><code></code><code>#ifdef FOO // This FOO does not get replaced because it’s part of another preprocessor directive</code><code>    std::cout &lt;&lt; FOO; // This FOO gets replaced with 9 because it's part of the normal code</code><code>#endif</code></pre><p>In actuality, the output of the preprocessor contains no directives at all -- they are all resolved/stripped out before compilation, because the compiler wouldn’t know what to do with them.</p><br><h3>The scope of defines</h3><p>Directives are resolved before compilation, from top to bottom on a file-by-file basis.</p><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void foo()</code><code>{</code><code>#define MY_NAME "Alex"</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "My name is: " &lt;&lt; MY_NAME;</code><code></code><code>	return 0;</code><code>}</code></pre><p>Even though it looks like <em>#define MY_NAME “Alex”</em> is defined inside function <em>foo</em>, the preprocessor won’t notice, as it doesn’t understand C++ concepts like functions. Therefore, this program behaves identically to one where <em>#define MY_NAME “Alex”</em> was defined either before or immediately after function <em>foo</em>. For general readability, you’ll generally want to #define identifiers outside of functions.</p><p>Once the preprocessor has finished, all defined identifiers from that file are discarded. This means that directives are only valid from the point of definition to the end of the file in which they are defined. Directives defined in one code file do not have impact on other code files in the same project.</p><p>Consider the following example:</p><p>function.cpp:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void doSomething()</code><code>{</code><code>#ifdef PRINT</code><code>    std::cout &lt;&lt; "Printing!";</code><code>#endif</code><code>#ifndef PRINT</code><code>    std::cout &lt;&lt; "Not printing!";</code><code>#endif</code><code>}</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>void doSomething(); // forward declaration for function doSomething()</code><code></code><code>#define PRINT</code><code></code><code>int main()</code><code>{</code><code>    doSomething();</code><code></code><code>    return 0;</code><code>}</code></pre><p>The above program will print:</p><pre>Not printing!
</pre><p>Even though PRINT was defined in <em>main.cpp</em>, that doesn’t have any impact on any of the code in <em>function.cpp</em> (PRINT is only #defined from the point of definition to the end of main.cpp). This will be of consequence when we discuss header guards in a future lesson.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">2.11 — Header files</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Headers, and their purpose</h3><p>As programs grow larger (and make use of more files), it becomes increasingly tedious to have to forward declare every function you want to use that is defined in a different file. Wouldn’t it be nice if you could put all your forward declarations in one place and then import them when you need them?</p><p>C++ code files (with a .cpp extension) are not the only files commonly seen in C++ programs. The other type of file is called a <span class="cpp-definition">header file</span>. Header files usually have a .h extension, but you will occasionally see them with a .hpp extension or no extension at all. The primary purpose of a header file is to propagate declarations to code files.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Header files allow us to put declarations in one location and then import them wherever we need them. This can save a lot of typing in multi-file programs.</p></div><br><h3>Using standard library header files</h3><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Hello, world!";</code><code>    return 0;</code><code>}</code></pre><p>This program prints “Hello, world!” to the console using <em>std::cout</em>. However, this program never provided a definition or declaration for <em>std::cout</em>, so how does the compiler know what <em>std::cout</em> is?</p><p>The answer is that <em>std::cout</em> has been forward declared in the “iostream” header file. When we <code>#include <iostream></iostream></code>, we’re requesting that the preprocessor copy all of the content (including forward declarations for std::cout) from the file named “iostream” into the file doing the #include.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>When you #include a file, the content of the included file is inserted at the point of inclusion. This provides a useful way to pull in declarations from another file.</p></div><p>Consider what would happen if the <em>iostream</em> header did not exist. Wherever you used <em>std::cout</em>, you would have to manually type or copy in all of the declarations related to <em>std::cout</em> into the top of each file that used <em>std::cout</em>! This would require a lot of knowledge about how <em>std::cout</em> was declared, and would be a ton of work. Even worse, if a function prototype was added or changed, we’d have to go manually update all of the forward declarations. It’s much easier to just <code>#include <iostream></iostream></code>!</p><p>When it comes to functions and variables, it’s worth keeping in mind that header files typically only contain function and variable declarations, not function and variable definitions (otherwise a violation of the <em>one definition rule</em> could result). <em>std::cout</em> is forward declared in the iostream header, but defined as part of the C++ standard library, which is automatically linked into your program during the linker phase.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Section1/IncludeLibrary.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Section1/IncludeLibrary.png"></div><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Header files should generally not contain function and variable definitions, so as not to violate the one definition rule. An exception is made for symbolic constants (which we cover in lesson <a href="https://www.learncpp.com/cpp-tutorial/const-variables-and-symbolic-constants/">4.13 -- Const variables and symbolic constants</a>).</p></div><br><h3>Writing your own header files</h3><p>Now let’s go back to the example we were discussing in a previous lesson. When we left off, we had two files, <em>add.cpp</em> and <em>main.cpp</em>, that looked like this:</p><p>add.cpp:</p><pre class="language-cpp line-numbers"><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y); // forward declaration using function prototype</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "The sum of 3 and 4 is " &lt;&lt; add(3, 4) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>(If you’re recreating this example from scratch, don’t forget to add <em>add.cpp</em> to your project so it gets compiled in).</p><p>In this example, we used a forward declaration so that the compiler will know what identifier <em>add</em> is when compiling <em>main.cpp</em>. As previously mentioned, manually adding forward declarations for every function you want to use that lives in another file can get tedious quickly.</p><p>Let’s write a header file to relieve us of this burden. Writing a header file is surprisingly easy, as header files only consist of two parts:</p><ol><li>A <em>header guard</em>, which we’ll discuss in more detail in the next lesson (<a href="https://www.learncpp.com/cpp-tutorial/header-guards/">2.12 -- Header guards</a>).</li><li>The actual content of the header file, which should be the forward declarations for all of the identifiers we want other files to be able to see.</li></ol><p>Adding a header file to a project works analogously to adding a source file (covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/programs-with-multiple-code-files/">2.8 -- Programs with multiple code files</a>). If using an IDE, go through the same steps and choose “Header” instead of “Source” when asked. If using the command line, just create a new file in your favorite editor.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use a .h suffix when naming your header files.</p></div><p>Header files are often paired with code files, with the header file providing forward declarations for the corresponding code file. Since our header file will contain a forward declaration for functions defined in <em>add.cpp</em>, we’ll call our new header file <em>add.h</em>.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>If a header file is paired with a code file (e.g. add.h with add.cpp), they should both have the same base name (add).</p></div><p>Here’s our completed header file:</p><p>add.h:</p><pre class="language-cpp line-numbers"><code>// 1) We really should have a header guard here, but will omit it for simplicity (we'll cover header guards in the next lesson)</code><code></code><code>// 2) This is the content of the .h file, which is where the declarations go</code><code>int add(int x, int y); // function prototype for add.h -- don't forget the semicolon!</code></pre><p>In order to use this header file in main.cpp, we have to #include it (using quotes, not angle brackets).</p><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include "add.h" // Insert contents of add.h at this point.  Note use of double quotes here.</code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "The sum of 3 and 4 is " &lt;&lt; add(3, 4) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>add.cpp:</p><pre class="language-cpp line-numbers"><code>#include "add.h" // Insert contents of add.h at this point.  Note use of double quotes here.</code><code></code><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code></pre><p>When the preprocessor processes the <code>#include "add.h"</code> line, it copies the contents of add.h into the current file at that point. Because our <em>add.h</em> contains a forward declaration for function <em>add</em>, that forward declaration will be copied into <em>main.cpp</em>. The end result is a program that is functionally the same as the one where we manually added the forward declaration at the top of <em>main.cpp</em>.</p><p>Consequently, our program will compile and link correctly.</p><p><img src="https://www.learncpp.com/images/CppTutorial/Section1/IncludeHeader.png" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Section1/IncludeHeader.png"></p><br><h3>Source files should include their paired header </h3><p>In C++, it is a best practice for code files to #include their paired header file (if one exists). In the example above, <em>add.cpp</em> includes <em>add.h</em>.</p><p>This allows the compiler to catch certain kinds of errors at compile time instead of link time. For example:</p><p>something.h:</p><pre class="language-cpp line-numbers"><code>int something(int); // return type of forward declaration is int</code></pre><p>something.cpp:</p><pre class="language-cpp line-numbers"><code>#include "something.h"</code><code></code><code>void something(int) // error: wrong return type</code><code>{</code><code>}</code></pre><p>Because <em>something.cpp</em> #includes <em>something.h</em>, the compiler will notice that function <em>something()</em> has a mismatched return type and give us a compile error. If <em>something.cpp</em> did not #include <em>something.h</em>, we’d have to wait until the linker discovered the discrepancy, which wastes time. For another example, see <a href="https://www.learncpp.com/cpp-tutorial/header-files/comment-page-8/#comment-398571">this comment</a>.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Source files should #include their paired header file (if one exists).</p></div><br><h3>Troubleshooting</h3><p>If you get a compiler error indicating that <em>add.h</em> isn’t found, make sure the file is really named <em>add.h</em>. Depending on how you created and named it, it’s possible the file could have been named something like <em>add</em> (no extension) or <em>add.h.txt</em> or <em>add.hpp</em>. Also make sure it’s sitting in the same directory as the rest of your code files.</p><p>If you get a linker error about function <em>add</em> not being defined, make sure you’ve added <em>add.cpp</em> in your project so the definition for function <em>add</em> can be linked into the program.</p><br><h3>Angled brackets vs double quotes </h3><p>You’re probably curious why we use angled brackets for <code>iostream</code>, and double quotes for <code>add.h</code>. It’s possible that a header file with the same filename might exist in multiple directories. Our use of angled brackets vs double quotes helps give the preprocessor a clue as to where it should look for header files.</p><p>When we use angled brackets, we’re telling the preprocessor that this is a header file we didn’t write ourselves. The preprocessor will search for the header only in the directories specified by the <code>include directories</code>. The <code>include directories</code> are configured as part of your project/IDE settings/compiler settings, and typically default to the directories containing the header files that come with your compiler and/or OS. The preprocessor will not search for the header file in your project’s source code directory.</p><p>When we use double-quotes, we’re telling the preprocessor that this is a header file that we wrote. The preprocessor will first search for the header file in the current directory. If it can’t find a matching header there, it will then search the <code>include directories</code>.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Rule</h4><p>Use double quotes to include header files that you’ve written or are expected to be found in the current directory. Use angled brackets to include headers that come with your compiler, OS, or third-party libraries you’ve installed elsewhere on your system.</p></div><br><h3>Why doesn’t iostream have a .h extension?</h3><p>Another commonly asked question is “why doesn’t iostream (or any of the other standard library header files) have a .h extension?”. The answer is that <em>iostream.h</em> is a different header file than <em>iostream</em>! To explain requires a short history lesson.</p><p>When C++ was first created, all of the files in the standard library ended in a <em>.h</em> suffix. Life was consistent, and it was good. The original version of <em>cout</em> and <em>cin</em> were declared in <em>iostream.h</em>. When the language was standardized by the ANSI committee, they decided to move all of the names used in the standard library into the <em>std</em> namespace to help avoid naming conflicts with user-defined identifiers. However, this presented a problem: if they moved all the names into the <em>std</em> namespace, none of the old programs (that included iostream.h) would work anymore!</p><p>To work around this issue, a new set of header files was introduced that lack the <em>.h</em> extension. These new header files define all names inside the <em>std</em> namespace. This way, older programs that include <code>#include <iostream.h></iostream.h></code> do not need to be rewritten, and newer programs can <code>#include <iostream></iostream></code>.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>The header files with the *.h* extension define their names in the global namespace, and may optionally define them in the <em>std</em> namespace as well.</p><p>The header files without the *.h* extension will define their names in the <em>std</em> namespace, and may optionally define them in the global namespace as well.</p></div><p>In addition, many of the libraries inherited from C that are still useful in C++ were given a <em>c</em> prefix (e.g. <em>stdlib.h</em> became <em>cstdlib</em>). The functionality from these libraries was also moved into the <em>std</em> namespace to help avoid naming collisions.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>When including a header file from the standard library, use the version without the .h extension if it exists. User-defined headers should still use a .h extension.</p></div><br><h3>Including header files from other directories</h3><p>Another common question involves how to include header files from other directories.</p><p>One (bad) way to do this is to include a relative path to the header file you want to include as part of the #include line. For example:</p><pre class="language-cpp line-numbers"><code>#include "headers/myHeader.h"</code><code>#include "../moreHeaders/myOtherHeader.h"</code></pre><p>While this will compile (assuming the files exist in those relative directories), the downside of this approach is that it requires you to reflect your directory structure in your code. If you ever update your directory structure, your code won’t work anymore.</p><p>A better method is to tell your compiler or IDE that you have a bunch of header files in some other location, so that it will look there when it can’t find them in the current directory. This can generally be done by setting an <em>include path</em> or <em>search directory</em> in your IDE project settings.</p><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>Right click on your project in the <em>Solution Explorer</em>, and choose <em>Properties</em>, then the <em>VC++ Directories</em> tab. From here, you will see a line called <em>Include Directories</em>. Add the directories you’d like the compiler to search for additional headers there.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>In Code::Blocks, go to the <em>Project</em> menu and select <em>Build Options</em>, then the <em>Search directories</em> tab. Add the directories you’d like the compiler to search for additional headers there.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For GCC/G++ users</h4><p>Using g++, you can use the -I option to specify an alternate include directory.</p><pre class="language-cpp line-numbers"><code>g++ -o main -I/source/includes main.cpp</code></pre></div><p>The nice thing about this approach is that if you ever change your directory structure, you only have to change a single compiler or IDE setting instead of every code file.</p><br><h3>Headers may include other headers </h3><p>It’s common that a header file will need a declaration or definition that lives in a different header file. Because of this, header files will often #include other header files.</p><p>When your code file #includes the first header file, you’ll also get any other header files that the first header file includes (and any header files those include, and so on). These additional header files are sometimes called <span class="cpp-definition">transitive includes</span>, as they’re included implicitly rather than explicitly.</p><p>The content of these transitive includes are available for use in your code file. However, you should not rely on the content of headers that are included transitively. The implementation of header files may change over time, or be different across different systems. If that happens, your code may only compile on certain systems, or may compile now but not in the future. This is easily avoided by explicitly including all of the header files the content of your code file requires.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Each file should explicitly #include all of the header files it needs to compile. Do not rely on headers included transitively from other headers.</p></div><p>Unfortunately, there is no easy way to detect when your code file is accidentally relying on content of a header file that has been included by another header file.</p><div class="cpp-note cpp-lightbluebackground"><h4>Q: I didn’t include <someheader> and my program worked anyway! Why?</someheader></h4><div id="missing_include_but_works"></div><p>This is one of the most commonly asked questions on this site. The answer is: it’s likely working, because you included some other header (e.g. &lt;iostream&gt;), which itself included &lt;someheader&gt;. Although your program will compile, per the best practice above, you should not rely on this. What compiles for you might not compile on a friend’s machine.</p></div><br><h3>The #include order of header files</h3><p>If your header files are written properly and #include everything they need, the order of inclusion shouldn’t matter.</p><p>Now consider the following scenario: let’s say header A needs declarations from header B, but forgets to include it. In our code file, if we include header B before header A, our code will still compile! This is because the compiler will compile all the declarations from B before it compiles the code from A that depends on those declarations.</p><p>However, if we include header A first, then the compiler will complain because the code from A will be compiled before the compiler has seen the declarations from B. This is actually preferable, because the error has been surfaced, and we can then fix it.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>To maximize the chance that missing includes will be flagged by compiler, order your #includes as follows:</p><ol><li>The paired header file</li><li>Other headers from your project</li><li>3rd party library headers</li><li>Standard library headers</li></ol><p>The headers for each grouping should be sorted alphabetically.</p></div><p>That way, if one of your user-defined headers is missing an #include for a 3rd party library or standard library header, it’s more likely to cause a compile error so you can fix it.</p><br><h3>Header file best practices</h3><p>Here are a few more recommendations for creating and using header files.</p><ul><li>Always include header guards (we’ll cover these next lesson).</li><li>Do not define variables and functions in header files (global constants are an exception -- we’ll cover these later)</li><li>Give a header file the same name as the source file it’s associated with (e.g. <em>grades.h</em> is paired with <em>grades.cpp</em>).</li><li>Each header file should have a specific job, and be as independent as possible. For example, you might put all your declarations related to functionality A in A.h and all your declarations related to functionality B in B.h. That way if you only care about A later, you can just include A.h and not get any of the stuff related to B.</li><li>Be mindful of which headers you need to explicitly include for the functionality that you are using in your code files</li><li>Every header you write should compile on its own (it should #include every dependency it needs)</li><li>Only #include what you need (don’t include everything just because you can).</li><li>Do not #include .cpp files.</li></ul></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">2.12 — Header guards</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>The duplicate definition problem</h3><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/forward-declarations/">2.7 -- Forward declarations and definitions</a>, we noted that a variable or function identifier can only have one definition (the one definition rule). Thus, a program that defines a variable identifier more than once will cause a compile error:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int x; // this is a definition for variable x</code><code>    int x; // compile error: duplicate definition</code><code></code><code>    return 0;</code><code>}</code></pre><p>Similarly, programs that define a function more than once will also cause a compile error:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int foo() // this is a definition for function foo</code><code>{</code><code>    return 5;</code><code>}</code><code></code><code>int foo() // compile error: duplicate definition</code><code>{</code><code>    return 5;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; foo();</code><code>    return 0;</code><code>}</code></pre><p>While these programs are easy to fix (remove the duplicate definition), with header files, it’s quite easy to end up in a situation where a definition in a header file gets included more than once. This can happen when a header file #includes another header file (which is common).</p><p>Consider the following academic example:</p><p>square.h:</p><pre class="language-cpp line-numbers"><code>// We shouldn't be including function definitions in header files</code><code>// But for the sake of this example, we will</code><code>int getSquareSides()</code><code>{</code><code>    return 4;</code><code>}</code></pre><p>geometry.h:</p><pre class="language-cpp line-numbers"><code>#include "square.h"</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include "square.h"</code><code>#include "geometry.h"</code><code></code><code>int main()</code><code>{</code><code>    return 0;</code><code>}</code></pre><p>This seemingly innocent looking program won’t compile! Here’s what’s happening. First, <em>main.cpp</em> #includes <em>square.h</em>, which copies the definition for function <em>getSquareSides</em> into <em>main.cpp</em>. Then <em>main.cpp</em> #includes <em>geometry.h</em>, which #includes <em>square.h</em> itself. This copies contents of <em>square.h</em> (including the definition for function <em>getSquareSides</em>) into <em>geometry.h</em>, which then gets copied into <em>main.cpp</em>.</p><p>Thus, after resolving all of the #includes, <em>main.cpp</em> ends up looking like this:</p><pre class="language-cpp line-numbers"><code>int getSquareSides()  // from square.h</code><code>{</code><code>    return 4;</code><code>}</code><code></code><code>int getSquareSides() // from geometry.h (via square.h)</code><code>{</code><code>    return 4;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    return 0;</code><code>}</code></pre><p>Duplicate definitions and a compile error. Each file, individually, is fine. However, because <em>main.cpp</em> ends up #including the content of <em>square.h</em> twice, we’ve run into problems. If <em>geometry.h</em> needs <em>getSquareSides()</em>, and <em>main.cpp</em> needs both <em>geometry.h</em> and <em>square.h</em>, how would you resolve this issue?</p><br><h3>Header guards</h3><p>The good news is that we can avoid the above problem via a mechanism called a <strong>header guard</strong> (also called an <strong>include guard</strong>). Header guards are conditional compilation directives that take the following form:</p><pre class="language-cpp line-numbers"><code>#ifndef SOME_UNIQUE_NAME_HERE</code><code>#define SOME_UNIQUE_NAME_HERE</code><code></code><code>// your declarations (and certain types of definitions) here</code><code></code><code>#endif</code></pre><p>When this header is #included, the preprocessor checks whether <em>SOME_UNIQUE_NAME_HERE</em> has been previously defined. If this is the first time we’re including the header, <em>SOME_UNIQUE_NAME_HERE</em> will not have been defined. Consequently, it #defines <em>SOME_UNIQUE_NAME_HERE</em> and includes the contents of the file. If the header is included again into the same file, <em>SOME_UNIQUE_NAME_HERE</em> will already have been defined from the first time the contents of the header were included, and the contents of the header will be ignored (thanks to the #ifndef).</p><p>All of your header files should have header guards on them. <em>SOME_UNIQUE_NAME_HERE</em> can be any name you want, but by convention is set to the full filename of the header file, typed in all caps, using underscores for spaces or punctuation. For example, <em>square.h</em> would have the header guard:</p><p>square.h:</p><pre class="language-cpp line-numbers"><code>#ifndef SQUARE_H</code><code>#define SQUARE_H</code><code></code><code>int getSquareSides()</code><code>{</code><code>    return 4;</code><code>}</code><code></code><code>#endif</code></pre><p>Even the standard library headers use header guards. If you were to take a look at the iostream header file from Visual Studio, you would see:</p><pre class="language-cpp line-numbers"><code>#ifndef _IOSTREAM_</code><code>#define _IOSTREAM_</code><code></code><code>// content here</code><code></code><code>#endif</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>In large programs, it’s possible to have two separate header files (included from different directories) that end up having the same filename (e.g. directoryA\config.h and directoryB\config.h). If only the filename is used for the include guard (e.g. CONFIG_H), these two files may end up using the same guard name. If that happens, any file that includes (directly or indirectly) both config.h files will not receive the contents of the include file to be included second. This will probably cause a compilation error.</p><p>Because of this possibility for guard name conflicts, many developers recommend using a more complex/unique name in your header guards. Some good suggestions are a naming convention of &lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H , &lt;FILE&gt;_&lt;LARGE RANDOM NUMBER&gt;_H, or &lt;FILE&gt;_&lt;CREATION DATE&gt;_H</p></div><br><h3>Updating our previous example with header guards</h3><p>Let’s return to the <em>square.h</em> example, using the <em>square.h</em> with header guards. For good form, we’ll also add header guards to <em>geometry.h</em>.</p><p>square.h</p><pre class="language-cpp line-numbers"><code>#ifndef SQUARE_H</code><code>#define SQUARE_H</code><code></code><code>int getSquareSides()</code><code>{</code><code>    return 4;</code><code>}</code><code></code><code>#endif</code></pre><p>geometry.h:</p><pre class="language-cpp line-numbers"><code>#ifndef GEOMETRY_H</code><code>#define GEOMETRY_H</code><code></code><code>#include "square.h"</code><code></code><code>#endif</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include "square.h"</code><code>#include "geometry.h"</code><code></code><code>int main()</code><code>{</code><code>    return 0;</code><code>}</code></pre><p>After the preprocessor resolves all of the #include directives, this program looks like this:</p><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>// Square.h included from main.cpp</code><code>#ifndef SQUARE_H // square.h included from main.cpp</code><code>#define SQUARE_H // SQUARE_H gets defined here</code><code></code><code>// and all this content gets included</code><code>int getSquareSides()</code><code>{</code><code>    return 4;</code><code>}</code><code></code><code>#endif // SQUARE_H</code><code></code><code>#ifndef GEOMETRY_H // geometry.h included from main.cpp</code><code>#define GEOMETRY_H</code><code>#ifndef SQUARE_H // square.h included from geometry.h, SQUARE_H is already defined from above</code><code>#define SQUARE_H // so none of this content gets included</code><code></code><code>int getSquareSides()</code><code>{</code><code>    return 4;</code><code>}</code><code></code><code>#endif // SQUARE_H</code><code>#endif // GEOMETRY_H</code><code></code><code>int main()</code><code>{</code><code>    return 0;</code><code>}</code></pre><p>As you can see from the example, the second inclusion of the contents of <em>square.h</em> (from <em>geometry.h</em>) gets ignored because <em>SQUARE_H</em> was already defined from the first inclusion. Therefore, function <em>getSquareSides</em> only gets included once.</p><br><h3>Header guards do not prevent a header from being included once into different code files</h3><p>Note that the goal of header guards is to prevent a code file from receiving more than one copy of a guarded header. By design, header guards do <em>not</em> prevent a given header file from being included (once) into separate code files. This can also cause unexpected problems. Consider:</p><p>square.h:</p><pre class="language-cpp line-numbers"><code>#ifndef SQUARE_H</code><code>#define SQUARE_H</code><code></code><code>int getSquareSides()</code><code>{</code><code>    return 4;</code><code>}</code><code></code><code>int getSquarePerimeter(int sideLength); // forward declaration for getSquarePerimeter</code><code></code><code>#endif</code></pre><p>square.cpp:</p><pre class="language-cpp line-numbers"><code>#include "square.h"  // square.h is included once here</code><code></code><code>int getSquarePerimeter(int sideLength)</code><code>{</code><code>    return sideLength * getSquareSides();</code><code>}</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include "square.h" // square.h is also included once here</code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "a square has " &lt;&lt; getSquareSides() &lt;&lt; " sides\n";</code><code>    std::cout &lt;&lt; "a square of length 5 has perimeter length " &lt;&lt; getSquarePerimeter(5) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note that <em>square.h</em> is included from both <em>main.cpp</em> and <em>square.cpp</em>. This means the contents of <em>square.h</em> will be included once into <em>square.cpp</em> and once into <em>main.cpp</em>.</p><p>Let’s examine why this happens in more detail. When <em>square.h</em> is included from <em>square.cpp</em>, <em>SQUARE_H</em> is defined until the end of <em>square.cpp</em>. This define prevents <em>square.h</em> from being included into <em>square.cpp</em> a second time (which is the point of header guards). However, once <em>square.cpp</em> is finished, <em>SQUARE_H</em> is no longer considered defined. This means that when the preprocessor runs on <em>main.cpp</em>, <em>SQUARE_H</em> is not initially defined in <em>main.cpp</em>.</p><p>The end result is that both <em>square.cpp</em> and <em>main.cpp</em> get a copy of the definition of <em>getSquareSides</em>. This program will compile, but the linker will complain about your program having multiple definitions for identifier <em>getSquareSides</em>!</p><p>The best way to work around this issue is simply to put the function definition in one of the .cpp files so that the header just contains a forward declaration:</p><p>square.h:</p><pre class="language-cpp line-numbers"><code>#ifndef SQUARE_H</code><code>#define SQUARE_H</code><code></code><code>int getSquareSides(); // forward declaration for getSquareSides</code><code>int getSquarePerimeter(int sideLength); // forward declaration for getSquarePerimeter</code><code></code><code>#endif</code></pre><p>square.cpp:</p><pre class="language-cpp line-numbers"><code>#include "square.h"</code><code></code><code>int getSquareSides() // actual definition for getSquareSides</code><code>{</code><code>    return 4;</code><code>}</code><code></code><code>int getSquarePerimeter(int sideLength)</code><code>{</code><code>    return sideLength * getSquareSides();</code><code>}</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include "square.h" // square.h is also included once here</code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "a square has " &lt;&lt; getSquareSides() &lt;&lt; "sides\n";</code><code>    std::cout &lt;&lt; "a square of length 5 has perimeter length " &lt;&lt; getSquarePerimeter(5) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Now when the program is compiled, function <em>getSquareSides</em> will have just one definition (via <em>square.cpp</em>), so the linker is happy. File <em>main.cpp</em> is able to call this function (even though it lives in <em>square.cpp</em>) because it includes <em>square.h</em>, which has a forward declaration for the function (the linker will connect the call to <em>getSquareSides</em> from <em>main.cpp</em> to the definition of <em>getSquareSides</em> in <em>square.cpp</em>).</p><br><h3>Can’t we just avoid definitions in header files?</h3><p>We’ve generally told you not to include function definitions in your headers. So you may be wondering why you should include header guards if they protect you from something you shouldn’t do.</p><p>There are quite a few cases we’ll show you in the future where it’s necessary to put non-function definitions in a header file. For example, C++ will let you create your own types. These user-defined types are typically defined in header files, so the type definitions can be propagated out to the code files that need to use them. Without a header guard, a code file could end up with multiple (identical) copies of a given type definition, which the compiler will flag as an error.</p><p>So even though it’s not strictly necessary to have header guards at this point in the tutorial series, we’re establishing good habits now, so you don’t have to unlearn bad habits later.</p><br><h3>#pragma once</h3><p>Modern compilers support a simpler, alternate form of header guards using the <em>#pragma</em> directive:</p><pre class="language-cpp line-numbers"><code>#pragma once</code><code></code><code>// your code here</code></pre><p><code>#pragma once</code> serves the same purpose as header guards, and has the added benefit of being shorter and less error-prone. For most projects, <code>#pragma once</code> works fine, and many developers prefer to use them over header guards. However, <code>#pragma once</code> is not an official part of the C++ language (and probably will never be, because it can’t be implemented in a way that works reliably in all cases).</p><p>For maximum compatibility, we recommend sticking to traditional header guards. They aren’t much more work and they’re guaranteed to be supported on all compilers.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Favor header guards over <code>#pragma once</code> for maximum portability.</p></div><br><h3>Summary</h3><p>Header guards are designed to ensure that the contents of a given header file are not copied more than once into any single file, in order to prevent duplicate definitions.</p><p>Note that duplicate <em>declarations</em> are fine, since a declaration can be declared multiple times without incident -- but even if your header file is composed of all declarations (no definitions) it’s still a best practice to include header guards.</p><p>Note that header guards do <em>not</em> prevent the contents of a header file from being copied (once) into separate project files. This is a good thing, because we often need to reference the contents of a given header from different project files.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Add header guards to this header file:</p><p>add.h:</p><pre class="language-cpp line-numbers"><code>int add(int x, int y);</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#ifndef ADD_H</code><code>#define ADD_H</code><code></code><code>int add(int x, int y);</code><code></code><code>#endif</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">2.13 — How to design your first programs</h1></header><div class="entry-content" itemprop="articleBody"><p>Now that you’ve learned some basics about programs, let’s look more closely at <em>how</em> to design a program.</p><p>When you sit down to write a program, generally you have some kind of idea, which you’d like to write a program for. New programmers often have trouble figuring out how to convert that idea into actual code. But it turns out, you have many of the problem solving skills you need already, acquired from everyday life.</p><p>The most important thing to remember (and hardest thing to do) is to design your program <i>before you start coding</i>. In many regards, programming is like architecture. What would happen if you tried to build a house without following an architectural plan? Odds are, unless you were very talented, you’d end up with a house that had a lot of problems: walls that weren’t straight, a leaky roof, etc… Similarly, if you try to program before you have a good game-plan moving forward, you’ll likely find that your code has a lot of problems, and you’ll have to spend a lot of time fixing problems that could have been avoided altogether with a little thinking ahead.</p><p>A little up-front planning will save you both time and frustration in the long run.</p><p>In this lesson, we’ll lay out a generalized approach for converting ideas into simple functional programs.</p><br><h3>Design step 1: Define your goal</h3><p>In order to write a successful program, you first need to define what your goal is. Ideally, you should be able to state this in a sentence or two. It is often useful to express this as a user-facing outcome. For example:</p><ul><li>Allow the user to organize a list of names and associated phone numbers.</li><li>Generate randomized dungeons that will produce interesting looking caverns.</li><li>Generate a list of stock recommendations for stocks that have high dividends.</li><li>Model how long it takes for a ball dropped off a tower to hit the ground.</li></ul><p>Although this step seems obvious, it’s also highly important. The worst thing you can do is write a program that doesn’t actually do what you (or your boss) wanted!</p><br><h3>Design step 2: Define requirements</h3><p>While defining your problem helps you determine <em>what</em> outcome you want, it’s still vague. The next step is to think about requirements.</p><p>Requirements is a fancy word for both the constraints that your solution needs to abide by (e.g. budget, timeline, space, memory, etc…), as well as the capabilities that the program must exhibit in order to meet the users’ needs. Note that your requirements should similarly be focused on the “what”, not the “how”.</p><p>For example:</p><ul><li>Phone numbers should be saved, so they can be recalled later.</li><li>The randomized dungeon should always contain a way to get from the entrance to an exit.</li><li>The stock recommendations should leverage historical pricing data.</li><li>The user should be able to enter the height of the tower.</li><li>We need a testable version within 7 days.</li><li>The program should produce results within 10 seconds of the user submitting their request.</li><li>The program should crash in less than 0.1% of user sessions.</li></ul><p>A single problem may yield many requirements, and the solution isn’t “done” until it satisfies all of them.</p><br><h3>Design step 3: Define your tools, targets, and backup plan</h3><p>When you are an experienced programmer, there are many other steps that typically would take place at this point, including:</p><ul><li>Defining what target architecture and/or OS your program will run on.</li><li>Determining what set of tools you will be using.</li><li>Determining whether you will write your program alone or as part of a team.</li><li>Defining your testing/feedback/release strategy.</li><li>Determining how you will back up your code.</li></ul><p>However, as a new programmer, the answers to these questions are typically simple: You are writing a program for your own use, alone, on your own system, using an IDE you purchased or downloaded, and your code is probably not used by anybody but you. This makes things easy.</p><p>That said, if you are going to work on anything of non-trivial complexity, you should have a plan to backup your code. It’s not enough to just zip or copy the directory to another location on your machine (though this is better than nothing). If your system crashes, you’ll lose everything. A good backup strategy involves getting a copy of the code off of your system altogether. There are lots of easy ways to do this: Zip it up and email it to yourself, copy it to Dropbox or another cloud service, FTP it to another machine, copy it to another machine on your local network, or use a version control system residing on another machine or in the cloud (e.g. github). Version control systems have the added advantage of not only being able to restore your files, but also to roll them back to a previous version.</p><br><h3>Design step 4: Break hard problems down into easy problems</h3><p>In real life, we often need to perform tasks that are very complex. Trying to figure out how to do these tasks can be very challenging. In such cases, we often make use of the <strong>top down</strong> method of problem solving. That is, instead of solving a single complex task, we break that task into multiple subtasks, each of which is individually easier to solve. If those subtasks are still too difficult to solve, they can be broken down further. By continuously splitting complex tasks into simpler ones, you can eventually get to a point where each individual task is manageable, if not trivial.</p><p>Let’s take a look at an example of this. Let’s say we want to clean our house. Our task hierarchy currently looks like this:</p><ul><li>Clean the house</li></ul><p>Cleaning the entire house is a pretty big task to do in one sitting, so let’s break it into subtasks:</p><ul><li>Clean the house<ul><li>Vacuum the carpets</li><li>Clean the bathrooms</li><li>Clean the kitchen</li></ul></li></ul><p>That’s more manageable, as we now have subtasks that we can focus on individually. However, we can break some of these down even further:</p><ul><li>Clean the house<ul><li>Vacuum the carpets</li><li>Clean the bathrooms<ul><li>Scrub the toilet (yuck!)</li><li>Wash the sink</li></ul></li><li>Clean the kitchen<ul><li>Clear the countertops</li><li>Clean the countertops</li><li>Scrub the sink</li><li>Take out the trash</li></ul></li></ul></li></ul><p>Now we have a hierarchy of tasks, none of them particularly hard. By completing each of these relatively manageable sub-items, we can complete the more difficult overall task of cleaning the house.</p><p>The other way to create a hierarchy of tasks is to do so from the <strong>bottom up</strong>. In this method, we’ll start from a list of easy tasks, and construct the hierarchy by grouping them.</p><p>As an example, many people have to go to work or school on weekdays, so let’s say we want to solve the problem of “go to work”. If you were asked what tasks you did in the morning to get from bed to work, you might come up with the following list:</p><ul><li>Pick out clothes</li><li>Get dressed</li><li>Eat breakfast</li><li>Travel to work</li><li>Brush your teeth</li><li>Get out of bed</li><li>Prepare breakfast</li><li>Get on your bicycle</li><li>Take a shower</li></ul><p>Using the bottom up method, we can organize these into a hierarchy of items by looking for ways to group items with similarities together:</p><ul><li>Get from bed to work<ul><li>Bedroom things<ul><li>Turn off alarm</li><li>Get out of bed</li><li>Pick out clothes</li></ul></li><li>Bathroom things<ul><li>Take a shower</li><li>Get dressed</li><li>Brush your teeth</li></ul></li><li>Breakfast things<ul><li>Make coffee or tea</li><li>Eat cereal</li></ul></li><li>Transportation things<ul><li>Get on your bicycle</li><li>Travel to work</li></ul></li></ul></li></ul><p>As it turns out, these task hierarchies are extremely useful in programming, because once you have a task hierarchy, you have essentially defined the structure of your overall program. The top level task (in this case, “Clean the house” or “Go to work”) becomes main() (because it is the main problem you are trying to solve). The subitems become functions in the program.</p><p>If it turns out that one of the items (functions) is too difficult to implement, simply split that item into multiple sub-items/sub-functions. Eventually you should reach a point where each function in your program is trivial to implement.</p><br><h3>Design step 5: Figure out the sequence of events</h3><p>Now that your program has a structure, it’s time to determine how to link all the tasks together. The first step is to determine the sequence of events that will be performed. For example, when you get up in the morning, what order do you do the above tasks? It might look like this:</p><ul><li>Bedroom things</li><li>Bathroom things</li><li>Breakfast things</li><li>Transportation things</li></ul><p>If we were writing a calculator, we might do things in this order:</p><ul><li>Get first number from user</li><li>Get mathematical operation from user</li><li>Get second number from user</li><li>Calculate result</li><li>Print result</li></ul><p>At this point, we’re ready for implementation.</p><br><h3>Implementation step 1: Outlining your main function</h3><p>Now we’re ready to start implementation. The above sequences can be used to outline your main program. Don’t worry about inputs and outputs for the time being.</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>//    doBedroomThings();</code><code>//    doBathroomThings();</code><code>//    doBreakfastThings();</code><code>//    doTransportationThings();</code><code></code><code>    return 0;</code><code>}</code></pre><p>Or in the case of the calculator:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    // Get first number from user</code><code>//    getUserInput();</code><code></code><code>    // Get mathematical operation from user</code><code>//    getMathematicalOperation();</code><code></code><code>    // Get second number from user</code><code>//    getUserInput();</code><code></code><code>    // Calculate result</code><code>//    calculateResult();</code><code></code><code>    // Print result</code><code>//    printResult();</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note that if you’re going to use this “outline” method for constructing your programs, your functions won’t compile because the definitions don’t exist yet. Commenting out the function calls until you’re ready to implement the function definitions is one way to address this (and the way we’ll show here). Alternatively, you can <em>stub out</em> your functions (create placeholder functions with empty bodies) so your program will compile.</p><br><h3>Implementation step 2: Implement each function</h3><p>In this step, for each function, you’ll do three things:</p><ol><li>Define the function prototype (inputs and outputs)</li><li>Write the function</li><li>Test the function</li></ol><p>If your functions are granular enough, each function should be fairly simple and straightforward. If a given function still seems overly-complex to implement, perhaps it needs to be broken down into subfunctions that can be more easily implemented (or it’s possible you did something in the wrong order, and need to revisit your sequencing of events).</p><p>Let’s do the first function from the calculator example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// Full implementation of the getUserInput function</code><code>int getUserInput()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer ";</code><code>    int input{};</code><code>    std::cin &gt;&gt; input;</code><code></code><code>    return input;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    // Get first number from user</code><code>    int value{ getUserInput() }; // Note we've included code here to test the return value!</code><code>    std::cout &lt;&lt; value; // debug code to ensure getUserInput() is working, we'll remove this later</code><code></code><code>    // Get mathematical operation from user</code><code>//    getMathematicalOperation();</code><code></code><code>    // Get second number from user</code><code>//    getUserInput();</code><code></code><code>    // Calculate result</code><code>//    calculateResult();</code><code></code><code>    // Print result</code><code>//    printResult();</code><code></code><code>    return 0;</code><code>}</code></pre><p>First, we’ve determined that the <em>getUserInput</em> function takes no arguments, and will return an int value back to the caller. That gets reflected in the function prototype having a return value of int and no parameters. Next, we’ve written the body of the function, which is a straightforward 4 statements. Finally, we’ve implemented some temporary code in function <em>main</em> to test that function <em>getUserInput</em> (including its return value) is working correctly.</p><p>We can run this program many times with different input values and make sure that the program is behaving as we expect at this point. If we find something that doesn’t work, we know the problem is in the code we’ve just written.</p><p>Once we’re convinced the program is working as intended up to this point, we can remove the temporary testing code, and proceed to implementation of the next function (function <em>getMathematicalOperation</em>). We won’t finish the program in this lesson, as we need to cover some additional topics first.</p><p>Remember: Don’t implement your entire program in one go. Work on it in steps, testing each step along the way before proceeding.</p><br><h3>Implementation step 3: Final testing</h3><p>Once your program is “finished”, the last step is to test the whole program and ensure it works as intended. If it doesn’t work, fix it.</p><br><h3>Words of advice when writing programs</h3><p><strong>Keep your programs simple to start</strong>. Often new programmers have a grand vision for all the things they want their program to do. “I want to write a role-playing game with graphics and sound and random monsters and dungeons, with a town you can visit to sell the items that you find in the dungeon” If you try to write something too complex to start, you will become overwhelmed and discouraged at your lack of progress. Instead, make your first goal as simple as possible, something that is definitely within your reach. For example, “I want to be able to display a 2-dimensional field on the screen”.</p><p><strong>Add features over time</strong>. Once you have your simple program working and working well, then you can add features to it. For example, once you can display your field, add a character who can walk around. Once you can walk around, add walls that can impede your progress. Once you have walls, build a simple town out of them. Once you have a town, add merchants. By adding each feature incrementally your program will get progressively more complex without overwhelming you in the process.</p><p><strong>Focus on one area at a time</strong>. Don’t try to code everything at once, and don’t divide your attention across multiple tasks. Focus on one task at a time. It is much better to have one working task and five that haven’t been started yet than six partially-working tasks. If you split your attention, you are more likely to make mistakes and forget important details.</p><p><strong>Test each piece of code as you go</strong>. New programmers will often write the entire program in one pass. Then when they compile it for the first time, the compiler reports hundreds of errors. This can not only be intimidating, if your code doesn’t work, it may be hard to figure out why. Instead, write a piece of code, and then compile and test it immediately. If it doesn’t work, you’ll know exactly where the problem is, and it will be easy to fix. Once you are sure that the code works, move to the next piece and repeat. It may take longer to finish writing your code, but when you are done the whole thing should work, and you won’t have to spend twice as long trying to figure out why it doesn’t.</p><p><strong>Don’t invest in perfecting early code</strong>. The first draft of a feature (or program) is rarely good. Furthermore, programs tend to evolve over time, as you add capabilities and find better ways to structure things. If you invest too early in polishing your code (adding lots of documentation, full compliance with best practices, making optimizations), you risk losing all of that investment when a code change is necessary. Instead, get your features minimally working and then move on. As you gain confidence in your solutions, apply successive layers of polish. Don’t aim for perfect -- non-trivial programs are never perfect, and there’s always something more that could be done to improve them. Get to good enough and move on.</p><p>Most new programmers will shortcut many of these steps and suggestions (because it seems like a lot of work and/or it’s not as much fun as writing the code). However, for any non-trivial project, following these steps will definitely save you a lot of time in the long run. A little planning up front saves a lot of debugging at the end.</p><p>The good news is that once you become comfortable with all of these concepts, they will start coming more naturally to you. Eventually you will get to the point where you can write entire functions without any pre-planning at all.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">2.x — Chapter 2 summary and quiz</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Chapter Review</h3><p>A <span class="cpp-definition">function</span> is a reusable sequence of statements designed to do a particular job. Functions you write yourself are called <span class="cpp-definition">user-defined</span> functions.</p><p>A <span class="cpp-definition">function call</span> is an expression that tells the CPU to execute a function. The function initiating the function call is the <span class="cpp-definition">caller</span>, and the function being called is the <span class="cpp-definition">callee</span> or <span class="cpp-definition">called</span> function. Do not forget to include parenthesis when making a function call.</p><p>The curly braces and statements in a function definition are called the <span class="cpp-definition">function body</span>.</p><p>A function that returns a value is called a <span class="cpp-definition">value-returning function</span>. The <span class="cpp-definition">return type</span> of a function indicates the type of value that the function will return. The <span class="cpp-definition">return statement</span> determines the specific <span class="cpp-definition">return value</span> that is returned to the caller. A return value is copied from the function back to the caller -- this process is called <span class="cpp-definition">return by value</span>. Failure to return a value from a non-void function will result in undefined behavior.</p><p>The return value from function <em>main</em> is called a <span class="cpp-definition">status code</span>, and it tells the operating system (and any other programs that called yours) whether your program executed successfully or not. By consensus a return value of 0 means success, and a positive return value means failure.</p><p>Practice <span class="cpp-definition">DRY</span> programming -- “don’t repeat yourself”. Make use of variables and functions to remove redundant code.</p><p>Functions with a return type of <span class="cpp-definition">void</span> do not return a value to the caller. A function that does not return a value is called a <span class="cpp-definition">void function</span> or <span class="cpp-definition">non-value returning function</span>. Void functions can’t be called where a value is required.</p><p>A return statement that is not the last statement in a function is called a <span class="cpp-definition">early return</span>. Such a statement causes the function to return to the caller immediately.</p><p>A <span class="cpp-definition">function parameter</span> is a variable used in a function where the value is provided by the caller of the function. An <span class="cpp-definition">argument</span> is the specific value passed from the caller to the function. When an argument is copied into the parameter, this is called <span class="cpp-definition">pass by value</span>.</p><p>Function parameters and variables defined inside the function body are called <span class="cpp-definition">local variables</span>. The time in which a variable exists is called its <span class="cpp-definition">lifetime</span>. Variables are created and destroyed at <span class="cpp-definition">runtime</span>, which is when the program is running. A variable’s <span class="cpp-definition">scope</span> determines where it can be accessed. When a variable can be accessed, we say it is <span class="cpp-definition">in scope</span>. When it can not be accessed, we say it is <span class="cpp-definition">out of scope</span>. Scope is a <span class="cpp-definition">compile-time</span> property, meaning it is enforced at compile time.</p><p><span class="cpp-definition">Whitespace</span> refers to characters used for formatting purposes. In C++, this includes spaces, tabs, and newlines.</p><p>A <span class="cpp-definition">forward declaration</span> allows us to tell the compiler about the existence of an identifier before actually defining the identifier. To write a forward declaration for a function, we use a <span class="cpp-definition">function prototype</span>, which includes the function’s return type, name, and parameters, but no function body, followed by a semicolon.</p><p>A <span class="cpp-definition">definition</span> actually implements (for functions and types) or instantiates (for variables) an identifier. A <span class="cpp-definition">declaration</span> is a statement that tells the compiler about the existence of the identifier. In C++, all definitions serve as declarations. <span class="cpp-definition">Pure declarations</span> are declarations that are not also definitions (such as function prototypes).</p><p>Most non-trivial programs contain multiple files.</p><p>When two identifiers are introduced into the same program in a way that the compiler or linker can’t tell them apart, the compiler or linker will error due to a <span class="cpp-definition">naming collision</span>. A <span class="cpp-definition">namespace</span> guarantees that all identifiers within the namespace are unique. The std namespace is one such namespace.</p><p>The <span class="cpp-definition">preprocessor</span> is a process that runs on the code before it is compiled. <span class="cpp-definition">Directives</span> are special instructions to the preprocessor. Directives start with a # symbol and end with a newline. A <span class="cpp-definition">macro</span> is a rule that defines how input text is converted to a replacement output text.</p><p><span class="cpp-definition">Header files</span> are files designed to propagate declarations to code files. When using the <em>#include</em> directive, the <em>#include</em> directive is replaced by the contents of the included file. When including headers, use angled brackets when including system headers (e.g. those in the C++ standard library), and use double quotes when including user-defined headers (the ones you write). When including system headers, include the versions with no .h extension if they exist.</p><p><span class="cpp-definition">Header guards</span> prevent the contents of a header from being included more than once into a given code file. They do not prevent the contents of a header from being included into multiple different code files.</p><br><h3>Quiz time</h3><p>Be sure to use your editor’s auto-formatting feature to keep your formatting consistent and make your code easier to read.</p><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Write a single-file program (named main.cpp) that reads two separate integers from the user, adds them together, and then outputs the answer. The program should use three functions:</p><ul><li>A function named “readNumber” should be used to get (and return) a single integer from the user.</li><li>A function named “writeAnswer” should be used to output the answer. This function should take a single parameter and have no return value.</li><li>A main() function should be used to glue the above functions together.</li></ul><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">Hint: You do not need to write a separate function to do the adding (just use operator+ directly).</div><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_1'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_1" style="display:none;margin-bottom:1em">Hint: You will need to call readNumber() twice.</div><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int readNumber()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number: ";</code><code>    int x {};</code><code>    std::cin &gt;&gt; x;</code><code>    return x;</code><code>}</code><code></code><code>void writeAnswer(int x)</code><code>{</code><code>    std::cout &lt;&lt; "The answer is " &lt;&lt; x &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x { readNumber() };</code><code>    int y { readNumber() };</code><code>    writeAnswer(x + y); // using operator+ to pass the sum of x and y to writeAnswer()</code><code>    return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>Modify the program you wrote in exercise #1 so that readNumber() and writeAnswer() live in a separate file called “io.cpp”. Use a forward declaration to access them from main().</p><p>If you’re having problems, make sure “io.cpp” is properly added to your project so it gets compiled.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>io.cpp:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int readNumber()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number: ";</code><code>    int x {};</code><code>    std::cin &gt;&gt; x;</code><code>    return x;</code><code>}</code><code></code><code>void writeAnswer(int x)</code><code>{</code><code>    std::cout &lt;&lt; "The answer is " &lt;&lt; x &lt;&lt; '\n';</code><code>}</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>// these are the forward declarations for the functions in io.cpp</code><code>int readNumber();</code><code>void writeAnswer(int x);</code><code></code><code>int main()</code><code>{</code><code>    int x { readNumber() };</code><code>    int y { readNumber() };</code><code>    writeAnswer(x+y);</code><code>    return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>Modify the program you wrote in #2 so that it uses a header file (named io.h) to access the functions instead of using forward declarations directly in your code (.cpp) files. Make sure your header file uses header guards.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>io.h:</p><pre class="language-cpp line-numbers"><code>#ifndef IO_H</code><code>#define IO_H</code><code></code><code>int readNumber();</code><code>void writeAnswer(int x);</code><code></code><code>#endif</code></pre><p>io.cpp:</p><pre class="language-cpp line-numbers"><code>#include "io.h"</code><code>#include <iostream></iostream></code><code></code><code>int readNumber()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number: ";</code><code>    int x {};</code><code>    std::cin &gt;&gt; x;</code><code>    return x;</code><code>}</code><code></code><code>void writeAnswer(int x)</code><code>{</code><code>    std::cout &lt;&lt; "The answer is " &lt;&lt; x &lt;&lt; '\n';</code><code>}</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include "io.h"</code><code></code><code>int main()</code><code>{</code><code>    int x { readNumber() };</code><code>    int y { readNumber() };</code><code>    writeAnswer(x+y);</code><code>    return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">3.1 — Syntax and semantic errors</h1></header><div class="entry-content" itemprop="articleBody"><p>Software errors are prevalent. It’s easy to make them, and it’s hard to find them. In this chapter, we’ll explore topics related to the finding and removal of bugs within our C++ programs, including learning how to use the integrated debugger that is part of our IDE.</p><p>Although debugging tools and techniques aren’t part of the C++ standard, learning to find and remove bugs in the programs you write is an extremely important part of being a successful programmer. Therefore, we’ll spend a bit of time covering such topics, so that as the programs you write become more complex, your ability to diagnose and remedy issues advances at a similar pace.</p><p>If you have experience from debugging programs in another compiled programming language, much of this will be familiar to you.</p><br><h3>Syntax and semantic errors</h3><p>Programming can be challenging, and C++ is somewhat of a quirky language. Put those two together, and there are a lot of ways to make mistakes. Errors generally fall into one of two categories: syntax errors, and semantic errors (logic errors).</p><p>A <span class="cpp-definition">syntax error</span> occurs when you write a statement that is not valid according to the grammar of the C++ language. This includes errors such as missing semicolons, using undeclared variables, mismatched parentheses or braces, etc… For example, the following program contains quite a few syntax errors:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt; "Hi there"; &lt;&lt; x; // invalid operator (&lt;), extraneous semicolon, undeclared variable (x)</code><code>    return 0 // missing semicolon at end of statement</code><code>}</code></pre><p>Fortunately, the compiler will generally catch syntax errors and generate warnings or errors, so you easily identify and fix the problem. Then it’s just a matter of compiling again until you get rid of all the errors.</p><p>Once your program is compiling correctly, getting it to actually produce the result(s) you want can be tricky. A <span class="cpp-definition">semantic error</span> occurs when a statement is syntactically valid, but does not do what the programmer intended.</p><p>Sometimes these will cause your program to crash, such as in the case of division by zero:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int a { 10 };</code><code>    int b { 0 };</code><code>    std::cout &lt;&lt; a &lt;&lt; " / " &lt;&lt; b &lt;&lt; " = " &lt;&lt; a / b; // division by 0 is undefined</code><code>    return 0;</code><code>}</code></pre><p>More often these will just produce the wrong value or behavior:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x;</code><code>    std::cout &lt;&lt; x; // Use of uninitialized variable leads to undefined result</code><code></code><code>    return 0;</code><code>}</code></pre><p>or</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y)</code><code>{</code><code>    return x - y; // function is supposed to add, but it doesn't</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; add(5, 3); // should produce 8, but produces 2</code><code></code><code>    return 0;</code><code>}</code></pre><p>or</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    return 0; // function returns here</code><code></code><code>    std::cout &lt;&lt; "Hello, world!"; // so this never executes</code><code>}</code></pre><p>Modern compilers have been getting better at detecting certain types of common semantic errors (e.g. use of an uninitialized variable). However, in most cases, the compiler will not be able to catch most of these types of problems, because the compiler is designed to enforce grammar, not intent.</p><p>In the above example, the errors are fairly easy to spot. But in most non-trivial programs, semantic errors are not easy to find by eyeballing the code. This is where debugging techniques can come in handy.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">3.2 — The debugging process</h1></header><div class="entry-content" itemprop="articleBody"><p>Let’s say you’ve written a program, and it’s not working correctly -- the code all compiles fine, but when you run it, you’re getting an incorrect result. You must have a semantic error somewhere. How can you find it? If you’ve been following best practices by writing a little bit of code and then testing it, you may have a good idea where your error is. Or you may have no clue at all.</p><p>All bugs stem from a simple premise: Something that you thought was correct, isn’t. Actually figuring out where that error is can be challenging. In this lesson, we’ll outline the general process of debugging a program.</p><p>Because we haven’t covered that many C++ topics yet, our example programs in this chapter are going to be pretty basic. That may make some of the techniques we’re showing here seem excessive. However, keep in mind that these techniques are designed to be used with larger, more complex programs, and will be of more use in such a setting (which is where you need them most).</p><br><h3>A general approach to debugging</h3><p>Once a problem has been identified, debugging the problem generally consists of five steps:</p><ol><li>Find the root cause of the problem (usually the line of code that’s not working)</li><li>Ensure you understand why the issue is occurring</li><li>Determine how you’ll fix the issue</li><li>Repair the issue causing the problem</li><li>Retest to ensure the problem has been fixed and no new problems have emerged</li></ol><p>Let’s use a real-life analogy here. Let’s say one evening, you go to get some ice from the ice dispenser in your freezer. You put your cup up to the dispenser, press, and … nothing comes out. Uh oh. You’ve discovered some kind of defect. What would you do? You’d probably start an investigation to see if you could identify the root cause of the issue.</p><p><strong>Find the root cause:</strong> Since you hear the ice dispenser trying to deliver ice, it’s probably not the ice delivery mechanism itself. So you open the freezer, and examine the ice tray. No ice. Is that the root cause of the issue? No, it’s another symptom. After further examination, you determine that the ice maker does not appear to be making ice. Is the problem the ice maker or something else? The freezer is still cold, the water line isn’t clogged, and everything else seems to be working, so you conclude that the root cause is that the ice maker is non-functional.</p><p><strong>Understand the problem:</strong> This is simple in this case. A broken ice maker won’t make ice.</p><p><strong>Determine a fix:</strong> At this point, you have several options for a fix: You could work around the issue (buy bags of ice from the store). You could try to diagnose the ice-maker further, to see if there’s a part that can be repaired. You could buy a new ice maker and install it in place of the current one. Or you could buy a new freezer. You decide to buy a new ice maker.</p><p><strong>Repair the issue:</strong> Once the ice maker has arrived, you install it.</p><p><strong>Retest:</strong> After turning the electricity back on and waiting overnight, your new ice maker starts making ice. No new issues are discovered.</p><p>Now let’s apply this process to our simple program from the previous lesson:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// Adds two numbers</code><code>int add(int x, int y)</code><code>{</code><code>    return x - y; // function is supposed to add, but it doesn't</code><code>}</code><code> </code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; add(5, 3) &lt;&lt; '\n'; // should produce 8, but produces 2</code><code>    return 0;</code><code>}</code></pre><p>This code is nice in one regard: the bug is very apparent, because the wrong answer gets printed to the screen via line 11. That gives us a starting point for our investigation.</p><p><strong>Find the root cause:</strong> On line 11, we can see that we’re passing in literals for arguments (5 and 3), so there is no room for error there. Since the inputs to function <em>add</em> are correct, but the output isn’t, it’s pretty apparent that function <em>add</em> must be producing the wrong value. The only statement in function <em>add</em> is the return statement, which must be the culprit. We’ve found the problem line. Now that we know where to focus our attention, noticing that we’re subtracting instead of adding is something you’re likely to find via inspection.</p><p><strong>Understand the problem:</strong> In this case, it’s obvious why the wrong value is being generated -- we’re using the wrong operator.</p><p><strong>Determine a fix:</strong> We’ll simply change <em>operator-</em> to <em>operator+</em>.</p><p><strong>Repair the issue:</strong> This is actually changing <em>operator-</em> to <em>operator+</em> and ensuring the program recompiles.</p><p><strong>Retest:</strong> After implementing the change, rerunning the program will indicate that our program now produces the correct value of 8. For this simple program, that’s all the testing that’s needed.</p><p>This example is trivial, but illustrates the basic process you’ll go through when diagnosing any program.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">3.3 — A strategy for debugging</h1></header><div class="entry-content" itemprop="articleBody"><p>When debugging a program, in most cases the vast majority of your time will be spent trying to find where the error actually is. Once the issue is found, the remaining steps (fixing the issue and validating that the issue was fixed) are often trivial in comparison.</p><p>In this lesson, we’ll start exploring how to find errors.</p><br><h3>Finding problems via code inspection</h3><p>Let’s say you’ve noticed a problem, and you want to track the cause of that specific problem down. In many cases (especially in smaller programs), we can quickly home in on the proximity of where the issue is.</p><p>Consider the following program snippet:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    getNames(); // ask user to enter a bunch of names</code><code>    sortNames(); // sort them in alphabetical order</code><code>    printNames(); // print the sorted list of names</code><code></code><code>    return 0;</code><code>}</code></pre><p>If you expected this program to print the names in alphabetical order, but it printed them in opposite order instead, the problem is probably in the <em>sortNames</em> function. In cases where you can narrow the problem down to a specific function, you may be able to spot the issue just by looking at the code.</p><p>However, as programs get more complex, finding issues by code inspection becomes more complex as well.</p><p>First, there’s a lot more code to look at. Looking at every line of code in a program that is thousands of lines long can take a really long time (not to mention it’s incredibly boring). Second, the code itself tends to be more complex, with more possible places for things to go wrong. Third, the code’s behavior may not give you many clues as to where things are going wrong. If you wrote a program to output stock recommendations and it actually output nothing at all, you probably wouldn’t have much of a lead on where to start looking for the problem.</p><p>Finally, bugs can be caused by making bad assumptions. It’s almost impossible to visually spot a bug caused by a bad assumption, because you’re likely to make the same bad assumption when inspecting the code, and not notice the error. So if we have an issue that we can’t find via code inspection, how do we find it?</p><br><h3>Finding problems by running the program</h3><p>Fortunately, if we can’t find an issue via code inspection, there is another avenue we can take: we can watch the behavior of the program as it runs, and try to diagnose the issue from that. This approach can be generalized as:</p><ol><li>Figure out how to reproduce the problem</li><li>Run the program and gather information to narrow down where the problem is</li><li>Repeat the prior step until you find the problem</li></ol><p>For the rest of this chapter, we’ll discuss techniques to facilitate this approach.</p><br><h3>Reproducing the problem</h3><p>The first and most important step in finding a problem is to be able to <em>reproduce the problem</em>. Reproducing the problem means making the problem appear in a consistent manner. The reason is simple: it’s extremely hard to find an issue unless you can observe it occurring.</p><p>Back to our ice dispenser analogy -- let’s say one day your friend tells you that your ice dispenser isn’t working. You go to look at it, and it works fine. How would you diagnose the problem? It would be very difficult. However, if you could actually see the issue of the ice dispenser not working, then you could start to diagnose why it wasn’t working much more effectively.</p><p>If a software issue is blatant (e.g. the program crashes in the same place every time you run it) then reproducing the problem can be trivial. However, sometimes reproducing an issue can be a lot more difficult. The problem may only occur on certain computers, or in particular circumstances (e.g. when the user enters certain input). In such cases, generating a set of reproduction steps can be helpful. <span class="cpp-definition">Reproduction steps</span> are a list of clear and precise steps that can be followed to cause an issue to recur with a high level of predictability. The goal is to be able to cause the issue to reoccur as much as possible, so we can run our program over and over and look for clues to determine what’s causing the problem. If the issue can be reproduced 100% of the time, that’s ideal, but less than 100% reproducibility can be okay. An issue that occurs only 50% of the time simply means it’ll take twice as long to diagnose the issue, as half the time the program won’t exhibit the problem and thus not contribute any useful diagnostic information.</p><br><h3>Homing in on issues</h3><p>Once we can reasonably reproduce the problem, the next step is to figure out where in the code the problem is. Based on the nature of the problem, this may be easy or difficult. For the sake of example, let’s say we don’t have much of an idea where the problem actually is. How do we find it?</p><p>An analogy will serve us well here. Let’s play a game of hi-lo. I’m going to ask you to guess a number between 1 and 10. For each guess you make, I’ll tell you whether each guess is too high, too low, or correct. An instance of this game might look like this:</p><pre>You: 5
Me: Too low
You: 8
Me: Too high
You: 6
Me: Too low
You: 7
Me: Correct
</pre><p>In the above game, you don’t have to guess every number to find the number I was thinking of. Through the process of making guesses and considering the information you learn from each guess, you can “home in” on the correct number with only a few guesses (if you use an optimal strategy, you can always find the number I’m thinking of in 4 or fewer guesses).</p><p>We can use a similar process to debug programs. In the worst case, we may have no idea where the bug is. However, we do know that the problem must be somewhere in the code that executes between the beginning of the program and the point where the program exhibits the first incorrect symptom that we can observe. That at least rules out the parts of the program that execute after the first observable symptom. But that still potentially leaves a lot of code to cover. To diagnose the issue, we’ll make some educated guesses about where the problem is, with the goal of homing in on the problem quickly.</p><p>Often, whatever it was that caused us to notice the problem will give us an initial guess that’s close to where the actual problem is. For example, if the program isn’t writing data to a file when it should be, then the issue is probably somewhere in the code that handles writing to a file (duh!). Then we can use a hi-lo like strategy to try and isolate where the problem actually is.</p><p>For example:</p><ul><li>If at some point in our program, we can prove that the problem has not occurred yet, this is analogous to receiving a “too low” hi-lo result -- we know the problem must be somewhere later in the program. For example, if our program is crashing in the same place every time, and we can prove that the program has not crashed at a particular point in the execution of the program, then the crash must be later in the code.</li><li>If at some point in our program we can observe incorrect behavior related to the problem, then this is analogous to receiving a “too high” hi-lo result, and we know the problem must be somewhere earlier in the program. For example, let’s say a program prints the value of some variable <em>x</em>. You were expecting it to print value <em>2</em>, but it printed <em>8</em> instead. Variable <em>x</em> must have the wrong value. If, at some point during the execution of our program, we can see that variable <em>x</em> already has value <em>8</em>, then we know the problem must have occurred before that point.</li></ul><p>The hi-lo analogy isn’t perfect -- we can also sometimes remove entire sections of our code from consideration without gaining any information on whether the actual problem is before or after that point.</p><p>We’ll show examples of all three of these cases in the next lesson.</p><p>Eventually, with enough guesses and some good technique, we can home in on the exact line causing the problem! If we’ve made any bad assumptions, this will help us discover where. When you’ve excluded everything else, the only thing left must be causing the problem. Then it’s just a matter of understanding why.</p><p>What guessing strategy you want to use is up to you -- the best one depends on what type of bug it is, so you’ll likely want to try many different approaches to narrow down the issue. As you gain experience in debugging issues, your intuition will help guide you.</p><p>So how do we “make guesses”? There are many ways to do so. We’re going to start with some simple approaches in the next chapter, and then we’ll build on these and explore others in future chapters.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">3.4 — Basic debugging tactics</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson, we explored a strategy for finding issues by running our programs and using guesswork to home in on where the problem is. In this lesson, we’ll explore some basic tactics for actually making those guesses and collecting information to help find issues.</p><br><h3>Debugging tactic #1: Commenting out your code</h3><p>Let’s start with an easy one. If your program is exhibiting erroneous behavior, one way to reduce the amount of code you have to search through is to comment some code out and see if the issue persists. If the issue remains, the commented out code wasn’t responsible.</p><p>Consider the following code:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    getNames(); // ask user to enter a bunch of names</code><code>    doMaintenance(); // do some random stuff</code><code>    sortNames(); // sort them in alphabetical order</code><code>    printNames(); // print the sorted list of names</code><code></code><code>    return 0;</code><code>}</code></pre><p>Let’s say this program is supposed to print the names the user enters in alphabetical order, but its printing them in reverse alphabetical order. Where’s the problem? Is <em>getNames</em> entering the names incorrectly? Is <em>sortNames</em> sorting them backwards? Is <em>printNames</em> printing them backwards? It could be any of those things. But we might suspect doMaintenance() has nothing to do with the problem, so let’s comment it out.</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    getNames(); // ask user to enter a bunch of names</code><code>//    doMaintenance(); // do some random stuff</code><code>    sortNames(); // sort them in alphabetical order</code><code>    printNames(); // print the sorted list of names</code><code></code><code>    return 0;</code><code>}</code></pre><p>If the problem goes away, then <em>doMaintenance</em> must be causing the problem, and we should focus our attention there.</p><p>However, if the problem persists (which is more likely), then we know <em>doMaintenance</em> wasn’t at fault, and we can exclude the entire function from our search. This doesn’t help us understand whether the actual problem is before or after the call to <em>doMaintenance</em>, but it reduces the amount of code we have to subsequently look through.</p><p>Don’t forget which functions you’ve commented out so you can uncomment them later!</p><br><h3>Debugging tactic #2: Validating your code flow</h3><p>Another problem common in more complex programs is that the program is calling a function too many or too few times (including not at all).</p><p>In such cases, it can be helpful to place statements at the top of your functions to print the function’s name. That way, when the program runs, you can see which functions are getting called.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>When printing information for debugging purposes, use std::cerr instead of std::cout. One reason for this is that std::cout may be buffered, which means there may be a pause between when you ask std::cout to output information and when it actually does. If you output using std::cout and then your program crashes immediately afterward, std::cout may or may not have actually output yet. This can mislead you about where the issue is. On the other hand, std::cerr is unbuffered, which means anything you send to it will output immediately. This helps ensure all debug output appears as soon as possible (at the cost of some performance, which we usually don’t care about when debugging).</p><p>Using std::cerr also helps make clear that the information being output is for an error case rather than a normal case.</p></div><p>Consider the following simple program that doesn’t work correctly:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getValue()</code><code>{</code><code>	return 4;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; getValue;</code><code></code><code>    return 0;</code><code>}</code></pre><p>You may need to disable “Treat warnings as errors” for the above to compile.</p><p>Although we expect this program to print the value <em>4</em>, it should print the value:</p><pre>1
</pre><p>On Visual Studio (and possibly some other compilers), it may print the following instead:</p><pre>00101424
</pre><p>Let’s add some debugging statements to these functions:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getValue()</code><code>{</code><code>std::cerr &lt;&lt; "getValue() called\n";</code><code>	return 4;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>std::cerr &lt;&lt; "main() called\n";</code><code>    std::cout &lt;&lt; getValue;</code><code></code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>When adding temporary debug statements, it can be helpful to not indent them. This makes them easier to find for removal later.</p></div><p>Now when these functions execute, they’ll output their names, indicating that they were called:</p><pre>main() called
1
</pre><p>Now we can see that function <em>getValue</em> was never called. There must be some problem with the code that calls the function. Let’s take a closer look at that line:</p><pre class="language-cpp line-numbers"><code>    std::cout &lt;&lt; getValue;</code></pre><p>Oh, look, we forgot the parenthesis on the function call. It should be:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getValue()</code><code>{</code><code>std::cerr &lt;&lt; "getValue() called\n";</code><code>	return 4;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>std::cerr &lt;&lt; "main() called\n";</code><code>    std::cout &lt;&lt; getValue(); // added parenthesis here</code><code></code><code>    return 0;</code><code>}</code></pre><p>This will now produce the correct output</p><pre>main() called
getValue() called
4
</pre><p>And we can remove the temporary debugging statements.</p><br><h3>Debugging tactic #3: Printing values</h3><p>With some types of bugs, the program may be calculating or passing the wrong value.</p><p>We can also output the value of variables (including parameters) or expressions to ensure that they are correct.</p><p>Consider the following program that is supposed to add two numbers but doesn’t work correctly:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y)</code><code>{</code><code>	return x + y;</code><code>}</code><code></code><code>void printResult(int z)</code><code>{</code><code>	std::cout &lt;&lt; "The answer is: " &lt;&lt; z &lt;&lt; '\n';</code><code>}</code><code></code><code>int getUserInput()</code><code>{</code><code>	std::cout &lt;&lt; "Enter a number: ";</code><code>	int x{};</code><code>	std::cin &gt;&gt; x;</code><code>	return x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int x{ getUserInput() };</code><code>	int y{ getUserInput() };</code><code></code><code>	std::cout &lt;&lt; x &lt;&lt; " + " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>	int z{ add(x, 5) };</code><code>	printResult(z);</code><code></code><code>	return 0;</code><code>}</code></pre><p>Here’s some output from this program:</p><pre>Enter a number: 4
Enter a number: 3
4 + 3
The answer is: 9
</pre><p>That’s not right. Do you see the error? Even in this short program, it can be hard to spot. Let’s add some code to debug our values:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y)</code><code>{</code><code>	return x + y;</code><code>}</code><code></code><code>void printResult(int z)</code><code>{</code><code>	std::cout &lt;&lt; "The answer is: " &lt;&lt; z &lt;&lt; '\n';</code><code>}</code><code></code><code>int getUserInput()</code><code>{</code><code>	std::cout &lt;&lt; "Enter a number: ";</code><code>	int x{};</code><code>	std::cin &gt;&gt; x;</code><code>	return x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int x{ getUserInput() };</code><code>std::cerr &lt;&lt; "main::x = " &lt;&lt; x &lt;&lt; '\n';</code><code>	int y{ getUserInput() };</code><code>std::cerr &lt;&lt; "main::y = " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>	std::cout &lt;&lt; x &lt;&lt; " + " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>	int z{ add(x, 5) };</code><code>std::cerr &lt;&lt; "main::z = " &lt;&lt; z &lt;&lt; '\n';</code><code>	printResult(z);</code><code></code><code>	return 0;</code><code>}</code></pre><p>Here’s the above output:</p><pre>Enter a number: 4
main::x = 4
Enter a number: 3
main::y = 3
4 + 3
main::z = 9
The answer is: 9
</pre><p>Variables <em>x</em> and <em>y</em> are getting the right values, but variable <em>z</em> isn’t. The issue must be between those two points, which makes function <em>add</em> a key suspect.</p><p>Let’s modify function add:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y)</code><code>{</code><code>std::cerr &lt;&lt; "add() called (x=" &lt;&lt; x &lt;&lt;", y=" &lt;&lt; y &lt;&lt; ")\n";</code><code>	return x + y;</code><code>}</code><code></code><code>void printResult(int z)</code><code>{</code><code>	std::cout &lt;&lt; "The answer is: " &lt;&lt; z &lt;&lt; '\n';</code><code>}</code><code></code><code>int getUserInput()</code><code>{</code><code>	std::cout &lt;&lt; "Enter a number: ";</code><code>	int x{};</code><code>	std::cin &gt;&gt; x;</code><code>	return x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int x{ getUserInput() };</code><code>std::cerr &lt;&lt; "main::x = " &lt;&lt; x &lt;&lt; '\n';</code><code>	int y{ getUserInput() };</code><code>std::cerr &lt;&lt; "main::y = " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>	std::cout &lt;&lt; x &lt;&lt; " + " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>	int z{ add(x, 5) };</code><code>std::cerr &lt;&lt; "main::z = " &lt;&lt; z &lt;&lt; '\n';</code><code>	printResult(z);</code><code></code><code>	return 0;</code><code>}</code></pre><p>Now we’ll get the output:</p><pre>Enter a number: 4
main::x = 4
Enter a number: 3
main::y = 3
add() called (x=4, y=5)
main::z = 9
The answer is: 9
</pre><p>Variable <em>y</em> had value 3, but somehow our function <em>add</em> got the value 5 for parameter <em>y</em>. We must have passed the wrong argument. Sure enough:</p><pre class="language-cpp line-numbers"><code>	int z{ add(x, 5) };</code></pre><p>There it is. We passed the literal <em>5</em> instead of the value of variable <em>y</em> as an argument. That’s an easy fix, and then we can remove the debug statements.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>The third-party library <a href="https://github.com/sharkdp/dbg-macro">dbg-macro</a> can help make debugging using print statements easier. Check it out if this is something you find yourself doing a lot.</p></div><br><h3>One more example</h3><p>This program is very similar to the prior one, but also doesn’t work like it should:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y)</code><code>{</code><code>	return x + y;</code><code>}</code><code></code><code>void printResult(int z)</code><code>{</code><code>	std::cout &lt;&lt; "The answer is: " &lt;&lt; z &lt;&lt; '\n';</code><code>}</code><code></code><code>int getUserInput()</code><code>{</code><code>	std::cout &lt;&lt; "Enter a number: ";</code><code>	int x{};</code><code>	std::cin &gt;&gt; x;</code><code>	return --x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int x{ getUserInput() };</code><code>	int y{ getUserInput() };</code><code></code><code>	int z { add(x, y) };</code><code>	printResult(z);</code><code></code><code>	return 0;</code><code>}</code></pre><p>If we run this code and see the following:</p><pre>Enter a number: 4
Enter a number: 3
The answer is: 5
</pre><p>Hmmm, something is wrong. But where?</p><p>Let’s instrument this code with some debugging:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y)</code><code>{</code><code>std::cerr &lt;&lt; "add() called (x=" &lt;&lt; x &lt;&lt; ", y=" &lt;&lt; y &lt;&lt; ")\n";</code><code>	return x + y;</code><code>}</code><code></code><code>void printResult(int z)</code><code>{</code><code>std::cerr &lt;&lt; "printResult() called (z=" &lt;&lt; z &lt;&lt; ")\n";</code><code>	std::cout &lt;&lt; "The answer is: " &lt;&lt; z &lt;&lt; '\n';</code><code>}</code><code></code><code>int getUserInput()</code><code>{</code><code>std::cerr &lt;&lt; "getUserInput() called\n";</code><code>	std::cout &lt;&lt; "Enter a number: ";</code><code>	int x{};</code><code>	std::cin &gt;&gt; x;</code><code>	return --x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>std::cerr &lt;&lt; "main() called\n";</code><code>	int x{ getUserInput() };</code><code>std::cerr &lt;&lt; "main::x = " &lt;&lt; x &lt;&lt; '\n';</code><code>	int y{ getUserInput() };</code><code>std::cerr &lt;&lt; "main::y = " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>	int z{ add(x, y) };</code><code>std::cerr &lt;&lt; "main::z = " &lt;&lt; z &lt;&lt; '\n';</code><code>	printResult(z);</code><code></code><code>	return 0;</code><code>}</code></pre><p>Now let’s run the program again with the same inputs:</p><pre>main() called
getUserInput() called
Enter a number: 4
main::x = 3
getUserInput() called
Enter a number: 3
main::y = 2
add() called (x=3, y=2)
main::z = 5
printResult() called (z=5)
The answer is: 5
</pre><p>Now we can immediately see something going wrong: The user is entering the value <em>4</em>, but main’s <em>x</em> is getting value <em>3</em>. Something must be going wrong between where the user enters input and where that value is assigned to main’s variable <em>x</em>. Let’s make sure that the program is getting the correct value from the user by adding some debug code to function <em>getUserInput</em>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y)</code><code>{</code><code>std::cerr &lt;&lt; "add() called (x=" &lt;&lt; x &lt;&lt; ", y=" &lt;&lt; y &lt;&lt; ")\n";</code><code>	return x + y;</code><code>}</code><code></code><code>void printResult(int z)</code><code>{</code><code>std::cerr &lt;&lt; "printResult() called (z=" &lt;&lt; z &lt;&lt; ")\n";</code><code>	std::cout &lt;&lt; "The answer is: " &lt;&lt; z &lt;&lt; '\n';</code><code>}</code><code></code><code>int getUserInput()</code><code>{</code><code>std::cerr &lt;&lt; "getUserInput() called\n";</code><code>	std::cout &lt;&lt; "Enter a number: ";</code><code>	int x{};</code><code>	std::cin &gt;&gt; x;</code><code>std::cerr &lt;&lt; "getUserInput::x = " &lt;&lt; x &lt;&lt; '\n'; // added this additional line of debugging</code><code>	return --x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>std::cerr &lt;&lt; "main() called\n";</code><code>	int x{ getUserInput() };</code><code>std::cerr &lt;&lt; "main::x = " &lt;&lt; x &lt;&lt; '\n';</code><code>	int y{ getUserInput() };</code><code>std::cerr &lt;&lt; "main::y = " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>	int z{ add(x, y) };</code><code>std::cerr &lt;&lt; "main::z = " &lt;&lt; z &lt;&lt; '\n';</code><code>	printResult(z);</code><code></code><code>	return 0;</code><code>}</code></pre><p>And the output:</p><pre>main() called
getUserInput() called
Enter a number: 4
getUserInput::x = 4
main::x = 3
getUserInput() called
Enter a number: 3
getUserInput::x = 3
main::y = 2
add() called (x=3, y=2)
main::z = 5
printResult() called (z=5)
The answer is: 5
</pre><p>With this additional line of debugging, we can see that the user input is received correctly into getUserInput’s variable <em>x</em>. And yet somehow main’s variable <em>x</em> is getting the wrong value. The problem must be between those two points. The only culprit left is the return value from function <em>getUserInput</em>. Let’s look at that line more closely.</p><pre class="language-cpp line-numbers"><code>	return --x;</code></pre><p>Hmmm, that’s odd. What’s that <code>--</code> symbol before x? We haven’t covered that yet in these tutorials, so don’t worry if you don’t know what it means. But even without knowing what it means, through your debugging efforts, you can be reasonably sure that this particular line is at fault -- and thus, it’s likely this <code>--</code> symbol is causing the problem.</p><p>Since we really want <em>getUserInput</em> to return just the value of <em>x</em>, let’s remove the <code>--</code> and see what happens:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y)</code><code>{</code><code>std::cerr &lt;&lt; "add() called (x=" &lt;&lt; x &lt;&lt; ", y=" &lt;&lt; y &lt;&lt; ")\n";</code><code>	return x + y;</code><code>}</code><code></code><code>void printResult(int z)</code><code>{</code><code>std::cerr &lt;&lt; "printResult() called (z=" &lt;&lt; z &lt;&lt; ")\n";</code><code>	std::cout &lt;&lt; "The answer is: " &lt;&lt; z &lt;&lt; '\n';</code><code>}</code><code></code><code>int getUserInput()</code><code>{</code><code>std::cerr &lt;&lt; "getUserInput() called\n";</code><code>	std::cout &lt;&lt; "Enter a number: ";</code><code>	int x{};</code><code>	std::cin &gt;&gt; x;</code><code>std::cerr &lt;&lt; "getUserInput::x = " &lt;&lt; x &lt;&lt; '\n';</code><code>	return x; // removed -- before x</code><code>}</code><code></code><code>int main()</code><code>{</code><code>std::cerr &lt;&lt; "main() called\n";</code><code>	int x{ getUserInput() };</code><code>std::cerr &lt;&lt; "main::x = " &lt;&lt; x &lt;&lt; '\n';</code><code>	int y{ getUserInput() };</code><code>std::cerr &lt;&lt; "main::y = " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>	int z{ add(x, y) };</code><code>std::cerr &lt;&lt; "main::z = " &lt;&lt; z &lt;&lt; '\n';</code><code>	printResult(z);</code><code></code><code>	return 0;</code><code>}</code></pre><p>And now the output:</p><pre>main() called
getUserInput() called
Enter a number: 4
getUserInput::x = 4
main::x = 4
getUserInput() called
Enter a number: 3
getUserInput::x = 3
main::y = 3
add() called (x=4, y=3)
main::z = 7
printResult() called (z=7)
The answer is: 7
</pre><p>The program is now working correctly. Even without understanding what <code>--</code> was doing, we were able to identify the specific line of code causing the issue, and then fix the issue.</p><br><h3>Why using printing statements to debug isn’t great</h3><p>While adding debug statements to programs for diagnostic purposes is a common rudimentary technique, and a functional one (especially when a debugger is not available for some reason), it’s not that great for a number of reasons:</p><ol><li>Debug statements clutter your code.</li><li>Debug statements clutter the output of your program.</li><li>Debug statements must be removed after you’re done with them, which makes them non-reusable.</li><li>Debug statements require modification of your code to both add and to remove, which can introduce new bugs.</li></ol><p>We can do better. We’ll explore how in future lessons.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">3.5 — More debugging tactics</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson (<a href="https://www.learncpp.com/cpp-tutorial/basic-debugging-tactics/">3.4 -- Basic debugging tactics</a>), we started exploring how to manually debug problems. In that lesson, we offered some criticisms of using statements to print debug text:</p><ol><li>Debug statements clutter your code.</li><li>Debug statements clutter the output of your program.</li><li>Debug statements require modification of your code to both add and to remove, which can introduce new bugs.</li><li>Debug statements must be removed after you’re done with them, which makes them non-reusable.</li></ol><p>We can mitigate some of these issues. In this lesson, we’ll explore some basic techniques for doing so.</p><br><h3>Conditionalizing your debugging code</h3><p>Consider the following program that contains some debug statements:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code> </code><code>int getUserInput()</code><code>{</code><code>std::cerr &lt;&lt; "getUserInput() called\n";</code><code>	std::cout &lt;&lt; "Enter a number: ";</code><code>	int x{};</code><code>	std::cin &gt;&gt; x;</code><code>	return x;</code><code>}</code><code> </code><code>int main()</code><code>{</code><code>std::cerr &lt;&lt; "main() called\n";</code><code>    int x{ getUserInput() };</code><code>    std::cout &lt;&lt; "You entered: " &lt;&lt; x;</code><code> </code><code>    return 0;</code><code>}</code></pre><p>When you’re done with the debugging statement, you’ll either need to remove them, or comment them out. Then if you want them again later, you’ll have to add them back, or uncomment them.</p><p>One way to make it easier to disable and enable debugging throughout your program is to make your debugging statements conditional using preprocessor directives:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code> </code><code>#define ENABLE_DEBUG // comment out to disable debugging</code><code></code><code>int getUserInput()</code><code>{</code><code>#ifdef ENABLE_DEBUG</code><code>std::cerr &lt;&lt; "getUserInput() called\n";</code><code>#endif</code><code>	std::cout &lt;&lt; "Enter a number: ";</code><code>	int x{};</code><code>	std::cin &gt;&gt; x;</code><code>	return x;</code><code>}</code><code> </code><code>int main()</code><code>{</code><code>#ifdef ENABLE_DEBUG</code><code>std::cerr &lt;&lt; "main() called\n";</code><code>#endif</code><code>    int x{ getUserInput() };</code><code>    std::cout &lt;&lt; "You entered: " &lt;&lt; x;</code><code> </code><code>    return 0;</code><code>}</code></pre><p>Now we can enable debugging simply by commenting / uncommenting <em>#define ENABLE_DEBUG</em>. This allows us to reuse previously added debug statements and then just disable them when we’re done with them, rather than having to actually remove them from the code. If this were a multi-file program, the #define ENABLE_DEBUG would go in a header file that’s included into all code files so we can comment / uncomment the #define in a single location and have it propagate to all code files.</p><p>This addresses the issue with having to remove debug statements and the risk in doing so, but at the cost of even more code clutter. Another downside of this approach is that if you make a typo (e.g. misspell “DEBUG”) or forget to include the header into a code file, some or all of the debugging for that file may not be enabled. So although this is better than the unconditionalized version, there’s still room to improve.</p><br><h3>Using a logger</h3><p>An alternative approach to conditionalized debugging via the preprocessor is to send your debugging information to a log file. A <span class="cpp-definition">log file</span> is a file (normally stored on disk) that records events that occur in software. The process of writing information to a log file is called <span class="cpp-definition">logging</span>. Most applications and operating systems write log files that can be used to help diagnose issues that occur.</p><p>Log files have a few advantages. Because the information written to a log file is separated from your program’s output, you can avoid the clutter caused by mingling your normal output and debug output. Log files can also be easily sent to other people for diagnosis -- so if someone using your software has an issue, you can ask them to send you the log file, and it might help give you a clue where the issue is.</p><p>While you can write your own code to create log file and send output to them, you’re better off using one of the many existing third-party logging tools available. Which one you use is up to you.</p><p>For illustrative purposes, we’ll show what outputting to a logger looks like using the <a href="https://github.com/SergiusTheBest/plog">plog</a> logger. Plog is implemented as a set of header files, so it’s easy to include anywhere you need it, and it’s lightweight and easy to use.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <plog log.h=""> // Step 1: include the logger headers</plog></code><code>#include <plog initializers="" rollingfileinitializer.h=""></plog></code><code></code><code>int getUserInput()</code><code>{</code><code>	PLOGD &lt;&lt; "getUserInput() called"; // PLOGD is defined by the plog library</code><code></code><code>	std::cout &lt;&lt; "Enter a number: ";</code><code>	int x{};</code><code>	std::cin &gt;&gt; x;</code><code>	return x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	plog::init(plog::debug, "Logfile.txt"); // Step 2: initialize the logger</code><code></code><code>	PLOGD &lt;&lt; "main() called"; // Step 3: Output to the log as if you were writing to the console</code><code></code><code>	int x{ getUserInput() };</code><code>	std::cout &lt;&lt; "You entered: " &lt;&lt; x;</code><code></code><code>	return 0;</code><code>}</code></pre><p>Here’s output from the above logger (in the <code>Logfile.txt</code> file):</p><pre>2018-12-26 20:03:33.295 DEBUG [4752] [<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="472a262e29077673">[email&nbsp;protected]</a>] main() called
2018-12-26 20:03:33.296 DEBUG [4752] [<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="91f6f4e5c4e2f4e3d8ffe1e4e5d1a5">[email&nbsp;protected]</a>] getUserInput() called
</pre><p>How you include, initialize, and use a logger will vary depending on the specific logger you select.</p><p>Note that conditional compilation directives are also not required using this method, as most loggers have a method to reduce/eliminate writing output to the log. This makes the code a lot easier to read, as the conditional compilation lines add a lot of clutter. With plog, logging can be temporarily disabled by changing the init statement to the following:</p><pre class="language-cpp line-numbers"><code>	plog::init(plog::none , "Logfile.txt"); // plog::none eliminates writing of most messages, essentially turning logging off</code></pre><p>We won’t use plog in any future lessons, so you don’t need to worry about learning it.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>If you want to compile the above example yourself, or use plog in your own projects, you can follow these instructions to install it:</p><p>First, get the latest plog release:</p><ul><li>Visit the <a href="https://github.com/SergiusTheBest/plog">plog</a> repo.</li><li>Click the green Code button in the top right corner, and choose “Download zip”</li></ul><p>Next, unzip the entire archive to <code>somewhere</code> on your hard drive.</p><p>Finally, for each project, set the <code>somewhere\plog-master\include\</code> directory as an <code>include directory</code> inside your IDE. There are instructions on how to do this for Visual Studio here: <a href="https://www.learncpp.com/cpp-tutorial/a2-using-libraries-with-visual-studio-2005-express/">A.2 -- Using libraries with Visual Studio</a> and Code::Blocks here: <a href="https://www.learncpp.com/cpp-tutorial/a3-using-libraries-with-codeblocks/">A.3 -- Using libraries with Code::Blocks</a>.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">3.6 — Using an integrated debugger: Stepping</h1></header><div class="entry-content" itemprop="articleBody"><p>When you run your program, execution begins at the top of the <em>main</em> function, and then proceeds sequentially statement by statement, until the program ends. At any point in time while your program is running, the program is keeping track of a lot of things: the value of the variables you’re using, which functions have been called (so that when those functions return, the program will know where to go back to), and the current point of execution within the program (so it knows which statement to execute next). All of this tracked information is called your <span class="cpp-definition">program state</span> (or just <em>state</em>, for short).</p><p>In previous lessons, we explored various ways to alter your code to help with debugging, including printing diagnostic information or using a logger. These are simple methods for examining the state of a program while it is running. Although these can be effective if used properly, they still have downsides: they require altering your code, which takes time and can introduce new bugs, and they clutter your code, making the existing code harder to understand.</p><p>Behind the techniques we’ve shown so far is an unstated assumption: that once we run the code, it will run to completion (only pausing to accept input) with no opportunity for us to intervene and inspect the results of the program at whatever point we want.</p><p>However, what if we were able to remove this assumption? Fortunately, most modern IDEs come with an integrated tool called a debugger that is designed to do exactly this.</p><br><h3>The debugger</h3><p>A <span class="cpp-definition">debugger</span> is a computer program that allows the programmer to control how another program executes and examine the program state while that program is running. For example, the programmer can use a debugger to execute a program line by line, examining the value of variables along the way. By comparing the actual value of variables to what is expected, or watching the path of execution through the code, the debugger can help immensely in tracking down semantic (logic) errors.</p><p>The power behind the debugger is twofold: the ability to precisely control execution of the program, and the ability to view (and modify, if desired) the program’s state.</p><p>Early debuggers, such as <a href="https://en.wikipedia.org/wiki/Gdb">gdb</a>, were separate programs that had command-line interfaces, where the programmer had to type arcane commands to make them work. Later debuggers (such as early versions of Borland’s <a href="https://en.wikipedia.org/wiki/Turbo_Debugger">turbo debugger</a>) were still standalone, but came with their own “graphical” front ends to make working with them easier. Many modern IDEs available these days have an <span class="cpp-definition">integrated debugger</span> -- that is, a debugger uses the same interface as the code editor, so you can debug using the same environment that you use to write your code (rather than having to switch programs).</p><p>While integrated debuggers are highly convenient and recommended for beginners, command line debuggers are well supported and commonly used in environments that do not support graphical interfaces (e.g. embedded systems).</p><p>Nearly all modern debuggers contain the same standard set of basic features -- however, there is little consistency in terms of how the menus to access these features are arranged, and even less consistency in the keyboard shortcuts. Although our examples will use screenshots from Microsoft Visual Studio (and we’ll cover how to do everything in Code::Blocks as well), you should have little trouble figuring out how to access each feature we discuss no matter which IDE you are using.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>Debugger keyboard shortcuts will only work if the IDE/integrated debugger is the active window.</p></div><p>The remainder of this chapter will be spent learning how to use the debugger.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>Don’t neglect learning to use a debugger. As your programs get more complicated, the amount of time you spend learning to use the integrated debugger effectively will pale in comparison to amount of time you save finding and fixing issues.</p></div><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Before proceeding with this lesson (and subsequent lessons related to using a debugger), make sure your project is compiled using a debug build configuration (see <a href="https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-build-configurations/">0.9 -- Configuring your compiler: Build configurations</a> for more information).</p><p>If you’re compiling your project using a release configuration instead, the functionality of the debugger may not work correctly (e.g. when you try to step into your program, it will just run the program instead).</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>If you’re using Code::Blocks, your debugger may or may not be set up correctly. Let’s check.</p><p>First, go to <em>Settings menu &gt; Debugger…</em>. Next, open the <em>GDB/CDB debugger</em> tree on the left, and choose <em>Default</em>. A dialog should open that looks something like this:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/CB-DebuggingSetup-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/CB-DebuggingSetup-min.png"></div><p>If you see a big red bar where the “Executable path” should be, then you need to locate your debugger. To do so, click the <em>…</em> button to the right of the <em>Executable path</em> field. Next, find the “gdb32.exe” file on your system -- mine was in <em>C:\Program Files (x86)\CodeBlocks\MinGW\bin\gdb32.exe</em>. Then click <em>OK</em>.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>There have been reports that the Code::Blocks integrated debugger (GDB) can have issues recognizing some file paths that contain spaces or non-English characters in them. If the debugger appears to be malfunctioning as you go through these lessons, that could be a reason why.</p></div><br><h3>Stepping</h3><p>We’re going to start our exploration of the debugger by first examining some of the debugging tools that allow us to control the way a program executes.</p><p><span class="cpp-definition">Stepping</span> is the name for a set of related debugger features that let us execute (step through) our code statement by statement.</p><p>There are a number of related stepping commands that we’ll cover in turn.</p><br><h3>Step into</h3><p>The <span class="cpp-definition">step into</span> command executes the next statement in the normal execution path of the program, and then pauses execution of the program so we can examine the program’s state using the debugger. If the statement being executed contains a function call, <em>step into</em> causes the program to jump to the top of the function being called, where it will pause.</p><p>Let’s take a look at a very simple program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printValue(int value)</code><code>{</code><code>    std::cout &lt;&lt; value &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printValue(5);</code><code></code><code>    return 0;</code><code>}</code></pre><p>Let’s debug this program using the <em>step into</em> command.</p><p>First, locate and then execute the <em>step into</em> debug command once.</p><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>In Visual Studio, the <em>step into</em> command can be accessed via <em>Debug menu &gt; Step Into</em>, or by pressing the F11 shortcut key.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>In Code::Blocks, the <em>step into</em> command can be accessed via <em>Debug menu &gt; Step into</em>, or by pressing the Shift-F7</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For other compilers</h4><p>If using a different IDE, you’ll likely find the <em>step into</em> command under a Debug or Run menu.</p></div><p>When your program isn’t running and you execute the first debug command, you may see quite a few things happen:</p><ul><li>The program will recompile if needed.</li><li>The program will begin to run. Because our application is a console program, a console output window should open. It will be empty because we haven’t output anything yet.</li><li>Your IDE may open some diagnostic windows, which may have names such as “Diagnostic Tools”, “Call Stack”, and “Watch”. We’ll cover what some of these are later -- for now you can ignore them.</li></ul><p>Because we did a <em>step into</em>, you should now see some kind of marker appear to the left of the opening brace of function <em>main</em> (line 9). In Visual Studio, this marker is a yellow arrow (Code::Blocks uses a yellow triangle). If you are using a different IDE, you should see something that serves the same purpose.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS2019-StepInto-Line9-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS2019-StepInto-Line9-min.png"></div><p>This arrow marker indicates that the line being pointed to will be executed next. In this case, the debugger is telling us that the next line to be executed is the opening brace of function <em>main</em> (line 9).</p><p>Choose <em>step into</em> (using the appropriate command for your IDE, listed above) to execute the opening brace, and the arrow will move to the next statement (line 10).</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS2019-StepInto-Line10-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS2019-StepInto-Line10-min.png"></div><p>This means the next line that will be executed is the call to function <em>printValue</em>.</p><p>Choose <em>step into</em> again. Because this statement contains a function call to <em>printValue</em>, we step into the function, and the arrow will move to the top of the body of <em>printValue</em> (line 4).</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS2019-StepInto-Line4-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS2019-StepInto-Line4-min.png"></div><p>Choose <em>step into</em> again to execute the opening brace of function <em>printValue</em>, which will advance the arrow to line 5.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS2019-StepInto-Line5-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS2019-StepInto-Line5-min.png"></div><p>Choose <em>step into</em> yet again, which will execute the statement <code>std::cout &lt;&lt; value</code> and move the arrow to line 6.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Because operator&lt;&lt; is implemented as a function, your IDE may step into the implementation of operator&lt;&lt; instead.</p><p>If this happens, you’ll see your IDE open a new code file, and the arrow marker will move to the top of a function named operator&lt;&lt; (this is part of the standard library). Close the code file that just opened, then find and execute <em>step out</em> debug command (instructions are below under the “step out” section, if you need help).</p></div><p>Now because <code>std::cout &lt;&lt; value</code> has executed, we should see the value <em>5</em> appear in the console window.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>In a prior lesson, we mentioned that std::cout is buffered, which means there may be a delay between when you ask std::cout to print a value, and when it actually does. Because of this, you may not see the value 5 appear at this point. To ensure that all output from std::cout is output immediately, you can temporarily add the following statement to the top of your main() function:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; std::unitbuf; // enable automatic flushing for std::cout (for debugging)</code></pre><p>For performance reasons, this statement should be removed or commented out after debugging.</p><p>If you don’t want to continually add/remove/comment/uncomment the above, you can wrap the statement in a conditional compilation preprocessor directive (covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-the-preprocessor/">2.10 -- Introduction to the preprocessor</a>):</p><pre class="language-cpp line-numbers"><code>#ifdef DEBUG</code><code>std::cout &lt;&lt; std::unitbuf; // enable automatic flushing for std::cout (for debugging)</code><code>#endif</code></pre><p>You’ll need to make sure the DEBUG preprocessor macro is defined, either somewhere above this statement, or as part of your compiler settings.</p></div><p>Choose <em>step into</em> again to execute the closing brace of function <em>printValue</em>. At this point, <em>printValue</em> has finished executing and control is returned to <em>main</em>.</p><p>You will note that the arrow is again pointing to <em>printValue</em>!</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS2019-StepInto-Line10-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS2019-StepInto-Line10-min.png"></div><p>While you might think that the debugger intends to call <em>printValue</em> again, in actuality the debugger is just letting you know that it is returning from the function call.</p><p>Choose <em>step into</em> three more times. At this point, we have executed all the lines in our program, so we are done. Some debuggers will terminate the debugging session automatically at this point, others may not. If your debugger does not, you may need to find a “Stop Debugging” command in your menus (in Visual Studio, this is under <em>Debug &gt; Stop Debugging</em>).</p><p>Note that <em>Stop Debugging</em> can be used at any point in the debugging process to end the debugging session.</p><p>Congratulations, you’ve now stepped through a program and watched every line execute!</p><br><h3>Step over</h3><p>Like <em>step into</em>, The <strong>step over</strong> command executes the next statement in the normal execution path of the program. However, whereas <em>step into</em> will enter function calls and execute them line by line, <em>step over</em> will execute an entire function without stopping and return control to you after the function has been executed.</p><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>In Visual Studio, the <em>step over</em> command can be accessed via <em>Debug menu &gt; Step Over</em>, or by pressing the F10 shortcut key.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>In Code::Blocks, the <em>step over</em> command is called <em>Next line</em> instead, and can be accessed via <em>Debug menu &gt; Next line</em>, or by pressing the F7 shortcut key.</p></div><p>Let’s take a look at an example where we step over the function call to <em>printValue</em>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printValue(int value)</code><code>{</code><code>    std::cout &lt;&lt; value &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printValue(5);</code><code></code><code>    return 0;</code><code>}</code></pre><p>First, use <em>step into</em> on your program until the execution marker is on line 10:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS2019-StepInto-Line10-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS2019-StepInto-Line10-min.png"></div><p>Now, choose <em>step over</em>. The debugger will execute the function (which prints the value <em>5</em> in the console output window) and then return control to you on the next statement (line 12).</p><p>The <em>step over</em> command provides a convenient way to skip functions when you are sure they already work or are not interested in debugging them right now.</p><br><h3>Step out</h3><p>Unlike the other two stepping commands, <span class="cpp-definition">Step out</span> does not just execute the next line of code. Instead, it executes all remaining code in the function currently being executed, and then returns control to you when the function has returned.</p><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>In Visual Studio, the <em>step out</em> command can be accessed via <em>Debug menu &gt; Step Out</em>, or by pressing the Shift-F11 shortcut combo.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>In Code::Blocks, the <em>step out</em> command can be accessed via <em>Debug menu &gt; Step out</em>, or by pressing the ctrl-F7 shortcut combo.</p></div><p>Let’s take a look at an example of this using the same program as above:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printValue(int value)</code><code>{</code><code>    std::cout &lt;&lt; value &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printValue(5);</code><code></code><code>    return 0;</code><code>}</code></pre><p><em>Step into</em> the program until you are inside function <em>printValue</em>, with the execution marker on line 4.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS2019-StepInto-Line4-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS2019-StepInto-Line4-min.png"></div><p>Then choose <em>step out</em>. You will notice the value <em>5</em> appears in the output window, and the debugger returns control to you after the function has terminated (on line 10).</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS2019-StepInto-Line10-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS2019-StepInto-Line10-min.png"></div><p>This command is most useful when you’ve accidentally stepped into a function that you don’t want to debug.</p><br><h3>A step too far</h3><p>When stepping through a program, you can normally only step forward. It’s very easy to accidentally step past (overstep) the place you wanted to examine.</p><p>If you step past your intended destination, the usual thing to do is stop debugging and restart debugging again, being a little more careful not to pass your target this time.</p><br><h3>Step back</h3><p>Some debuggers (such as Visual Studio Enterprise Edition and GDB 7.0) have introduced a stepping capability generally referred to as <em>step back</em> or <em>reverse debugging</em>. The goal of a <em>step back</em> is to rewind the last step, so you can return the program to a prior state. This can be useful if you overstep, or if you want to re-examine a statement that just executed.</p><p>Implementing <em>step back</em> requires a great deal of sophistication on the part of the debugger (because it has to keep track of a separate program state for each step). Because of the complexity, this capability isn’t standardized yet, and varies by debugger. As of the time of writing (Jan 2019), neither Visual Studio Community edition nor the latest version of Code::Blocks support this capability. Hopefully at some point in the future, it will trickle down into these products and be available for wider use.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">3.7 — Using an integrated debugger: Running and breakpoints</h1></header><div class="entry-content" itemprop="articleBody"><p>While stepping (covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/using-an-integrated-debugger-stepping/">3.6 -- Using an integrated debugger: Stepping</a>) is useful for examining each individual line of your code in isolation, in a large program, it can take a long time to step through your code to even get to the point where you want to examine in more detail.</p><p>Fortunately, modern debuggers provide more tools to help us efficiently debug our programs. In this lesson, we’ll look at some of the debugger features that let us more quickly navigate our code.</p><br><h3>Run to cursor</h3><p>The first useful command is commonly called <em>Run to cursor</em>. This <span class="cpp-definition">Run to cursor</span> command executes the program until execution reaches the statement selected by your cursor. Then it returns control to you so you can debug starting at that point. This makes for an efficient way to start debugging at a particular point in your code, or if already debugging, to move straight to some place you want to examine further.</p><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>In Visual Studio, the <em>run to cursor</em> command can be accessed by right clicking a statement in your code and choosing <em>Run to Cursor</em> from the context menu, or by pressing the ctrl-F10 keyboard combo.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>In Code::Blocks, the <em>run to cursor</em> command can be accessed by right clicking a statement in your code and choosing either <em>Run to cursor</em> from the context menu or <em>Debug menu &gt; Run to cursor</em>, or by pressing the F4 shortcut key.</p></div><p>Let’s try it using the same program we’ve been using:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printValue(int value)</code><code>{</code><code>    std::cout &lt;&lt; value;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printValue(5);</code><code></code><code>    return 0;</code><code>}</code></pre><p>Simply right click anywhere on line 5, then choose “Run to cursor”.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-StepInto4-min.png?ezimgfmt=rs%3Adevice%2Frscb2-1" alt="" ezimgfmt="rs rscb2 src ng ngcb2" loading="eager" srcset="" sizes="" importance="high"></div><p>You will notice the program starts running, and the execution marker moves to the line you just selected. Your program has executed up to this point and is now waiting for your further debugging commands. From here, you can step through your program, <em>run to cursor</em> to a different location, etc…</p><p>If you <em>run to cursor</em> to a location that doesn’t execute, <em>run to cursor</em> will simply run your program until termination.</p><br><h3>Continue</h3><p>Once you’re in the middle of a debugging session, you may want to just run the program from that point forward. The easiest way to do this is to use the <em>continue</em> command. The <span class="cpp-definition">continue</span> debug command simply continues running the program as per normal, either until the program terminates, or until something triggers control to return back to you again (such as a breakpoint, which we’ll cover later in this lesson).</p><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>In Visual Studio, the <em>continue</em> command can be accessed while already debugging a program via <em>Debug menu &gt; Continue</em>, or by pressing the F5 shortcut key.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>In Code::Blocks, the <em>continue</em> command can be accessed while already debugging a program via <em>Debug menu &gt; Start / Continue</em>, or by pressing the F8 shortcut key.</p></div><p>Let’s test out the <em>continue</em> command. If your execution marker isn’t already on line 5, <em>run to cursor</em> to line 5. Then choose <em>continue</em> from this point. Your program will finish executing and then terminate.</p><br><h3>Start</h3><p>The <em>continue</em> command has a twin brother named <em>start</em>. The <em>start</em> command performs the same action as <em>continue</em>, just starting from the beginning of the program. It can only be invoked when not already in a debug session.</p><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>In Visual Studio, the <em>start</em> command can be accessed while not debugging a program via <em>Debug menu &gt; Start Debugging</em>, or by pressing the F5 shortcut key.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>In Code::Blocks, the <em>start</em> command can be accessed while not debugging a program via <em>Debug menu &gt; Start / Continue</em>, or by pressing the F8 shortcut key.</p></div><p>If you use the <em>start</em> command on the above sample program, it will run all the way through without interruption. While this may seem unremarkable, that’s only because we haven’t told the debugger to interrupt the program. We’ll put this command to better use in the next section.</p><br><h3>Breakpoints</h3><p>The last topic we are going to talk about in this section is breakpoints. A <span class="cpp-definition">breakpoint</span> is a special marker that tells the debugger to stop execution of the program at the breakpoint when running in debug mode.</p><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>In Visual Studio, you can set or remove a breakpoint via <em>Debug menu &gt; Toggle Breakpoint</em>, or by right clicking on a statement and choosing <em>Toggle Breakpoint</em> from the context menu, or by pressing the F9 shortcut key, or by clicking to the left of the line number (in the light grey area).</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>In Code::Blocks, you can set or remove a breakpoint via <em>Debug menu &gt; Toggle breakpoint</em>, or by right clicking on a statement and choosing <em>Toggle breakpoint</em> from the context menu, or by pressing the F5 shortcut key, or by clicking to the right of the line number.</p></div><p>When you set a breakpoint, you will see a new type of icon appear. Visual Studio uses a red circle, Code::Blocks uses a red octagon (like a stop sign):</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Breakpoint1-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Breakpoint1-min.png"></div><p>Go ahead and set a breakpoint on the line 5, as shown in the image above.</p><p>Now, choose the <em>Start</em> command to have the debugger run your code, and let’s see the breakpoint in action. You will notice that instead of running all the way to the end of the program, the debugger stops at the breakpoint (with the execution marker sitting on top of the breakpoint icon):</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Breakpoint2-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Breakpoint2-min.png"></div><p>It’s just as if you’d <em>run to cursor</em> to this point.</p><p>Breakpoints have a couple of advantages over <em>run to cursor</em>. First, a breakpoint will cause the debugger to return control to you every time they are encountered (unlike <em>run to cursor</em>, which only runs to the cursor once each time it is invoked). Second, you can set a breakpoint and it will persist until you remove it, whereas with <em>run to cursor</em> you have to locate the spot you want to run to each time you invoke the command.</p><p>Note that breakpoints placed on lines that are not in the path of execution will not cause the debugger to halt execution of the code.</p><p>Let’s take a look at a slightly modified program that better illustrates the difference between breakpoints and <em>run to cursor</em>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printValue(int value)</code><code>{</code><code>    std::cout &lt;&lt; value;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printValue(5);</code><code>    printValue(6);</code><code>    printValue(7);</code><code></code><code>    return 0;</code><code>}</code></pre><p>First, start a new debugging session and then do a <em>run to cursor</em> to line 5. Now choose <em>continue</em>. The program will continue to the end (it won’t stop on line 5 again, even though line 5 is executed twice more).</p><p>Next, place a breakpoint on line 5, then choose <em>start</em>. The program will stop on line 5. Now choose <em>continue</em>. The program will stop on line 5 a second time. Choose <em>continue</em> again, and it will stop a third time. One more <em>continue</em>, and the program will terminate. You can see that the breakpoint caused the program to stop as many times as that line was executed.</p><br><h3>Set next statement</h3><p>There’s one more debugging command that’s used fairly uncommonly, but is still at least worth knowing about, even if you won’t use it very often. The <span class="cpp-definition">set next statement</span> command allows us to change the point of execution to some other statement (sometimes informally called <em>jumping</em>). This can be used to jump the point of execution forwards and skip some code that would otherwise execute, or backwards and have something that already executed run again.</p><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>In Visual Studio, you can jump the point of execution by right clicking on a statement and choosing <em>Set next statement</em> from the context menu, or by pressing the Ctrl-Shift-F10 shortcut combination. This option is contextual and only occurs while already debugging a program.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>In Code::Blocks, you can jump the point of execution via <em>Debug menu &gt; Set next statement</em>, or by right clicking on a statement and choosing <em>Set next statement</em> from the context menu. Code::Blocks doesn’t have a keyboard shortcut for this command.</p></div><p>Let’s see jumping forwards in action:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printValue(int value)</code><code>{</code><code>    std::cout &lt;&lt; value;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printValue(5);</code><code>    printValue(6);</code><code>    printValue(7);</code><code></code><code>    return 0;</code><code>}</code></pre><p>First, <em>run to cursor</em> to line 11. At this point, you should see the value of <em>5</em> in the console output window.</p><p>Now, right click on line 12, and choose <em>set next statement</em>. This causes line 11 to be skipped and not execute. Then choose <em>continue</em> to finish executing your program.</p><p>The output of your program should look like this:</p><pre>57
</pre><p>We can see that <code>printValue(6)</code> was skipped.</p><p>This functionality can be useful in several contexts.</p><p>In our exploration of basic debugging techniques, we discussed commenting out a function as a way to determine whether that function had a role in causing an issue. This requires modifying our code, and remembering to uncomment the function later. In the debugger, there’s no direct way to skip a function, so if you decide you want to do this, using <em>set next statement</em> to jump over a function call is the easiest way to do so.</p><p>Jumping backwards can also be useful if we want to watch a function that just executed run again, so we can see what it is doing.</p><p>With the same code above, <em>run to cursor</em> to line 12. Then <em>set next statement</em> on line 11, and <em>continue</em>. The program’s output should be:</p><pre>5667
</pre><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>The <em>set next statement</em> command will change the point of execution, but will not otherwise change the program state. Your variables will retain whatever values they had before the jump. As a result, jumping may cause your program to produce different values, results, or behaviors than it would otherwise. Use this capability judiciously (especially jumping backwards).</p></div><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>You should not use <em>set next statement</em> to change the point of execution to a different function. This will result in undefined behavior, and likely a crash.</p></div><br><h3>Conclusion</h3><p>You now learned the major ways that you can use an integrated debugger to watch and control how your program executes. While these commands can be useful for diagnosing code flow issues (e.g. to determine if certain functions are or aren’t being called), they are only a portion of the benefit that the integrated debugger brings to the table. In the next lesson, we’ll start exploring additional ways to examine your program’s state, for which you’ll need these commands as a prerequisite. Let’s go!</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">3.8 — Using an integrated debugger: Watching variables</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lessons (<a href="https://www.learncpp.com/cpp-tutorial/using-an-integrated-debugger-stepping/">3.6 -- Using an integrated debugger: Stepping</a> and <a href="https://www.learncpp.com/cpp-tutorial/using-an-integrated-debugger-running-and-breakpoints/">3.7 -- Using an integrated debugger: Running and breakpoints</a>), you learned how to use the debugger to watch the path of execution through your program. However, stepping through a program is only half of what makes the debugger useful. The debugger also lets you examine the value of variables as you step through your code, all without having to modify your code.</p><p>As per previous lessons, our examples here will use Visual Studio -- if you are using a different IDE/debugger, the commands may have slightly different names or be located in different locations.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>In case you are returning, make sure your project is compiled using a debug build configuration (see <a href="https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-build-configurations/">0.9 -- Configuring your compiler: Build configurations</a> for more information). If you’re compiling your project using a release configuration instead, the functionality of the debugger may not work correctly.</p></div><br><h3>Watching variables</h3><p><span class="cpp-definition">Watching a variable</span> is the process of inspecting the value of a variable while the program is executing in debug mode. Most debuggers provide several ways to do this.</p><p>Let’s take a look at a sample program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	int x{ 1 };</code><code>	std::cout &lt;&lt; x &lt;&lt; ' ';</code><code></code><code>	x = x + 2;</code><code>	std::cout &lt;&lt; x &lt;&lt; ' ';</code><code></code><code>	x = x + 3;</code><code>	std::cout &lt;&lt; x &lt;&lt; ' ';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This is a pretty straightforward sample program -- it prints the numbers 1, 3, and 6.</p><p>First, <em>run to cursor</em> to line 6.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Watch1-min.png?ezimgfmt=rs%3Adevice%2Frscb2-1" alt="" ezimgfmt="rs rscb2 src ng ngcb2" loading="eager" srcset="" sizes="" importance="high"></div><p>At this point, the variable x has already been created and initialized with the value 1, so when we examine the value of x, we should expect to see the value 1.</p><p>The easiest way to examine the value of a simple variable like x is to hover your mouse over the variable x. Some modern debuggers support this method of inspecting simple variables, and it is the most straightforward way to do so.</p><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>If you’re using Code::Blocks, this option is (inexplicably) off by default. Let’s turn it on. First, go to <em>Settings menu &gt; Debugger…</em>. Then under the <em>GDB/CDB debugger node</em>, select the <em>Default</em> profile. Finally, check the box labeled <em>Evaluate expression under cursor</em>.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/CB-EvaluateExpression-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/CB-EvaluateExpression-min.png"></div></div><p>Hover your mouse cursor over variable x on line 6, and you should see something like this:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Watch2-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Watch2-min.png"></div><p>Note that you can hover over any variable x, not just the one on the current line. For example, if we hover over the x on line 12, we’ll see the same value:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Watch3-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Watch3-min.png"></div><p>If you’re using Visual Studio, you can also use QuickWatch. Highlight the variable name x with your mouse, and then choose “QuickWatch” from the right-click menu.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-QuickWatch1-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-QuickWatch1-min.png"></div><p>This will pull up a subwindow containing the current value of the variable:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-QuickWatch2-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-QuickWatch2-min.png"></div><p>Go ahead and close QuickWatch if you opened it.</p><p>Now let’s watch this variable change as we step through the program. Either choose <em>step over</em> twice, or <em>run to cursor</em> to line 9. The variable x should now have value <em>3</em>. Inspect it and make sure that it does!</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Watch4-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Watch4-min.png"></div><br><h3>The watch window</h3><p>Using the mouse hover or QuickWatch methods to inspect variables is fine if you want to know the value of a variable at a particular point in time, but it’s not particularly well suited to watching the value of a variable change as you run the code because you continually have to rehover/reselect the variable.</p><p>In order to address this issue, all modern integrated debuggers provide another feature, called a watch window. The <span class="cpp-definition">watch window</span> is a window where you can add variables you would like to continually inspect, and these variables will be updated as you step through your program. The watch window may already be on your screen when you enter debug mode, but if it is not, you can bring it up through your IDE’s window commands (these are typically found in a View or Debug menu).</p><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>In Visual Studio, the watch menu can be found at <em>Debug menu &gt; Windows &gt; Watch &gt; Watch 1</em>. Do note that you have to be in debug mode for this option to be enabled, so <em>step into</em> your program first.</p><p>Where this window appears (docked left, right, or bottom) may vary. You can change where it is docked by dragging the <em>Watch 1</em> tab to a different side of the application window.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>In Code::Blocks, the watch menu can be found at <em>Debug menu &gt; Debugging windows &gt; Watches</em>. This window will likely appear as a separate window. You can dock it into your main window by dragging it over.</p></div><p>You should now see something like this:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Watch5-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Watch5-min.png"></div><p>The watches window may or may not contain anything in it already.</p><p>There are typically two different ways to add variables to the watch window:</p><ol><li>Pull up the watch window, and type in the name of the variable you would like to watch in the leftmost column of the watch window.</li><li>In the code window, right click on the variable you’d like to watch, and choose <em>Add Watch</em> (Visual Studio) or <em>Watch x</em> (replace x with the variable’s name) (Code::Blocks).</li></ol><p>If you’re not already in a debugging session with the execution marker on line 9 of your program, start a new debugging session and <em>run to cursor</em> to line 9.</p><p>Now, go ahead and add the variable “x” to your watch list. You should now see this:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Watch6-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-Watch6-min.png"></div><p>Now <em>step over</em> twice, or <em>run to cursor</em> to line 12, and you should see the value of <em>x</em> change from <em>3</em> to <em>6</em>.</p><p>Variables that go out of scope (e.g. a local variable inside a function that has already returned to the caller) will stay in your watch window, but will generally either be marked as “not available”, or may show the last known value but grayed out. If the variable returns to scope (e.g. the function is called again), its value will begin showing again. Therefore, it’s fine to leave variables in the watch window, even if they’re out of scope.</p><p>Using watches is the best way to watch the value of a variable change over time as you step through your program.</p><br><h3>The watch window can evaluate expressions too</h3><p>The watch window will also allow you to evaluate simple expressions. If you haven’t already, <em>run to cursor</em> to line 12. Then try entering <em>x + 2</em> into the watch window and see what happens (it should evaluate to 8).</p><p>You can also highlight an expression in your code and then inspect the value of that expression via hover or by adding it to the watch window via the right-click context menu.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Identifiers in watched expressions will evaluate to their current values. If you want to know what value an expression in your code is actually evaluating to, <em>run to cursor</em> to it first, so that all identifiers have the correct values.</p></div><br><h3>Local watches</h3><p>Because inspecting the value of local variables inside a function is common while debugging, many debuggers will offer some way to quickly watch the value of <em>all</em> local variables in scope.</p><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>In Visual Studio, you can see the value of all local variables in the <em>Locals</em> window, which can be found at <em>Debug menu &gt; Windows &gt; Locals</em>. Note that you have to be in a debug session to activate this window.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>In Code::Blocks, this is integrated into the <em>Watch</em> window, under the <em>Locals</em> node. If you don’t see any, there either aren’t any, or you need to uncollapse the node.</p></div><p>If you’re just looking to watch the value of a local variable, check the <em>locals</em> window first. It should already be there.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">3.9 — Using an integrated debugger: The call stack</h1></header><div class="entry-content" itemprop="articleBody"><p>Modern debuggers contain one more debugging information window that can be very useful in debugging your program, and that is the call stack window.</p><p>When your program calls a function, you already know that it bookmarks the current location, makes the function call, and then returns. How does it know where to return to? The answer is that it keeps track in the call stack.</p><p>The <span class="cpp-definition">call stack</span> is a list of all the active functions that have been called to get to the current point of execution. The call stack includes an entry for each function called, as well as which line of code will be returned to when the function returns. Whenever a new function is called, that function is added to the top of the call stack. When the current function returns to the caller, it is removed from the top of the call stack, and control returns to the function just below it.</p><p>The <span class="cpp-definition">call stack window</span> is a debugger window that shows the current call stack. If you don’t see the call stack window, you will need to tell the IDE to show it.</p><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>In Visual Studio, the call stack window can be found via <em>Debug menu &gt; Windows &gt; Call Stack</em>. Note that you have to be in a debug session to activate this window.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Code::Blocks users</h4><p>In Code::Blocks, the call stack window can be found via <em>Debug menu &gt; Debugging windows &gt; Call stack</em>.</p></div><p>Let’s take a look at the call stack using a sample program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void a()</code><code>{</code><code>	std::cout &lt;&lt; "a() called\n";</code><code>}</code><code></code><code>void b()</code><code>{</code><code>	std::cout &lt;&lt; "b() called\n";</code><code>	a();</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	a();</code><code>	b();</code><code></code><code>	return 0;</code><code>}</code></pre><p>Put breakpoints on lines 5 and 10 of this program, and then start debugging mode. Because function <em>a</em> is called first, the breakpoint on line 5 will be hit first.</p><p>At this point, you should see something like this:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-CallStack1-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-CallStack1-min.png"></div><p>Note that your line numbers may be slightly different (off by 1), and that instead of <em>[External Code]</em> you may see a bunch of other crazily named functions. These differences are insubstantial.</p><p>What’s relevant here is the top two lines. From the bottom up, we can see that function <em>main</em> was called first, and then that function <em>a</em> was called next.</p><p>The <em>line 5</em> next to function <em>a</em> shows us where the current point of execution is (which matches the execution marker in the code window). The <em>line 17</em> on the second line indicates the line that will be returned to when control returns to function <em>main</em>.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>The line numbers after the function names show the next line to be executed in each function.</p><p>Since the top entry on the call stack represents the currently executing function, the line number here shows the next line that will execute when execution resumes. The remaining entries in the call stack represent functions that will be returned to at some point, so the line number for these represent the next statement that will execute after the function is returned to.</p></div><p>Now, choose the <em>continue</em> debug command to advance execution to the next breakpoint, which will be on line 10. The call stack should update to reflect the new situation:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-CallStack2-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-CallStack2-min.png"></div><p>You’ll notice that function <em>b</em> is now the top line of the call stack, reflecting the fact that function <em>b</em> is the function that is actively being executed. Note that function <em>a</em> is no longer represented on the call stack. This is because function <em>a</em> was removed from the call stack when it returned.</p><p>Choose the <em>continue</em> debug command one more time, and we’ll hit the breakpoint on line 5 again (because function <em>b</em> calls function <em>a</em>). The call stack will look like this:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-CallStack3-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Chapter3/VS-CallStack3-min.png"></div><p>There are now three functions on the call stack: (from bottom to top) <em>main</em>, which called function <em>b</em>, which called function <em>a</em>.</p><p>The call stack is useful in conjunction with breakpoints, when your breakpoint is hit and you want to know what functions were called to get to that specific point in the code.</p><br><h3>Conclusion</h3><p>Congratulations, you now know the basics of using an integrated debugger! Using stepping, breakpoints, watches, and the call stack window, you now have the fundamentals to be able to debug almost any problem. Like many things, becoming good at using a debugger takes some practice and some trial and error. But again, we’ll reiterate the point that the time devoted to learning how to use an integrated debugger effectively will be repaid many times over in time saved debugging your programs!</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">3.10 — Finding issues before they become problems</h1></header><div class="entry-content" itemprop="articleBody"><p>When you make a semantic error, that error may or may not be immediately noticeable when you run your program. An issue may lurk undetected in your code for a long time before newly introduced code or changed circumstances cause it to manifest as a program malfunction. The longer an error sits in the code base before it is found, the more likely it is to be hard to find, and something that may have been easy to fix originally turns into a debugging adventure that eats up time and energy.</p><p>So what can we do about that?</p><br><h3>Don’t make errors</h3><p>Well, the best thing is to not make errors in the first place. Here’s an incomplete list of things that can help avoid making errors:</p><ul><li>Follow best practices</li><li>Don’t program when tired</li><li>Understand where the common pitfalls are in a language (all those things we warn you not to do)</li><li>Keep your programs simple</li><li>Don’t let your functions get too long</li><li>Prefer using the standard library to writing your own code, when possible</li><li>Comment your code liberally</li></ul><br><h3>Refactoring your code</h3><p>As you add new capabilities to your programs (“behavioral changes”), you will find that some of your functions grow in length. As functions get longer, they get both more complex and harder to understand.</p><p>One way to address this is to break a single long function into multiple shorter functions. This process of making structural changes to your code without changing its behavior (typically in order to make your program more organized, modular, or performant) is called <span class="cpp-definition">refactoring</span>.</p><p>So how long is too long for a function? A function that takes up one vertical screen worth of code is generally regarded as far too long -- if you have to scroll to read the whole function, the function’s comprehensibility drops significantly. But the shorter the better -- functions less than ten lines are good. Functions that are less than five lines are even better.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>When making changes to your code, make behavioral changes OR structural changes, and then retest for correctness. Making behavioral and structural changes at the same time tends to lead to more errors as well as errors that are harder to find.</p></div><br><h3>An introduction to defensive programming</h3><p>Errors can be not only of your own making (e.g. incorrect logic), but also occur when your users use the application in a way that you did not anticipate. For example, if you ask the user to enter an integer, and they enter a letter instead, how does your program behave in such a case? Unless you anticipated this, and added some error handling for this case, probably not very well.</p><p><span class="cpp-definition">Defensive programming</span> is a practice whereby the programmer tries to anticipate all of the ways the software could be misused, either by end-users, or by other developers (including the programmer themselves) using the code. These misuses can often be detected and then mitigated (e.g. by asking a user who entered bad input to try again).</p><p>We’ll explore topics related to error handling in future lessons.</p><br><h3>Finding errors fast</h3><p>Since not making errors is difficult in large programs, the next best thing is to catch errors you do make quickly.</p><p>The best way to do this is to program a little bit at a time, and then test your code and make sure it works.</p><p>However, there are a few other techniques we can also use.</p><br><h3>An introduction to testing functions</h3><p>One common way to help uncover issues with your program is to write testing functions to “exercise” the code you’ve written. Here’s a primitive attempt, more for illustrative purposes than anything:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y)</code><code>{</code><code>	return x + y;</code><code>}</code><code></code><code>void testadd()</code><code>{</code><code>	std::cout &lt;&lt; "This function should print: 2 0 0 -2\n";</code><code>	std::cout &lt;&lt; add(1, 1) &lt;&lt; ' ';</code><code>	std::cout &lt;&lt; add(-1, 1) &lt;&lt; ' ';</code><code>	std::cout &lt;&lt; add(1, -1) &lt;&lt; ' ';</code><code>	std::cout &lt;&lt; add(-1, -1) &lt;&lt; ' ';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	testadd();</code><code></code><code>	return 0;</code><code>}</code></pre><p>The testadd() function tests the add() function by calling it with different values. If all the values match our expectations, then we can be reasonably confident the function works. Even better, we can keep this function around, and run it any time we change function <em>add</em> to ensure we haven’t accidentally broken it.</p><p>This is a primitive form of <span class="cpp-definition">unit testing</span>, which is a software testing method by which small units of source code are tested to determine whether they are correct.</p><p>As with logging frameworks, there are many 3rd party unit testing frameworks that can be used. It’s also possible to write your own, though we’ll need more language features at our disposal to do the topic justice. We’ll come back to some of this in a future lesson.</p><br><h3>An introduction to constraints</h3><p>Constraints-based techniques involve the addition of some extra code (that can be compiled out in a non-debug build, if desired) to check that some set of assumptions or expectations are not violated.</p><p>For example, if we were writing a function to calculate the factorial of a number, which expects a non-negative argument, the function could check to make sure the caller passed in a non-negative number before proceeding. If the caller passes in a negative number, then the function could immediately error out rather than producing some indeterminate result, helping ensure the problem is caught immediately.</p><p>One common method of doing this is via <em>assert</em> and <em>static_assert</em>, which we cover in lesson <a href="https://www.learncpp.com/cpp-tutorial/assert-and-static_assert/">7.17 -- Assert and static_assert</a>.</p><br><h3>Shotgunning for general issues</h3><p>Programmers tend to make certain kinds of common mistakes, and some of those mistakes can be discovered by programs trained to look for them. These programs, generally known as <span class="cpp-definition">static analysis tools</span> (sometimes informally called <em>linters</em>) are programs that analyze your code to identify specific semantic issues (in this context, <em>static</em> means that these tools analyze the source code). The issues found by static analysis tools may or may not be the cause of any particular problem you are having, but may help point out fragile areas of code or issues that can be problematic in certain circumstances.</p><p>You already have one static analysis tool at your disposal -- your compiler! In addition to ensuring your program is syntactically correct, most modern C++ compilers will do some light static analysis to identify some common problems. For example, many compilers will warn you if you try to use a variable that has not been initialized. If you haven’t already, turning up your compiler warning and error levels (see lesson <a href="https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-warning-and-error-levels/">0.11 -- Configuring your compiler: Warning and error levels</a>) can help surface these.</p><p><a href="https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#C,_C++">Many static analysis tools exist</a>, some of which can identify over 300 types of programming errors. And on large programs, this can surface tens or hundreds of potential issues. On our small academic programs, use of a static analysis tool is optional (but may help you find areas where your code is non-compliant with best practices). On larger non-academic programs, use of a static analysis tool is highly recommended.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use a static analysis tool on your programs to help find areas where your code is non-compliant with best practices.</p></div><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>Visual Studio 2019 comes with a built-in static analysis tool. You can access it via <em>Build &gt; Run Code Analysis on Solution (Alt+F11)</em>.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">3.x — Chapter 3 summary and quiz</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Chapter Review</h3><p>A <span class="cpp-definition">syntax error</span> is an error that occurs when you write a statement that is not valid according to the grammar of the C++ language. The compiler will catch these.</p><p>A <span class="cpp-definition">semantic error</span> occurs when a statement is syntactically valid, but does not do what the programmer intended.</p><p>The process of finding and removing errors from a program is called <span class="cpp-definition">debugging</span>.</p><p>We can use a five step process to approach debugging:</p><ol><li>Find the root cause</li><li>Understand the problem</li><li>Determine a fix</li><li>Repair the issue</li><li>Retest</li></ol><p>Finding an error is usually the hardest part of debugging.</p><p><span class="cpp-definition">Static analysis tools</span> are tools that analyze your code and look for semantic issues that may indicate problems with your code.</p><p>Being able to reliably reproduce an issue is the first and most important step in debugging.</p><p>There are a number of tactics we can use to help find issues:</p><ul><li>Commenting out code</li><li>Using output statements to validate your code flow</li><li>Printing values</li></ul><p>When using print statements, use <em>std::cerr</em> instead of <em>std::cout</em>. But even better, avoid debugging via print statements.</p><p>A <span class="cpp-definition">log file</span> is a file that records events that occur in a program. The process of writing information to a log file is called <span class="cpp-definition">logging</span>.</p><p>The process of restructuring your code without changing how it behaves is called <span class="cpp-definition">refactoring</span>. This is typically done to make your program more organized, modular, or performant.</p><p><span class="cpp-definition">Unit testing</span> is a software testing method by which small units of source code are tested to determine whether they are correct.</p><p><span class="cpp-definition">Defensive programming</span> is a technique whereby the programmer tries to anticipate all of the ways the software could be misused. These misuses can often be detected and mitigated.</p><p>All of the information tracked in a program (variable values, which functions have been called, the current point of execution) is part of the <span class="cpp-definition">program state</span>.</p><p>A <span class="cpp-definition">debugger</span> is a tool that allows the programmer to control how a program executes and examine the program state while the program is running. An <span class="cpp-definition">integrated debugger</span> is a debugger that integrates into the code editor.</p><p><span class="cpp-definition">Stepping</span> is the name for a set of related debugging features that allow you to step through our code statement by statement.</p><p><span class="cpp-definition">Step into</span> executes the next statement in the normal execution path of the program, and then pauses execution. If the statement contains a function call, <em>step into</em> causes the program to jump to the top of the function being called.</p><p><span class="cpp-definition">Step over</span> executes the next statement in the normal execution path of the program, and then pauses execution. If the statement contains a function call, <em>step over</em> executes the function and returns control to you after the function has been executed.</p><p><span class="cpp-definition">Step out</span> executes all remaining code in the function currently being executed and then returns control to you when the function has returned.</p><p><span class="cpp-definition">Run to cursor</span> executes the program until execution reaches the statement selected by your mouse cursor.</p><p><span class="cpp-definition">Continue</span> runs the program, until the program terminates or a breakpoint is hit.<br><span class="cpp-definition">Start</span> is the same as continue, just from the beginning of the program.</p><p>A <span class="cpp-definition">breakpoint</span> is a special marker that tells the debugger to stop execution of the program when the breakpoint is reached.</p><p><span class="cpp-definition">Watching a variable</span> allows you to inspect the value of a variable while the program is executing in debug mode. The <span class="cpp-definition">watch window</span> allows you to examine the value of variables or expressions.</p><p>The <span class="cpp-definition">call stack</span> is a list of all the active functions that have been executed to get to the current point of execution. The <span class="cpp-definition">call stack window</span> is a debugger window that shows the call stack.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>The following program is supposed to add two numbers, but doesn’t work correctly.</p><p>Use the integrated debugger to step through this program and watch the value of x. Based on the information you learn, fix the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int readNumber(int x)</code><code>{</code><code>	std::cout &lt;&lt; "Please enter a number: ";</code><code>	std::cin &gt;&gt; x;</code><code>	return x;</code><code>}</code><code></code><code>void writeAnswer(int x)</code><code>{</code><code>	std::cout &lt;&lt; "The sum is: " &lt;&lt; x &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int x {};</code><code>	readNumber(x);</code><code>	x = x + readNumber(x);</code><code>	writeAnswer(x);</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>The major issue here is in the second line of function <em>main</em> -- the return value of readNumber isn’t assigned to anything, so it is discarded. A minor issue is that <em>readNumber</em> is taking an argument when it should have a local variable instead.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int readNumber()</code><code>{</code><code>	std::cout &lt;&lt; "Please enter a number: ";</code><code>	int x {};</code><code>	std::cin &gt;&gt; x;</code><code>	return x;</code><code>}</code><code></code><code>void writeAnswer(int x)</code><code>{</code><code>	std::cout &lt;&lt; "The sum is: " &lt;&lt; x &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int x { readNumber() };</code><code>	x = x + readNumber();</code><code>	writeAnswer(x);</code><code></code><code>	return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>The following program is supposed to divide two numbers, but doesn’t work correctly.</p><p>Use the integrated debugger to step through this program. For inputs, enter 8 and 4. Based on the information you learn, fix the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int readNumber()</code><code>{</code><code>	std::cout &lt;&lt; "Please enter a number: ";</code><code>	int x {};</code><code>	std::cin &gt;&gt; x;</code><code>	return x;</code><code>}</code><code></code><code>void writeAnswer(int x)</code><code>{</code><code>	std::cout &lt;&lt; "The quotient is: " &lt;&lt; x &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int x{ };</code><code>	int y{ };</code><code>	x = readNumber();</code><code>	x = readNumber();</code><code>	writeAnswer(x/y);</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>The issue here is that the second call to <em>readNumber</em> accidentally assigns its value to x instead of y, resulting in a division by 0, which causes the program to crash.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int readNumber()</code><code>{</code><code>	std::cout &lt;&lt; "Please enter a number: ";</code><code>	int x {};</code><code>	std::cin &gt;&gt; x;</code><code>	return x;</code><code>}</code><code></code><code>void writeAnswer(int x)</code><code>{</code><code>	std::cout &lt;&lt; "The quotient is: " &lt;&lt; x &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int x{ readNumber() };</code><code>	int y{ readNumber() };</code><code>	writeAnswer(x/y);</code><code></code><code>	return 0;</code><code>}</code></pre><p>You may notice that when the second input doesn’t divide evenly into the first, this program appears to produce an incorrect answer. When doing division with integers, C++ will drop any fractional parts of the quotient. We’ll discuss this in more detail when we discuss integers (in the next chapter).</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>What does the call stack look like in the following program when the point of execution is on line 4? Only the function names are needed for this exercise, not the line numbers indicating the point of return.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void d()</code><code>{ // here</code><code>}</code><code></code><code>void c()</code><code>{</code><code>}</code><code></code><code>void b()</code><code>{</code><code>	c();</code><code>	d();</code><code>}</code><code></code><code>void a()</code><code>{</code><code>	b();</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	a();</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>d<br>b<br>a<br>main</p></div></div><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>It’s hard to find good examples of simple programs that have non-obvious issues to debug, given the limited material covered so far. Any readers have any suggestions?</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">4.1 — Introduction to fundamental data types</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Bits, bytes, and memory addressing</h3><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-objects-and-variables/">1.3 -- Introduction to objects and variables</a>, we talked about the fact that variables are names for a piece of memory that can be used to store information. To recap briefly, computers have random access memory (RAM) that is available for programs to use. When a variable is defined, a piece of that memory is set aside for that variable.</p><p>The smallest unit of memory is a <span class="cpp-definition">binary digit</span> (also called a <span class="cpp-definition">bit</span>), which can hold a value of 0 or 1. You can think of a bit as being like a traditional light switch -- either the light is off (0), or it is on (1). There is no in-between. If you were to look at a random segment of memory, all you would see is …011010100101010… or some combination thereof.</p><p>Memory is organized into sequential units called <span class="cpp-definition">memory addresses</span> (or <span class="cpp-definition">addresses</span> for short). Similar to how a street address can be used to find a given house on a street, the memory address allows us to find and access the contents of memory at a particular location.</p><p>Perhaps surprisingly, in modern computer architectures, each bit does not get its own unique memory address. This is because the number of memory addresses are limited, and the need to access data bit-by-bit is rare. Instead, each memory address holds 1 byte of data. A <span class="cpp-definition">byte</span> is a group of bits that are operated on as a unit. The modern standard is that a byte is comprised of 8 sequential bits.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>In C++, we typically work with “byte-sized” chunks of data.</p></div><p>The following picture shows some sequential memory addresses, along with the corresponding byte of data:</p><p><img src="https://www.learncpp.com/images/CppTutorial/Section2/MemoryAddresses.png" alt="Memory Addressing" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Section2/MemoryAddresses.png"></p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>Some older or non-standard machines may have bytes of a different size (from 1 to 48 bits) -- however, we generally need not worry about these, as the modern de-facto standard is that a byte is 8 bits. For these tutorials, we’ll assume a byte is 8 bits.</p></div><span class="cpp-definition">Data types</span><p>Because all data on a computer is just a sequence of bits, we use a <span class="cpp-definition">data type</span> (often called a “type” for short) to tell the compiler how to interpret the contents of memory in some meaningful way. You have already seen one example of a data type: the integer. When we declare a variable as an integer, we are telling the compiler “the piece of memory that this variable uses is going to be interpreted as an integer value”.</p><p>When you give an object a value, the compiler and CPU take care of encoding your value into the appropriate sequence of bits for that data type, which are then stored in memory (remember: memory can only store bits). For example, if you assign an integer object the value <em>65</em>, that value is converted to the sequence of bits <code>0100 0001</code> and stored in the memory assigned to the object.</p><p>Conversely, when the object is evaluated to produce a value, that sequence of bits is reconstituted back into the original value. Meaning that <code>0100 0001</code> is converted back into the value <em>65</em>.</p><p>Fortunately, the compiler and CPU do all the hard work here, so you generally don’t need to worry about how values get converted into bit sequences and back.</p><p>All you need to do is pick a data type for your object that best matches your desired use.</p><br><h3>Fundamental data types</h3><p>C++ comes with built-in support for many different data types. These are called <span class="cpp-definition">fundamental data types</span>, but are often informally called <span class="cpp-definition">basic types</span>, <span class="cpp-definition">primitive types</span>, or <span class="cpp-definition">built-in types</span>.</p><p>Here is a list of the fundamental data types, some of which you have already seen:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Types</th><th>Category</th><th>Meaning</th><th>Example</th></tr><tr><td>float<br>double<br>long double</td><td>Floating Point</td><td>a number with a fractional part</td><td>3.14159</td></tr><tr><td>bool</td><td>Integral (Boolean)</td><td>true or false</td><td>true</td></tr><tr><td>char<br>wchar_t<br>char8_t (C++20)<br>char16_t (C++11)<br>char32_t (C++11)</td><td>Integral (Character)</td><td>a single character of text</td><td>‘c’</td></tr><tr><td>short<br>int<br>long<br>long long (C++11)</td><td>Integral (Integer)</td><td>positive and negative whole numbers, including 0</td><td>64</td></tr><tr><td>std::nullptr_t (C++11)</td><td>Null Pointer</td><td>a null pointer</td><td>nullptr</td></tr><tr><td>void</td><td>Void</td><td>no type</td><td>n/a</td></tr></tbody></table></div><p>This chapter is dedicated to exploring these fundamental data types in detail (except std::nullptr_t, which we’ll discuss when we talk about pointers). C++ also supports a number of other more complex types, called <em>compound types</em>. We’ll explore compound types in a future chapter.</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>The terms <code>integer</code> and <code>integral</code> are similar, but have different meanings. An <code>integer</code> is a specific data type that hold non-fractional numbers, such as whole numbers, 0, and negative whole numbers. <code>Integral</code> means “like an integer”. Most often, <code>integral</code> is used as part of the term <code>integral type</code>, which includes all of the Boolean, characters, and integer types (also enumerated types, which we’ll discuss in <a href="https://www.learncpp.com#Chapter9">chapter 9</a>). <code>Integral type</code> are named so because they are stored in memory as integers, even though their behaviors might vary (which we’ll see later in this chapter when we talk about the character types).</p></div><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>Most modern programming languages include a fundamental <code>string</code> type (strings are a data type that lets us hold a sequence of characters, typically used to represent text). In C++, strings aren’t a fundamental type (they’re a compound type). But because basic string usage is straightforward and useful, we’ll introduce strings in this chapter as well (in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-stdstring/">4.17 -- Introduction to std::string</a>).</p></div><br><h3>The _t suffix</h3><p>Many of the types defined in newer versions of C++ (e.g. std::nullptr_t) use a _t suffix. This suffix means “type”, and it’s a common nomenclature applied to modern types.</p><p>If you see something with a _t suffix, it’s probably a type. But many types don’t have a _t suffix, so this isn’t consistently applied.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">4.2 — Void</h1></header><div class="entry-content" itemprop="articleBody"><p>Void is the easiest of the data types to explain. Basically, <span class="cpp-definition">void</span> means “no type”!</p><p>Consequentially, variables can not be defined with a type of void:</p><pre class="language-cpp line-numbers"><code>void value; // won't work, variables can't be defined with a void type</code></pre><p>Void is typically used in several different contexts.</p><br><h3>Functions that do not return a value</h3><p>Most commonly, <em>void</em> is used to indicate that a function does not return a value:</p><pre class="language-cpp line-numbers"><code>void writeValue(int x) // void here means no return value</code><code>{</code><code>    std::cout &lt;&lt; "The value of x is: " &lt;&lt; x &lt;&lt; '\n';</code><code>    // no return statement, because this function doesn't return a value</code><code>}</code></pre><p>If you use a return statement to try to return a value in such a function, a compile error will result:</p><pre class="language-cpp line-numbers"><code>void noReturn(int x) // void here means no return value</code><code>{</code><code>    return 5; // error</code><code>}</code></pre><p>On Visual Studio 2017, this produced the error:</p><pre>error C2562: 'noReturn': 'void' function returning a value
</pre><br><h3>Deprecated: Functions that do not take parameters</h3><p>In C, void is used as a way to indicate that a function does not take any parameters:</p><pre class="language-cpp line-numbers"><code>int getValue(void) // void here means no parameters</code><code>{</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code>    return x;</code><code>}</code></pre><p>Although this will compile in C++ (for backwards compatibility reasons), this use of keyword <em>void</em> is considered deprecated in C++. The following code is equivalent, and preferred in C++:</p><pre class="language-cpp line-numbers"><code>int getValue() // empty function parameters is an implicit void</code><code>{</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code>    return x;</code><code>}</code></pre><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use an empty parameter list instead of <em>void</em> to indicate that a function has no parameters.</p></div><br><h3>Other uses of void</h3><p>The void keyword has a third (more advanced) use in C++ that we cover in section <a href="https://www.learncpp.com/cpp-tutorial/void-pointers/">11.14 -- Void pointers</a>. Since we haven’t covered what a pointer is yet, you don’t need to worry about this case for now.</p><p>Let’s move on!</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">4.3 — Object sizes and the sizeof operator</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Object sizes</h3><p>As you learned in the lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-fundamental-data-types/">4.1 -- Introduction to fundamental data types</a>, memory on modern machines is typically organized into byte-sized units, with each byte of memory having a unique address. Up to this point, it has been useful to think of memory as a bunch of cubbyholes or mailboxes where we can put and retrieve information, and variables as names for accessing those cubbyholes or mailboxes.</p><p>However, this analogy is not quite correct in one regard -- most objects actually take up more than 1 byte of memory. A single object may use 2, 4, 8, or even more consecutive memory addresses. The amount of memory that an object uses is based on its data type.</p><p>Because we typically access memory through variable names (and not directly via memory addresses), the compiler is able to hide the details of how many bytes a given object uses from us. When we access some variable <em>x</em>, the compiler knows how many bytes of data to retrieve (based on the type of variable <em>x</em>), and can handle that task for us.</p><p>Even so, there are several reasons it is useful to know how much memory an object uses.</p><p>First, the more memory an object uses, the more information it can hold.</p><p>A single bit can hold 2 possible values, a 0, or a 1:<br></p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>bit 0</th></tr><tr><td>0</td></tr><tr><td>1</td></tr></tbody></table></div><p>2 bits can hold 4 possible values:<br></p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>bit 0</th><th>bit 1</th></tr><tr><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td></tr></tbody></table></div><p>3 bits can hold 8 possible values:<br></p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>bit 0</th><th>bit 1</th><th>bit 2</th></tr><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p>To generalize, an object with <em>n</em> bits (where n is an integer) can hold 2<sup>n</sup> (2 to the power of n, also commonly written 2^n) unique values. Therefore, with an 8-bit byte, a byte-sized object can hold 2<sup>8</sup> (256) different values. An object that uses 2 bytes can hold 2^16 (65536) different values!</p><p>Thus, the size of the object puts a limit on the amount of unique values it can store -- objects that utilize more bytes can store a larger number of unique values. We will explore this further when we talk more about integers.</p><p>Second, computers have a finite amount of free memory. Every time we define an object, a small portion of that free memory is used for as long as the object is in existence. Because modern computers have a lot of memory, this impact is usually negligible. However, for programs that need a large amount of objects or data (e.g. a game that is rendering millions of polygons), the difference between using 1 byte and 8 byte objects can be significant.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>New programmers often focus too much on optimizing their code to use as little memory as possible. In most cases, this makes a negligible difference. Focus on writing maintainable code, and optimize only when and where the benefit will be substantive.</p></div><br><h3>Fundamental data type sizes</h3><p>The obvious next question is “how much memory do variables of different data types take?”. You may be surprised to find that the size of a given data type is dependent on the compiler and/or the computer architecture!</p><p>C++ only guarantees that each fundamental data types will have a minimum size:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Category</th><th>Type</th><th>Minimum Size</th><th>Note</th></tr><tr><td>boolean</td><td>bool</td><td>1 byte</td><td></td></tr><tr><td>character</td><td>char</td><td>1 byte</td><td>Always exactly 1 byte</td></tr><tr><td></td><td>wchar_t</td><td>1 byte</td><td></td></tr><tr><td></td><td>char16_t</td><td>2 bytes</td><td></td></tr><tr><td></td><td>char32_t</td><td>4 bytes</td><td></td></tr><tr><td>integer</td><td>short</td><td>2 bytes</td><td></td></tr><tr><td></td><td>int</td><td>2 bytes</td><td></td></tr><tr><td></td><td>long</td><td>4 bytes</td><td></td></tr><tr><td></td><td>long long</td><td>8 bytes</td><td></td></tr><tr><td>floating point</td><td>float</td><td>4 bytes</td><td></td></tr><tr><td></td><td>double</td><td>8 bytes</td><td></td></tr><tr><td></td><td>long double</td><td>8 bytes</td><td></td></tr></tbody></table></div><p>However, the actual size of the variables may be different on your machine (particularly int, which is more often 4 bytes).</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>For maximum compatibility, you shouldn’t assume that variables are larger than the specified minimum size.</p></div><p>Objects of fundamental data types are generally extremely fast.</p><br><h3>The sizeof operator</h3><p>In order to determine the size of data types on a particular machine, C++ provides an operator named <em>sizeof</em>. The <span class="cpp-definition">sizeof operator</span> is a unary operator that takes either a type or a variable, and returns its size in bytes. You can compile and run the following program to find out how large some of your data types are:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "bool:\t\t" &lt;&lt; sizeof(bool) &lt;&lt; " bytes\n";</code><code>    std::cout &lt;&lt; "char:\t\t" &lt;&lt; sizeof(char) &lt;&lt; " bytes\n";</code><code>    std::cout &lt;&lt; "wchar_t:\t" &lt;&lt; sizeof(wchar_t) &lt;&lt; " bytes\n";</code><code>    std::cout &lt;&lt; "char16_t:\t" &lt;&lt; sizeof(char16_t) &lt;&lt; " bytes\n";</code><code>    std::cout &lt;&lt; "char32_t:\t" &lt;&lt; sizeof(char32_t) &lt;&lt; " bytes\n";</code><code>    std::cout &lt;&lt; "short:\t\t" &lt;&lt; sizeof(short) &lt;&lt; " bytes\n";</code><code>    std::cout &lt;&lt; "int:\t\t" &lt;&lt; sizeof(int) &lt;&lt; " bytes\n";</code><code>    std::cout &lt;&lt; "long:\t\t" &lt;&lt; sizeof(long) &lt;&lt; " bytes\n";</code><code>    std::cout &lt;&lt; "long long:\t" &lt;&lt; sizeof(long long) &lt;&lt; " bytes\n";</code><code>    std::cout &lt;&lt; "float:\t\t" &lt;&lt; sizeof(float) &lt;&lt; " bytes\n";</code><code>    std::cout &lt;&lt; "double:\t\t" &lt;&lt; sizeof(double) &lt;&lt; " bytes\n";</code><code>    std::cout &lt;&lt; "long double:\t" &lt;&lt; sizeof(long double) &lt;&lt; " bytes\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>Here is the output from the author’s x64 machine, using Visual Studio:</p><pre>bool:           1 bytes
char:           1 bytes
wchar_t:        2 bytes
char16_t:       2 bytes
char32_t:       4 bytes
short:          2 bytes
int:            4 bytes
long:           4 bytes
long long:      8 bytes
float:          4 bytes
double:         8 bytes
long double:    8 bytes
</pre><p>Your results may vary if you are using a different type of machine, or a different compiler. Note that you can not use the <em>sizeof</em> operator on the <em>void</em> type, since it has no size (doing so will cause a compile error).</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>If you’re wondering what ‘\t’ is in the above program, it’s a special symbol that inserts a tab (in the example, we’re using it to align the output columns). We will cover ‘\t’ and other special symbols in lesson <a href="https://www.learncpp.com/cpp-tutorial/chars/">4.11 -- Chars</a>.</p></div><p>You can also use the <em>sizeof</em> operator on a variable name:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{};</code><code>    std::cout &lt;&lt; "x is " &lt;&lt; sizeof(x) &lt;&lt; " bytes\n";</code><code></code><code>    return 0;</code><code>}</code></pre><pre>x is 4 bytes
</pre><br><h3>Fundamental data type performance</h3><p>On modern machines, objects of the fundamental data types are fast, so performance while using these types should generally not be a concern.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>You might assume that types that use less memory would be faster than types that use more memory. This is not always true. CPUs are often optimized to process data of a certain size (e.g. 32 bits), and types that match that size may be processed quicker. On such a machine, a 32-bit <em>int</em> could be faster than a 16-bit <em>short</em> or an 8-bit <em>char</em>.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">4.4 — Signed integers</h1></header><div class="entry-content" itemprop="articleBody"><p>An <span class="cpp-definition">integer</span> is an integral type that can represent positive and negative whole numbers, including 0 (e.g. -2, -1, 0, 1, 2). C++ has <em>4</em> different fundamental integer types available for use:</p><p style="clear:both"></p><p></p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Type</th><th>Minimum Size</th><th>Note</th></tr><tr><td>short int</td><td>16 bits</td><td></td></tr><tr><td>int</td><td>16 bits</td><td>Typically 32 bits on modern architectures</td></tr><tr><td>long int</td><td>32 bits</td><td></td></tr><tr><td>long long int</td><td>64 bits</td><td></td></tr></tbody></table></div><p>The key difference between the various integer types is that they have varying sizes -- the larger integers can hold bigger numbers.</p><div class="cpp-note cpp-lightgraybackground"><h4>A reminder</h4><p>C++ only guarantees that integers will have a certain minimum size, not that they will have a specific size. See lesson <a href="https://www.learncpp.com/cpp-tutorial/object-sizes-and-the-sizeof-operator/">4.3 -- Object sizes and the sizeof operator</a> for information on how to determine how large each type is on your machine.</p></div><br><h3>Signed integers</h3><p>When writing negative numbers in everyday life, we use a negative sign. For example, <em>-3</em> means “negative 3”. We’d also typically recognize <em>+3</em> as “positive 3” (though common convention dictates that we typically omit plus prefixes). This attribute of being positive, negative, or zero is called the number’s <span class="cpp-definition">sign</span>.</p><p>By default, integers are <span class="cpp-definition">signed</span>, which means the number’s sign is stored as part of the number (using a single bit called the <span class="cpp-definition">sign bit</span>). Therefore, a signed integer can hold both positive and negative numbers (and 0).</p><p>In this lesson, we’ll focus on signed integers. We’ll discuss unsigned integers (which can only hold non-negative numbers) in the next lesson.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We discuss how the sign bit is used when representing numbers in binary in lesson <a href="https://www.learncpp.com/cpp-tutorial/converting-between-binary-and-decimal/">O.4 -- Converting between binary and decimal</a>.</p></div><br><h3>Defining signed integers</h3><p>Here is the preferred way to define the four types of signed integers:</p><pre class="language-cpp line-numbers"><code>short s;      // prefer "short" instead of "short int"</code><code>int i;</code><code>long l;       // prefer "long" instead of "long int"</code><code>long long ll; // prefer "long long" instead of "long long int"</code></pre><p>Although <em>short int</em>, <em>long int</em>, or <em>long long int</em> will work, we prefer the short names for these types (that do not use the <em>int</em> suffix). In addition to being more typing, adding the <em>int</em> suffix makes the type harder to distinguish from variables of type <em>int</em>. This can lead to mistakes if the short or long modifier is inadvertently missed.</p><p>The integer types can also take an optional <em>signed</em> keyword, which by convention is typically placed before the type name:</p><pre class="language-cpp line-numbers"><code>signed short ss;</code><code>signed int si;</code><code>signed long sl;</code><code>signed long long sll;</code></pre><p>However, this keyword should not be used, as it is redundant, since integers are signed by default.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Prefer the shorthand types that do not use the <em>int</em> suffix or signed prefix.</p></div><br><h3>Signed integer ranges</h3><p>As you learned in the last section, a variable with <em>n</em> bits can hold 2<sup>n</sup> possible values. But which specific values? We call the set of specific values that a data type can hold its <span class="cpp-definition">range</span>. The range of an integer variable is determined by two factors: its size (in bits), and whether it is signed or not.</p><p>By definition, an 8-bit signed integer has a range of -128 to 127. This means a signed integer can store any integer value between -128 and 127 (inclusive) safely.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>Math time: an 8-bit integer contains 8 bits. 2<sup>8</sup> is 256, so an 8-bit integer can hold 256 possible values. There are 256 possible values between -128 to 127, inclusive.</p></div><p>Here’s a table containing the range of signed integers of different sizes:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Size/Type</th><th>Range</th></tr><tr><td>8 bit signed</td><td>-128 to 127</td></tr><tr><td>16 bit signed</td><td>-32,768 to 32,767</td></tr><tr><td>32 bit signed</td><td>-2,147,483,648 to 2,147,483,647</td></tr><tr><td>64 bit signed</td><td>-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td></tr></tbody></table></div><p>For the math inclined, an n-bit signed variable has a range of -(2<sup>n-1</sup>) to 2<sup>n-1</sup>-1.</p><p>For the non-math inclined… use the table. :)</p><br><h3>Integer overflow</h3><p>What happens if we try to assign the value <em>280</em> to an 8-bit signed integer? This number is outside the range that a 8-bit signed integer can hold. The number 280 requires 9 bits (plus 1 sign bit) to be represented, but we only have 7 bits (plus 1 sign bit) available in a 8-bit signed integer.</p><p><span class="cpp-definition">Integer overflow</span> (often called <em>overflow</em> for short) occurs when we try to store a value that is outside the range of the type. Essentially, the number we are trying to store requires more bits to represent than the object has available. In such a case, data is lost because the object doesn’t have enough memory to store everything.</p><p>In the case of signed integers, which bits are lost is not well defined, thus signed integer overflow leads to undefined behavior.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Signed integer overflow will result in undefined behavior.</p></div><p>In general, overflow results in information being lost, which is almost never desirable. If there is <em>any</em> suspicion that an object might need to store a value that falls outside its range, use a type with a bigger range!</p><br><h3>Integer division</h3><p>When dividing two integers, C++ works like you’d expect when the quotient is a whole number:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; 20 / 4 &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>This produces the expected result:</p><pre>5
</pre><p>But let’s look at what happens when integer division causes a fractional result:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; 8 / 5 &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>This produces a possibly unexpected result:</p><pre>1
</pre><p>When doing division with two integers (called <span class="cpp-definition">integer division</span>), C++ always produces an integer result. Since integers can’t hold fractional values, any fractional portion is simply dropped (not rounded!).</p><p>Taking a closer look at the above example, 8 / 5 produces the value 1.6. The fractional part (0.6) is dropped, and the result of 1 remains.</p><p>Similarly, -8 / 5 results in the value -1.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Be careful when using integer division, as you will lose any fractional parts of the quotient. However, if it’s what you want, integer division is safe to use, as the results are predictable.</p></div><p>If fractional results are desired, we show a method to do this in lesson <a href="https://www.learncpp.com/cpp-tutorial/arithmetic-operators/">5.2 -- Arithmetic operators</a>.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">4.5 — Unsigned integers, and why to avoid them</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Unsigned integers</h3><p>In the previous lesson (<a href="https://www.learncpp.com/cpp-tutorial/signed-integers/">4.4 -- Signed integers</a>), we covered signed integers, which are a set of types that can hold positive and negative whole numbers, including 0.</p><p>C++ also supports unsigned integers. <span class="cpp-definition">Unsigned integers</span> are integers that can only hold non-negative whole numbers.</p><br><h3>Defining unsigned integers</h3><p>To define an unsigned integer, we use the <em>unsigned</em> keyword. By convention, this is placed before the type:</p><pre class="language-cpp line-numbers"><code>unsigned short us;</code><code>unsigned int ui;</code><code>unsigned long ul;</code><code>unsigned long long ull;</code></pre><br><h3>Unsigned integer range</h3><p>A 1-byte unsigned integer has a range of 0 to 255. Compare this to the 1-byte signed integer range of -128 to 127. Both can store 256 different values, but signed integers use half of their range for negative numbers, whereas unsigned integers can store positive numbers that are twice as large.</p><p>Here’s a table showing the range for unsigned integers:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Size/Type</th><th>Range</th></tr><tr><td>1 byte unsigned</td><td>0 to 255</td></tr><tr><td>2 byte unsigned</td><td>0 to 65,535</td></tr><tr><td>4 byte unsigned</td><td>0 to 4,294,967,295</td></tr><tr><td>8 byte unsigned</td><td>0 to 18,446,744,073,709,551,615</td></tr></tbody></table></div><p>An n-bit unsigned variable has a range of 0 to (2<sup>n</sup>)-1.</p><p>When no negative numbers are required, unsigned integers are well-suited for networking and systems with little memory, because unsigned integers can store more positive numbers without taking up extra memory.</p><br><h3>Remembering the terms signed and unsigned</h3><p>New programmers sometimes get signed and unsigned mixed up. The following is a simple way to remember the difference: in order to differentiate negative numbers from positive ones, we use a negative sign. If a sign is not provided, we assume a number is positive. Consequently, an integer with a sign (a signed integer) can tell the difference between positive and negative. An integer without a sign (an unsigned integer) assumes all values are positive.</p><br><h3>Unsigned integer overflow</h3><p>What happens if we try to store the number 280 (which requires 9 bits to represent) in a 1-byte (8-bit) unsigned integer? The answer is overflow.</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>Oddly, the C++ standard explicitly says “a computation involving unsigned operands can never overflow”. This is contrary to general programming consensus that integer overflow encompasses both signed and unsigned use cases <sup>(<a href="https://en.wikipedia.org/wiki/Integer_overflow#Definition_variations_and_ambiguity">cite</a>)</sup>. Given that most programmers would consider this overflow, we’ll call this overflow despite C++’s statements to the contrary.</p></div><p>If an unsigned value is out of range, it is divided by one greater than the largest number of the type, and only the remainder kept.</p><p>The number 280 is too big to fit in our 1-byte range of 0 to 255. 1 greater than the largest number of the type is 256. Therefore, we divide 280 by 256, getting 1 remainder 24. The remainder of 24 is what is stored.</p><p>Here’s another way to think about the same thing. Any number bigger than the largest number representable by the type simply “wraps around” (sometimes called “modulo wrapping”). 255 is in range of a 1-byte integer, so 255 is fine. 256, however, is outside the range, so it wraps around to the value 0. 257 wraps around to the value 1. 280 wraps around to the value 24.</p><p>Let’s take a look at this using 2-byte shorts:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    unsigned short x{ 65535 }; // largest 16-bit unsigned value possible</code><code>    std::cout &lt;&lt; "x was: " &lt;&lt; x &lt;&lt; '\n';</code><code></code><code>    x = 65536; // 65536 is out of our range, so we get wrap-around</code><code>    std::cout &lt;&lt; "x is now: " &lt;&lt; x &lt;&lt; '\n';</code><code></code><code>    x = 65537; // 65537 is out of our range, so we get wrap-around</code><code>    std::cout &lt;&lt; "x is now: " &lt;&lt; x &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>What do you think the result of this program will be?</p><p>(Note: If you try to compile the above program, your compiler should issue warnings about overflow or truncation -- you’ll need to disable “treat warnings as errors” to run the program)</p><pre>x was: 65535
x is now: 0
x is now: 1
</pre><p>It’s possible to wrap around the other direction as well. 0 is representable in a 2-byte unsigned integer, so that’s fine. -1 is not representable, so it wraps around to the top of the range, producing the value 65535. -2 wraps around to 65534. And so forth.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    unsigned short x{ 0 }; // smallest 2-byte unsigned value possible</code><code>    std::cout &lt;&lt; "x was: " &lt;&lt; x &lt;&lt; '\n';</code><code></code><code>    x = -1; // -1 is out of our range, so we get wrap-around</code><code>    std::cout &lt;&lt; "x is now: " &lt;&lt; x &lt;&lt; '\n';</code><code></code><code>    x = -2; // -2 is out of our range, so we get wrap-around</code><code>    std::cout &lt;&lt; "x is now: " &lt;&lt; x &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><pre>x was: 0
x is now: 65535
x is now: 65534
</pre><p>The above code triggers a warning in some compilers, because the compiler detects that the integer literal is out-of-range for the given type. If you want to compile the code anyway, temporarily disable “Treat warnings as errors”.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>Many notable bugs in video game history happened due to wrap around behavior with unsigned integers. In the arcade game Donkey Kong, it’s not possible to go past level 22 due to an overflow bug that leaves the user with not enough bonus time to complete the level.</p><p>In the PC game Civilization, Gandhi was known for often being the first one to use nuclear weapons, which seems contrary to his expected passive nature. Players had a theory that Gandhi’s aggression setting was initially set at 1, but if he chose a democratic government, he’d get a -2 aggression modifier (lowering his current aggression value by 2). This would cause his aggression to overflow to 255, making him maximally aggressive! However, more recently Sid Meier (the game’s author) clarified that this wasn’t actually the case.</p></div><br><h3>The controversy over unsigned numbers</h3><p>Many developers (and some large development houses, such as Google) believe that developers should generally avoid unsigned integers.</p><p>This is largely because of two behaviors that can cause problems.</p><p>First, consider the subtraction of two unsigned numbers, such as 3 and 5. 3 minus 5 is -2, but -2 can’t be represented as an unsigned number.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	unsigned int x{ 3 };</code><code>	unsigned int y{ 5 };</code><code></code><code>	std::cout &lt;&lt; x - y &lt;&lt; '\n';</code><code>	return 0;</code><code>}</code></pre><p>On the author’s machine, this seemingly innocent looking program produces the result:</p><pre class="language-cpp line-numbers"><code>4294967294</code></pre><p>This occurs due to -2 wrapping around to a number close to the top of the range of a 4-byte integer. Another common unwanted wrap-around happens when an unsigned integer is repeatedly decremented by 1 (using the <code>--</code> operator). You’ll see an example of this when loops are introduced.</p><p>Second, unexpected behavior can result when you mix signed and unsigned integers. In a mathematical operation in C++ (e.g. arithmetic or comparison), if one signed and one unsigned integer are used, the signed integer will be converted to unsigned. And because unsigned integers can not store negative numbers, this can result in loss of data.</p><p>Consider the following program demonstrating this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    signed int s { -1 };</code><code>    unsigned int u { 1 };</code><code></code><code>    if (s &lt; u) // -1 is implicitly converted to 4294967295, and 4294967295 &lt; 1 is false</code><code>        std::cout &lt;&lt; "-1 is less than 1\n";</code><code>    else</code><code>        std::cout &lt;&lt; "1 is less than -1\n"; // this statement executes</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program is well formed, compiles, and is logically consistent to the eye. But it prints the wrong answer. And while your compiler should warn you about a signed/unsigned mismatch in this case, your compiler will also generate identical warnings for other cases that do not suffer from this problem (e.g. when both numbers are positive), making it hard to detect when there is an actual problem.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We cover if-statements in upcoming lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-if-statements/">4.10 -- Introduction to if statements</a>.</p></div><p>Additionally, there are other problematic cases that are essentially undetectable. Consider the following:</p><pre class="language-cpp line-numbers"><code>void doSomething(unsigned int x)</code><code>{</code><code>    // Run some code x times</code><code></code><code>    std::cout &lt;&lt; "x is " &lt;&lt; x &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    doSomething(-1);</code><code></code><code>    return 0;</code><code>}</code></pre><p>The author of doSomething() was expecting someone to call this function with only positive numbers. But the caller is passing in <em>-1</em> -- clearly a mistake, but one made none-the-less. What happens in this case?</p><p>The signed argument of <em>-1</em> gets implicitly converted to an unsigned parameter. -1 isn’t in the range of an unsigned number, so it wraps around to some large number (probably 4294967295). Then your program goes ballistic. Worse, there’s no good way to guard against this condition from happening. C++ will freely convert between signed and unsigned numbers, but it won’t do any range checking to make sure you don’t overflow your type.</p><p>All of these problems are commonly encountered, produce unexpected behavior, and are hard to find, even using automated tools designed to detect problem cases.</p><p>Given the above, the somewhat controversial best practice that we’ll advocate for is to avoid unsigned types except in specific circumstances.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Favor signed numbers over unsigned numbers for holding quantities (even quantities that should be non-negative) and mathematical operations. Avoid mixing signed and unsigned numbers.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>Additional material in support of the above recommendations (also covers refutation of some common counter-arguments):</p><ol><li><a href="https://www.youtube.com/watch?v=_nrly6PH6NU">Interactive C++ panel</a> (see 12:12-13:08, 42:40-45:26, and 1:02:50-1:03:15)</li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1428r0.pdf">Subscripts and sizes should be signed</a></li><li><a href="https://blog.libtorrent.org/2016/05/unsigned-integers/">Unsigned integers from the libtorrent blog</a></li></ol></div><br><h3>So when should you use unsigned numbers?</h3><p>There are still a few cases in C++ where it’s okay / necessary to use unsigned numbers.</p><p>First, unsigned numbers are preferred when dealing with bit manipulation (covered in chapter O -- that’s a capital ‘o’, not a ‘0’). They are also useful when well-defined wrap-around behavior is required (useful in some algorithms like encryption and random number generation).</p><p>Second, use of unsigned numbers is still unavoidable in some cases, mainly those having to do with array indexing. We’ll talk more about this in the lessons on arrays and array indexing. In these cases, the unsigned value can be converted to a signed value.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We discuss how to convert unsigned values to signed values in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-type-conversion-and-static_cast/">4.12 -- Introduction to type conversion and static_cast</a>.</p></div><p>Also note that if you’re developing for an embedded system (e.g. an Arduino) or some other processor/memory limited context, use of unsigned numbers is more common and accepted (and in some cases, unavoidable) for performance reasons.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">4.6 — Fixed-width integers and size_t</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lessons on integers, we covered that C++ only guarantees that integer variables will have a minimum size -- but they could be larger, depending on the target system.</p><br><h3>Why isn’t the size of the integer variables fixed?</h3><p>The short answer is that this goes back to C, when computers were slow and performance was of the utmost concern. C opted to intentionally leave the size of an integer open so that the compiler implementers could pick a size for int that performs best on the target computer architecture.</p><br><h3>Doesn’t this suck?</h3><p>By modern standards, yes. As a programmer, it’s a little ridiculous to have to deal with types that have uncertain ranges.</p><p>Consider the int type. The minimum size for int is 2 bytes, but it’s often 4 bytes on modern architectures. If you assume an int is 4 bytes because that’s most likely, then your program will probably misbehave on architectures where int is actually 2 bytes (since you will probably be storing values that require 4 bytes in a 2 byte variable, which will cause overflow or undefined behavior). If you assume an int is only 2 bytes to ensure maximum compatibility, then on systems where int is 4 bytes, you’re wasting 2 bytes per integer and doubling your memory usage!</p><br><h3>Fixed-width integers</h3><p>To address the above issues, C99 defined a set of <span class="cpp-definition">fixed-width integers</span> (in the stdint.h header) that are guaranteed to be the same size on any architecture.</p><p>These are defined as follows:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Name</th><th>Type</th><th>Range</th><th>Notes</th></tr><tr><td>std::int8_t</td><td>1 byte signed</td><td>-128 to 127</td><td>Treated like a signed char on many systems. See note below.</td></tr><tr><td>std::uint8_t</td><td>1 byte unsigned</td><td>0 to 255</td><td>Treated like an unsigned char on many systems. See note below.</td></tr><tr><td>std::int16_t</td><td>2 byte signed</td><td>-32,768 to 32,767</td><td></td></tr><tr><td>std::uint16_t</td><td>2 byte unsigned</td><td>0 to 65,535</td><td></td></tr><tr><td>std::int32_t</td><td>4 byte signed</td><td>-2,147,483,648 to 2,147,483,647</td><td></td></tr><tr><td>std::uint32_t</td><td>4 byte unsigned</td><td>0 to 4,294,967,295</td><td></td></tr><tr><td>std::int64_t</td><td>8 byte signed</td><td>-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td><td></td></tr><tr><td>std::uint64_t</td><td>8 byte unsigned</td><td>0 to 18,446,744,073,709,551,615</td><td></td></tr></tbody></table></div><p>C++ officially adopted these fixed-width integers as part of C++11. They can be accessed by including the <code><cstdint></cstdint></code> header, where they are defined inside the <em>std</em> namespace. Here’s an example:</p><pre class="language-cpp line-numbers"><code>#include <cstdint> // for fixed-width integers</cstdint></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::int16_t i{5};</code><code>    std::cout &lt;&lt; i;</code><code>    return 0;</code><code>}</code></pre><p>The fixed-width integers have two downsides that are typically raised.</p><p>First, the fixed-width integers are not guaranteed to be defined on all architectures. They only exist on systems where there are fundamental types matching their widths and following a certain binary representation. Your program will fail to compile on any such architecture that does not support a fixed-width integer that your program is using. However, given that most modern architectures have standardized around 8/16/32/64-bit variables, this is unlikely to be a problem unless your program needs to be portable to some exotic mainframe or embedded architectures.</p><p>Second, if you use a fixed-width integer, it may be slower than a wider type on some architectures. For example, if you need an integer that is guaranteed to be 32-bits, you might decide to use <code>std::int32_t</code>, but your CPU might actually be faster at processing 64-bit integers. However, just because your CPU can process a given type faster doesn’t mean your program will be faster overall -- modern programs are often constrained by memory usage rather than CPU, and the larger memory footprint may slow your program more than the faster CPU processing accelerates it. It’s hard to know without actually measuring.</p><br><h3>Fast and least integers</h3><p>To help address the above downsides, C++ also defines two alternative sets of integers that are guaranteed to be defined.</p><p>The fast types (std::int_fast#_t and std::uint_fast#_t) provide the fastest signed/unsigned integer type with a width of at least # bits (where # = 8, 16, 32, or 64). For example, <em>std::int_fast32_t</em> will give you the fastest signed integer type that’s at least 32 bits.</p><p>The least types (std::int_least#_t and std::uint_least#_t) provide the smallest signed/unsigned integer type with a width of at least # bits (where # = 8, 16, 32, or 64). For example, <em>std::uint_least32_t</em> will give you the smallest unsigned integer type that’s at least 32 bits.</p><p>Here’s an example from the author’s Visual Studio (32-bit console application):</p><pre class="language-cpp line-numbers"><code>#include <cstdint> // for fixed-width integers</cstdint></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "least 8:  " &lt;&lt; sizeof(std::int_least8_t) * 8 &lt;&lt; " bits\n";</code><code>	std::cout &lt;&lt; "least 16: " &lt;&lt; sizeof(std::int_least16_t) * 8 &lt;&lt; " bits\n";</code><code>	std::cout &lt;&lt; "least 32: " &lt;&lt; sizeof(std::int_least32_t) * 8 &lt;&lt; " bits\n";</code><code>	std::cout &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; "fast 8:  " &lt;&lt; sizeof(std::int_fast8_t) * 8 &lt;&lt; " bits\n";</code><code>	std::cout &lt;&lt; "fast 16: " &lt;&lt; sizeof(std::int_fast16_t) * 8 &lt;&lt; " bits\n";</code><code>	std::cout &lt;&lt; "fast 32: " &lt;&lt; sizeof(std::int_fast32_t) * 8 &lt;&lt; " bits\n";</code><code></code><code>	return 0;</code><code>}</code></pre><p>This produced the result:</p><pre>least 8:  8 bits
least 16: 16 bits
least 32: 32 bits

fast 8:  8 bits
fast 16: 32 bits
fast 32: 32 bits
</pre><p>You can see that std::int_least16_t is 16 bits, whereas std::int_fast16_t is actually 32 bits. This is because on the author’s machine, 32-bit integers are faster to process than 16-bit integers.</p><p>However, these fast and least integers have their own downsides: First, not many programmers actually use them, and a lack of familiarity can lead to errors. Second, the fast types can lead to the same kind of memory wastage that we saw with 4 byte integers. Most seriously, because the size of the fast/least integers can vary, it’s possible that your program may exhibit different behaviors on architectures where they resolve to different sizes. For example:</p><pre class="language-cpp line-numbers"><code>#include <cstdint> // for fixed-width integers</cstdint></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::uint_fast16_t sometype { 0 };</code><code>    --sometype; // intentionally overflow to invoke wraparound behavior</code><code></code><code>    std::cout &lt;&lt; sometype;</code><code></code><code>    return 0;</code><code>}</code></pre><p>This code will produce different results depending on whether std::uint_fast16_t is 16, 32, or 64 bits.</p><p>It’s hard to know where your program might not function as expected until you’ve rigorously tested your program on such architectures. And we imagine not many developers have access to a wide range of different architectures to test with!</p><br><h3>std::int8_t and std::uint8_t likely behave like chars instead of integers</h3><p>Due to an oversight in the C++ specification, most compilers define and treat <em>std::int8_t</em> and <em>std::uint8_t</em> (and the corresponding fast and least fixed-width types) identically to types <em>signed char</em> and <em>unsigned char</em> respectively. This means these 8-bit types may (or may not) behave differently than the rest of the fixed-width types, which can lead to errors. This behavior is system-dependent, so a program that behaves correctly on one architecture may not compile or behave correctly on another architecture.</p><p>We show an example of this in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-type-conversion-and-static_cast/">4.12 -- Introduction to type conversion and static_cast</a>.</p><p>For consistency, it’s best to avoid <em>std::int8_t</em> and <em>std::uint8_t</em> (and the related fast and least types) altogether (use <em>std::int16_t</em> or <em>std::uint16_t</em> instead).</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>The 8-bit fixed-width integer types are often treated like chars instead of integer values (and this may vary per system). Prefer the 16-bit fixed integral types for most cases.</p></div><br><h3>Integral best practices</h3><p>Given the various pros and cons of the fundamental integral types, the fixed-width integral types, the fast/least integral types, and signed/unsigned challenges, there is little consensus on integral best practices.</p><p>Our stance is that it’s better to be correct than fast, better to fail at compile time than runtime -- therefore, we recommend avoiding the fast/least types in favor of the fixed-width types. If you later discover the need to support a platform for which the fixed-width types won’t compile, then you can decide how to migrate your program (and thoroughly test) at that point.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><ul><li>Prefer <code>int</code> when the size of the integer doesn’t matter (e.g. the number will always fit within the range of a 2-byte signed integer). For example, if you’re asking the user to enter their age, or counting from 1 to 10, it doesn’t matter whether int is 16 or 32 bits (the numbers will fit either way). This will cover the vast majority of the cases you’re likely to run across.</li><li>Prefer <code>std::int#_t</code> when storing a quantity that needs a guaranteed range.</li><li>Prefer <code>std::uint#_t</code> when doing bit manipulation or where well-defined wrap-around behavior is required.</li></ul><p>Avoid the following when possible:</p><ul><li>Unsigned types for holding quantities</li><li>The 8-bit fixed-width integer types</li><li>The fast and least fixed-width types</li><li>Any compiler-specific fixed-width integers -- for example, Visual Studio defines __int8, __int16, etc…</li></ul></div><br><h3>What is std::size_t?</h3><p>Consider the following code:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; sizeof(int) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>On the author’s machine, this prints:</p><pre>4
</pre><p>Pretty simple, right? We can infer that operator sizeof returns an integer value -- but what integer type is that return value? An int? A short? The answer is that sizeof (and many functions that return a size or length value) return a value of type <em>std::size_t</em>. <span class="cpp-definition">std::size_t</span> is defined as an unsigned integral type, and it is typically used to represent the size or length of objects.</p><p>Amusingly, we can use the <em>sizeof</em> operator (which returns a value of type <em>std::size_t</em>) to ask for the size of <em>std::size_t</em> itself:</p><pre class="language-cpp line-numbers"><code>#include <cstddef> // std::size_t</cstddef></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; sizeof(std::size_t) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>Compiled as a 32-bit (4 byte) console app on the author’s system, this prints:</p><pre>4
</pre><p>Much like an integer can vary in size depending on the system, <em>std::size_t</em> also varies in size. <em>std::size_t</em> is guaranteed to be unsigned and at least 16 bits, but on most systems will be equivalent to the address-width of the application. That is, for 32-bit applications, <em>std::size_t</em> will typically be a 32-bit unsigned integer, and for a 64-bit application, <em>size_t</em> will typically be a 64-bit unsigned integer. <em>size_t</em> is defined to be big enough to hold the size of the largest object creatable on your system (in bytes). For example, if <em>std::size_t</em> is 4 bytes wide, the largest object creatable on your system can’t be larger than 4,294,967,295 bytes, because 4,294,967,295 is the largest number a 4-byte unsigned integer can store. This is only the uppermost limit of an object’s size, the real size limit can be lower depending on the compiler you’re using.</p><p>By definition, any object with a size (in bytes) larger than the largest integral value <em>size_t</em> can hold is considered ill-formed (and will cause a compile error), as the <em>sizeof</em> operator would not be able to return the size without wrapping around.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>Some compilers limit the largest creatable object to half the maximum value of <code>std::size_t</code> (a good explanation for this can be found <a href="https://stackoverflow.com/a/42428240">here</a>).</p><p>In practice, the largest creatable object may be smaller than this amount (perhaps significantly so), depending on how much contiguous memory your computer has available for allocation.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">4.7 — Introduction to scientific notation</h1></header><div class="entry-content" itemprop="articleBody"><p>Before we talk about our next subject, we’re going to sidebar into the topic of scientific notation.</p><p><strong>Scientific notation</strong> is a useful shorthand for writing lengthy numbers in a concise manner. And although scientific notation may seem foreign at first, understanding scientific notation will help you understand how floating point numbers work, and more importantly, what their limitations are.</p><p>Numbers in scientific notation take the following form: <em>significand</em> x 10<sup><em>exponent</em></sup>. For example, in the scientific notation <code>1.2 x 10⁴</code>, <code>1.2</code> is the significand and <code>4</code> is the exponent. Since 10⁴ evaluates to 10,000, 1.2 x 10⁴ evaluates to 12,000.</p><p>By convention, numbers in scientific notation are written with one digit before the decimal point, and the rest of the digits afterward.</p><p>Consider the mass of the Earth. In decimal notation, we’d write this as <code>5973600000000000000000000 kg</code>. That’s a really large number (too big to fit even in an 8 byte integer). It’s also hard to read (is that 19 or 20 zeros?). Even with separators (5,973,600,000,000,000,000,000,000) the number is still hard to read.</p><p>In scientific notation, this would be written as <code>5.9736 x 10²⁴ kg</code>, which is much easier to read. Scientific notation has the added benefit of making it easier to compare the magnitude of two really large or really small numbers simply by comparing the exponent.</p><p>Because it can be hard to type or display exponents in C++, we use the letter ‘e’ (or sometimes ‘E’) to represent the “times 10 to the power of” part of the equation. For example, <code>1.2 x 10⁴</code> would be written as <code>1.2e4</code>, and <code>5.9736 x 10²⁴</code> would be written as <code>5.9736e24</code>.</p><p>For numbers smaller than 1, the exponent can be negative. The number <code>5e-2</code> is equivalent to <code>5 * 10⁻²</code>, which is <code>5 / 10²</code>, or <code>0.05</code>. The mass of an electron is <code>9.1093822e-31 kg</code>.</p><br><h3>How to convert numbers to scientific notation</h3><p>Use the following procedure:</p><ul><li>Your exponent starts at zero.</li><li>Slide the decimal so there is only one non-zero digit to the left of the decimal.<ul><li>Each place you slide the decimal to the left increases the exponent by 1.</li><li>Each place you slide the decimal to the right decreases the exponent by 1.</li></ul></li><li>Trim off any leading zeros (on the left end of the significand)</li><li>Trim off any trailing zeros (on the right end of the significand) only if the original number had no decimal point. We’re assuming they’re not significant unless otherwise specified.</li></ul><p>Here’s some examples:</p><pre>Start with: 42030
Slide decimal left 4 spaces: 4.2030e4
No leading zeros to trim: 4.2030e4
Trim trailing zeros: 4.203e4 (4 significant digits)
</pre><pre>Start with: 0.0078900
Slide decimal right 3 spaces: 0007.8900e-3
Trim leading zeros: 7.8900e-3
Don't trim trailing zeros: 7.8900e-3 (5 significant digits)
</pre><pre>Start with: 600.410
Slide decimal left 2 spaces: 6.00410e2
No leading zeros to trim: 6.00410e2
Don't trim trailing zeros: 6.00410e2 (6 significant digits)
</pre><p>Here’s the most important thing to understand: The digits in the significand (the part before the ‘e’) are called the <strong>significant digits</strong>. The number of significant digits defines a number’s <strong>precision</strong>. The more digits in the significand, the more precise a number is.</p><br><h3>Precision and trailing zeros after the decimal</h3><p>Consider the case where we ask two lab assistants each to weigh the same apple. One returns and says the apple weighs 87 grams. The other returns and says the apple weighs 87.00 grams. Let’s assume the weighing is correct. In the former case, the actual weight of the apple could be anywhere between 86.50 and 87.49 grams. Maybe the scale was only precise to the nearest gram. Or maybe our assistant rounded a bit. In the latter case, we are confident about the actual weight of the apple to a much higher degree (it weighs between 86.9950 and 87.0049 grams, which has much less variability).</p><p>So in standard scientific notation, we prefer to keep trailing zeros after a decimal point, because those digits impart useful information about the precision of the number.</p><p>However, in C++, 87 and 87.000 are treated exactly the same, and the compiler will store the same value for each. There’s no technical reason why we should prefer one over the other (though there might be scientific reasons, if you’re using the source code as documentation).</p><p>Now that we’ve covered scientific notation, we’re ready to cover floating point numbers.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Convert the following numbers to scientific notation (using an e to represent the exponent) and determine how many significant digits each has (keep trailing zeros after the decimal):</p><p>a) 34.50</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none">3.450e1 (4 significant digits)</div><p>b) 0.004000</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none">4.000e-3 (4 significant digits)</div><p>c) 123.005</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none">1.23005e2 (6 significant digits)</div><p>d) 146000</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none">1.46e5 (3 significant digits). Remember, trailing zeros in a whole number with no decimal are not significant.</div><p>e) 146000.001</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none">1.46000001e5 (9 significant digits)</div><p>f) 0.0000000008</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none">8e-10 (1 significant digit). The correct significand is 8, not 8.0. 8.0 has two significant digits, but this number only has 1.</div><p>g) 34500.0</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none">3.45000e4 (6 significant digits). We don’t trim the trailing zeros here because the number <em>does</em> have a decimal point. Even though the decimal point doesn’t affect the value of the number, it affects the precision, so it needs to be included in the significant.<p>If the number had been specified as 34500, then the answer would have been 3.45e4 (3 significant digits).</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">4.8 — Floating point numbers</h1></header><div class="entry-content" itemprop="articleBody"><p>Integers are great for counting whole numbers, but sometimes we need to store <em>very</em> large numbers, or numbers with a fractional component. A <strong>floating point</strong> type variable is a variable that can hold a real number, such as 4320.0, -3.33, or 0.01226. The <em>floating</em> part of the name <em>floating point</em> refers to the fact that the decimal point can “float”; that is, it can support a variable number of digits before and after the decimal point.</p><p>There are three different floating point data types: <strong>float</strong>, <strong>double</strong>, and <strong>long double</strong>. As with integers, C++ does not define the actual size of these types (but it does guarantee minimum sizes). On modern architectures, floating point representation almost always follows IEEE 754 binary format. In this format, a float is 4 bytes, a double is 8, and a long double can be equivalent to a double (8 bytes), 80-bits (often padded to 12 bytes), or 16 bytes.</p><p>Floating point data types are always signed (can hold positive and negative values).</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Category</th><th>Type</th><th>Minimum Size</th><th>Typical Size</th></tr><tr><td>floating point</td><td>float</td><td>4 bytes</td><td>4 bytes</td></tr><tr><td></td><td>double</td><td>8 bytes</td><td>8 bytes</td></tr><tr><td></td><td>long double</td><td>8 bytes</td><td>8, 12, or 16 bytes</td></tr></tbody></table></div><p>Here are some definitions of floating point variables:</p><pre class="language-cpp line-numbers"><code>float fValue;</code><code>double dValue;</code><code>long double ldValue;</code></pre><p>When using floating point literals, always include at least one decimal place (even if the decimal is 0). This helps the compiler understand that the number is a floating point number and not an integer.</p><pre class="language-cpp line-numbers"><code>int x{5}; // 5 means integer</code><code>double y{5.0}; // 5.0 is a floating point literal (no suffix means double type by default)</code><code>float z{5.0f}; // 5.0 is a floating point literal, f suffix means float type</code></pre><p>Note that by default, floating point literals default to type double. An f suffix is used to denote a literal of type float.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Always make sure the type of your literals match the type of the variables they’re being assigned to or used to initialize. Otherwise an unnecessary conversion will result, possibly with a loss of precision.</p></div><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Make sure you don’t use integer literals where floating point literals should be used. This includes when initializing or assigning values to floating point objects, doing floating point arithmetic, and calling functions that expect floating point values.</p></div><br><h3>Printing floating point numbers</h3><p>Now consider this simple program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; 5.0 &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; 6.7f &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; 9876543.21 &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>The results of this seemingly simple program may surprise you:</p><pre>5
6.7
9.87654e+06
</pre><p>In the first case, the std::cout printed 5, even though we typed in 5.0. By default, std::cout will not print the fractional part of a number if the fractional part is 0.</p><p>In the second case, the number prints as we expect.</p><p>In the third case, it printed the number in scientific notation (if you need a refresher on scientific notation, see lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-scientific-notation/">4.7 -- Introduction to scientific notation</a>).</p><br><h3>Floating point range</h3><p>Assuming IEEE 754 representation:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Size</th><th>Range</th><th>Precision</th></tr><tr><td>4 bytes</td><td>±1.18 x 10<sup>-38</sup> to ±3.4 x 10<sup>38</sup></td><td>6-9 significant digits, typically 7</td></tr><tr><td>8 bytes</td><td>±2.23 x 10<sup>-308</sup> to ±1.80 x 10<sup>308</sup></td><td>15-18 significant digits, typically 16</td></tr><tr><td>80-bits (typically uses 12 or 16 bytes)</td><td>±3.36 x 10<sup>-4932</sup> to ±1.18 x 10<sup>4932</sup></td><td>18-21 significant digits</td></tr><tr><td>16 bytes</td><td>±3.36 x 10<sup>-4932</sup> to ±1.18 x 10<sup>4932</sup></td><td>33-36 significant digits</td></tr></tbody></table></div><p>The 80-bit floating point type is a bit of a historical anomaly. On modern processors, it is typically implemented using 12 or 16 bytes (which is a more natural size for processors to handle).</p><p>It may seem a little odd that the 80-bit floating point type has the same range as the 16-byte floating point type. This is because they have the same number of bits dedicated to the exponent -- however, the 16-byte number can store more significant digits.</p><br><h3>Floating point precision</h3><p>Consider the fraction 1/3. The decimal representation of this number is 0.33333333333333… with 3’s going out to infinity. If you were writing this number on a piece of paper, your arm would get tired at some point, and you’d eventually stop writing. And the number you were left with would be close to 0.3333333333…. (with 3’s going out to infinity) but not exactly.</p><p>On a computer, an infinite length number would require infinite memory to store, and typically we only have 4 or 8 bytes. This limited memory means floating point numbers can only store a certain number of significant digits -- and that any additional significant digits are lost. The number that is actually stored will be close to the desired number, but not exact.</p><p>The <span class="cpp-definition">precision</span> of a floating point number defines how many <em>significant digits</em> it can represent without information loss.</p><p>When outputting floating point numbers, std::cout has a default precision of 6 -- that is, it assumes all floating point variables are only significant to 6 digits (the minimum precision of a float), and hence it will truncate anything after that.</p><p>The following program shows std::cout truncating to 6 digits:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; 9.87654321f &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; 987.654321f &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; 987654.321f &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; 9876543.21f &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; 0.0000987654321f &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program outputs:</p><pre>9.87654
987.654
987654
9.87654e+006
9.87654e-005
</pre><p>Note that each of these only have 6 significant digits.</p><p>Also note that std::cout will switch to outputting numbers in scientific notation in some cases. Depending on the compiler, the exponent will typically be padded to a minimum number of digits. Fear not, 9.87654e+006 is the same as 9.87654e6, just with some padding 0’s. The minimum number of exponent digits displayed is compiler-specific (Visual Studio uses 3, some others use 2 as per the C99 standard).</p><p>The number of digits of precision a floating point variable has depends on both the size (floats have less precision than doubles) and the particular value being stored (some values have more precision than others). Float values have between 6 and 9 digits of precision, with most float values having at least 7 significant digits. Double values have between 15 and 18 digits of precision, with most double values having at least 16 significant digits. Long double has a minimum precision of 15, 18, or 33 significant digits depending on how many bytes it occupies.</p><p>We can override the default precision that std::cout shows by using an <code>output manipulator</code> function named <code>std::setprecision()</code>. <span class="cpp-definition">Output manipulators</span> alter how data is output, and are defined in the <em>iomanip</em> header.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iomanip> // for output manipulator std::setprecision()</iomanip></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; std::setprecision(16); // show 16 digits of precision</code><code>    std::cout &lt;&lt; 3.33333333333333333333333333333333333333f &lt;&lt;'\n'; // f suffix means float</code><code>    std::cout &lt;&lt; 3.33333333333333333333333333333333333333 &lt;&lt; '\n'; // no suffix means double</code><code></code><code>    return 0;</code><code>}</code></pre><p>Outputs:</p><pre>3.333333253860474
3.333333333333334
</pre><p>Because we set the precision to 16 digits using <code>std::setprecision()</code>, each of the above numbers is printed with 16 digits. But, as you can see, the numbers certainly aren’t precise to 16 digits! And because floats are less precise than doubles, the float has more error.</p><p>Precision issues don’t just impact fractional numbers, they impact any number with too many significant digits. Let’s consider a big number:</p><pre class="language-cpp line-numbers"><code>#include <iomanip> // for std::setprecision()</iomanip></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    float f { 123456789.0f }; // f has 10 significant digits</code><code>    std::cout &lt;&lt; std::setprecision(9); // to show 9 digits in f</code><code>    std::cout &lt;&lt; f &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Output:</p><pre>123456792
</pre><p>123456792 is greater than 123456789. The value 123456789.0 has 10 significant digits, but float values typically have 7 digits of precision (and the result of 123456792 is precise only to 7 significant digits). We lost some precision! When precision is lost because a number can’t be stored precisely, this is called a <span class="cpp-definition">rounding error</span>.</p><p>Consequently, one has to be careful when using floating point numbers that require more precision than the variables can hold.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Favor double over float unless space is at a premium, as the lack of precision in a float will often lead to inaccuracies.</p></div><br><h3>Rounding errors make floating point comparisons tricky</h3><p>Floating point numbers are tricky to work with due to non-obvious differences between binary (how data is stored) and decimal (how we think) numbers. Consider the fraction 1/10. In decimal, this is easily represented as 0.1, and we are used to thinking of 0.1 as an easily representable number with 1 significant digit. However, in binary, 0.1 is represented by the infinite sequence: 0.00011001100110011… Because of this, when we assign 0.1 to a floating point number, we’ll run into precision problems.</p><p>You can see the effects of this in the following program:</p><pre class="language-cpp line-numbers"><code>#include <iomanip> // for std::setprecision()</iomanip></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    double d{0.1};</code><code>    std::cout &lt;&lt; d &lt;&lt; '\n'; // use default cout precision of 6</code><code>    std::cout &lt;&lt; std::setprecision(17);</code><code>    std::cout &lt;&lt; d &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This outputs:</p><pre>0.1
0.10000000000000001
</pre><p>On the top line, std::cout prints 0.1, as we expect.</p><p>On the bottom line, where we have std::cout show us 17 digits of precision, we see that d is actually <em>not quite</em> 0.1! This is because the double had to truncate the approximation due to its limited memory. The result is a number that is precise to 16 significant digits (which type double guarantees), but the number is not <em>exactly</em> 0.1. Rounding errors may make a number either slightly smaller or slightly larger, depending on where the truncation happens.</p><p>Rounding errors can have unexpected consequences:</p><pre class="language-cpp line-numbers"><code>#include <iomanip> // for std::setprecision()</iomanip></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; std::setprecision(17);</code><code></code><code>    double d1{ 1.0 };</code><code>    std::cout &lt;&lt; d1 &lt;&lt; '\n';</code><code>	</code><code>    double d2{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 }; // should equal 1.0</code><code>    std::cout &lt;&lt; d2 &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><pre>1
0.99999999999999989
</pre><p>Although we might expect that d1 and d2 should be equal, we see that they are not. If we were to compare d1 and d2 in a program, the program would probably not perform as expected. Because floating point numbers tend to be inexact, comparing floating point numbers is generally problematic -- we discuss the subject more (and solutions) in lesson <a href="https://www.learncpp.com/cpp-tutorial/relational-operators-and-floating-point-comparisons/">5.6 -- Relational operators and floating point comparisons</a>.</p><p>One last note on rounding errors: mathematical operations (such as addition and multiplication) tend to make rounding errors grow. So even though 0.1 has a rounding error in the 17th significant digit, when we add 0.1 ten times, the rounding error has crept into the 16th significant digit. Continued operations would cause this error to become increasingly significant.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Rounding errors occur when a number can’t be stored precisely. This can happen even with simple numbers, like 0.1. Therefore, rounding errors can, and do, happen all the time. Rounding errors aren’t the exception -- they’re the rule. Never assume your floating point numbers are exact.</p><p>A corollary of this rule is: be wary of using floating point numbers for financial or currency data.</p></div><br><h3>NaN and Inf</h3><p>There are two special categories of floating point numbers. The first is <span class="cpp-definition">Inf</span>, which represents infinity. Inf can be positive or negative. The second is <span class="cpp-definition">NaN</span>, which stands for “Not a Number”. There are several different kinds of NaN (which we won’t discuss here). NaN and Inf are only available if the compiler uses a specific format (IEEE 754) for floating point numbers. If another format is used, the following code produces undefined behavior.</p><p>Here’s a program showing all three:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    double zero {0.0};</code><code>    double posinf { 5.0 / zero }; // positive infinity</code><code>    std::cout &lt;&lt; posinf &lt;&lt; '\n';</code><code></code><code>    double neginf { -5.0 / zero }; // negative infinity</code><code>    std::cout &lt;&lt; neginf &lt;&lt; '\n';</code><code></code><code>    double nan { zero / zero }; // not a number (mathematically invalid)</code><code>    std::cout &lt;&lt; nan &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>And the results using Visual Studio 2008 on Windows:</p><pre>1.#INF
-1.#INF
1.#IND
</pre><p><em>INF</em> stands for infinity, and <em>IND</em> stands for indeterminate. Note that the results of printing <em>Inf</em> and <em>NaN</em> are platform specific, so your results may vary.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Avoid division by 0 altogether, even if your compiler supports it.</p></div><br><h3>Conclusion</h3><p>To summarize, the two things you should remember about floating point numbers:</p><ol start="1"><li>Floating point numbers are useful for storing very large or very small numbers, including those with fractional components.</li><li>Floating point numbers often have small rounding errors, even when the number has fewer significant digits than the precision. Many times these go unnoticed because they are so small, and because the numbers are truncated for output. However, comparisons of floating point numbers may not give the expected results. Performing mathematical operations on these values will cause the rounding errors to grow larger.</li></ol></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">4.9 — Boolean values</h1></header><div class="entry-content" itemprop="articleBody"><p>In real-life, it’s common to ask or be asked questions that can be answered with “yes” or “no”. “Is an apple a fruit?” Yes. “Do you like asparagus?” No.</p><p>Now consider a similar statement that can be answered with a “true” or “false”: “Apples are a fruit”. It’s clearly true. Or how about, “I like asparagus”. Absolutely false (yuck!).</p><p>These kinds of sentences that have only two possible outcomes: yes/true, or no/false are so common, that many programming languages include a special type for dealing with them. That type is called a <span class="cpp-definition">Boolean</span> type (note: Boolean is properly capitalized in the English language because it’s named after its inventor, George Boole).</p><br><h3>Boolean variables</h3><p>Boolean variables are variables that can have only two possible values: <em>true</em>, and <em>false</em>.</p><p>To declare a Boolean variable, we use the keyword <strong>bool</strong>.</p><pre class="language-cpp line-numbers"><code>bool b;</code></pre><p>To initialize or assign a <em>true</em> or <em>false</em> value to a Boolean variable, we use the keywords <span class="cpp-definition">true</span> and <span class="cpp-definition">false</span>.</p><pre class="language-cpp line-numbers"><code>bool b1 { true };</code><code>bool b2 { false };</code><code>b1 = false;</code><code>bool b3 {}; // default initialize to false</code></pre><p>Just as the unary minus operator (-) can be used to make an integer negative, the logical NOT operator (!) can be used to flip a Boolean value from <em>true</em> to <em>false</em>, or <em>false</em> to <em>true</em>:</p><pre class="language-cpp line-numbers"><code>bool b1 { !true }; // b1 will be initialized with the value false</code><code>bool b2 { !false }; // b2 will be initialized with the value true</code></pre><p>Boolean values are not actually stored in Boolean variables as the words “true” or “false”. Instead, they are stored as integers: <em>true</em> becomes the integer <em>1</em>, and <em>false</em> becomes the integer <em>0</em>. Similarly, when Boolean values are evaluated, they don’t actually evaluate to “true” or “false”. They evaluate to the integers <em>0</em> (false) or <em>1</em> (true). Because Booleans actually store integers, they are considered an integral type.</p><br><h3>Printing Boolean values</h3><p>When we print Boolean values, std::cout prints <em>0</em> for <em>false</em>, and <em>1</em> for <em>true</em>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; true &lt;&lt; '\n'; // true evaluates to 1</code><code>    std::cout &lt;&lt; !true &lt;&lt; '\n'; // !true evaluates to 0</code><code></code><code>    bool b{false};</code><code>    std::cout &lt;&lt; b &lt;&lt; '\n'; // b is false, which evaluates to 0</code><code>    std::cout &lt;&lt; !b &lt;&lt; '\n'; // !b is true, which evaluates to 1</code><code>    return 0;</code><code>}</code></pre><p>Outputs:</p><pre>1
0
0
1
</pre><p>If you want std::cout to print “true” or “false” instead of 0 or 1, you can use <em>std::boolalpha</em>. Here’s an example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; true &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; false &lt;&lt; '\n';</code><code></code><code>    std::cout &lt;&lt; std::boolalpha; // print bools as true or false</code><code></code><code>    std::cout &lt;&lt; true &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; false &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>1
0
true
false
</pre><p>You can use <em>std::noboolalpha</em> to turn it back off.</p><br><h3>Integer to Boolean conversion</h3><p>You can’t initialize a Boolean with an integer using uniform initialization:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	bool b{ 4 }; // error: narrowing conversions disallowed</code><code>	std::cout &lt;&lt; b;</code><code>	</code><code>	return 0;</code><code>}</code></pre><p>However, in any context where an integer can be converted to a Boolean, the integer <em>0</em> is converted to <em>false</em>, and any other integer is converted to <em>true</em>.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; std::boolalpha; // print bools as true or false</code><code></code><code>	bool b1 = 4 ; // copy initialization allows implicit conversion from int to bool</code><code>	std::cout &lt;&lt; b1 &lt;&lt; '\n';</code><code></code><code>	bool b2 = 0 ; // copy initialization allows implicit conversion from int to bool</code><code>	std::cout &lt;&lt; b2 &lt;&lt; '\n';</code><code></code><code>	</code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>true
false
</pre><p>Note: <code>bool b1 = 4;</code> may generate a warning. If so you’ll have to disable treating warnings as errors to compile the example.</p><br><h3>Inputting Boolean values</h3><p>Inputting Boolean values using <em>std::cin</em> sometimes trips new programmers up.</p><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	bool b{}; // default initialize to false</code><code>	std::cout &lt;&lt; "Enter a boolean value: ";</code><code>	std::cin &gt;&gt; b;</code><code>	std::cout &lt;&lt; "You entered: " &lt;&lt; b &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><pre>Enter a Boolean value: true
You entered: 0
</pre><p>Wait, what?</p><p>It turns out that <em>std::cin</em> only accepts two inputs for boolean variables: 0 and 1 (<em>not</em> true or false). Any other inputs will cause <em>std::cin</em> to silently fail. In this case, because we entered <em>true</em>, <em>std::cin</em> silently failed. A failed input will also zero-out the variable, so <em>b</em> also gets assigned value <em>false</em>. Consequently, when <em>std::cout</em> prints a value for <em>b</em>, it prints 0.</p><p>To allow <em>std::cin</em> to accept “false” and “true” as inputs, the <em>std::boolalpha</em> option has to be enabled:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	bool b{};</code><code>	std::cout &lt;&lt; "Enter a boolean value: ";</code><code></code><code>	// Allow the user to enter 'true' or 'false' for boolean values</code><code>	// This is case-sensitive, so True or TRUE will not work</code><code>	std::cin &gt;&gt; std::boolalpha;</code><code>	std::cin &gt;&gt; b;</code><code></code><code>	std::cout &lt;&lt; "You entered: " &lt;&lt; b &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>However, when <em>std::boolalpha</em> is enabled, “0” and “1” will no longer be treated as booleans.</p><br><h3>Boolean return values</h3><p>Boolean values are often used as the return values for functions that check whether something is true or not. Such functions are typically named starting with the word <em>is</em> (e.g. isEqual) or <em>has</em> (e.g. hasCommonDivisor).</p><p>Consider the following example, which is quite similar to the above:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// returns true if x and y are equal, false otherwise</code><code>bool isEqual(int x, int y)</code><code>{</code><code>    return (x == y); // operator== returns true if x equals y, and false otherwise</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    std::cout &lt;&lt; "Enter another integer: ";</code><code>    int y{};</code><code>    std::cin &gt;&gt; y;</code><code></code><code>    std::cout &lt;&lt; std::boolalpha; // print bools as true or false</code><code>    </code><code>    std::cout &lt;&lt; x &lt;&lt; " and " &lt;&lt; y &lt;&lt; " are equal? ";</code><code>    std::cout &lt;&lt; isEqual(x, y); // will return true or false</code><code></code><code>    return 0;</code><code>}</code></pre><p>Here’s output from two runs of this program:</p><pre>Enter an integer: 5
Enter another integer: 5
5 and 5 are equal? true
</pre><pre>Enter an integer: 6
Enter another integer: 4
6 and 4 are equal? false
</pre><p>How does this work? First we read in integer values for <em>x</em> and <em>y</em>. Next, the expression “isEqual(x, y)” is evaluated. In the first run, this results in a function call to isEqual(5, 5). Inside that function, 5 == 5 is evaluated, producing the value <em>true</em>. The value <em>true</em> is returned back to the caller to be printed by std::cout. In the second run, the call to isEqual(6, 4) returns the value <em>false</em>.</p><p>Boolean values take a little bit of getting used to, but once you get your mind wrapped around them, they’re quite refreshing in their simplicity! Boolean values are also a huge part of the language -- you’ll end up using them more than all the other fundamental types put together!</p><p>We’ll continue our exploration of Boolean values in the next lesson.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">4.10 — Introduction to if statements</h1></header><div class="entry-content" itemprop="articleBody"><p>Consider a case where you’re going to go to the market, and your roommate tells you, “if they have strawberries on sale, buy some”. This is a conditional statement, meaning that you’ll execute some action (“buy some”) only if the condition (“they have strawberries on sale”) is true.</p><p>Such conditions are common in programming, as they allow us to implement conditional behavior into our programs. The simplest kind of conditional statement in C++ is called an <em>if statement</em>. An <span class="cpp-definition">if statement</span> allows us to execute one (or more) lines of code only if some condition is true.</p><p>The simplest <em>if statement</em> takes the following form:</p><pre>if (condition) true_statement;
</pre><p>For readability, this is more often written as following:</p><pre>if (condition)
    true_statement;
</pre><p>A <span class="cpp-definition">condition</span> (also called a <span class="cpp-definition">conditional expression</span>) is an expression that evaluates to a Boolean value.</p><p>If the <em>condition</em> of an <em>if statement</em> evaluates to Boolean value <em>true</em>, then <em>true_statement</em> is executed. If the <em>condition</em> instead evaluates to Boolean value <em>false</em>, then <em>true_statement</em> is skipped.</p><br><h3>A sample program using an if statement</h3><p>Given the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    int x {};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    if (x == 0)</code><code>        std::cout &lt;&lt; "The value is zero\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>Here’s output from one run of this program:</p><pre>Enter an integer: 0
The value is zero
</pre><p>Let’s examine how this works in more detail.</p><p>First, the user enters an integer. Then the condition <em>x == 0</em> is evaluated. The <em>equality operator</em> (==) is used to test whether two values are equal. Operator== returns <em>true</em> if the operands are equal, and <em>false</em> if they are not. Since <em>x</em> has value 0, and <em>0 == 0</em> is true, this expression evaluates to <em>true</em>.</p><p>Because the condition has evaluated to <em>true</em>, the subsequent statement executes, printing <em>The value is zero</em>.</p><p>Here’s another run of this program:</p><pre>Enter an integer: 5
</pre><p>In this case, <em>x == 0</em> evaluates to <em>false</em>. The subsequent statement is skipped, the program ends, and nothing else is printed.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p><em>If statements</em> only conditionally execute a single statement. We talk about how to conditionally execute multiple statements in lesson <a href="https://www.learncpp.com/cpp-tutorial/if-statements-and-blocks/">7.2 -- If statements and blocks</a>.</p></div><br><h3>If-else</h3><p>Given the above example, what if we wanted to tell the user that the number they entered was non-zero?</p><p>We could write something like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    int x {};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    if (x == 0)</code><code>        std::cout &lt;&lt; "The value is zero\n";</code><code>    if (x != 0)</code><code>        std::cout &lt;&lt; "The value is non-zero\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>Or this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    int x {};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    bool zero { (x == 0) };</code><code>    if (zero)</code><code>        std::cout &lt;&lt; "The value is zero\n";</code><code>    if (!zero)</code><code>        std::cout &lt;&lt; "The value is non-zero\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>Both of these programs are more complex than they need to be. Instead, we can use an alternative form of the <em>if statement</em> called <em>if-else</em>. <em>If-else</em> takes the following form:</p><pre>if (condition)
    true_statement;
else
    false_statement;
</pre><p>If the <em>condition</em> evaluates to Boolean true, <em>true_statement</em> executes. Otherwise <em>false_statement</em> executes.</p><p>Let’s amend our previous program to use an <em>if-else</em>.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    int x {};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    if (x == 0)</code><code>        std::cout &lt;&lt; "The value is zero\n";</code><code>    else</code><code>        std::cout &lt;&lt; "The value is non-zero\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>Now our program will produce the following output:</p><pre>Enter an integer: 0
The value is zero
</pre><pre>Enter an integer: 5
The value is non-zero
</pre><br><h3>Chaining if statements</h3><p>Sometimes we want to check if several things are true or false in sequence. We can do so by chaining an <em>if statement</em> to a prior <em>if-else</em>, like so:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    int x {};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    if (x &gt; 0)</code><code>        std::cout &lt;&lt; "The value is positive\n";</code><code>    else if (x &lt; 0)</code><code>        std::cout &lt;&lt; "The value is negative\n";</code><code>    else </code><code>        std::cout &lt;&lt; "The value is zero\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>The <em>less than operator</em> (&lt;) is used to test whether one value is less than another. Similarly, the <em>greater than operator</em> (&gt;) is used to test whether one value is greater than another. These operators both return Boolean values.</p><p>Here’s output from a few runs of this program:</p><pre>Enter an integer: 4
The value is positive
</pre><pre>Enter an integer: -3
The value is negative
</pre><pre>Enter an integer: 0
The value is zero
</pre><p>Note that you can chain <em>if statements</em> as many times as you have conditions you want to evaluate. We’ll see an example in the quiz where this is useful.</p><br><h3>Boolean return values and if statements</h3><p>In the previous lesson (<a href="https://www.learncpp.com/cpp-tutorial/boolean-values/">4.9 -- Boolean values</a>), we wrote this program using a function that returns a Boolean value:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code> </code><code>// returns true if x and y are equal, false otherwise</code><code>bool isEqual(int x, int y)</code><code>{</code><code>    return (x == y); // operator== returns true if x equals y, and false otherwise</code><code>}</code><code> </code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    int x {};</code><code>    std::cin &gt;&gt; x;</code><code> </code><code>    std::cout &lt;&lt; "Enter another integer: ";</code><code>    int y {};</code><code>    std::cin &gt;&gt; y;</code><code> </code><code>    std::cout &lt;&lt; std::boolalpha; // print bools as true or false</code><code>    </code><code>    std::cout &lt;&lt; x &lt;&lt; " and " &lt;&lt; y &lt;&lt; " are equal? ";</code><code>    std::cout &lt;&lt; isEqual(x, y); // will return true or false</code><code> </code><code>    return 0;</code><code>}</code></pre><p>Let’s improve this program using an <em>if statement</em>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code> </code><code>// returns true if x and y are equal, false otherwise</code><code>bool isEqual(int x, int y)</code><code>{</code><code>    return (x == y); // operator== returns true if x equals y, and false otherwise</code><code>}</code><code> </code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    int x {};</code><code>    std::cin &gt;&gt; x;</code><code> </code><code>    std::cout &lt;&lt; "Enter another integer: ";</code><code>    int y {};</code><code>    std::cin &gt;&gt; y;</code><code>    </code><code>    if (isEqual(x, y))</code><code>        std::cout &lt;&lt; x &lt;&lt; " and " &lt;&lt; y &lt;&lt; " are equal\n";</code><code>    else</code><code>        std::cout &lt;&lt; x &lt;&lt; " and " &lt;&lt; y &lt;&lt; " are not equal\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>Two runs of this program:</p><pre>Enter an integer: 5
Enter another integer: 5
5 and 5 are equal
</pre><pre>Enter an integer: 6
Enter another integer: 4
6 and 4 are not equal
</pre><p>In this case, our conditional expression is simply a function call to function <em>isEqual</em>, which returns a Boolean value.</p><br><h3>Non-Boolean conditionals</h3><p>In all of the examples above, our conditionals have been either Boolean values (true or false), Boolean variables, or functions that return a Boolean value. What happens if your conditional is an expression that does not evaluate to a Boolean value?</p><p>In such a case, the conditional expression is converted to a Boolean value: non-zero values get converted to Boolean <em>true</em>, and zero-values get converted to Boolean <em>false</em>.</p><p>Therefore, if we do something like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    if (4) // nonsensical, but for the sake of example...</code><code>        std::cout &lt;&lt; "hi";</code><code>    else</code><code>        std::cout &lt;&lt; "bye";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This will print “hi”, since 4 is a non-zero value that gets converted to Boolean <em>true</em>, causing the statement attached to the <em>if</em> to execute.</p><p>We’ll continue our exploration of <em>if statements</em> in future lesson <a href="https://www.learncpp.com/cpp-tutorial/if-statements-and-blocks/">7.2 -- If statements and blocks</a>.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>A prime number is a whole number greater than 1 that can only be divided evenly by 1 and itself. Write a program that asks the user to enter a number 0 through 9 (inclusive). If the user enters a number within this range that is prime (2, 3, 5, or 7), print “The digit is prime”. Otherwise, print “The digit is not prime”.</p><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">Hint: Use a chain of <em>if-else statements</em> to compare the number the user entered to the prime numbers to see if there is a match.</div><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>bool isPrime(int x)</code><code>{</code><code>    if (x == 2) // if user entered 2, the digit is prime</code><code>        return true;</code><code>    else if (x == 3) // if user entered 3, the digit is prime</code><code>        return true;</code><code>    else if (x == 5) // if user entered 5, the digit is prime</code><code>        return true;</code><code>    else if (x == 7) // if user entered 7, the digit is prime</code><code>        return true;</code><code></code><code>    return false; // if the user did not enter 2, 3, 5, 7, the digit must not be prime</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number 0 through 9: ";</code><code>    int x {};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    if ( isPrime(x) )</code><code>        std::cout &lt;&lt; "The digit is prime\n";</code><code>    else</code><code>        std::cout &lt;&lt; "The digit is not prime\n";</code><code></code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>If the <code>isPrime()</code> function above seems a bit verbose/repetitive -- it is. We can write <code>isPrime()</code> more compactly and efficiently using some concepts that we’ll explain in future lessons.</p><p>Using the logical OR (||) operator (<a href="https://www.learncpp.com/cpp-tutorial/logical-operators/">5.7 -- Logical operators</a>):</p><pre class="language-cpp line-numbers"><code>bool isPrime(int x)</code><code>{</code><code>    return (x == 2 || x == 3 || x == 5 || x == 7); // if user entered 2 or 3 or 5 or 7 the digit is prime</code><code>}</code></pre><p>Using a switch statement (<a href="https://www.learncpp.com/cpp-tutorial/switch-statement-basics/">7.4 -- Switch statement basics</a>):</p><pre class="language-cpp line-numbers"><code>bool isPrime(int x)</code><code>{</code><code>    switch (x)</code><code>    {</code><code>        case 2: // if the user entered 2</code><code>        case 3: // or if the user entered 3</code><code>        case 5: // or if the user entered 5</code><code>        case 7: // or if the user entered 7</code><code>            return true; // then the digit is prime</code><code>    }</code><code></code><code>    return false; // otherwise the digit must not be prime</code><code>}</code></pre></div></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>How can the length of the following code be reduced (without changing the formatting)?</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>bool isAllowedToTakeFunRide()</code><code>{</code><code>  std::cout &lt;&lt; "How tall are you? (cm)\n";</code><code></code><code>  double height{};</code><code>  std::cin &gt;&gt; height;</code><code></code><code>  if (height &gt; 140.0)</code><code>    return true;</code><code>  else</code><code>    return false;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  if (isAllowedToTakeFunRide())</code><code>    std::cout &lt;&lt; "Have fun!\n";</code><code>  else</code><code>    std::cout &lt;&lt; "Sorry, you're too short.\n";</code><code></code><code>  return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>We don’t need the if-statement in <code>isAllowedToTakeFunRide()</code>. The expression <code>height &gt; 140.0</code> evaluates to a <code>bool</code>, which can be directly returned.</p><pre class="language-cpp line-numbers"><code>bool isAllowedToTakeFunRide()</code><code>{</code><code>  std::cout &lt;&lt; "How tall are you? (cm)\n";</code><code></code><code>  double height{};</code><code>  std::cin &gt;&gt; height;</code><code></code><code>  return (height &gt; 140.0);</code><code>}</code></pre><p>You never need an if-statement of the form:</p><pre class="language-cpp line-numbers"><code>if (condition)</code><code>  return true;</code><code>else</code><code>  return false;</code></pre><p>This can be replaced by the single statement <code>return condition</code>.</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">4.11 — Chars</h1></header><div class="entry-content" itemprop="articleBody"><p>To this point, the fundamental data types we’ve looked at have been used to hold numbers (integers and floating point) or true/false values (booleans). But what if we want to store letters or punctuation?</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Would you like a burrito? (y/n)";</code><code></code><code>    // We want the user to enter a 'y' or 'n' character</code><code>    // How do we do this?</code><code></code><code>    return 0;</code><code>}</code></pre><p>The <span class="cpp-definition">char</span> data type was designed to hold a <code>character</code>. A <span class="cpp-definition">character</span> can be a single letter, number, symbol, or whitespace.</p><p>The char data type is an integral type, meaning the underlying value is stored as an integer. Similar to how a Boolean value <code>0</code> is interpreted as <code>false</code> and non-zero is interpreted as <code>true</code>, the integer stored by a <code>char</code> variable are intepreted as an <code>ASCII character</code>.</p><p><span class="cpp-definition">ASCII</span> stands for American Standard Code for Information Interchange, and it defines a particular way to represent English characters (plus a few other symbols) as numbers between 0 and 127 (called an <span class="cpp-definition">ASCII code</span> or <span class="cpp-definition">code point</span>). For example, ASCII code 97 is interpreted as the character ‘a’.</p><p>Character literals are always placed between single quotes (e.g. ‘g’, ‘1’, ‘ ‘).</p><p style="clear:both">Here’s a full table of ASCII characters:</p><p></p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Code</th><th>Symbol</th><th>Code</th><th>Symbol</th><th>Code</th><th>Symbol</th><th>Code</th><th>Symbol</th></tr><tr><td style="background-color:#ccc">0</td><td>NUL (null)</td><td style="background-color:#ccc">32</td><td>(space)</td><td style="background-color:#ccc">64</td><td>@</td><td style="background-color:#ccc">96</td><td>`</td></tr><tr><td style="background-color:#ccc">1</td><td>SOH (start of header)</td><td style="background-color:#ccc">33</td><td>!</td><td style="background-color:#ccc">65</td><td>A</td><td style="background-color:#ccc">97</td><td>a</td></tr><tr><td style="background-color:#ccc">2</td><td>STX (start of text)</td><td style="background-color:#ccc">34</td><td>”</td><td style="background-color:#ccc">66</td><td>B</td><td style="background-color:#ccc">98</td><td>b</td></tr><tr><td style="background-color:#ccc">3</td><td>ETX (end of text)</td><td style="background-color:#ccc">35</td><td>#</td><td style="background-color:#ccc">67</td><td>C</td><td style="background-color:#ccc">99</td><td>c</td></tr><tr><td style="background-color:#ccc">4</td><td>EOT (end of transmission)</td><td style="background-color:#ccc">36</td><td>$</td><td style="background-color:#ccc">68</td><td>D</td><td style="background-color:#ccc">100</td><td>d</td></tr><tr><td style="background-color:#ccc">5</td><td>ENQ (enquiry)</td><td style="background-color:#ccc">37</td><td>%</td><td style="background-color:#ccc">69</td><td>E</td><td style="background-color:#ccc">101</td><td>e</td></tr><tr><td style="background-color:#ccc">6</td><td>ACK (acknowledge)</td><td style="background-color:#ccc">38</td><td>&amp;</td><td style="background-color:#ccc">70</td><td>F</td><td style="background-color:#ccc">102</td><td>f</td></tr><tr><td style="background-color:#ccc">7</td><td>BEL (bell)</td><td style="background-color:#ccc">39</td><td>’</td><td style="background-color:#ccc">71</td><td>G</td><td style="background-color:#ccc">103</td><td>g</td></tr><tr><td style="background-color:#ccc">8</td><td>BS (backspace)</td><td style="background-color:#ccc">40</td><td>(</td><td style="background-color:#ccc">72</td><td>H</td><td style="background-color:#ccc">104</td><td>h</td></tr><tr><td style="background-color:#ccc">9</td><td>HT (horizontal tab)</td><td style="background-color:#ccc">41</td><td>)</td><td style="background-color:#ccc">73</td><td>I</td><td style="background-color:#ccc">105</td><td>i</td></tr><tr><td style="background-color:#ccc">10</td><td>LF (line feed/new line)</td><td style="background-color:#ccc">42</td><td>*</td><td style="background-color:#ccc">74</td><td>J</td><td style="background-color:#ccc">106</td><td>j</td></tr><tr><td style="background-color:#ccc">11</td><td>VT (vertical tab)</td><td style="background-color:#ccc">43</td><td>+</td><td style="background-color:#ccc">75</td><td>K</td><td style="background-color:#ccc">107</td><td>k</td></tr><tr><td style="background-color:#ccc">12</td><td>FF (form feed / new page)</td><td style="background-color:#ccc">44</td><td>,</td><td style="background-color:#ccc">76</td><td>L</td><td style="background-color:#ccc">108</td><td>l</td></tr><tr><td style="background-color:#ccc">13</td><td>CR (carriage return)</td><td style="background-color:#ccc">45</td><td>-</td><td style="background-color:#ccc">77</td><td>M</td><td style="background-color:#ccc">109</td><td>m</td></tr><tr><td style="background-color:#ccc">14</td><td>SO (shift out)</td><td style="background-color:#ccc">46</td><td>.</td><td style="background-color:#ccc">78</td><td>N</td><td style="background-color:#ccc">110</td><td>n</td></tr><tr><td style="background-color:#ccc">15</td><td>SI (shift in)</td><td style="background-color:#ccc">47</td><td>/</td><td style="background-color:#ccc">79</td><td>O</td><td style="background-color:#ccc">111</td><td>o</td></tr><tr><td style="background-color:#ccc">16</td><td>DLE (data link escape)</td><td style="background-color:#ccc">48</td><td>0</td><td style="background-color:#ccc">80</td><td>P</td><td style="background-color:#ccc">112</td><td>p</td></tr><tr><td style="background-color:#ccc">17</td><td>DC1 (data control 1)</td><td style="background-color:#ccc">49</td><td>1</td><td style="background-color:#ccc">81</td><td>Q</td><td style="background-color:#ccc">113</td><td>q</td></tr><tr><td style="background-color:#ccc">18</td><td>DC2 (data control 2)</td><td style="background-color:#ccc">50</td><td>2</td><td style="background-color:#ccc">82</td><td>R</td><td style="background-color:#ccc">114</td><td>r</td></tr><tr><td style="background-color:#ccc">19</td><td>DC3 (data control 3)</td><td style="background-color:#ccc">51</td><td>3</td><td style="background-color:#ccc">83</td><td>S</td><td style="background-color:#ccc">115</td><td>s</td></tr><tr><td style="background-color:#ccc">20</td><td>DC4 (data control 4)</td><td style="background-color:#ccc">52</td><td>4</td><td style="background-color:#ccc">84</td><td>T</td><td style="background-color:#ccc">116</td><td>t</td></tr><tr><td style="background-color:#ccc">21</td><td>NAK (negative acknowledge)</td><td style="background-color:#ccc">53</td><td>5</td><td style="background-color:#ccc">85</td><td>U</td><td style="background-color:#ccc">117</td><td>u</td></tr><tr><td style="background-color:#ccc">22</td><td>SYN (synchronous idle)</td><td style="background-color:#ccc">54</td><td>6</td><td style="background-color:#ccc">86</td><td>V</td><td style="background-color:#ccc">118</td><td>v</td></tr><tr><td style="background-color:#ccc">23</td><td>ETB (end of transmission block)</td><td style="background-color:#ccc">55</td><td>7</td><td style="background-color:#ccc">87</td><td>W</td><td style="background-color:#ccc">119</td><td>w</td></tr><tr><td style="background-color:#ccc">24</td><td>CAN (cancel)</td><td style="background-color:#ccc">56</td><td>8</td><td style="background-color:#ccc">88</td><td>X</td><td style="background-color:#ccc">120</td><td>x</td></tr><tr><td style="background-color:#ccc">25</td><td>EM (end of medium)</td><td style="background-color:#ccc">57</td><td>9</td><td style="background-color:#ccc">89</td><td>Y</td><td style="background-color:#ccc">121</td><td>y</td></tr><tr><td style="background-color:#ccc">26</td><td>SUB (substitute)</td><td style="background-color:#ccc">58</td><td>:</td><td style="background-color:#ccc">90</td><td>Z</td><td style="background-color:#ccc">122</td><td>z</td></tr><tr><td style="background-color:#ccc">27</td><td>ESC (escape)</td><td style="background-color:#ccc">59</td><td>;</td><td style="background-color:#ccc">91</td><td>[</td><td style="background-color:#ccc">123</td><td>{</td></tr><tr><td style="background-color:#ccc">28</td><td>FS (file separator)</td><td style="background-color:#ccc">60</td><td>&lt;</td><td style="background-color:#ccc">92</td><td>\</td><td style="background-color:#ccc">124</td><td>|</td></tr><tr><td style="background-color:#ccc">29</td><td>GS (group separator)</td><td style="background-color:#ccc">61</td><td>=</td><td style="background-color:#ccc">93</td><td>]</td><td style="background-color:#ccc">125</td><td>}</td></tr><tr><td style="background-color:#ccc">30</td><td>RS (record separator)</td><td style="background-color:#ccc">62</td><td>&gt;</td><td style="background-color:#ccc">94</td><td>^</td><td style="background-color:#ccc">126</td><td>~</td></tr><tr><td style="background-color:#ccc">31</td><td>US (unit separator)</td><td style="background-color:#ccc">63</td><td>?</td><td style="background-color:#ccc">95</td><td>_</td><td style="background-color:#ccc">127</td><td>DEL (delete)</td></tr></tbody></table></div><p>Codes 0-31 are called the unprintable chars, and they’re mostly used to do formatting and control printers. Most of these are obsolete now. If you try to print these chars, the results are dependent upon your OS (you may get some emoji-like characters).</p><p>Codes 32-127 are called the printable characters, and they represent the letters, number characters, and punctuation that most computers use to display basic English text.</p><br><h3>Initializing chars</h3><p>You can initialize char variables using character literals:</p><pre class="language-cpp line-numbers"><code>char ch2{ 'a' }; // initialize with code point for 'a' (stored as integer 97) (preferred)</code></pre><p>You can initialize chars with integers as well, but this should be avoided if possible</p><pre class="language-cpp line-numbers"><code>char ch1{ 97 }; // initialize with integer 97 ('a') (not preferred)</code></pre><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Be careful not to mix up character numbers with integer numbers. The following two initializations are not the same:</p><pre class="language-cpp line-numbers"><code>char ch{5}; // initialize with integer 5 (stored as integer 5)</code><code>char ch{'5'}; // initialize with code point for '5' (stored as integer 53)</code></pre><p>Character numbers are intended to be used when we want to represent numbers as text, rather than as numbers to apply mathematical operations to.</p></div><br><h3>Printing chars</h3><p>When using std::cout to print a char, std::cout outputs the char variable as an ASCII character:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    char ch1{ 'a' }; // (preferred)</code><code>    std::cout &lt;&lt; ch1; // cout prints character 'a'</code><code></code><code>    char ch2{ 98 }; // code point for 'b' (not preferred)</code><code>    std::cout &lt;&lt; ch2; // cout prints a character ('b')</code><code></code><code></code><code>    return 0;</code><code>}</code></pre><p>This produces the result:</p><pre>ab
</pre><p>We can also output char literals directly:</p><pre class="language-cpp line-numbers"><code>cout &lt;&lt; 'c';</code></pre><p>This produces the result:</p><pre>c
</pre><br><h3>Inputting chars</h3><p>The following program asks the user to input a character, then prints out the character:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Input a keyboard character: ";</code><code></code><code>    char ch{};</code><code>    std::cin &gt;&gt; ch;</code><code>    std::cout &lt;&lt; "You entered: " &lt;&lt; ch &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Here’s the output from one run:</p><pre>Input a keyboard character: q
You entered q
</pre><p>Note that std::cin will let you enter multiple characters. However, variable <em>ch</em> can only hold 1 character. Consequently, only the first input character is extracted into variable <em>ch</em>. The rest of the user input is left in the input buffer that std::cin uses, and can be extracted with subsequent calls to std::cin.</p><p>You can see this behavior in the following example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Input a keyboard character: "; // assume the user enters "abcd" (without quotes)</code><code></code><code>    char ch{};</code><code>    std::cin &gt;&gt; ch; // ch = 'a', "bcd" is left queued.</code><code>    std::cout &lt;&lt; "You entered: " &lt;&lt; ch &lt;&lt; '\n';</code><code></code><code>    // Note: The following cin doesn't ask the user for input, it grabs queued input!</code><code>    std::cin &gt;&gt; ch; // ch = 'b', "cd" is left queued.</code><code>    std::cout &lt;&lt; "You entered: " &lt;&lt; ch &lt;&lt; '\n';</code><code>    </code><code>    return 0;</code><code>}</code></pre><pre>Input a keyboard character: abcd
You entered: a
You entered: b
</pre><p>If you want to read in more than one char at a time (e.g. to read in a name, word, or sentence), you’ll want to use a string instead of a char. A <span class="cpp-definition">string</span> is a collection of sequential characters (and thus, a string can hold multiple symbols).</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We discuss strings in upcoming lesson (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-stdstring/">4.17 -- Introduction to std::string</a>).</p></div><br><h3>Char size, range, and default sign</h3><p>Char is defined by C++ to always be 1 byte in size. By default, a char may be signed or unsigned (though it’s usually signed). If you’re using chars to hold ASCII characters, you don’t need to specify a sign (since both signed and unsigned chars can hold values between 0 and 127).</p><p>If you’re using a char to hold small integers (something you should not do unless you’re explicitly optimizing for space), you should always specify whether it is signed or unsigned. A signed char can hold a number between -128 and 127. An unsigned char can hold a number between 0 and 255.</p><br><h3>Escape sequences</h3><p>There are some characters in C++ that have special meaning. These characters are called <span class="cpp-definition">escape sequences</span>. An escape sequence starts with a ‘\’ (backslash) character, and then a following letter or number.</p><p>You’ve already seen the most common escape sequence: ‘\n’, which can be used to embed a newline in a string of text:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "First line\nSecond line\n";</code><code>    return 0;</code><code>}</code></pre><p>This outputs:</p><pre>First line
Second line
</pre><p>Another commonly used escape sequence is ‘\t’, which embeds a horizontal tab:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "First part\tSecond part";</code><code>    return 0;</code><code>}</code></pre><p>Which outputs:</p><pre>First part        Second part
</pre><p>Three other notable escape sequences are:<br>\’ prints a single quote<br>\” prints a double quote<br>\\ prints a backslash</p><p>Here’s a table of all of the escape sequences:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Name</th><th>Symbol</th><th>Meaning</th></tr><tr><td>Alert</td><td>\a</td><td>Makes an alert, such as a beep</td></tr><tr><td>Backspace</td><td>\b</td><td>Moves the cursor back one space</td></tr><tr><td>Formfeed</td><td>\f</td><td>Moves the cursor to next logical page</td></tr><tr><td>Newline</td><td>\n</td><td>Moves cursor to next line</td></tr><tr><td>Carriage return</td><td>\r</td><td>Moves cursor to beginning of line</td></tr><tr><td>Horizontal tab</td><td>\t</td><td>Prints a horizontal tab</td></tr><tr><td>Vertical tab</td><td>\v</td><td>Prints a vertical tab</td></tr><tr><td>Single quote</td><td>\’</td><td>Prints a single quote</td></tr><tr><td>Double quote</td><td>\”</td><td>Prints a double quote</td></tr><tr><td>Backslash</td><td>\\</td><td>Prints a backslash.</td></tr><tr><td>Question mark</td><td>\?</td><td>Prints a question mark.<br>No longer relevant. You can use question marks unescaped.</td></tr><tr><td>Octal number</td><td>\(number)</td><td>Translates into char represented by octal</td></tr><tr><td>Hex number</td><td>\x(number)</td><td>Translates into char represented by hex number</td></tr></tbody></table></div><p>Here are some examples:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "\"This is quoted text\"\n";</code><code>    std::cout &lt;&lt; "This string contains a single backslash \\\n";</code><code>    std::cout &lt;&lt; "6F in hex is char '\x6F'\n";</code><code>    return 0;</code><code>}</code></pre><p>Prints:</p><pre>"This is quoted text"
This string contains a single backslash \
6F in hex is char 'o'
</pre><br><h3>Newline (\n) vs. std::endl</h3><p>We cover this topic in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-iostream-cout-cin-and-endl/">1.5 -- Introduction to iostream: cout, cin, and endl</a>.</p><br><h3>What’s the difference between putting symbols in single and double quotes?</h3><p>Single chars are always put in single quotes (e.g. ‘a’, ‘+’, ‘5’). A char can only represent one symbol (e.g. the letter a, the plus symbol, the number 5). Something like this is illegal:</p><pre class="language-cpp line-numbers"><code>char ch{'56'}; // a char can only hold one symbol</code></pre><p>Text put between double quotes (e.g. “Hello, world!”) is treated as a string.</p><p>For now, you’re welcome to use string literals in your code:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; "Hello, world!"; // "Hello, world!" is a string literal</code></pre><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Put stand-alone chars in single quotes (e.g. ‘t’ or ‘\n’, not “t” or “\n”). This helps the compiler optimize more effectively.</p></div><br><h3>What about the other char types, wchar_t, char16_t, and char32_t?</h3><p>wchar_t should be avoided in almost all cases (except when interfacing with the Windows API). Its size is implementation defined, and is not reliable. It has largely been deprecated.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>The term “deprecated” means “still supported, but no longer recommended for use, because it has been replaced by something better or is no longer considered safe”.</p></div><p>Much like ASCII maps the integers 0-127 to American English characters, other character encoding standards exist to map integers (of varying sizes) to characters in other languages. The most well-known mapping outside of ASCII is the Unicode standard, which maps over 144,000 integers to characters in many different languages. Because Unicode contains so many code points, a single Unicode code point needs 32-bits to represent a character (called UTF-32). However, Unicode characters can also be encoded using multiple 16-bit or 8-bit characters (called UTF-16 and UTF-8 respectively).</p><p>char16_t and char32_t were added to C++11 to provide explicit support for 16-bit and 32-bit Unicode characters. char8_t has been added in C++20.</p><p>You won’t need to use char8_t, char16_t, or char32_t unless you’re planning on making your program Unicode compatible. Unicode and localization are generally outside the scope of these tutorials, so we won’t cover it further.</p><p>In the meantime, you should only use ASCII characters when working with characters (and strings). Using characters from other character sets may cause your characters to display incorrectly.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">4.12 — Introduction to type conversion and static_cast</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Implicit type conversion</h3><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print(double x) // print takes an double parameter</code><code>{</code><code>	std::cout &lt;&lt; x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	print(5); // what happens when we pass an int value?</code><code></code><code>	return 0;</code><code>}</code></pre><p>In the above example, the <code>print()</code> function has a parameter of type <code>double</code> but the caller is passing in the value <code>5</code> which is of type <code>int</code>. What happens in this case?</p><p>In most cases, C++ will allow us convert values of one fundamental type to another fundamental type. The process of converting a value from one type to another type is called <span class="cpp-definition">type conversion</span>. Thus, the int argument <code>5</code> will be converted to double value <code>5.0</code> and then copied into parameter <code>x</code>. The <code>print()</code> function will print this value, resulting in the following output:</p><pre>5
</pre><p>When the compiler does type conversion on our behalf without us explicitly asking, we call this <span class="cpp-definition">implicit type conversion</span>. The above example illustrates this -- nowhere do we explicitly tell the compiler to convert integer value <code>5</code> to double value <code>5.0</code>. Rather, the function is expecting a double value, and we pass in an integer argument. The compiler will notice the mismatch and implicitly convert the integer to a double.</p><p>Here’s a similar example where our argument is an int variable instead of an int literal:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print(double x) // print takes an double parameter</code><code>{</code><code>	std::cout &lt;&lt; x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int y { 5 };</code><code>	print(y); // y is of type int</code><code></code><code>	return 0;</code><code>}</code></pre><p>This works identically to the above. The value held by int variable <code>y</code> (<code>5</code>) will be converted to double value <code>5.0</code>, and then copied into parameter <code>x</code>.</p><br><h3>Type conversion produces a new value</h3><p>Even though it is called a conversion, a type conversion does not actually change the value or type of the value being converted. Instead, the value to be converted is used as input, and the conversion results in a new value of the target type.</p><p>In the above example, the conversion does not change variable <code>y</code> from type <code>int</code> to <code>double</code>. Instead, the conversion uses the value of <code>y</code> (<code>5</code>) as input to create a new double value (<code>5.0</code>). This double value is then passed to function <code>print</code>.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Type conversion produces a new value of the target type from a value of a different type.</p></div><br><h3>Implicit type conversion warnings</h3><p>Although implicit type conversion is sufficient for most cases where type conversion is needed, there are a few cases where it is not. Consider the following program, which is similar to the example above:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print(int x) // print now takes an int parameter</code><code>{</code><code>	std::cout &lt;&lt; x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	print(5.5); // warning: we're passing in a double value</code><code></code><code>	return 0;</code><code>}</code></pre><p>In this program, we’ve changed <code>print()</code> to take an <code>int</code> parameter, and the function call to <code>print()</code> is now passing in <code>double</code> value <code>5.5</code>. Similar to the above, the compiler will use implicit type conversion in order to convert double value <code>5.5</code> into an value of of type <code>int</code>, so that it can be passed to function <code>print()</code>.</p><p>Unlike the initial example, when this program is compiled, your compiler will generate some kind of a warning about a possible loss of data. And because you have “treat warnings as errors” turned on (you do, right?), your compiler will abort the compilation process.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>You’ll need to disable “treat warnings as errors” temporarily if you want to compile this example. See lesson <a href="https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-warning-and-error-levels/">0.11 -- Configuring your compiler: Warning and error levels</a> for more information about this setting.</p></div><p>When compiled and run, this program prints the following:</p><pre>5
</pre><p>Note that although we passed in value <code>5.5</code>, the program printed <code>5</code>. Because integral values can’t hold fractions, when double value <code>5.5</code> is implicitly converted to an <code>int</code>, the fractional component is dropped, and only the integral value is retained.</p><p>Because converting a floating point value to an integral value results in any fractional component being dropped, the compiler will warn us when it does an implicit type conversion from a floating point to an integral value. This happens even if we were to pass in a floating point value with no fractional component, like <code>5.0</code> -- no actual loss of value occurs during the conversion to integral value <code>5</code> in this specific case, but the compiler will still warn us that the conversion is unsafe.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Some type conversions are always safe to make (such as <code>int</code> to <code>double</code>), whereas others may result in the value being changed during conversion (such as <code>double</code> to <code>int</code>). Unsafe implicit conversions will typically either generate a compiler warning, or (in the case of brace initialization) an error.</p><p>This is one of the primary reasons brace initialization is the preferred initialization form. Brace initialization will ensure we don’t try to initialize a variable with a initializer that will lose value when it is implicitly type converted:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    double d { 5 }; // okay: int to double is safe</code><code>    int x { 5.5 }; // error: double to int not safe</code><code></code><code>    return 0;</code><code>}</code></pre></div><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>Implicit type conversion is a meaty topic. We dig into this topic in more depth in future lessons, starting with lesson <a href="https://www.learncpp.com/cpp-tutorial/implicit-type-conversion-coercion/">8.1 -- Implicit type conversion (coercion)</a>.</p></div><br><h3>An introduction to explicit type conversion via the static_cast operator</h3><p>Back to our most recent <code>print()</code> example, what if we <em>intentionally</em> wanted to pass a double value to a function taking an integer (knowing that the converted value would drop any fractional component?) Turning off “treat warnings as errors” to just to make our program compile is a bad idea, because then we’ll have warnings every time we compile (which we will quickly learn to ignore), and we risk overlooking warnings about more serious issues.</p><p>as it might cause us to overlook some other warning that represents a serious problem.</p><p>C++ supports a second method of type conversion, called explicit type conversion. <span class="cpp-definition">Explicit type conversion</span> allow us (the programmer) to explicitly tell the compiler to convert a value from one type to another type, and that we take full responsibility for the result of that conversion (meaning that if the conversion results in the loss of value, it’s our fault).</p><p>To perform an explicit type conversion, in most cases we’ll use the <code>static_cast</code> operator. The syntax for the <code>static cast</code> looks a little funny:</p><pre>static_cast&lt;new_type&gt;(expression)
</pre><p>static_cast takes the value from an expression as input, and returns that value converted into the type specified by <em>new_type</em> (e.g. int, bool, char, double).</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Whenever you see C++ syntax (excluding the preprocessor) that makes use of angled brackets (&lt;&gt;), the thing between the angled brackets will most likely be a type. This is typically how C++ deals with code that need a parameterized type.</p></div><p>Let’s update our prior program using <code>static_cast</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print(int x)</code><code>{</code><code>	std::cout &lt;&lt; x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	print( static_cast<int>(5.5) ); // explicitly convert double value 5.5 to an int</int></code><code></code><code>	return 0;</code><code>}</code></pre><p>Because we’re now explicitly requesting that double value <code>5.5</code> be converted to an <code>int</code> value, the compiler will not generate a warning about a possible loss of data upon compilation (meaning we can leave “treat warnings as errors” enabled).</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>C++ supports other types of casts. We talk more about the different types of casts in future lesson <a href="https://www.learncpp.com/cpp-tutorial/explicit-type-conversion-casting-and-static-cast/">8.5 -- Explicit type conversion (casting) and static_cast</a>.</p></div><br><h3>Using static_cast to convert char to int</h3><p>In the lesson on chars <a href="https://www.learncpp.com/cpp-tutorial/chars/">4.11 -- Chars</a>, we saw that printing a char value using <code>std::cout</code> results in the value being printed as a char:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    char ch{ 97 }; // 97 is ASCII code for 'a'</code><code>    std::cout &lt;&lt; ch &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>a
</pre><p>If we want to print the integral value instead of the char, we can do this by using <code>static_cast</code> to cast the value from a <code>char</code> to an <code>int</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    char ch{ 97 }; // 97 is ASCII code for 'a'</code><code>    std::cout &lt;&lt; ch &lt;&lt; " has value " &lt;&lt; static_cast<int>(ch) &lt;&lt; '\n'; // print value of variable ch as an int</int></code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>a has value 97
</pre><p>It’s worth noting that the argument to <em>static_cast</em> evaluates as an expression. When we pass in a variable, that variable is evaluated to produce its value, and that value is then converted to the new type. The variable itself is <em>not</em> affected by casting its value to a new type. In the above case, variable <code>ch</code> is still a char, and still holds the same value even after we’ve cast its value to an <code>int</code>.</p><br><h3>Converting unsigned numbers to signed numbers</h3><p>To convert an unsigned number to a signed number, you can also use the <code>static_cast</code> operator:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    unsigned int u { 5u }; // 5u means the number 5 as an unsigned int</code><code>    int s { static_cast<int>(u) }; // return value of variable u as an int</int></code><code></code><code>    std::cout &lt;&lt; s;</code><code>    return 0;</code><code>}</code></pre><p>The <code>static_cast</code> operator doesn’t do any range checking, so if you cast a value to a type whose range doesn’t contain that value, undefined behavior will result. Therefore, the above cast from <code>unsigned int</code> to <code>int</code> will yield unpredictable results if the value of the <code>unsigned int</code> is greater than the maximum value a signed <code>int</code> can hold.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>The static_cast operator will produce undefined behavior if the value being converted doesn’t fit in range of the new type.</p></div><br><h3>std::int8_t and std::uint8_t likely behave like chars instead of integers</h3><p>As noted in lesson <a href="https://www.learncpp.com/cpp-tutorial/fixed-width-integers-and-size-t/">4.6 -- Fixed-width integers and size_t</a>, most compilers define and treat <code>std::int8_t</code> and <code>std::uint8_t</code> (and the corresponding fast and least fixed-width types) identically to types <code>signed char</code> and <code>unsigned char</code> respectively. Now that we’ve covered what chars are, we can demonstrate where this can be problematic:</p><pre class="language-cpp line-numbers"><code>#include <cstdint></cstdint></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::int8_t myint{65}; // initialize myint with value 65</code><code>    std::cout &lt;&lt; myint;    // you're probably expecting this to print 65</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because <code>std::int8_t</code> describes itself as an int, you might be tricked into believing that the above program will print the integral value <code>65</code>. However, on most systems, this program will print <code>A</code> instead (treating <code>myint</code> as a <code>signed char</code>). However, this is not guaranteed (on some systems, it may actually print <code>65</code>).</p><p>If you want to ensure that a <code>std::int8_t</code> or <code>std::uint8_t</code> object is treated as an integer, you can convert the value to an integer using <code>static_cast</code>:</p><pre class="language-cpp line-numbers"><code>#include <cstdint></cstdint></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::int8_t myint{65};</code><code>    std::cout &lt;&lt; static_cast<int>(myint); // will always print 65</int></code><code></code><code>    return 0;</code><code>}</code></pre><p>In cases where <code>std::int8_t</code> is treated as a char, input from the console can also cause problems:</p><pre class="language-cpp line-numbers"><code>#include <cstdint></cstdint></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number between 0 and 255: ";</code><code>    std::int8_t myint{};</code><code>    std::cin &gt;&gt; myint;</code><code></code><code>    std::cout &lt;&lt; "You entered: " &lt;&lt; static_cast<int>(myint);</int></code><code></code><code>    return 0;</code><code>}</code></pre><p>A sample run of this program:</p><pre>Enter a number between 0 and 255: 35
You entered: 51
</pre><p>Here’s what’s happening. When <code>std::int8_t</code> is treated as a char, the input routines interpret our input as a sequence of characters, not as an integer. So when we enter <code>35</code>, we’re actually entering two chars, <code>'3'</code> and <code>'5'</code>. Because a char object can only hold one character, the <code>'3'</code> is extracted (the <code>'5'</code> is left in the input stream for possible extraction later). Because the char <code>'3'</code> has ASCII code point 51, the value <code>51</code> is stored in <code>myint</code>, which we then print later as an int.</p><p>In contrast, the other fixed-width types will always print and input as integral values.</p><p></p><br><h3>Quiz time</h3><p class="cpp-quiz-question" style="clear:both">Question #1</p><p>Write a short program where the user is asked to enter a single character. Print the value of the character and its ASCII code, using <code>static_cast</code>.</p><p>The program’s output should match the following:</p><pre>Enter a single character: a
You entered 'a', which has ASCII code 97.
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Enter a single character: ";</code><code>	char c{};</code><code>	std::cin &gt;&gt; c;</code><code>	std::cout &lt;&lt; "You entered '" &lt;&lt; c &lt;&lt; "', which has ASCII code " &lt;&lt; static_cast<int>(c) &lt;&lt; ".\n";</int></code><code></code><code>	return 0;</code><code>}</code></pre></div><p class="cpp-quiz-question cpp-topline" style="clear:both">Question #2</p><p>Modify the program you wrote for quiz #1 to use implicit type conversion instead of <code>static_cast</code>. How many different ways can you think of to do this?</p><p>Note: You should favor explicit conversions over implicit conversions, so don’t actually do this in real programs -- this is just to test your understanding of where implicit conversions can occur.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>There are a few easy ways to do this.</p><p>First, we can create an <code>int</code> variable, and initialize it with our <code>char</code> value. This will do the implicit conversion on initialization.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Enter a single character: ";</code><code>	char c{};</code><code>	std::cin &gt;&gt; c;</code><code></code><code>	int ascii{ c };</code><code>	std::cout &lt;&lt; "You entered '" &lt;&lt; c &lt;&lt; "', which has ASCII code " &lt;&lt; ascii &lt;&lt; ".\n";</code><code></code><code>	return 0;</code><code>}</code></pre><p>Alternatively, we can use a function to return the <code>char</code> value as an <code>int</code>. This will do the implicit conversion at the point of return.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int charAsInt(char c)</code><code>{</code><code>	return c;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Enter a single character: ";</code><code>	char c{};</code><code>	std::cin &gt;&gt; c;</code><code></code><code>	std::cout &lt;&lt; "You entered '" &lt;&lt; c &lt;&lt; "', which has ASCII code " &lt;&lt; charAsInt(c) &lt;&lt; ".\n";</code><code></code><code>	return 0;</code><code>}</code></pre><p>We can also use a function and have the implicit conversion happen at the point where the argument is copied into the function parameter:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getInt(int c)</code><code>{</code><code>	return c;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Enter a single character: ";</code><code>	char c{};</code><code>	std::cin &gt;&gt; c;</code><code></code><code>	std::cout &lt;&lt; "You entered '" &lt;&lt; c &lt;&lt; "', which has ASCII code " &lt;&lt; getInt(c) &lt;&lt; ".\n";</code><code></code><code>	return 0;</code><code>}</code></pre></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">4.13 — Const variables and symbolic constants</h1></header><div class="entry-content" itemprop="articleBody"><p>In programming, a <span class="cpp-definition">constant</span> is a value that may not be changed. C++ supports several types of constants: const variables (which we’ll cover in this lesson and <a href="https://www.learncpp.com/cpp-tutorial/compile-time-constants-constant-expressions-and-constexpr/">4.14 -- Compile-time constants, constant expressions, and constexpr</a>), and literals (which we’ll cover shortly, in lesson <a href="https://www.learncpp.com/cpp-tutorial/literals/">4.15 -- Literals</a>).</p><br><h3>Const variables</h3><p>So far, all of the variables we’ve seen have been non-constant -- that is, their values can be changed at any time (typically through assignment of a new value). For example:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int x { 4 }; // x is a non-constant variable</code><code>    x = 5; // change value of x to 5 using assignment operator</code><code></code><code>    return 0;</code><code>}</code></pre><p>However, there are many cases where it is useful to define variables with values that can not be changed. For example, consider the gravity of Earth (near the surface): 9.8 meters/second<sup>2</sup>. This isn’t likely to change any time soon (and if it does, you’ve likely got bigger problems than learning C++). Defining this value as a constant helps ensure that this value isn’t accidentally changed. Constants also have other benefits that we’ll explore momentarily.</p><p>A variable whose value can not be changed is called a <span class="cpp-definition">constant variable</span>.</p><br><h3>The const keyword</h3><p>To make a variable a constant, place the <code>const</code> keyword in the variable’s declaration either before or after the variable type, like so:</p><pre class="language-cpp line-numbers"><code>const double gravity { 9.8 };  // preferred use of const before type</code><code>int const sidesInSquare { 4 }; // "east const" style, okay but not preferred</code></pre><p>Although C++ will accept <code>const</code> either before or after the type, it’s much more common to use <code>const</code> before the type because it better follows standard English language convention where modifiers come before the object being modified (e.g. a “a green ball”, not a “a ball green”).</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>Due to the way that the compiler parses more complex declarations, some developers prefer placing the <code>const</code> after the type (because it is slightly more consistent). This style is called “east const”. While this style has some advocates (and some reasonable points), it has not caught on significantly.</p></div><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Place <code>const</code> before the type (because it is more idiomatic to do so).</p></div><br><h3>Const variables must be initialized</h3><p>Const variables <em>must</em> be initialized when you define them, and then that value can not be changed via assignment:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    const double gravity; // error: const variables must be initialized</code><code>    gravity = 9.9;        // error: const variables can not be changed</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note that const variables can be initialized from other variables (including non-const ones):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{ </code><code>    std::cout &lt;&lt; "Enter your age: ";</code><code>    int age{};</code><code>    std::cin &gt;&gt; age;</code><code></code><code>    const int constAge { age }; // initialize const variable using non-const value</code><code></code><code>    age = 5;      // ok: age is non-const, so we can change its value</code><code>    constAge = 6; // error: constAge is const, so we cannot change its value</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, we initialize const variable <code>constAge</code> with non-const variable <code>age</code>. Because <code>age</code> is still non-const, we can change its value. However, because <code>constAge</code> is const, we cannot change the value it has after initialization.</p><br><h3>Naming your const variables</h3><p>There are a number of different naming conventions that are used for const variables.</p><p>Programmers who have transitioned from C often prefer underscored, upper-case names for const variables (e.g. <code>EARTH_GRAVITY</code>). More common in C++ is to use intercapped names with a ‘k’ prefix (e.g. <code>kEarthGravity</code>).</p><p>However, because const variables act like normal variables (except they can not be assigned to), there is no reason that they need a special naming convention. For this reason, we prefer using the same naming convention that we use for non-const variables (e.g. <code>earthGravity</code>).</p><br><h3>Const function parameters</h3><p>Function parameters can be made constants via the <code>const</code> keyword:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printInt(const int x)</code><code>{</code><code>    std::cout &lt;&lt; x &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printInt(5); // 5 will be used as the initializer for x</code><code>    printInt(6); // 6 will be used as the initializer for x</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note that we did not provide an explicit initializer for our const parameter <code>x</code> -- the value of the argument in the function call will be used as the initializer for <code>x</code>.</p><p>Making a function parameter constant enlists the compiler’s help to ensure that the parameter’s value is not changed inside the function. However, when arguments are passed by value, we generally don’t care if the function changes the value of the parameter (since it’s just a copy that will be destroyed at the end of the function anyway). For this reason, we usually don’t <code>const</code> parameters passed by value (as it adds clutter to our code without providing much actual value).</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Don’t use <code>const</code> when passing by value.</p></div><p>Later in this tutorial series, we’ll talk about two other ways to pass arguments to functions: pass by reference, and pass by address. When using either of these methods, proper use of <code>const</code> is important.</p><br><h3>Const return values</h3><p>A function’s return value may also be made const:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>const int getValue()</code><code>{</code><code>    return 5;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; getValue() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>However, since the returned value is a copy, there’s little point in making it <code>const</code>. Returning a const value can also impede certain kinds of compiler optimizations, which can result in lower performance.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Don’t use <code>const</code> when returning by value.</p></div><br><h3>What is a symbolic constant?</h3><p>A <span class="cpp-definition">symbolic constant</span> is a name that is given to a constant value. Constant variables are one type of symbolic constant, as a variable has a name (its identifier) and a constant value.</p><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-the-preprocessor/">2.10 -- Introduction to the preprocessor</a>, we discussed that the preprocessor supports object-like macros with substitution text. These take the form:</p><pre>#define identifier substitution_text
</pre><p>Whenever the preprocessor processes this directive, any further occurrence of <em>identifier</em> is replaced by <em>substitution_text</em>. The identifier is traditionally typed in all capital letters, using underscores to represent spaces.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#define MAX_STUDENTS_PER_CLASS 30</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "The class has " &lt;&lt; MAX_STUDENTS_PER_CLASS &lt;&lt; " students.\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>When compiling this program, the preprocessor will replace <code>MAX_STUDENTS_PER_CLASS</code> with the literal value <code>30</code>, which the compiler will then compile into your executable.</p><p>Because object-like macros have a name, and the substitution text is a constant value, object-like macros with substitution text are also symbolic constants.</p><br><h3>For symbolic constants, prefer constant variables to object-like macros</h3><p>So why not use #define to make symbolic constants? There are (at least) three major problems.</p><p>First, because macros are resolved by the preprocessor, all occurrences of the macro are replaced with the defined value just prior to compilation. If you are debugging your code, you won’t see the actual value (e.g. <code>30</code>) -- you’ll only see the name of the symbolic constant (e.g. <code>MAX_STUDENTS_PER_CLASS</code>). And because these #defined values aren’t variables, you can’t add a watch in the debugger to see their values. If you want to know what value <code>MAX_STUDENTS_PER_CLASS</code> resolves to, you’ll have to find the definition of <code>MAX_STUDENTS_PER_CLASS</code> (which could be in a different file). This can make your programs harder to debug.</p><p>Second, macros can have naming conflicts with normal code. For example:</p><pre class="language-cpp line-numbers"><code>#include "someheader.h"</code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int beta { 5 };</code><code>    std::cout &lt;&lt; beta &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>If someheader.h happened to #define a macro named <code>beta</code>, this simple program would break, as the preprocessor would replace the int variable beta’s name with the macro’s substitution text. This is normally avoided by using all caps for macro names, but it can still happen.</p><p>Thirdly, macros don’t follow normal scoping rules, which means in rare cases a macro defined in one part of a program can conflict with code written in another part of the program that it wasn’t supposed to interact with.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Prefer constant variables over object-like macros with substitution text.</p></div><br><h3>Using constant variables throughout a multi-file program</h3><p>In many applications, a given symbolic constant needs to be used throughout your code (not just in one location). These can include physics or mathematical constants that don’t change (e.g. pi or Avogadro’s number), or application-specific “tuning” values (e.g. friction or gravity coefficients). Instead of redefining these every time they are needed, it’s better to declare them once in a central location and use them wherever needed. That way, if you ever need to change them, you only need to change them in one place.</p><p>There are multiple ways to facilitate this within C++ -- we cover this topic in full detail in lesson <a href="https://www.learncpp.com/cpp-tutorial/sharing-global-constants-across-multiple-files-using-inline-variables/">6.9 -- Sharing global constants across multiple files (using inline variables)</a>.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">4.14 — Compile-time constants, constant expressions, and constexpr</h1></header><div class="entry-content" itemprop="articleBody"><p>Consider the following short program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	int x { 3 + 4 };</code><code>	std::cout &lt;&lt; x &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>The output is straightforward:</p><pre>7
</pre><p>However, there’s an interesting optimization possibility hidden within.</p><p>If this program were compiled as it was written, the compiler would generate an executable that calculates the result of <code>3 + 4</code> at runtime (when the program is run). If the program were executed a million times, <code>3 + 4</code> would be evaluated a million times, and the resulting value of <code>7</code> produced a million times. But note that the result of <code>3 + 4</code> never changes -- it is always <code>7</code>. So re-evaluating <code>3 + 4</code> every time the program is run is wasteful.</p><br><h3>Constant expressions</h3><p>A <span class="cpp-definition">constant expression</span> is an expression that can be evaluated by the compiler at compile-time. To be a constant expression, all the values in the expression must be known at compile-time (and all of the operators and functions called must support compile-time evaluation).</p><p>When the compiler encounters a constant expression, it will replace the constant expression with the result of evaluating the constant expression.</p><p>In the above program, the expression <code>3 + 4</code> is a constant expression. So when this program is compiled, the compiler will evaluate constant expression <code>3 + 4</code> and then replace the constant expression <code>3 + 4</code> with the resulting value <code>7</code>. In other words, the compiler actually compiles this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	int x { 7 };</code><code>	std::cout &lt;&lt; x &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This program produces the same output (<code>7</code>), but the resulting executable no longer needs to spend CPU cycles calculating <code>3 + 4</code> at runtime!</p><p>Note that the expression <code>std::cout &lt;&lt; x</code> is not a constant expression, because our program can’t output values to the console at compile-time. So this expression will evaluate at runtime.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Evaluating constant expressions at compile-time makes our compilation take longer (because the compiler has to do more work), but such expressions only need to be evaluated once (rather than every time the program is run). The resulting executables are faster and use less memory.</p></div><br><h3>Compile-time constants</h3><p>A <span class="cpp-definition">Compile-time constant</span> is a constant whose value is known at compile-time. Literals (e.g. ‘1’, ‘2.3’, and “Hello, world!”) are one type of compile-time constant.</p><p>But what about const variables? Const variables may or may not be compile-time constants.</p><br><h3>Compile-time const</h3><p>A const variable is a compile-time constant if its initializer is a constant expression.</p><p>Consider a program similar to the above that uses const variables:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	const int x { 3 };  // x is a compile-time const</code><code>	const int y { 4 };  // y is a compile-time const</code><code></code><code>	const int z { x + y }; // x + y is a compile-time expression</code><code></code><code>	std::cout &lt;&lt; z &lt;&lt; '\n'; </code><code></code><code>	return 0;</code><code>}</code></pre><p>Because the initialization values of <code>x</code> and <code>y</code> are constant expressions, <code>x</code> and <code>y</code> are compile-time constants. This means <code>x + y</code> is also constant expression. So when the compiler compiles this program, it can evaluate <code>x + y</code> for their values, and replace the constant expression with the resulting literal <code>7</code>.</p><p>Note that the initializer of a compile-time const can be any constant expression. Both of the following will be compile-time const variables:</p><pre class="language-cpp line-numbers"><code>const int a { 1 + 2 };</code><code>const int b { z * 2 };</code></pre><p>Compile-time const variables are often used as symbolic constants:</p><pre class="language-cpp line-numbers"><code>const double gravity { 9.8 };</code></pre><p>Compile-time constants enable the compiler to perform optimizations that aren’t available with non-compile-time constants. For example, whenever <code>gravity</code> is used, the compiler can simply substitute the identifier <code>gravity</code> with the literal double <code>9.8</code>, which avoids having to fetch the value from somewhere in memory.</p><p>In many cases, compile-time constants will be optimized out of the program entirely. In cases where this is not possible (or when optimizations are turned off), the variable will still be created (and initialized) at runtime.</p><br><h3>Runtime const</h3><p>Any const variable that is initialized with a non-constant expression is a runtime constant. <span class="cpp-definition">Runtime constants</span> are constants whose initialization values aren’t known until runtime.</p><p>The following example illustrates the use of a constant that is a runtime constant:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getNumber()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number: ";</code><code>    int y{};</code><code>    std::cin &gt;&gt; y;</code><code></code><code>    return y;  </code><code>}</code><code></code><code>int main()</code><code>{</code><code>    const int x{ 3 };           // x is a compile time constant</code><code></code><code>    const int y{ getNumber() }; // y is a runtime constant</code><code></code><code>    const int z{ x + y };       // x + y is a runtime expression</code><code>    std::cout &lt;&lt; z &lt;&lt; '\n';     // this is also a runtime expression</code><code>    </code><code>    return 0;</code><code>}</code></pre><p>Even though <code>y</code> is const, the initialization value (the return value of <code>getNumber()</code>) isn’t known until runtime. Thus, <code>y</code> is a runtime constant, not a compile-time constant. And as such, the expression <code>x + y</code> is a runtime expression.</p><br><h3>The constexpr keyword</h3><p>When you declare a const variable, the compiler will implicitly keep track of whether it’s a runtime or compile-time constant. In most cases, this doesn’t matter for anything other than optimization purposes, but there are a few odd cases where C++ requires a compile-time constant instead of a run-time constant (we’ll cover these cases later as we introduce those topics).</p><p>Because compile-time constants generally allow for better optimization (and have little downside), we typically want to use compile-time constants wherever possible.</p><p>When using <code>const</code>, our variables could end up as either a compile-time const or a runtime const, depending on whether the initializer is a compile-time expression or not. Because the definitions for both look identical, we can end up with a runtime const where we thought we were getting a compile-time const. In the previous example, it’s hard to tell if <code>y</code> is a compile-time const or a runtime const -- we’d have to look at the return value of <code>getNumber()</code> to determine.</p><p>Fortunately, we can enlist the compiler’s help to ensure we get a compile-time const where we expect one. To do so, we use the <code>constexpr</code> keyword instead of <code>const</code> in a variable’s declaration. A <span class="cpp-definition">constexpr</span> (which is short for “constant expression”) variable can only be a compile-time constant. If the initialization value of a constexpr variable is not a constant expression, the compiler will error.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int five()</code><code>{</code><code>    return 5;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    constexpr double gravity { 9.8 }; // ok: 9.8 is a constant expression</code><code>    constexpr int sum { 4 + 5 };      // ok: 4 + 5 is a constant expression</code><code>    constexpr int something { sum };  // ok: sum is a constant expression</code><code></code><code>    std::cout &lt;&lt; "Enter your age: ";</code><code>    int age{};</code><code>    std::cin &gt;&gt; age;</code><code></code><code>    constexpr int myAge { age };      // compile error: age is not a constant expression</code><code>    constexpr int f { five() };       // compile error: return value of five() is not a constant expression</code><code></code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Any variable that should not be modifiable after initialization and whose initializer is known at compile-time should be declared as <code>constexpr</code>.<br>Any variable that should not be modifiable after initialization and whose initializer is not known at compile-time should be declared as <code>const</code>.</p></div><p>Although function parameters can be <code>const</code>, they cannot be <code>constexpr</code>.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>C++ does support functions that can be evaluated at compile-time (and thus can be used in constant expressions) -- we discuss these in lesson <a href="https://www.learncpp.com/cpp-tutorial/constexpr-and-consteval-functions/">6.14 -- Constexpr and consteval functions</a>.</p></div><br><h3>Constant folding for constant subexpressions</h3><p>Consider the following example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	constexpr int x { 3 + 4 }; // 3 + 4 is a constant expression</code><code>	std::cout &lt;&lt; x &lt;&lt; '\n';    // this is a runtime expression</code><code></code><code>	return 0;</code><code>}</code></pre><p><code>3 + 4</code> is a constant expression, so the compiler will evaluate <code>3 + 4</code> at compile-time, and replace it with value <code>7</code>. The compiler will likely optimize <code>x</code> out of the above program, replacing <code>std::cout &lt;&lt; x &lt;&lt; '\n'</code> with <code>std::cout &lt;&lt; 7 &lt;&lt; '\n'</code>. The output expression will execute at runtime.</p><p>However, because <code>x</code> is only used once, it’s more likely we’d write the program like this in the first place:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; 3 + 4 &lt;&lt; '\n'; // this is a runtime expression</code><code></code><code>	return 0;</code><code>}</code></pre><p>Since the full expression <code>std::cout &lt;&lt; 3 + 4 &lt;&lt; '\n'</code> is not a constant expression, it’s reasonable to wonder whether the constant subexpression <code>3 + 4</code> will still be optimized at compile-time. The answer is generally “yes”. Compilers have long been able to optimize constant subexpressions, including variables whose values can be determined at compile-time (compile-time const and constexpr variables).</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>This optimization process is called “constant folding”.</p></div><p>Making our variables constexpr ensures that those variables have values known at compile-time, and thus are eligible for constant folding when they are used in expressions (even in non-const expressions).</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">4.15 — Literals</h1></header><div class="entry-content" itemprop="articleBody"><p><span class="cpp-definition">Literals</span> are unnamed values inserted directly into the code. For example:</p><pre class="language-cpp line-numbers"><code>return 5;                   // 5 is an integer literal</code><code>bool myNameIsAlex { true }; // true is a boolean literal</code><code>std::cout &lt;&lt; 3.4;           // 3.4 is a double literal</code></pre><p>Literals are sometimes called <span class="cpp-definition">literal constants</span> because their values cannot be reassigned.</p><br><h3>The type of a literal</h3><p>Just like objects have a type, all literals have a type. The type of a literal is deduced from the literal’s value. For example, a literal that is a whole number (e.g. <code>5</code>) is deduced to be of type <code>int</code>.</p><p>By default:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Literal value</th><th>Examples</th><th>Default literal type</th></tr><tr><td>integer value</td><td>5, 0, -3</td><td>int</td></tr><tr><td>boolean value</td><td>true, false</td><td>bool</td></tr><tr><td>floating point value</td><td>1.2, 0.0, 3.4</td><td>double (not float!)</td></tr><tr><td>character</td><td>‘a’, ‘\n’</td><td>char</td></tr><tr><td>C-style string</td><td>“Hello, world!”</td><td>const char[14]</td></tr></tbody></table></div><br><br><h3>Literal suffixes</h3><p>If the default type of a literal is not as desired, you can change the type of a literal by adding a suffix:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Data type</th><th>Suffix</th><th>Meaning</th></tr><tr><td>integral</td><td>u or U</td><td>unsigned int</td></tr><tr><td>integral</td><td>l or L</td><td>long</td></tr><tr><td>integral</td><td>ul, uL, Ul, UL, lu, lU, Lu, or LU</td><td>unsigned long</td></tr><tr><td>integral</td><td>ll or LL</td><td>long long</td></tr><tr><td>integral</td><td>ull, uLL, Ull, ULL, llu, llU, LLu, or LLU</td><td>unsigned long long</td></tr><tr><td>integral</td><td>z or Z</td><td>The signed version of std::size_t (C++23)</td></tr><tr><td>integral</td><td>uz or UZ</td><td>std::size_t (C++23)</td></tr><tr><td>floating point</td><td>f or F</td><td>float</td></tr><tr><td>floating point</td><td>l or L</td><td>long double</td></tr><tr><td>string</td><td>s</td><td>std::string</td></tr><tr><td>string</td><td>sv</td><td>std::string_view</td></tr></tbody></table></div><br>Suffixes are not case sensitive. Because lower-case <code>L</code> can look like numeric <code>1</code> in some fonts, some developers prefer to use upper-case literals.<div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Prefer literal suffix L (upper case) over l (lower case).</p></div><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We discuss string literals and suffixes in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-stdstring/">4.17 -- Introduction to std::string</a> and <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-stdstring_view/">4.18 -- Introduction to std::string_view</a>.</p></div><br><h3>Integral literals</h3><p>You generally won’t need to use suffixes for integral literals, but here are examples:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; 5; // 5 (no suffix) is type int (by default)</code><code>    std::cout &lt;&lt; 5L; // 5L is type long</code><code></code><code>    return 0;</code><code>}</code></pre><p>One exception is the <code>u</code> (or ‘U’) suffix, which is used to denote an unsigned integer literal:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    unsigned int x { 5u }; // 5u is type unsigned int</code><code>    std::cout &lt;&lt; x;</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>Floating point literals</h3><p>By default, floating point literals have a type of <code>double</code>. To make them <code>float</code> literals instead, the <code>f</code> (or <code>F</code>) suffix should be used:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; 5.0; // 5.0 (no suffix) is type double (by default)</code><code>    std::cout &lt;&lt; 5.0f; // 5.0f is type float</code><code></code><code>    return 0;</code><code>}</code></pre><p>New programmers are often confused about why the following causes a compiler warning:</p><pre class="language-cpp line-numbers"><code>float f { 4.1 }; // warning: 4.1 is a double literal, not a float literal</code></pre><p>Because <code>4.1</code> has no suffix, the literal has type <code>double</code>, not <code>float</code>. When the compiler determines the type of a literal, it doesn’t care what you’re doing with the literal (e.g. in this case, using it to initialize a <code>float</code> variable). Since the type of the literal (<code>double</code>) doesn’t match the type of the variable it is being used to initialize (<code>float</code>), the literal value must be converted to a <code>float</code> so it can then be used to initialize variable <code>f</code>. Converting a value from a <code>double</code> to a <code>float</code> can result in a loss of precision, so the compiler will issue a warning.</p><p>The solution here is one of the following:</p><pre class="language-cpp line-numbers"><code>float f { 4.1f }; // use 'f' suffix so the literal is a float and matches variable type of float</code><code>double d { 4.1 }; // change variable to type double so it matches the literal type double</code></pre><br><h3>Scientific notation for floating point literals</h3><p>There are two different ways to declare floating-point literals:</p><pre class="language-cpp line-numbers"><code>double pi { 3.14159 }; // 3.14159 is a double literal in standard notation</code><code>double avogadro { 6.02e23 }; // 6.02 x 10^23 is a double literal in scientific notation</code></pre><p>In the second form, the number after the exponent can be negative:</p><pre class="language-cpp line-numbers"><code>double electronCharge { 1.6e-19 }; // charge on an electron is 1.6 x 10^-19</code></pre><br><h3>Magic numbers</h3><p>A <span class="cpp-definition">magic number</span> is a literal (usually a number) that either has an unclear meaning or may need to be changed later.</p><p>Here are two statements showing examples of magic numbers:</p><pre class="language-cpp line-numbers"><code>constexpr int maxStudentsPerSchool{ numClassrooms * 30 };</code><code>setMax(30);</code></pre><p>What do the literals <code>30</code> mean in these contexts? In the former, you can probably guess that it’s the number of students per class, but it’s not immediately obvious. In the latter, who knows. We’d have to go look at the function to know what it does.</p><p>In complex programs, it can be very difficult to infer what a literal represents, unless there’s a comment to explain it.</p><p>Using magic numbers is generally considered bad practice because, in addition to not providing context as to what they are being used for, they pose problems if the value needs to change. Let’s assume that the school buys new desks that allow them to raise the class size from 30 to 35, and our program needs to reflect that.</p><p>To do so, we need to update one or more literal from <code>30</code> to <code>35</code>. But which literals? The <code>30</code> in the initializer of <code>maxStudentsPerSchool</code> seems obvious. But what about the <code>30</code> used as an argument to <code>setMax()</code>? Does that <code>30</code> have the same meaning as the other <code>30</code>? If so, it should be updated. If not, it should be left alone, or we might break our program somewhere else. If you do a global search-and-replace, you might inadvertently update the argument of <code>setMax()</code> when it wasn’t supposed to change. So you have to look through all the code for every instance of the literal <code>30</code> (of which there might be hundreds), and then make an individual determination as to whether it needs to change or not. That can be seriously time consuming (and error prone).</p><p>Fortunately, both the lack of context and the issues around updating can be easily addressed by using symbolic constants:</p><pre class="language-cpp line-numbers"><code>constexpr int maxStudentsPerClass { 30 };</code><code>constexpr int totalStudents{ numClassrooms * maxStudentsPerClass }; // now obvious what this 30 means</code><code></code><code>constexpr int maxNameLength{ 30 };</code><code>setMax(maxNameLength); // now obvious this 30 is used in a different context</code></pre><p>The name of the constant provides context, and we only need to update a value in one place to make a change to the value across our entire program.</p><p>Note that magic numbers aren’t always numbers -- they can also be text (e.g. names) or other types.</p><p>Literals used in obvious contexts that are unlikely to change are typically not considered magic. The values <code>-1</code>, <code>0</code>, <code>0.0</code>, and <code>1</code> are often used in such contexts:</p><pre class="language-cpp line-numbers"><code>int idGenerator { 0 };         // fine: we're starting our id generator with value 0</code><code>idGenerator = idGenerator + 1; // fine: we're just incrementing our generator</code></pre><p>Other numbers may also be obvious in context (and thus, not considered magic):</p><pre class="language-cpp line-numbers"><code>int kmtoM(int km)</code><code>{</code><code>    return km * 1000; // fine: it's obvious 1000 is a conversion factor</code><code>}</code></pre><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Avoid magic numbers in your code (use constexpr variables instead).</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">4.16 — Numeral systems (decimal, binary, hexadecimal, and octal)</h1></header><div class="entry-content" itemprop="articleBody"><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>This lesson is optional.</p><p>Future lessons reference hexadecimal numbers, so you should at least have a passing familiarity with the concept before proceeding.</p></div><p>In everyday life, we count using <span class="cpp-definition">decimal</span> numbers, where each numerical digit can be 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9. Decimal is also called “base 10”, because there are 10 possible digits (0 through 9). In this system, we count like this: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, … By default, numbers in C++ programs are assumed to be decimal.</p><pre class="language-cpp line-numbers"><code>int x { 12 }; // 12 is assumed to be a decimal number</code></pre><p>In <span class="cpp-definition">binary</span>, there are only 2 digits: 0 and 1, so it is called “base 2”. In binary, we count like this: 0, 1, 10, 11, 100, 101, 110, 111, …</p><p>Decimal and binary are two examples of <span class="cpp-definition">numeral systems</span>, which is a fancy name for a collection of symbols (e.g. digits) used to represent numbers. There are 4 main numeral systems available in C++. In order of popularity, these are: decimal (base 10), binary (base 2), hexadecimal (base 16), and octal (base 8).</p><br><h3>Octal and hexadecimal literals</h3><p><span class="cpp-definition">Octal</span> is base 8 -- that is, the only digits available are: 0, 1, 2, 3, 4, 5, 6, and 7. In Octal, we count like this: 0, 1, 2, 3, 4, 5, 6, 7, 10, 11, 12, … (note: no 8 and 9, so we skip from 7 to 10).</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td>Decimal</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td></tr><tr><td>Octal</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>10</td><td>11</td><td>12</td><td>13</td></tr></tbody></table></div><p>To use an octal literal, prefix your literal with a 0 (zero):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 012 }; // 0 before the number means this is octal</code><code>    std::cout &lt;&lt; x &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>10
</pre><p>Why 10 instead of 12? Because numbers are output in decimal by default, and 12 octal = 10 decimal.</p><p>Octal is hardly ever used, and we recommend you avoid it.</p><p><span class="cpp-definition">Hexadecimal</span> is base 16. In hexadecimal, we count like this: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, 10, 11, 12, …</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td>Decimal</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td></tr><tr><td>Hexadecimal</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>10</td><td>11</td></tr></tbody></table></div><p>To use a hexadecimal literal, prefix your literal with 0x.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 0xF }; // 0x before the number means this is hexadecimal</code><code>    std::cout &lt;&lt; x &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>15
</pre><p>Because there are 16 different values for a hexadecimal digit, we can say that a single hexadecimal digit encompasses 4 bits. Consequently, a pair of hexadecimal digits can be used to exactly represent a full byte.</p><p>Consider a 32-bit integer with value 0011 1010 0111 1111 1001 1000 0010 0110. Because of the length and repetition of digits, that’s not easy to read. In hexadecimal, this same value would be: 3A7F 9826, which is much more concise. For this reason, hexadecimal values are often used to represent memory addresses or raw data in memory (whose type isn’t known).</p><br><h3>Binary literals and digit separators</h3><p>Prior to C++14, there is no support for binary literals. However, hexadecimal literals provide us with a useful workaround (that you may still see in existing code bases):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int bin{};    // assume 16-bit ints</code><code>    bin = 0x0001; // assign binary 0000 0000 0000 0001 to the variable</code><code>    bin = 0x0002; // assign binary 0000 0000 0000 0010 to the variable</code><code>    bin = 0x0004; // assign binary 0000 0000 0000 0100 to the variable</code><code>    bin = 0x0008; // assign binary 0000 0000 0000 1000 to the variable</code><code>    bin = 0x0010; // assign binary 0000 0000 0001 0000 to the variable</code><code>    bin = 0x0020; // assign binary 0000 0000 0010 0000 to the variable</code><code>    bin = 0x0040; // assign binary 0000 0000 0100 0000 to the variable</code><code>    bin = 0x0080; // assign binary 0000 0000 1000 0000 to the variable</code><code>    bin = 0x00FF; // assign binary 0000 0000 1111 1111 to the variable</code><code>    bin = 0x00B3; // assign binary 0000 0000 1011 0011 to the variable</code><code>    bin = 0xF770; // assign binary 1111 0111 0111 0000 to the variable</code><code></code><code>    return 0;</code><code>}</code></pre><p>In C++14, we can use binary literals by using the 0b prefix:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int bin{};        // assume 16-bit ints</code><code>    bin = 0b1;        // assign binary 0000 0000 0000 0001 to the variable</code><code>    bin = 0b11;       // assign binary 0000 0000 0000 0011 to the variable</code><code>    bin = 0b1010;     // assign binary 0000 0000 0000 1010 to the variable</code><code>    bin = 0b11110000; // assign binary 0000 0000 1111 0000 to the variable</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because long literals can be hard to read, C++14 also adds the ability to use a quotation mark (‘) as a digit separator.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int bin { 0b1011'0010 };  // assign binary 1011 0010 to the variable</code><code>    long value { 2'132'673'462 }; // much easier to read than 2132673462</code><code></code><code>    return 0;</code><code>}</code></pre><p>Also note that the separator can not occur before the first digit of the value:</p><pre class="language-cpp line-numbers"><code>    int bin { 0b'1011'0010 };  // error: ' used before first digit of value</code></pre><br><h3>Outputting values in decimal, octal, or hexadecimal</h3><p>By default, C++ outputs values in decimal. However, you can change the output format via use of the <code>std::dec</code>, <code>std::oct</code>, and <code>std::hex</code> I/O manipulators:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x { 12 };</code><code>    std::cout &lt;&lt; x &lt;&lt; '\n'; // decimal (by default)</code><code>    std::cout &lt;&lt; std::hex &lt;&lt; x &lt;&lt; '\n'; // hexadecimal</code><code>    std::cout &lt;&lt; x &lt;&lt; '\n'; // now hexadecimal</code><code>    std::cout &lt;&lt; std::oct &lt;&lt; x &lt;&lt; '\n'; // octal</code><code>    std::cout &lt;&lt; std::dec &lt;&lt; x &lt;&lt; '\n'; // return to decimal</code><code>    std::cout &lt;&lt; x &lt;&lt; '\n'; // decimal</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>12
c
c
14
12
12
</pre><p>Note that once applied, the I/O manipulator remains set for future output until it is changed again.</p><br><h3>Outputting values in binary</h3><p>Outputting values in binary is a little harder, as <code>std::cout</code> doesn’t come with this capability built-in. Fortunately, the C++ standard library includes a type called <code>std::bitset</code> that will do this for us (in the &lt;bitset&gt; header). To use <code>std::bitset</code>, we can define a <code>std::bitset</code> variable and tell <code>std::bitset</code> how many bits we want to store. The number of bits must be a compile-time constant. <code>std::bitset</code> can be initialized with an unsigned integral value (in any format, including decimal, octal, hex, or binary).</p><pre class="language-cpp line-numbers"><code>#include <bitset> // for std::bitset</bitset></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	// std::bitset&lt;8&gt; means we want to store 8 bits</code><code>	std::bitset&lt;8&gt; bin1{ 0b1100'0101 }; // binary literal for binary 1100 0101</code><code>	std::bitset&lt;8&gt; bin2{ 0xC5 }; // hexadecimal literal for binary 1100 0101</code><code></code><code>	std::cout &lt;&lt; bin1 &lt;&lt; '\n' &lt;&lt; bin2 &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; std::bitset&lt;4&gt;{ 0b1010 } &lt;&lt; '\n'; // create a temporary std::bitset and print it</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>11000101
11000101
1010
</pre><p>In the above code, this line:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; std::bitset&lt;4&gt;{ 0b1010 } &lt;&lt; '\n'; // create a temporary std::bitset and print it</code></pre><p>creates a temporary (unnamed) <code>std::bitset</code> object with 4 bits, initializes it with binary literal <code>0b1010</code>, prints the value in binary, and then discards the temporary object.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">4.17 — Introduction to std::string</h1></header><div class="entry-content" itemprop="articleBody"><p>The very first C++ program you wrote probably looked something like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code> </code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Hello, world!\n";</code><code>    return 0;</code><code>}</code></pre><p>So what is “Hello, world!” exactly? “Hello, world!” is a collection of sequential characters called a <span class="cpp-definition">string</span>. In C++, we use strings to represent text (such as names, words, and sentences). String literals (such as “Hello, world!\n”) are placed between double quotes to identify them as strings.</p><p>Because strings are commonly used in programs, most modern programming languages include a fundamental string data type. For historical reasons, strings are not a fundamental type in C++. Rather, they have a strange, complicated type that is hard to work with (we’ll cover how/why in a future lesson, once we’ve covered more fundamentals required to explain how they work). For now, we’ll call double-quoted strings “C-style strings”, as they were inherited from the C-language.</p><p>Fortunately, C++ has introduced two additional string types into the language that are much easier and safer to work with: <code>std::string</code> and <code>std::string_view</code> (C++17). Although <code>std::string</code> and <code>std::string_view</code> aren’t fundamental types, they’re straightforward and useful enough that we’ll introduce them here rather than wait until the chapter on compound types (<a href="https://www.learncpp.com#Chapter9">chapter 9</a>).</p><br><h3>Introducing std::string</h3><p>The easiest way to work with strings and string objects in C++ is via the <code>std::string</code> type, which lives in the &lt;string&gt; header.</p><p>We can create objects of type <code>std::string</code> just like other objects:</p><pre class="language-cpp line-numbers"><code>#include <string> // allows use of std::string</string></code><code></code><code>int main()</code><code>{</code><code>    std::string name {}; // empty string</code><code></code><code>    return 0;</code><code>}</code></pre><p>Just like normal variables, you can initialize or assign values to std::string objects as you would expect:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>    std::string name { "Alex" }; // initialize name with string literal "Alex"</code><code>    name = "John";              // change name to "John"</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note that strings can hold numbers as well:</p><pre class="language-cpp line-numbers"><code>std::string myID{ "45" }; // "45" is not the same as integer 45!</code></pre><p>In string form, numbers are treated as text, not as numbers, and thus they can not be manipulated as numbers (e.g. you can’t multiply them). C++ will not automatically convert strings to integer or floating point values or vice-versa (though there are ways to do so that we’ll cover in a future lesson).</p><br><h3>String output</h3><p><code>std::string</code> objects can be output as expected using <code>std::cout</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>    std::string name { "Alex" };</code><code>    std::cout &lt;&lt; "My name is: " &lt;&lt; name &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>My name is: Alex
</pre><p>Empty strings will print nothing:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>    std::string empty{ };</code><code>    std::cout &lt;&lt; '[' &lt;&lt; empty &lt;&lt; ']';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Which prints:</p><pre>[]
</pre><br><h3>String input with std::cin</h3><p>Using strings with <code>std::cin</code> may yield some surprises! Consider the following example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter your full name: ";</code><code>    std::string name{};</code><code>    std::cin &gt;&gt; name; // this won't work as expected since std::cin breaks on whitespace</code><code></code><code>    std::cout &lt;&lt; "Enter your age: ";</code><code>    std::string age{};</code><code>    std::cin &gt;&gt; age;</code><code></code><code>    std::cout &lt;&lt; "Your name is " &lt;&lt; name &lt;&lt; " and your age is " &lt;&lt; age &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Here’s the results from a sample run of this program:</p><pre>Enter your full name: John Doe
Enter your age: Your name is John and your age is Doe
</pre><p>Hmmm, that isn’t right! What happened? It turns out that when using <code>operator&gt;&gt;</code> to extract a string from <code>std::cin</code>, <code>operator&gt;&gt;</code> only returns characters up to the first whitespace it encounters. Any other characters are left inside <code>std::cin</code>, waiting for the next extraction.</p><p>So when we used <code>operator&gt;&gt;</code> to extract input into variable <code>name</code>, only <code>"John"</code> was extracted, leaving <code>" Doe"</code> inside <code>std::cin</code>. When we then used <code>operator&gt;&gt;</code> to get extract input into variable <code>age</code>, it extracted <code>"Doe"</code> instead of waiting for us to input an age. Then the program ends.</p><br><h3>Use std::getline() to input text</h3><p>To read a full line of input into a string, you’re better off using the <code>std::getline()</code> function instead. <code>std::getline()</code> requires two arguments: the first is <code>std::cin</code>, and the second is your string variable.</p><p>Here’s the same program as above using <code>std::getline()</code>:</p><pre class="language-cpp line-numbers"><code>#include <string> // For std::string and std::getline</string></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter your full name: ";</code><code>    std::string name{};</code><code>    std::getline(std::cin &gt;&gt; std::ws, name); // read a full line of text into name</code><code></code><code>    std::cout &lt;&lt; "Enter your age: ";</code><code>    std::string age{};</code><code>    std::getline(std::cin &gt;&gt; std::ws, age); // read a full line of text into age</code><code></code><code>    std::cout &lt;&lt; "Your name is " &lt;&lt; name &lt;&lt; " and your age is " &lt;&lt; age &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Now our program works as expected:</p><pre>Enter your full name: John Doe
Enter your age: 23
Your name is John Doe and your age is 23
</pre><br><h3>What the heck is std::ws?</h3><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/floating-point-numbers/">4.8 -- Floating point numbers</a>, we discussed output manipulators, which allow us to alter the way output is displayed. In that lesson, we used the output manipulator function <code>std::setprecision()</code> to change the number of digits of precision that <code>std::cout</code> displayed.</p><p>C++ also supports <span class="cpp-definition"></span>input manipulators<span class="cpp-definition"></span>, which alter the way that input is accepted. The <code>std::ws</code> input manipulator tells <code>std::cin</code> to ignore any leading whitespace before extraction. Leading whitespace is any whitespace character (spaces, tabs, newlines) that occur at the start of the string.</p><p>Let’s explore why this is useful. Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Pick 1 or 2: ";</code><code>    int choice{};</code><code>    std::cin &gt;&gt; choice;</code><code></code><code>    std::cout &lt;&lt; "Now enter your name: ";</code><code>    std::string name{};</code><code>    std::getline(std::cin, name); // note: no std::ws here</code><code></code><code>    std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; ", you picked " &lt;&lt; choice &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Here’s some output from this program:</p><pre>Pick 1 or 2: 2
Now enter your name: Hello, , you picked 2
</pre><p>This program first asks you to enter 1 or 2, and waits for you to do so. All good so far. Then it will ask you to enter your name. However, it won’t actually wait for you to enter your name! Instead, it prints the “Hello” string, and then exits.</p><p>When you enter a value using <code>operator&gt;&gt;</code>, <code>std::cin</code> not only captures the value, it also captures the newline character (<code>'\n'</code>) that occurs when you hit the enter key. So when we type <code>2</code> and then hit enter, <code>std::cin</code> captures the string <code>"2\n"</code> as input. It then extracts the value <code>2</code> to variable <code>choice</code>, leaving the newline character behind for later. Then, when <code>std::getline()</code> goes to extract text to <code>name</code>, it sees <code>"\n"</code> is already waiting in <code>std::cin</code>, and figures we must have previously entered an empty string! Definitely not what was intended.</p><p>We can amend the above program to use the <code>std::ws</code> input manipulator, to tell <code>std::getline()</code> to ignore any leading whitespace characters:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Pick 1 or 2: ";</code><code>    int choice{};</code><code>    std::cin &gt;&gt; choice;</code><code></code><code>    std::cout &lt;&lt; "Now enter your name: ";</code><code>    std::string name{};</code><code>    std::getline(std::cin &gt;&gt; std::ws, name); // note: added std::ws here</code><code></code><code>    std::cout &lt;&lt; "Hello, " &lt;&lt; name &lt;&lt; ", you picked " &lt;&lt; choice &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Now this program will function as intended.</p><pre>Pick 1 or 2: 2
Now enter your name: Alex
Hello, Alex, you picked 2
</pre><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>If using <code>std::getline()</code> to read strings, use <code>std::cin &gt;&gt; std::ws</code> input manipulator to ignore leading whitespace.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Using the extraction operator (&gt;&gt;) with std::cin ignores leading whitespace.<br>std::getline() does not ignore leading whitespace unless you use input manipulator std::ws.</p></div><br><h3>String length</h3><p>If we want to know how many characters are in a <code>std::string</code>, we can ask a <code>std::string</code> object for its length. The syntax for doing this is different than you’ve seen before, but is pretty straightforward:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>    std::string name{ "Alex" };</code><code>    std::cout &lt;&lt; name &lt;&lt; " has " &lt;&lt; name.length() &lt;&lt; " characters\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>Alex has 4 characters
</pre><p>Note that instead of asking for the string length as <code>length(name)</code>, we say <code>name.length()</code>. The <code>length()</code> function isn’t a normal standalone function -- it’s a special type of function that is nested within <code>std::string</code> called a <em>member function</em>. Because <code>length()</code> lives within std::string, it is sometimes written as <code>std::string::length()</code> in documentation.</p><p>We’ll cover member functions, including how to write your own, in more detail later.</p><p>Also note that <code>std::string::length()</code> returns an unsigned integral value (most likely of type <code>size_t</code>). If you want to assign the length to an <code>int</code> variable, you should <code>static_cast</code> it to avoid compiler warnings about signed/unsigned conversions:</p><pre class="language-cpp line-numbers"><code>int length { static_cast<int>(name.length()) };</int></code></pre><p>In C++20, you can also use the <code>std::ssize()</code> function to get the length of a <code>std::string</code> as a signed integer:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>    std::string name{ "Alex" };</code><code>    std::cout &lt;&lt; name &lt;&lt; " has " &lt;&lt; std::ssize(name) &lt;&lt; " characters\n";</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>std::string is expensive to initialize and copy</h3><p>Whenever a <code>std::string</code> is initialized, a copy of the string used to initialize it is made. And whenever a <code>std::string</code> is passed by value to a <code>std::string</code> parameter, another copy is made. These copies are expensive, and should be avoided if possible.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Do not pass <code>std::string</code> by value, as making copies of <code>std::string</code> is expensive. Prefer <code>std::string_view</code> parameters.</p></div><p>We’ll discuss this topic (and <code>std::string_view</code>) further in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-stdstring_view/">4.18 -- Introduction to std::string_view</a>.</p><br><h3>Literals for std::string</h3><p>Double-quoted string literals (like “Hello, world!”) are C-style strings by default (and thus, have a strange type).</p><p>We can create string literals with type <code>std::string</code> by using a <code>s</code> suffix after the double-quoted string literal.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string>      // for std::string</string></code><code>#include <string_view> // for std::string_view</string_view></code><code></code><code>int main()</code><code>{</code><code>    using namespace std::literals; // easiest way to access the s and sv suffixes</code><code></code><code>    std::cout &lt;&lt; "foo\n";   // no suffix is a C-style string literal</code><code>    std::cout &lt;&lt; "goo\n"s;  // s suffix is a std::string literal</code><code>    std::cout &lt;&lt; "moo\n"sv; // sv suffix is a std::string_view literal</code><code></code><code>    return 0;</code><code>};</code></pre><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>The “s” suffix lives in the namespace <code>std::literals::string_literals</code>. The easiest way to access the literal suffixes is via using directive <code>using namespace std::literals</code>. We discuss using directives in lesson <a href="https://www.learncpp.com/cpp-tutorial/using-declarations-and-using-directives/">6.12 -- Using declarations and using directives</a>. This is one of the exception cases where <code>using</code> an entire namespace is okay, because the suffixes defined within are unlikely to collide with any of your code.</p></div><p>You probably won’t need to use <code>std::string</code> literals very often (as it’s fine to initialize a <code>std::string</code> object with a C-style string literal), but we’ll see a few cases in future lessons where using <code>std::string</code> literals instead of C-style string literals makes things easier.</p><br><h3>Constexpr strings </h3><p>If you try to define a <code>constexpr std::string</code>, your compiler will probably generate an error:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>using namespace std::literals;</code><code></code><code>int main()</code><code>{</code><code>    constexpr std::string name{ "Alex"s }; // compile error</code><code></code><code>    std::cout &lt;&lt; "My name is: " &lt;&lt; name;</code><code></code><code>    return 0;</code><code>}</code></pre><p>This happens because <code>constexpr std::string</code> isn’t supported in C++17 or earlier, and only has minimal support in C++20. If you need constexpr strings, use <code>std::string_view</code> instead (discussed in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-stdstring_view/">4.18 -- Introduction to std::string_view</a>.</p><br><h3>Conclusion</h3><p>std::string is complex, leveraging many language features that we haven’t covered yet. Fortunately, you don’t need to understand these complexities to use std::string for simple tasks, like basic string input and output. We encourage you to start experimenting with strings now, and we’ll cover additional string capabilities later.</p><br><h3>Quiz time</h3><p class="cpp-quiz-question" style="clear:both">Question #1</p><p>Write a program that asks the user to enter their full name and their age. As output, tell the user the sum of their age and the number of letters in their name (use the <code>std::string::length()</code> member function to get the length of the string). For simplicity, count any spaces in the name as a letter.</p><p>Sample output:</p><pre>Enter your full name: John Doe
Enter your age: 32
Your age + length of name is: 40
</pre><p>Reminder: std::string::length() returns an unsigned int. You should static_cast this to an int before adding the age so you don’t mix signed and unsigned values.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter your full name: ";</code><code>    std::string name{};</code><code>    std::getline(std::cin &gt;&gt; std::ws, name); // read a full line of text into name</code><code></code><code>    std::cout &lt;&lt; "Enter your age: ";</code><code>    int age{}; // age needs to be an integer, not a string, so we can do math with it</code><code>    std::cin &gt;&gt; age;</code><code></code><code>    // age is signed, and name.length() is unsigned -- we shouldn't mix these</code><code>    // We'll convert name.length() to a signed value</code><code>    int letters{ static_cast<int>(name.length()) }; // get number of letters in name (including spaces)</int></code><code>    std::cout &lt;&lt; "Your age + length of name is: " &lt;&lt; age + letters &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">4.18 — Introduction to std::string_view</h1></header><div class="entry-content" itemprop="articleBody"><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x { 5 };</code><code>    std::cout &lt;&lt; x &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>When the definition for <code>x</code> is executed, the initialization value <code>5</code> is copied into the memory allocated for <code>int</code> <code>x</code>. For fundamental types, initializing (or copying) a variable is fast.</p><p>Now consider this similar program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>    std::string s{ "Hello, world!" };</code><code>    std::cout &lt;&lt; s &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>When <code>s</code> is initialized, the C-style string literal <code>"Hello, world!"</code> is copied into memory allocated for <code>std::string s</code>. Unlike fundamental types, initializing (or copying) a <code>std::string</code> is slow.</p><p>In the above program, all we do with <code>s</code> is print the value to the console, and then <code>s</code> is destroyed. We’ve essentially made a copy of “Hello, world!” just to print and then destroy that copy. That’s inefficient.</p><p>We see something similar in this example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>void printString(std::string str)</code><code>{</code><code>    std::cout &lt;&lt; str &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::string s{ "Hello, world!" };</code><code>    printString(s);</code><code></code><code>    return 0;</code><code>}</code></pre><p>This example makes two copies of the C-style string “Hello, world!”: one when we initialize <code>s</code> in <code>main()</code>, and another when we initialize parameter <code>str</code> in <code>printString()</code>. That’s a lot of needless copying just to print a string!</p><br><h3>std::string_view C++17</h3><p>To address the issue with <code>std::string</code> being expensive to initialize (or copy), C++17 introduced <code>std::string_view</code> (which lives in the &lt;string_view&gt; header). <code>std::string_view</code> provides read-only access to an <em>existing</em> string (a C-style string literal, a <code>std::string</code>, or a char array) without making a copy.</p><p>The following example is identical to the prior one, except we’ve replaced <code>std::string</code> with <code>std::string_view</code>.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>void printSV(std::string_view str) // now a std::string_view</code><code>{</code><code>    std::cout &lt;&lt; str &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::string_view s{ "Hello, world!" }; // now a std::string_view</code><code>    printSV(s);</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program produces the same output as the prior one, but no copies of the string “Hello, world!” are made.</p><p>When we initialize <code>std::string_view s</code> with C-style string literal <code>"Hello, world!"</code>, <code>s</code> provides read-only access to “Hello, world!” without making a copy of the string. When we pass <code>s</code> to <code>printSV()</code>, parameter <code>str</code> is initialized from <code>s</code>. This allows us to access “Hello, world!” through <code>str</code>, again without making a copy of the string.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Prefer <code>std::string_view</code> over <code>std::string</code> when you need a read-only string, especially for function parameters.</p></div><br><h3>constexpr std::string_view</h3><p>Unlike <code>std::string</code>, <code>std::string_view</code> has full support for constexpr:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>int main()</code><code>{</code><code>    constexpr std::string_view s{ "Hello, world!" };</code><code>    std::cout &lt;&lt; s &lt;&lt; '\n'; // s will be replaced with "Hello, world!" at compile-time</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>Converting a std::string to a std::string_view</h3><p>A <code>std::string_view</code> can be created using a <code>std::string</code> initializer, and a <code>std::string</code> will implicitly convert to a <code>std::string_view</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>void printSV(std::string_view str)</code><code>{</code><code>    std::cout &lt;&lt; str &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::string s{ "Hello, world" };</code><code>    std::string_view sv{ s }; // Initialize a std::string_view from a std::string</code><code>    std::cout &lt;&lt; sv &lt;&lt; '\n';</code><code></code><code>    printSV(s); // implicitly convert a std::string to std::string_view</code><code>        </code><code>    return 0;</code><code>}</code></pre><br><h3>Converting a std::string_view to a std::string</h3><p>Because <code>std::string</code> makes a copy of its initializer, C++ won’t allow implicit conversion of a <code>std::string</code> from a <code>std::string_view</code>. However, we can explicitly create a <code>std::string</code> with a <code>std::string_view</code> initializer, or we can convert an existing <code>std::string_view</code> to a <code>std::string</code> using <code>static_cast</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>void printString(std::string str)</code><code>{</code><code>    std::cout &lt;&lt; str &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  std::string_view sv{ "balloon" };</code><code></code><code>  std::string str{ sv }; // okay, we can create std::string using std::string_view initializer</code><code></code><code>  // printString(sv);   // compile error: won't implicitly convert std::string_view to a std::string</code><code></code><code>  printString(static_cast<std::string>(sv)); // okay, we can explicitly cast a std::string_view to a std::string</std::string></code><code>	   </code><code>  return 0;</code><code>}</code></pre><br><h3>Literals for std::string_view</h3><p>Double-quoted string literals are C-style string literals by default. We can create string literals with type <code>std::string_view</code> by using a <code>sv</code> suffix after the double-quoted string literal.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string>      // for std::string</string></code><code>#include <string_view> // for std::string_view</string_view></code><code></code><code>int main()</code><code>{</code><code>    using namespace std::literals; // easiest way to access the s and sv suffixes</code><code></code><code>    std::cout &lt;&lt; "foo\n";   // no suffix is a C-style string literal</code><code>    std::cout &lt;&lt; "goo\n"s;  // s suffix is a std::string literal</code><code>    std::cout &lt;&lt; "moo\n"sv; // sv suffix is a std::string_view literal</code><code></code><code>    return 0;</code><code>};</code></pre><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>The “sv” suffix lives in the namespace <code>std::literals::string_view_literals</code>. The easiest way to access the literal suffixes is via using directive <code>using namespace std::literals</code>. We discuss using directives in lesson <a href="https://www.learncpp.com/cpp-tutorial/using-declarations-and-using-directives/">6.12 -- Using declarations and using directives</a>. This is one of the exception cases where <code>using</code> an entire namespace is okay.</p></div><br><h3>Do not return a std::string_view</h3><p>Returning a std::string_view from a function is usually a bad idea. We’ll explore why in lesson <a href="https://www.learncpp.com/cpp-tutorial/stdstring_view-part-2/">11.7 -- std::string_view (part 2)</a>. For now, avoid doing so.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">4.x — Chapter 4 summary and quiz</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Chapter Review</h3><p>The smallest unit of memory is a <span class="cpp-definition">binary digit</span>, also called a <span class="cpp-definition">bit</span>. The smallest unit amount of memory that can be addressed directly is a <span class="cpp-definition">byte</span>. The modern standard is that a byte equals 8 bits.</p><p>A <span class="cpp-definition">data type</span> tells the compiler how to interpret the contents of memory in some meaningful way.</p><p>C++ comes with support for many fundamental data types, including floating point numbers, integers, boolean, chars, null pointers, and void.</p><p><span class="cpp-definition">Void</span> is used to indicate no type. It is primarily used to indicate that a function does not return a value.</p><p>Different types take different amounts of memory, and the amount of memory used may vary by machine. See <a href="https://www.learncpp.com/cpp-tutorial/object-sizes-and-the-sizeof-operator/">4.3 -- Object sizes and the sizeof operator</a> for a table indicating the minimum size for each fundamental type.</p><p>The <span class="cpp-definition">sizeof</span> operator can be used to return the size of a type in bytes.</p><p><span class="cpp-definition">Signed integers</span> are used for holding positive and negative whole numbers, including 0. The set of values that a specific data type can hold is called its <span class="cpp-definition">range</span>. When using integers, keep an eye out for overflow and integer division problems.</p><p><span class="cpp-definition">Unsigned integers</span> only hold positive numbers, and should generally be avoided unless you’re doing bit-level manipulation.</p><p><span class="cpp-definition">Fixed-width integers</span> are integers with guaranteed sizes, but they may not exist on all architectures. The fast and least integers are the fastest and smallest integers that are at least some size. std::int8_t and std::uint8_t should generally be avoided, as they tend to behave like chars instead of integers.</p><p><span class="cpp-definition">size_t</span> is an unsigned integral type that is used to represent the size or length of objects.</p><p><span class="cpp-definition">Scientific notation</span> is a shorthand way of writing lengthy numbers. C++ supports scientific notation in conjunction with floating point numbers. The digits in the significand (the part before the e) are called the <span class="cpp-definition">significant digits</span>.</p><p><span class="cpp-definition">Floating point</span> is a set of types designed to hold real numbers (including those with a fractional component). The <span class="cpp-definition">precision</span> of a number defines how many significant digits it can represent without information loss. A <span class="cpp-definition">rounding error</span> can occur when too many significant digits are stored in a floating point number that can’t hold that much precision. Rounding errors happen all the time, even with simple numbers such as 0.1. Because of this, you shouldn’t compare floating point numbers directly.</p><p>The <span class="cpp-definition">boolean</span> type is used to store a true or false value.</p><p><span class="cpp-definition">If statements</span> allow us to execute one or more lines of code if some condition is true. The conditional expression of an <em>if statement</em> is interpreted as a boolean value.</p><p><span class="cpp-definition">Char</span> is used to store values that are interpreted as an ASCII character. When using chars, be careful not to mix up ASCII code values and numbers. Printing a char as an integer value requires use of static_cast.</p><p>Angled brackets are typically used in C++ to represent something that needs a parameterizable type. This is used with static_cast to determine what data type the argument should be converted to (e.g. <code>static_cast<int>(x)</int></code> will convert <em>x</em> to an int).</p><p>A <span class="cpp-definition">constant</span> is a value that may not be changed. C++ supports two types of constants: const variables, and literals. A variables whose value can not be changed is called a <span class="cpp-definition">constant variable</span>. The <span class="cpp-definition">const</span> keyword is used to make a variable constant.</p><p>A <span class="cpp-definition">symbolic constant</span> is a name given to a constant value. Constant variables are one type of symbolic constant, as are object-like macros with substitution text.</p><p>A <span class="cpp-definition">constant expression</span> is an expression that can be evaluated at compile-time. A <span class="cpp-definition">compile-time constant</span> is a constant whose value is known at compile-time. A <span class="cpp-definition">runtime constant</span> is a constant whose initialization value isn’t known until runtime. A <span class="cpp-definition">constexpr</span> variable must be a compile-time constant.</p><p><span class="cpp-definition">Literals</span> are values inserted directly into the code. Literals have types, and literal suffixes can be used to change the type of a literal from the default type.</p><p>A <span class="cpp-definition">magic number</span> is a literal (usually a number) that either has an unclear meaning or may need to be changed later. Don’t use magic numbers in your code. Instead, use symbolic constants.</p><p>In everyday life, we count using <span class="cpp-definition">decimal</span> numbers, which have 10 digits. Computers use <span class="cpp-definition">binary</span>, which only has 2 digits. C++ also supports <span class="cpp-definition">octal</span> (base 8) and <span class="cpp-definition">hexadecimal</span> (base 16). These are all examples of <span class="cpp-definition">numeral systems</span>, which are collections of symbols (digits) used to represent numbers.</p><p>A <span class="cpp-definition">string</span> is a collection of sequential characters that is used to represent text (such as names, words, and sentences). String literals are always placed between double quotes. String literals in C++ are C-style strings, which have a strange type that is hard to work with.</p><p><span class="cpp-definition">std::string</span> offers an easy and safe way to deal with text strings. std::string lives in the &lt;string&gt; header. <code>std::string</code> is expensive to initialize and copy.</p><p><span class="cpp-definition">std::string_view</span> provides read-only access to an existing string (a C-style string literal, a std::string, or a char array) without making a copy.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Why are symbolic constants usually a better choice than literal constants? Why are const/constexpr symbolic constants usually a better choice than #defined symbolic constants?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>Using literal constants (a.k.a. magic numbers) in your program makes your program harder to understand and harder to modify. Symbolic constants help document what the numbers actually represent, and changing a symbolic constant at its declaration changes the value everywhere it is used. #define constants do not show up in the debugger and are more likely to have naming conflicts.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>Pick the appropriate data type for a variable in each of the following situations. Be as specific as possible. If the answer is an integer, pick int (if size isn’t important), or a specific fixed-width integer type (e.g. std::int16_t) based on range. If the variable should be const, say so.</p><p>a) The age of the user (in years) (assume the size of the type isn’t important)</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none">int</div><p>b) Whether the user wants the application to check for updates</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none">bool</div><p>c) pi (3.14159265)</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none">constexpr double</div><p>d) The number of pages in a textbook (assume size is not important)</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none">Since books probably won’t have more than 32,767 pages, int should be fine here.</div><p>e) The length of a couch in feet, to 2 decimal places (assume size is important)</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none">float</div><p>f) How many times you’ve blinked since you were born (note: answer is in the millions)</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none">std::int32_t</div><p>g) A user selecting an option from a menu by letter</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_7'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_7" style="display:none">char</div><p>h) The year someone was born (assuming size is important)</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_8'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_8" style="display:none">std::int16_t. You can use positive numbers to represent AD birthdates, and negative numbers to represent BC birthdates.</div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>The quizzes get more challenging starting here. These quizzes that ask you to write a program are designed to ensure you can integrate multiple concepts that have been presented throughout the lessons. You should be prepared to spend some time with these problems. If you’re new to programming, you shouldn’t expect to be able to answer these immediately.</p><p>Remember, the goal here is to help you pinpoint what you know, and which concepts you may need to spend additional time on. If you find yourself struggling a bit, that’s okay.</p><p>Here are some tips:</p><ul><li>Don’t try to write the whole solution at once. Write one function, then test it to make sure it works as expected. Then proceed.</li><li>Use your debugger to help figure out where things are going wrong.</li><li>Go back and review the answers to quizzes from prior lessons in the chapter, as they’ll often contain similar concepts</li></ul><p>If you are truly stuck, feel free to look at the solution, but take the time to make sure you understand what each line does before proceeding. As long as you leave understanding the concepts, it doesn’t matter so much whether you were able to get it yourself, or had to look at the solution before proceeding.</p></div><p>Write the following program: The user is asked to enter 2 floating point numbers (use doubles). The user is then asked to enter one of the following mathematical symbols: +, -, *, or /. The program computes the answer on the two numbers the user entered and prints the results. If the user enters an invalid symbol, the program should print nothing.</p><p>Example of program:</p><pre>Enter a double value: 6.2
Enter a double value: 5
Enter one of the following: +, -, *, or /: *
6.2 * 5 is 31
</pre><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">Hint: Write three functions: one to get a double value, one to get the arithmetic symbol, and one to calculate and print the answer.</div><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_1'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_1" style="display:none;margin-bottom:1em">Hint: Use if statements and operator== to compare the user input to the desired arithmetic symbol.</div><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_9'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_9" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>double getDouble()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a double value: ";</code><code>    double x{};</code><code>    std::cin &gt;&gt; x;</code><code>    return x;</code><code>}</code><code></code><code>char getOperator()</code><code>{</code><code>    std::cout &lt;&lt; "Enter one of the following: +, -, *, or / ";</code><code>    char operation{};</code><code>    std::cin &gt;&gt; operation;</code><code>    return operation;</code><code>}</code><code></code><code>void printResult(double x, char operation, double y)</code><code>{</code><code>    if (operation == '+')</code><code>        std::cout &lt;&lt; x &lt;&lt; " + " &lt;&lt; y &lt;&lt; " is " &lt;&lt; x + y &lt;&lt; '\n';</code><code>    else if (operation == '-')</code><code>        std::cout &lt;&lt; x &lt;&lt; " - " &lt;&lt; y &lt;&lt; " is " &lt;&lt; x - y &lt;&lt; '\n';</code><code>    else if (operation == '*')</code><code>        std::cout &lt;&lt; x &lt;&lt; " * " &lt;&lt; y &lt;&lt; " is " &lt;&lt; x * y &lt;&lt; '\n';</code><code>    else if (operation == '/')</code><code>        std::cout &lt;&lt; x &lt;&lt; " / " &lt;&lt; y &lt;&lt; " is " &lt;&lt; x / y &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    double x { getDouble() };</code><code>    double y { getDouble() };</code><code></code><code>    char operation { getOperator() };</code><code></code><code>    printResult(x, operation, y);</code><code></code><code>    return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #4</p><p>Extra credit: This one is a little more challenging.</p><p>Write a short program to simulate a ball being dropped off of a tower. To start, the user should be asked for the height of the tower in meters. Assume normal gravity (9.8 m/s<sup>2</sup>), and that the ball has no initial velocity (the ball is not moving to start). Have the program output the height of the ball above the ground after 0, 1, 2, 3, 4, and 5 seconds. The ball should not go underneath the ground (height 0).</p><p>Use a function to calculate the height of the ball after x seconds. The function can calculate how far the ball has fallen after x seconds using the following formula: distance fallen = gravity_constant * x_seconds<sup>2</sup> / 2</p><p>Desired output:</p><pre>Enter the height of the tower in meters: 100
At 0 seconds, the ball is at height: 100 meters
At 1 seconds, the ball is at height: 95.1 meters
At 2 seconds, the ball is at height: 80.4 meters
At 3 seconds, the ball is at height: 55.9 meters
At 4 seconds, the ball is at height: 21.6 meters
At 5 seconds, the ball is on the ground.
</pre><p>Note: Depending on the height of the tower, the ball may not reach the ground in 5 seconds -- that’s okay. We’ll improve this program once we’ve covered loops.<br>Note: The ^ symbol isn’t an exponent in C++. Implement the formula using multiplication instead of exponentiation.<br>Note: Remember to use double literals for doubles, eg. 2.0 rather than 2.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_10'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_10" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// gets height from user and returns it</code><code>double getTowerHeight()</code><code>{</code><code>	std::cout &lt;&lt; "Enter the height of the tower in meters: ";</code><code>	double towerHeight{};</code><code>	std::cin &gt;&gt; towerHeight;</code><code>	return towerHeight;</code><code>}</code><code></code><code>// Returns height from ground after "seconds" seconds</code><code>double calculateHeight(double towerHeight, int seconds)</code><code>{</code><code>	constexpr double gravity{ 9.8 };</code><code></code><code>	// Using formula: [ s = u * t + (a * t^2) / 2 ], here u(initial velocity) = 0</code><code>	const double distanceFallen{ (gravity * (seconds * seconds)) / 2.0 };</code><code>	const double currentHeight{ towerHeight - distanceFallen };</code><code></code><code>	return currentHeight;</code><code>}</code><code></code><code>// Prints height every second till ball has reached the ground</code><code>void printHeight(double height, int seconds)</code><code>{</code><code>	if (height &gt; 0.0)</code><code>		std::cout &lt;&lt; "At " &lt;&lt; seconds &lt;&lt; " seconds, the ball is at height: " &lt;&lt; height &lt;&lt; " meters\n";</code><code>	else</code><code>		std::cout &lt;&lt; "At " &lt;&lt; seconds &lt;&lt; " seconds, the ball is on the ground.\n";</code><code>}</code><code></code><code>void calculateAndPrintHeight(double towerHeight, int seconds)</code><code>{</code><code>	const double height{ calculateHeight(towerHeight, seconds) };</code><code>	printHeight(height, seconds);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	const double towerHeight{ getTowerHeight() };</code><code></code><code>	calculateAndPrintHeight(towerHeight, 0);</code><code>	calculateAndPrintHeight(towerHeight, 1);</code><code>	calculateAndPrintHeight(towerHeight, 2);</code><code>	calculateAndPrintHeight(towerHeight, 3);</code><code>	calculateAndPrintHeight(towerHeight, 4);</code><code>	calculateAndPrintHeight(towerHeight, 5);</code><code></code><code>	return 0;</code><code>}</code></pre><p>Note that calculateHeight() doesn’t print the height itself, under the best practice that functions should do one and only one thing. We use a different function to do the printing.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #5</p><p>Find 3 issues (affecting 4 lines) in the following code.</p><pre class="language-cpp line-numbers"><code>#include <cstdint></cstdint></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>  std::cout &lt;&lt; "How old are you?\n";</code><code></code><code>  std::uint8_t age{};</code><code>  std::cin &gt;&gt; age;</code><code></code><code>  std::cout &lt;&lt; "Allowed to drive a car in Texas [";</code><code></code><code>  if (age &gt;= 16)</code><code>    std::cout &lt;&lt; "x";</code><code>  else</code><code>    std::cout &lt;&lt; " ";</code><code></code><code>  std::cout &lt;&lt; "]\n";</code><code></code><code>  return 0;</code><code>}</code></pre><p>Sample output</p><pre>How old are you?
6
Allowed to drive a car in Texas [ ]
</pre><pre>How old are you?
19
Allowed to drive a car in Texas [x]
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_11'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_11" style="display:none"><ol start="1"><li>There’s no reason to use <code>std::uint8_t</code> (Line 8). If we were to print <code>age</code>, it would be treated as a character by <code>std::cout</code>. A regular <code>int</code> should be used to store the age. Age doesn’t require a specific minimum integer width.</li><li>Characters should be placed in single quotation marks, not full quotation marks (Line 14, 16).</li></ol><p>These lines should use <code>'x'</code> and <code>' '</code>, not <code>"x"</code> and <code>" "</code>. Full quotation marks need more storage and cause slower functions to be called than if we used single quotation marks.</p><ol start="3"><li>Although the meaning of 16 is clear from the context it is used in, 16 can be seen as a magic number. As per best practice, a <code>constexpr</code> variable with the value 16 should be defined and used instead.</li></ol></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">5.1 — Operator precedence and associativity</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Chapter introduction</h3><p>This chapter builds on top of the concepts from lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-literals-and-operators/">1.9 -- Introduction to literals and operators</a>. A quick review follows:</p><p>In mathematics, an <span class="cpp-definition">operation</span> is a mathematical calculation involving zero or more input values (called <span class="cpp-definition">operands</span>) that produces a new value (called an output value). The specific operation to be performed is denoted by a construct (typically a symbol or pair of symbols) called an <span class="cpp-definition">operator</span>.</p><p>For example, as children we all learn that <em>2 + 3</em> equals <em>5</em>. In this case, the literals <em>2</em> and <em>3</em> are the operands, and the symbol <em>+</em> is the operator that tells us to apply mathematical addition on the operands to produce the new value <em>5</em>.</p><p>In this chapter, we’ll discuss topics related to operators, and explore many of the common operators that C++ supports.</p><br><h3>Operator precedence</h3><p>Now, let’s consider a more complicated expression, such as <em>4 + 2 * 3</em>. An expression that has multiple operators is called a <span class="cpp-definition">compound expression</span>. In order to evaluate this compound expression, we must understand both what the operators do, and the correct order to apply them. The order in which operators are evaluated in a compound expression is determined by an operator’s <span class="cpp-definition">precedence</span>. Using normal mathematical precedence rules (which state that multiplication is resolved before addition), we know that the above expression should evaluate as <em>4 + (2 * 3)</em> to produce the value 10.</p><p>In C++, when the compiler encounters an expression, it must similarly analyze the expression and determine how it should be evaluated. To assist with this, all operators are assigned a level of precedence. Operators with the highest level of precedence are evaluated first.</p><p>You can see in the table below that multiplication and division (precedence level 5) have more precedence than addition and subtraction (precedence level 6). Thus, <em>4 + 2 * 3</em> evaluates as <em>4 + (2 * 3)</em> because multiplication has a higher level of precedence than addition.</p><br><h3>Operator associativity</h3><p>What happens if two operators in the same expression have the same precedence level? For example, in the expression <em>3 * 4 / 2</em>, the multiplication and division operators are both precedence level 5. In this case, the compiler can’t rely upon precedence alone to determine how to evaluate the result.</p><p>If two operators with the same precedence level are adjacent to each other in an expression, the operator’s <span class="cpp-definition">associativity</span> tells the compiler whether to evaluate the operators from left to right or from right to left. The operators in precedence level 5 have an associativity of left to right, so the expression is resolved from left to right: <em>(3 * 4) / 2 = 6</em>.</p><br><h3>Table of operators</h3><p>The below table is primarily meant to be a reference chart that you can refer back to in the future to resolve any precedence or associativity questions you have.</p><p>Notes:</p><ul><li>Precedence level 1 is the highest precedence level, and level 17 is the lowest. Operators with a higher precedence level get evaluated first.</li><li>L-&gt;R means left to right associativity.</li><li>R-&gt;L means right to left associativity.</li></ul><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Prec/Ass</th><th>Operator</th><th>Description</th><th>Pattern</th></tr><tr><td>1 L-&gt;R</td><td>::<br>::</td><td>Global scope (unary)<br>Namespace scope (binary)</td><td>::name<br>class_name::member_name</td></tr><tr><td>2 L-&gt;R</td><td>()<br>()<br>()<br>{}<br>type()<br>type{}<br>[]<br>.<br>-&gt;<br>++<br>––<br>typeid<br>const_cast<br>dynamic_cast<br>reinterpret_cast<br>static_cast<br>sizeof…<br>noexcept<br>alignof</td><td>Parentheses<br>Function call<br>Initialization<br>Uniform initialization (C++11)<br>Functional cast<br>Functional cast (C++11)<br>Array subscript<br>Member access from object<br>Member access from object ptr<br>Post-increment<br>Post-decrement<br>Run-time type information<br>Cast away const<br>Run-time type-checked cast<br>Cast one type to another<br>Compile-time type-checked cast<br>Get parameter pack size<br>Compile-time exception check<br>Get type alignment</td><td>(expression)<br>function_name(parameters)<br>type name(expression)<br>type name{expression}<br>new_type(expression)<br>new_type{expression}<br>pointer[expression]<br>object.member_name<br>object_pointer-&gt;member_name<br>lvalue++<br>lvalue––<br>typeid(type) or typeid(expression)<br>const_cast&lt;type&gt;(expression)<br>dynamic_cast&lt;type&gt;(expression)<br>reinterpret_cast&lt;type&gt;(expression)<br>static_cast&lt;type&gt;(expression)<br>sizeof…(expression)<br>noexcept(expression)<br>alignof(Type)</td></tr><tr><td>3 R-&gt;L</td><td>+<br>-<br>++<br>––<br>!<br>~<br>(type)<br>sizeof<br>co_await<br>&amp;<br>*<br>new<br>new[]<br>delete<br>delete[]</td><td>Unary plus<br>Unary minus<br>Pre-increment<br>Pre-decrement<br>Logical NOT<br>Bitwise NOT<br>C-style cast<br>Size in bytes<br>Await asynchronous call<br>Address of<br>Dereference<br>Dynamic memory allocation<br>Dynamic array allocation<br>Dynamic memory deletion<br>Dynamic array deletion</td><td>+expression<br>-expression<br>++lvalue<br>––lvalue<br>!expression<br>~expression<br>(new_type)expression<br>sizeof(type) or sizeof(expression)<br>co_await expression<br>&amp;lvalue<br>*expression<br>new type<br>new type[expression]<br>delete pointer<br>delete[] pointer</td></tr><tr><td>4 L-&gt;R</td><td>-&gt;*<br>.*</td><td>Member pointer selector<br>Member object selector</td><td>object_pointer-&gt;*pointer_to_member<br>object.*pointer_to_member</td></tr><tr><td>5 L-&gt;R</td><td>*<br>/<br>%</td><td>Multiplication<br>Division<br>Modulus</td><td>expression * expression<br>expression / expression<br>expression % expression</td></tr><tr><td>6 L-&gt;R</td><td>+<br>-</td><td>Addition<br>Subtraction</td><td>expression + expression<br>expression - expression</td></tr><tr><td>7 L-&gt;R</td><td>&lt;&lt;<br>&gt;&gt;</td><td>Bitwise shift left<br>Bitwise shift right</td><td>expression &lt;&lt; expression<br>expression &gt;&gt; expression</td></tr><tr><td>8 L-&gt;R</td><td>&lt;=&gt;</td><td>Three-way comparison</td><td>expression &lt;=&gt; expression</td></tr><tr><td>9 L-&gt;R</td><td>&lt;<br>&lt;=<br>&gt;<br>&gt;=</td><td>Comparison less than<br>Comparison less than or equals<br>Comparison greater than<br>Comparison greater than or equals</td><td>expression &lt; expression<br>expression &lt;= expression<br>expression &gt; expression<br>expression &gt;= expression</td></tr><tr><td>10 L-&gt;R</td><td>==<br>!=</td><td>Equality<br>Inequality</td><td>expression == expression<br>expression != expression</td></tr><tr><td>11 L-&gt;R</td><td>&amp;</td><td>Bitwise AND</td><td>expression &amp; expression</td></tr><tr><td>12 L-&gt;R</td><td>^</td><td>Bitwise XOR</td><td>expression ^ expression</td></tr><tr><td>13 L-&gt;R</td><td>|</td><td>Bitwise OR</td><td>expression | expression</td></tr><tr><td>14 L-&gt;R</td><td>&amp;&amp;</td><td>Logical AND</td><td>expression &amp;&amp; expression</td></tr><tr><td>15 L-&gt;R</td><td>||</td><td>Logical OR</td><td>expression || expression</td></tr><tr><td>16 R-&gt;L</td><td>throw<br>co_yield<br>?:<br>=<br>*=<br>/=<br>%=<br>+=<br>-=<br>&lt;&lt;=<br>&gt;&gt;=<br>&amp;=<br>|=<br>^=</td><td>Throw expression<br>Yield expression<br>Conditional<br>Assignment<br>Multiplication assignment<br>Division assignment<br>Modulus assignment<br>Addition assignment<br>Subtraction assignment<br>Bitwise shift left assignment<br>Bitwise shift right assignment<br>Bitwise AND assignment<br>Bitwise OR assignment<br>Bitwise XOR assignment</td><td>throw expression<br>co_yield expression<br>expression ? expression : expression<br>lvalue = expression<br>lvalue *= expression<br>lvalue /= expression<br>lvalue %= expression<br>lvalue += expression<br>lvalue -= expression<br>lvalue &lt;&lt;= expression<br>lvalue &gt;&gt;= expression<br>lvalue &amp;= expression<br>lvalue |= expression<br>lvalue ^= expression</td></tr><tr><td>17 L-&gt;R</td><td>,</td><td>Comma operator</td><td>expression, expression</td></tr></tbody></table></div><p>You should already recognize a few of these operators, such as +, -, *, /, (), and sizeof. However, unless you have experience with another programming language, the majority of the operators in this table will probably be incomprehensible to you right now. That’s expected at this point. We’ll cover many of them in this chapter, and the rest will be introduced as there is a need for them.</p><div class="cpp-note cpp-lightbluebackground"><h4>Q: Where’s the exponent operator?</h4><p>C++ doesn’t include an operator to do exponentiation (operator^ has a different function in C++). We discuss exponentiation more in lesson <a href="https://www.learncpp.com/cpp-tutorial/5-3-modulus-and-exponentiation/">5.3 -- Modulus and Exponentiation</a>.</p></div><br><h3>Parenthesization</h3><p>In normal arithmetic, you learned that you can use parentheses to change the order of application of operations. For example, we know that <em>4 + 2 * 3</em> evaluates as <em>4 + (2 * 3)</em>, but if you want it to evaluate as <em>(4 + 2) * 3</em> instead, you can explicitly parenthesize the expression to make it evaluate the way you want. This works in C++ because parentheses have one of the highest precedence levels, so parentheses generally evaluate before whatever is inside them.</p><p>Now consider an expression like <em>x &amp;&amp; y || z</em>. Does this evaluate as <em>(x &amp;&amp; y) || z</em> or <em>x &amp;&amp; (y || z)</em>? You could look up in the table and see that &amp;&amp; takes precedence over ||. But there are so many operators and precedence levels that it’s hard to remember them all.</p><p>In order to reduce mistakes and make your code easier to understand without referencing a precedence table, it’s a good idea to parenthesize any non-trivial compound expression, so it’s clear what your intent is.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use parentheses to make it clear how a non-trivial expression should evaluate (even if they are technically unnecessary).</p></div><p>There is one notable exception to the above best practice: Expressions that have a single assignment operator do not need to have the right operand of the assignment wrapped in parenthesis.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>x = (y + z + w);   // instead of this</code><code>x = y + z + w;     // it's okay to do this</code><code></code><code>x = ((y || z) &amp;&amp; w); // instead of this</code><code>x = (y || z) &amp;&amp; w;   // it's okay to do this</code><code></code><code>x = (y *= z); // expressions with multiple assignments still benefit from parenthesis</code></pre><p>The assignment operators have the second lowest precedence (only the comma operator is lower, and it’s rarely used). Therefore, so long as there is only one assignment (and no commas), we know the right operand will fully evaluate before the assignment.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Expressions with a single assignment operator do not need to have the right operand of the assignment wrapped in parenthesis.</p></div><br><h3>The order of evaluation of expressions and function arguments is mostly unspecified</h3><p>Consider the following expression:</p><pre class="language-cpp line-numbers"><code>a + b * c</code></pre><p>We know from the precedence and associativity rules above that this expression will evaluate as if we had typed:</p><pre class="language-cpp line-numbers"><code>a + (b * c)</code></pre><p>If <em>a</em> is <em>1</em>, <em>b</em> is <em>2</em>, and <em>c</em> is 3, this expression will evaluate to the answer <em>7</em>.</p><p>However, the precedence and associativity rules only tell us how operators evaluate in relation to other operators. It does not tell us anything about the order in which the rest of the expression evaluates. For example, does variable <em>a</em>, <em>b</em>, or <em>c</em> get evaluated first?</p><p>Perhaps surprisingly, in many cases, the order of evaluation of any part of a compound expression (including function calls and argument evaluation) is unspecified. In such cases, the compiler is free to choose any evaluation order it believes is optimal.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>In many cases, the operands in a compound expression may evaluate in any order. This includes function calls and the arguments to those function calls.</p></div><p>For most expressions, this is irrelevant. In our sample expression above, it doesn’t matter whether in which order variables <em>a</em>, <em>b</em>, or <em>c</em> are evaluated for their values: the answer will always be <em>7</em>. There is no ambiguity here.</p><p>But it is possible to write expressions where the order of evaluation does matter. Consider this program, which contains a mistake often made by new C++ programmers:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getValue()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code></code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code>    return x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; getValue() + (getValue() * getValue()); // a + (b * c)</code><code>    return 0;</code><code>}</code></pre><p>If you run this program and enter inputs <em>1</em>, <em>2</em>, and <em>3</em>, you might assume that this program would calculate <code>1 + (2 * 3)</code> and print <em>7</em>. But that is making the assumption that the calls to getValue() will evaluate in left-to-right order. The compiler may choose a different order. For example, if the compiler chose a right-to-left order instead, the program would calculate <code>3 + (2 * 1)</code>, which would print <em>5</em> for the same set of inputs.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Outside of the operator precedence and associativity rules, assume that the parts of an expression could evaluate in any order. Ensure that the expressions you write are not dependent on the order of evaluation of those parts.</p></div><p>The above program can be made unambiguous by making each function call a separate statement:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getValue()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code></code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code>    return x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int a{ getValue() }; // will execute first</code><code>    int b{ getValue() }; // will execute second</code><code>    int c{ getValue() }; // will execute third</code><code>    </code><code>    std::cout &lt;&lt; a + (b * c); // order of eval doesn't matter now</code><code></code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>There are some additional examples of cases where order of evaluation problems can occur in lesson <a href="https://www.learncpp.com/cpp-tutorial/increment-decrement-operators-and-side-effects/">5.4 -- Increment/decrement operators, and side effects</a>.</p></div><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>You know from everyday mathematics that expressions inside of parentheses get evaluated first. For example, in the expression <code>(2 + 3) * 4</code>, the <code>(2 + 3)</code> part is evaluated first.</p><p>For this exercise, you are given a set of expressions that have no parentheses. Using the operator precedence and associativity rules in the table above, add parentheses to each expression to make it clear how the compiler will evaluate the expression.</p><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">Hint: Use the pattern column in the table above to determine whether the operator is unary (has one operand) or binary (has two operands). Review the lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-literals-and-operators/">1.9 -- Introduction to literals and operators</a> if you need a refresher on what unary and binary operators are.</div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td>Sample problem: x = 2 + 3 % 4<p>Binary operator <code>%</code> has higher precedence than operator <code>+</code> or operator <code>=</code>, so it gets evaluated first:</p><p>x = 2 + (3 % 4)</p><p>Binary operator <code>+</code> has a higher precedence than operator <code>=</code>, so it gets evaluated next:</p><p>Final answer: x = (2 + (3 % 4))</p><p>We now no longer need the table above to understand how this expression will evaluate.</p></td></tr></tbody></table></div><p>a) x = 3 + 4 + 5;</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>Binary operator <code>+</code> has higher precedence than <code>=</code>:</p><p>x = (3 + 4 + 5);</p><p>Binary operator <code>+</code> has left to right association:</p><p>Final answer: x = ((3 + 4) + 5);</p></div><p>b) x = y = z;</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>Binary operator <code>=</code> has right to left association:</p><p>Final answer: x = (y = z);</p></div><p>c) z *= ++y + 5;</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>Unary operator <code>++</code> has the highest precedence:</p><p>z *= (++y) + 5;</p><p>Binary operator <code>+</code> has the next highest precedence:</p><p>Final answer: z *= ((++y) + 5);</p></div><p>d) a || b &amp;&amp; c || d;</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><p>Binary operator <code>&amp;&amp;</code> has higher precedence than <code>||</code>:</p><p>a || (b &amp;&amp; c) || d;</p><p>Binary operator <code>||</code> has left to right association:</p><p>Final answer: (a || (b &amp;&amp; c)) || d;</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">5.2 — Arithmetic operators</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Unary arithmetic operators</h3><p>There are two unary arithmetic operators, plus (+), and minus (-). As a reminder, unary operators are operators that only take one operand.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Operator</th><th>Symbol</th><th>Form</th><th>Operation</th></tr><tr><td>Unary plus</td><td>+</td><td>+x</td><td>Value of x</td></tr><tr><td>Unary minus</td><td>-</td><td>-x</td><td>Negation of x</td></tr></tbody></table></div><p>The <span class="cpp-definition">unary minus</span> operator returns the operand multiplied by -1. In other words, if x = 5, -x is -5.</p><p>The <span class="cpp-definition">unary plus</span> operator returns the value of the operand. In other words, +5 is 5, and +x is x. Generally you won’t need to use this operator since it’s redundant. It was added largely to provide symmetry with the <em>unary minus</em> operator.</p><p>For readability, both of these operators should be placed immediately preceding the operand (e.g. <code>-x</code>, not <code>- x</code>).</p><p>Do not confuse the <em>unary minus</em> operator with the <em>binary subtraction</em> operator, which uses the same symbol. For example, in the expression <code>x = 5 - -3;</code>, the first minus is the <em>binary subtraction</em> operator, and the second is the <em>unary minus</em> operator.</p><br><h3>Binary arithmetic operators</h3><p>There are 5 binary arithmetic operators. Binary operators are operators that take a left and right operand.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Operator</th><th>Symbol</th><th>Form</th><th>Operation</th></tr><tr><td>Addition</td><td>+</td><td>x + y</td><td>x plus y</td></tr><tr><td>Subtraction</td><td>-</td><td>x - y</td><td>x minus y</td></tr><tr><td>Multiplication</td><td>*</td><td>x * y</td><td>x multiplied by y</td></tr><tr><td>Division</td><td>/</td><td>x / y</td><td>x divided by y</td></tr><tr><td>Modulus (Remainder)</td><td>%</td><td>x % y</td><td>The remainder of x divided by y</td></tr></tbody></table></div><p>The addition, subtraction, and multiplication operators work just like they do in real life, with no caveats.</p><p>Division and modulus (remainder) need some additional explanation. We’ll talk about division below, and modulus in the next lesson.</p><br><h3>Integer and floating point division</h3><p>It is easiest to think of the division operator as having two different “modes”.</p><p>If either (or both) of the operands are floating point values, the <em>division operator</em> performs floating point division. <span class="cpp-definition">Floating point division</span> returns a floating point value, and the fraction is kept. For example, <code>7.0 / 4 = 1.75</code>, <code>7 / 4.0 = 1.75</code>, and <code>7.0 / 4.0 = 1.75</code>. As with all floating point arithmetic operations, rounding errors may occur.</p><p>If both of the operands are integers, the <em>division operator</em> performs integer division instead. <span class="cpp-definition">Integer division</span> drops any fractions and returns an integer value. For example, <code>7 / 4 = 1</code> because the fractional portion of the result is dropped. Similarly, <code>-7 / 4 = -1</code> because the fraction is dropped.</p><br><h3>Using static_cast to do floating point division with integers</h3><p>The above raises the question -- if we have two integers, and want to divide them without losing the fraction, how would we do so?</p><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-type-conversion-and-static_cast/">4.12 -- Introduction to type conversion and static_cast</a>, we showed how we could use the <em>static_cast&lt;&gt;</em> operator to convert a char into an integer so it would print as an integer rather than a character.</p><p>We can similarly use <em>static_cast&lt;&gt;</em> to convert an integer to a floating point number so that we can do <em>floating point division</em> instead of <em>integer division</em>. Consider the following code:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 7 };</code><code>    int y{ 4 };</code><code></code><code>    std::cout &lt;&lt; "int / int = " &lt;&lt; x / y &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "double / int = " &lt;&lt; static_cast<double>(x) / y &lt;&lt; '\n';</double></code><code>    std::cout &lt;&lt; "int / double = " &lt;&lt; x / static_cast<double>(y) &lt;&lt; '\n';</double></code><code>    std::cout &lt;&lt; "double / double = " &lt;&lt; static_cast<double>(x) / static_cast<double>(y) &lt;&lt; '\n';</double></double></code><code></code><code>    return 0;</code><code>}</code></pre><p>This produces the result:</p><pre>int / int = 1
double / int = 1.75
int / double = 1.75
double / double = 1.75
</pre><p>The above illustrates that if either operand is a floating point number, the result will be floating point division, not integer division.</p><br><h3>Dividing by zero</h3><p>Trying to divide by 0 (or 0.0) will generally cause your program to crash, as the results are mathematically undefined!</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Enter a divisor: ";</code><code>	int x{};</code><code>	std::cin &gt;&gt; x;</code><code></code><code>	std::cout &lt;&lt; "12 / " &lt;&lt; x &lt;&lt; " = " &lt;&lt; 12 / x &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>If you run the above program and enter 0, your program will either crash or terminate abnormally. Go ahead and try it, it won’t harm your computer.</p><br><h3>Arithmetic assignment operators</h3><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Operator</th><th>Symbol</th><th>Form</th><th>Operation</th></tr><tr><td>Assignment</td><td>=</td><td>x = y</td><td>Assign value y to x</td></tr><tr><td>Addition assignment</td><td>+=</td><td>x += y</td><td>Add y to x</td></tr><tr><td>Subtraction assignment</td><td>-=</td><td>x -= y</td><td>Subtract y from x</td></tr><tr><td>Multiplication assignment</td><td>*=</td><td>x *= y</td><td>Multiply x by y</td></tr><tr><td>Division assignment</td><td>/=</td><td>x /= y</td><td>Divide x by y</td></tr><tr><td>Modulus assignment</td><td>%=</td><td>x %= y</td><td>Put the remainder of x / y in x</td></tr></tbody></table></div><p>Up to this point, when you’ve needed to add 4 to a variable, you’ve likely done the following:</p><pre class="language-cpp line-numbers"><code>x = x + 4; // add 4 to existing value of x</code></pre><p>This works, but it’s a little clunky, and takes two operators to execute (operator+, and operator=).</p><p>Because writing statements such as <code>x = x + 4</code> is so common, C++ provides five arithmetic assignment operators for convenience. Instead of writing <code>x = x + 4</code>, you can write <code>x += 4</code>. Instead of <code>x = x * y</code>, you can write <code>x *= y</code>.</p><p>Thus, the above becomes:</p><pre class="language-cpp line-numbers"><code>x += 4; // add 4 to existing value of x</code></pre></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">5.3 — Modulus and Exponentiation</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>The modulus operator</h3><p>The <span class="cpp-definition">modulus operator</span> (also informally known as the <em>remainder operator</em>) is an operator that returns the remainder after doing an integer division. For example, 7 / 4 = 1 remainder 3. Therefore, 7 % 4 = 3. As another example, 25 / 7 = 3 remainder 4, thus 25 % 7 = 4. Modulus only works with integer operands.</p><p>Modulus is most useful for testing whether a number is evenly divisible by another number (meaning that after division, there is no remainder): if <em>x % y</em> evaluates to 0, then we know that <em>x</em> is evenly divisible by <em>y</em>.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Enter an integer: ";</code><code>	int x{};</code><code>	std::cin &gt;&gt; x;</code><code></code><code>	std::cout &lt;&lt; "Enter another integer: ";</code><code>	int y{};</code><code>	std::cin &gt;&gt; y;</code><code></code><code>	std::cout &lt;&lt; "The remainder is: " &lt;&lt; x % y &lt;&lt; '\n';</code><code></code><code>	if ((x % y) == 0)</code><code>		std::cout &lt;&lt; x &lt;&lt; " is evenly divisible by " &lt;&lt; y &lt;&lt; '\n';</code><code>	else</code><code>		std::cout &lt;&lt; x &lt;&lt; " is not evenly divisible by " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>Here are a couple runs of this program:</p><pre>Enter an integer: 6
Enter another integer: 3
The remainder is: 0
6 is evenly divisible by 3
</pre><pre>Enter an integer: 6
Enter another integer: 4
The remainder is: 2
6 is not evenly divisible by 4
</pre><p>Now let’s try an example where the second number is bigger than the first:</p><pre>Enter an integer: 2
Enter another integer: 4
The remainder is: 2
2 is not evenly divisible by 4
</pre><p>A remainder of 2 might be a little non-obvious at first, but it’s simple: 2 / 4 is 0 (using integer division) remainder 2. Whenever the second number is larger than the first, the second number will divide the first 0 times, so the first number will be the remainder.</p><br><h3>Modulus with negative numbers</h3><p>The modulus operator can also work with negative operands. <code>x % y</code> always returns results with the sign of <em>x</em>.</p><p>Running the above program:</p><pre>Enter an integer: -6
Enter another integer: 4
The remainder is: -2
-6 is not evenly divisible by 4
</pre><pre>Enter an integer: 6
Enter another integer: -4
The remainder is: 2
6 is not evenly divisible by -4
</pre><p>In both cases, you can see the remainder takes the sign of the first operand.</p><br><h3>Where’s the exponent operator?</h3><p>You’ll note that the <em>^</em> operator (commonly used to denote exponentiation in mathematics) is a <em>Bitwise XOR</em> operation in C++ (covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/bit-manipulation-with-bitwise-operators-and-bit-masks/">O.3 -- Bit manipulation with bitwise operators and bit masks</a>). C++ does not include an exponent operator.</p><p>To do exponents in C++, #include the &lt;cmath&gt; header, and use the pow() function:</p><pre class="language-cpp line-numbers"><code>#include <cmath></cmath></code><code></code><code>double x{ std::pow(3.0, 4.0) }; // 3 to the 4th power</code></pre><p>Note that the parameters (and return value) of function pow() are of type double. Due to rounding errors in floating point numbers, the results of pow() may not be precise (even if you pass it integers or whole numbers).</p><p>If you want to do integer exponentiation, you’re best off using your own function to do so. The following function implements integer exponentiation (using the non-intuitive “exponentiation by squaring” algorithm for efficiency):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cstdint> // for std::int64_t</cstdint></code><code>#include <cassert> // for assert</cassert></code><code></code><code>// note: exp must be non-negative</code><code>std::int64_t powint(std::int64_t base, int exp)</code><code>{</code><code>	assert(exp &gt;= 0 &amp;&amp; "powint: exp parameter has negative value");</code><code></code><code>	std::int64_t result{ 1 };</code><code>	while (exp)</code><code>	{</code><code>		if (exp &amp; 1)</code><code>			result *= base;</code><code>		exp &gt;&gt;= 1;</code><code>		base *= base;</code><code>	}</code><code></code><code>	return result;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; powint(7, 12); // 7 to the 12th power</code><code></code><code>	return 0;</code><code>}</code></pre><p>Produces:</p><pre>13841287201
</pre><p>Don’t worry if you don’t understand how this function works -- you don’t need to understand it in order to call it.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We cover asserts in lesson <a href="https://www.learncpp.com/cpp-tutorial/assert-and-static_assert/">7.17 -- Assert and static_assert</a>.</p></div><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>In the vast majority of cases, integer exponentiation will overflow the integral type. This is likely why such a function wasn’t included in the standard library in the first place.</p></div><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>What does the following expression evaluate to? <code>6 + 5 * 4 % 3</code></p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none">Because * and % have higher precedence than +, the + will evaluate last. We can rewrite our expression as 6 + (5 * 4 % 3). Operators * and % have the same precedence, so we have to look at the associativity to resolve them. The associativity for operators * and % is left to right, so we resolve the left operator first. We can rewrite our expression like this: 6 + ((5 * 4) % 3).<p>6 + ((5 * 4) % 3) = 6 + (20 % 3) = 6 + 2 = 8</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>Write a program that asks the user to input an integer, and tells the user whether the number is even or odd. Write a function called isEven() that returns true if an integer passed to it is even, and false otherwise. Use the modulus operator to test whether the integer parameter is even.</p><p>Hint: You’ll need to use if statements and the comparison operator (==) for this program. See lesson <a href="https://www.learncpp.com/cpp-tutorial/boolean-values/">4.9 -- Boolean values</a> if you need a refresher on how to do this.</p><p>Your program should match the following output:</p><pre>Enter an integer: 5
5 is odd
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>bool isEven(int x)</code><code>{</code><code>    // if x % 2 == 0, 2 divides evenly into our number, which means it must be an even number</code><code>    return (x % 2) == 0;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    if (isEven(x))</code><code>        std::cout &lt;&lt; x &lt;&lt; " is even\n";</code><code>    else</code><code>        std::cout &lt;&lt; x &lt;&lt; " is odd\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note: You may have been tempted to write function isEven() like this:</p><pre class="language-cpp line-numbers"><code>bool isEven(int x)</code><code>{</code><code>    if ((x % 2) == 0)</code><code>        return true;</code><code>    else</code><code>        return false;</code><code>}</code></pre><p>While this works, it’s more complicated than it needs to be. Let’s take a look at how we can simplify it. First, let’s pull out the if statement conditional and assign it to a separate boolean:</p><pre class="language-cpp line-numbers"><code>bool isEven(int x)</code><code>{</code><code>    bool isEven = (x % 2) == 0;</code><code>    if (isEven) // isEven is true</code><code>        return true;</code><code>    else // isEven is false</code><code>        return false;</code><code>}</code></pre><p>Now, note that the if statement above essentially says “if isEven is true, return true, otherwise if isEven is false, return false”. If that’s the case, we can just return isEven:</p><pre class="language-cpp line-numbers"><code>bool isEven(int x)</code><code>{</code><code>    bool isEven = (x % 2) == 0;</code><code>    return isEven;</code><code>}</code></pre><p>And in this case, since we only use variable isEven once, we might as well eliminate the variable:</p><pre class="language-cpp line-numbers"><code>bool isEven(int x)</code><code>{</code><code>    return (x % 2) == 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">5.4 — Increment/decrement operators, and side effects</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Incrementing and decrementing variables</h3><p>Incrementing (adding 1 to) and decrementing (subtracting 1 from) a variable are both so common that they have their own operators.</p><p style="clear:both"></p><p></p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Operator</th><th>Symbol</th><th>Form</th><th>Operation</th></tr><tr><td>Prefix increment (pre-increment)</td><td>++</td><td>++x</td><td>Increment x, then return x</td></tr><tr><td>Prefix decrement (pre-decrement)</td><td>––</td><td>––x</td><td>Decrement x, then return x</td></tr><tr><td>Postfix increment (post-increment)</td><td>++</td><td>x++</td><td>Copy x, then increment x, then return the copy</td></tr><tr><td>Postfix decrement (post-decrement)</td><td>––</td><td>x––</td><td>Copy x, then decrement x, then return the copy</td></tr></tbody></table></div><p>Note that there are two versions of each operator -- a prefix version (where the operator comes before the operand) and a postfix version (where the operator comes after the operand).</p><p>The prefix increment/decrement operators are very straightforward. First, the operand is incremented or decremented, and then expression evaluates to the value of the operand. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x { 5 };</code><code>    int y = ++x; // x is incremented to 6, x is evaluated to the value 6, and 6 is assigned to y</code><code></code><code>    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>6 6
</pre><p>The postfix increment/decrement operators are trickier. First, a copy of the operand is made. Then the operand (not the copy) is incremented or decremented. Finally, the copy (not the original) is evaluated. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x { 5 };</code><code>    int y = x++; // x is incremented to 6, copy of original x is evaluated to the value 5, and 5 is assigned to y</code><code></code><code>    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>6 5
</pre><p>Let’s examine how this line 6 works in more detail. First, a temporary copy of <em>x</em> is made that starts with the same value as <em>x</em> (5). Then the actual <em>x</em> is incremented from <em>5</em> to <em>6</em>. Then the copy of <em>x</em> (which still has value <em>5</em>) is returned and assigned to <em>y</em>. Then the temporary copy is discarded.</p><p>Consequently, <em>y</em> ends up with the value of <em>5</em> (the pre-incremented value), and <em>x</em> ends up with the value <em>6</em> (the post-incremented value).</p><p>Note that the postfix version takes a lot more steps, and thus may not be as performant as the prefix version.</p><p>Here is another example showing the difference between the prefix and postfix versions:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    int y{ 5 };</code><code>    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; ++x &lt;&lt; ' ' &lt;&lt; --y &lt;&lt; '\n'; // prefix</code><code>    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; x++ &lt;&lt; ' ' &lt;&lt; y-- &lt;&lt; '\n'; // postfix</code><code>    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This produces the output:</p><pre>5 5
6 4
6 4
6 4
7 3
</pre><p>On the 8th line, we do a prefix increment and decrement. On this line, <em>x</em> and <em>y</em> are incremented/decremented <em>before</em> their values are sent to std::cout, so we see their updated values reflected by std::cout.</p><p>On the 10th line, we do a postfix increment and decrement. On this line, the copy of <em>x</em> and <em>y</em> (with the pre-incremented and pre-decremented values) are what is sent to std::cout, so we don’t see the increment and decrement reflected here. Those changes don’t show up until the next line, when <em>x</em> and <em>y</em> are evaluated again.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Strongly favor the prefix version of the increment and decrement operators, as they are generally more performant, and you’re less likely to run into strange issues with them.</p></div><br><h3>Side effects</h3><p>A function or expression is said to have a <span class="cpp-definition">side effect</span> if it does anything that persists beyond the life of the function or expression itself.</p><p>Common examples of side effects include changing the value of objects, doing input or output, or updating a graphical user interface (e.g. enabling or disabling a button).</p><p>Most of the time, side effects are useful:</p><pre class="language-cpp line-numbers"><code>x = 5; // the assignment operator modifies the state of x</code><code>++x; // operator++ modifies the state of x</code><code>std::cout &lt;&lt; x; // operator&lt;&lt; modifies the state of the console</code></pre><p>The assignment operator in the above example has the side effect of changing the value of <em>x</em> permanently. Even after the statement has finished executing, <em>x</em> will still have the value 5. Similarly with operator++, the value of <em>x</em> is altered even after the statement has finished evaluating. The outputting of <em>x</em> also has the side effect of modifying the state of the console, as you can now see the value of <em>x</em> printed to the console.</p><p>However, side effects can also lead to unexpected results:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    int value{ add(x, ++x) }; // is this 5 + 6, or 6 + 6?</code><code>    // It depends on what order your compiler evaluates the function arguments in</code><code></code><code>    std::cout &lt;&lt; value &lt;&lt; '\n'; // value could be 11 or 12, depending on how the above line evaluates!</code><code>    return 0;</code><code>}</code></pre><p>The C++ standard does not define the order in which function arguments are evaluated. If the left argument is evaluated first, this becomes a call to add(5, 6), which equals 11. If the right argument is evaluated first, this becomes a call to add(6, 6), which equals 12! Note that this is only a problem because one of the arguments to function add() has a side effect.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>The C++ standard intentionally does not define these things so that compilers can do whatever is most natural (and thus most performant) for a given architecture.</p></div><p>There are other cases where the C++ standard does not specify the order in which certain things are evaluated (such as operator operands), so different compilers may exhibit different behaviors. Even when the C++ standard does make it clear how things should be evaluated, historically this has been an area where there have been many compiler bugs. These problems can generally <em>all</em> be avoided by ensuring that any variable that has a side-effect applied is used no more than once in a given statement.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>C++ does not define the order of evaluation for function arguments or operator operands.</p></div><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Don’t use a variable that has a side effect applied to it more than once in a given statement. If you do, the result may be undefined.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">5.5 — Comma and conditional operators</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>The comma operator</h3><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Operator</th><th>Symbol</th><th>Form</th><th>Operation</th></tr><tr><td>Comma</td><td>,</td><td>x, y</td><td>Evaluate x then y, returns value of y</td></tr></tbody></table></div><p>The <span class="cpp-definition">comma operator (,)</span> allows you to evaluate multiple expressions wherever a single expression is allowed. The comma operator evaluates the left operand, then the right operand, and then returns the result of the right operand.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 1 };</code><code>    int y{ 2 };</code><code></code><code>    std::cout &lt;&lt; (++x, ++y) &lt;&lt; '\n'; // increment x and y, evaluates to the right operand</code><code></code><code>    return 0;</code><code>}</code></pre><p>First the left operand of the comma operator is evaluated, which increments <em>x</em> from <em>1</em> to <em>2</em>. Next, the right operand is evaluated, which increments <em>y</em> from <em>2</em> to <em>3</em>. The comma operator returns the result of the right operand (<em>3</em>), which is subsequently printed to the console.</p><p>Note that comma has the lowest precedence of all the operators, even lower than assignment. Because of this, the following two lines of code do different things:</p><pre class="language-cpp line-numbers"><code>z = (a, b); // evaluate (a, b) first to get result of b, then assign that value to variable z.</code><code>z = a, b; // evaluates as "(z = a), b", so z gets assigned the value of a, and b is evaluated and discarded.</code></pre><p>This makes the comma operator somewhat dangerous to use.</p><p>In almost every case, a statement written using the comma operator would be better written as separate statements. For example, the above code could be written as:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 1 };</code><code>    int y{ 2 };</code><code></code><code>    ++x;</code><code>    std::cout &lt;&lt; ++y &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Most programmers do not use the comma operator at all, with the single exception of inside <em>for loops</em>, where its use is fairly common. We discuss for loops in future lesson <a href="https://www.learncpp.com/cpp-tutorial/for-statements/">7.9 -- For statements</a>.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Avoid using the comma operator, except within <em>for loops</em>.</p></div><br><h3>Comma as a separator</h3><p>In C++, the comma symbol is often used as a separator, and these uses do not invoke the comma operator. Some examples of separator commas:</p><pre class="language-cpp line-numbers"><code>void foo(int x, int y) // Comma used to separate parameters in function definition</code><code>{</code><code>    add(x, y); // Comma used to separate arguments in function call</code><code>    constexpr int z{ 3 }, w{ 5 }; // Comma used to separate multiple variables being defined on the same line (don't do this)</code><code>}</code></pre><p>There is no need to avoid separator commas (except when declaring multiple variables, which you should not do).</p><br><h3>The conditional operator</h3><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Operator</th><th>Symbol</th><th>Form</th><th>Operation</th></tr><tr><td>Conditional</td><td>?:</td><td>c ? x : y</td><td>If c is nonzero (true) then evaluate x, otherwise evaluate y</td></tr></tbody></table></div><p>The <span class="cpp-definition">conditional operator (?:)</span> (also sometimes called the “arithmetic if” operator) is a ternary operator (it takes 3 operands). Because it has historically been C++’s only ternary operator, it’s also sometimes referred to as “the ternary operator”.</p><p>The ?: operator provides a shorthand method for doing a particular type of if/else statement. Please review lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-if-statements/">4.10 -- Introduction to if statements</a> if you need a brush up on if/else before proceeding.</p><p>An if/else statement takes the following form:</p><pre>if (condition)
    statement1;
else
    statement2;
</pre><p>If <em>condition</em> evaluates to <em>true</em>, then <em>statement1</em> is executed, otherwise <em>statement2</em> is executed.</p><p>The ?: operator takes the following form:</p><pre>(condition) ? expression1 : expression2;
</pre><p>If <em>condition</em> evaluates to <em>true</em>, then <em>expression1</em> is executed, otherwise <em>expression2</em> is executed. Note that <em>expression2</em> is not optional.</p><p>Consider an if/else statement that looks like this:</p><pre class="language-cpp line-numbers"><code>if (x &gt; y)</code><code>    larger = x;</code><code>else</code><code>    larger = y;</code></pre><p>can be rewritten as:</p><pre class="language-cpp line-numbers"><code>larger = (x &gt; y) ? x : y;</code></pre><p>In such uses, the conditional operator can help compact code without losing readability.</p><br><h3>Parenthesization of the conditional operator</h3><p>It is common convention to put the conditional part of the operation inside of parentheses, both to make it easier to read, and also to make sure the precedence is correct. The other operands evaluate as if they were parenthesized, so explicit parenthesization is not required for those.</p><p>Note that the ?: operator has a very low precedence. If doing anything other than assigning the result to a variable, the whole ?: operator also needs to be wrapped in parentheses.</p><p>For example, to print the larger of values x and y to the screen, we could do this:</p><pre class="language-cpp line-numbers"><code>if (x &gt; y)</code><code>    std::cout &lt;&lt; x &lt;&lt; '\n';</code><code>else</code><code>    std::cout &lt;&lt; y &lt;&lt; '\n';</code></pre><p>Or we could use the conditional operator to do this:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; ((x &gt; y) ? x : y) &lt;&lt; '\n';</code></pre><p>Let’s examine what happens if we don’t parenthesize the whole conditional operator in the above case.</p><p>Because the &lt;&lt; operator has higher precedence than the ?: operator, the statement:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; (x &gt; y) ? x : y &lt;&lt; '\n';</code></pre><p>would evaluate as:</p><pre class="language-cpp line-numbers"><code>(std::cout &lt;&lt; (x &gt; y)) ? x : y &lt;&lt; '\n';</code></pre><p>That would print 1 (true) if x &gt; y, or 0 (false) otherwise!</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Always parenthesize the conditional part of the conditional operator, and consider parenthesizing the whole thing as well.</p></div><br><h3>The conditional operator evaluates as an expression</h3><p>Because the conditional operator operands are expressions rather than statements, the conditional operator can be used in some places where if/else can not.</p><p>For example, when initializing a constant variable:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    constexpr bool inBigClassroom { false };</code><code>    constexpr int classSize { inBigClassroom ? 30 : 20 };</code><code>    std::cout &lt;&lt; "The class size is: " &lt;&lt; classSize &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>There’s no satisfactory if/else statement for this. You might think to try something like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    constexpr bool inBigClassroom { false };</code><code></code><code>    if (inBigClassroom)</code><code>        constexpr int classSize { 30 };</code><code>    else</code><code>        constexpr int classSize { 20 };</code><code></code><code>    std::cout &lt;&lt; "The class size is: " &lt;&lt; classSize &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>However, this won’t compile, and you’ll get an error message that classSize isn’t defined. Much like how variables defined inside functions die at the end of the function, variables defined inside an if or else statement die at the end of the if or else statement. Thus, classSize has already been destroyed by the time we try to print it.</p><p>If you want to use an if/else, you’d have to do something like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getClassSize(bool inBigClassroom)</code><code>{</code><code>    if (inBigClassroom)</code><code>        return 30;</code><code></code><code>    return 20;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    const int classSize { getClassSize(false) };</code><code>    std::cout &lt;&lt; "The class size is: " &lt;&lt; classSize &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This one works because we’re not defining variables inside the <em>if</em> or <em>else</em>, we’re just returning a value back to the caller, which can then be used as the initializer.</p><p>That’s a lot of extra work!</p><br><h3>The type of the expressions must match or be convertible</h3><p>To properly comply with C++’s type checking, either the type of both expressions in a conditional statement must match, or the both expressions must be convertible to a common type.</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>The conversion rules used when the types don’t match are rather complicated. You can find them <a href="https://en.cppreference.com/w/cpp/language/operator_other">here</a>.</p></div><p>So while you might expect to be able to do something like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	constexpr int x{ 5 };</code><code>	std::cout &lt;&lt; (x != 5 ? x : "x is 5"); // won't compile</code><code></code><code>	return 0;</code><code>}</code></pre><p>The above example won’t compile. One of the expressions is an integer, and the other is a C-style string literal. The compiler is unable to determine a common type for expressions of these types. In such cases, you’ll have to use an if/else.</p><br><h3>So when should you use the conditional operator?</h3><p>The conditional operator gives us a convenient way to compact some if/else statements. It’s most useful when we need a conditional initializer (or assignment) for a variable, or to pass a conditional value to a function.</p><p>It should not be used for complex if/else statements, as it quickly becomes both unreadable and error prone.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Only use the conditional operator for simple conditionals where you use the result and where it enhances readability.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">5.6 — Relational operators and floating point comparisons</h1></header><div class="entry-content" itemprop="articleBody"><p><span class="cpp-definition">Relational operators</span> are operators that let you compare two values. There are 6 relational operators:</p><p style="clear:both"></p><p></p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Operator</th><th>Symbol</th><th>Form</th><th>Operation</th></tr><tr><td>Greater than</td><td>&gt;</td><td>x &gt; y</td><td>true if x is greater than y, false otherwise</td></tr><tr><td>Less than</td><td>&lt;</td><td>x &lt; y</td><td>true if x is less than y, false otherwise</td></tr><tr><td>Greater than or equals</td><td>&gt;=</td><td>x &gt;= y</td><td>true if x is greater than or equal to y, false otherwise</td></tr><tr><td>Less than or equals</td><td>&lt;=</td><td>x &lt;= y</td><td>true if x is less than or equal to y, false otherwise</td></tr><tr><td>Equality</td><td>==</td><td>x == y</td><td>true if x equals y, false otherwise</td></tr><tr><td>Inequality</td><td>!=</td><td>x != y</td><td>true if x does not equal y, false otherwise</td></tr></tbody></table></div><p>You have already seen how most of these work, and they are pretty intuitive. Each of these operators evaluates to the boolean value true (1), or false (0).</p><p>Here’s some sample code using these operators with integers:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    std::cout &lt;&lt; "Enter another integer: ";</code><code>    int y{};</code><code>    std::cin &gt;&gt; y;</code><code></code><code>    if (x == y)</code><code>        std::cout &lt;&lt; x &lt;&lt; " equals " &lt;&lt; y &lt;&lt; '\n';</code><code>    if (x != y)</code><code>        std::cout &lt;&lt; x &lt;&lt; " does not equal " &lt;&lt; y &lt;&lt; '\n';</code><code>    if (x &gt; y)</code><code>        std::cout &lt;&lt; x &lt;&lt; " is greater than " &lt;&lt; y &lt;&lt; '\n';</code><code>    if (x &lt; y)</code><code>        std::cout &lt;&lt; x &lt;&lt; " is less than " &lt;&lt; y &lt;&lt; '\n';</code><code>    if (x &gt;= y)</code><code>        std::cout &lt;&lt; x &lt;&lt; " is greater than or equal to " &lt;&lt; y &lt;&lt; '\n';</code><code>    if (x &lt;= y)</code><code>        std::cout &lt;&lt; x &lt;&lt; " is less than or equal to " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>And the results from a sample run:</p><pre>Enter an integer: 4
Enter another integer: 5
4 does not equal 5
4 is less than 5
4 is less than or equal to 5
</pre><p>These operators are extremely straightforward to use when comparing integers.</p><br><h3>Boolean conditional values</h3><p>By default, conditions in an <em>if statement</em> or <em>conditional operator</em> (and a few other places) evaluate as Boolean values.</p><p>Many new programmers will write statements like this one:</p><pre class="language-cpp line-numbers"><code>if (b1 == true) ...</code></pre><p>This is redundant, as the <code>== true</code> doesn’t actually add any value to the condition. Instead, we should write:</p><pre class="language-cpp line-numbers"><code>if (b1) ...</code></pre><p>Similarly, the following:</p><pre class="language-cpp line-numbers"><code>if (b1 == false) ...</code></pre><p>is better written as:</p><pre class="language-cpp line-numbers"><code>if (!b1) ...</code></pre><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Don’t add unnecessary == or != to conditions. It makes them harder to read without offering any additional value.</p></div><br><h3>Comparison of calculated floating point values can be problematic</h3><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    double d1{ 100.0 - 99.99 }; // should equal 0.01 mathematically</code><code>    double d2{ 10.0 - 9.99 }; // should equal 0.01 mathematically</code><code></code><code>    if (d1 == d2)</code><code>        std::cout &lt;&lt; "d1 == d2" &lt;&lt; '\n';</code><code>    else if (d1 &gt; d2)</code><code>        std::cout &lt;&lt; "d1 &gt; d2" &lt;&lt; '\n';</code><code>    else if (d1 &lt; d2)</code><code>        std::cout &lt;&lt; "d1 &lt; d2" &lt;&lt; '\n';</code><code>    </code><code>    return 0;</code><code>}</code></pre><p>Variables d1 and d2 should both have value <em>0.01</em>. But this program prints an unexpected result:</p><pre>d1 &gt; d2
</pre><p>If you inspect the value of d1 and d2 in a debugger, you’d likely see that d1 = 0.0100000000000005116 and d2 = 0.0099999999999997868. Both numbers are close to 0.01, but d1 is greater than, and d2 is less than.</p><p>If a high level of precision is required, comparing floating point values using any of the relational operators can be dangerous. This is because floating point values are not precise, and small rounding errors in the floating point operands may cause unexpected results. We discussed rounding errors in lesson <a href="https://www.learncpp.com/cpp-tutorial/floating-point-numbers/">4.8 -- Floating point numbers</a> if you need a refresher.</p><p>When the less than and greater than operators (&lt;, &lt;=, &gt;, and &gt;=) are used with floating point values, they will usually produce the correct answer (only potentially failing when the operands are almost identical). Because of this, use of these operators with floating point operands can be acceptable, so long as the consequence of getting a wrong answer when the operands are similar is slight.</p><p>For example, consider a game (such as Space Invaders) where you want to determine whether two moving objects (such as a missile and an alien) intersect. If the objects are still far apart, these operators will return the correct answer. If the two objects are extremely close together, you might get an answer either way. In such cases, the wrong answer probably wouldn’t even be noticed (it would just look like a near miss, or near hit) and the game would continue.</p><br><h3>Floating point equality</h3><p>The equality operators (== and !=) are much more troublesome. Consider operator==, which returns true only if its operands are exactly equal. Because even the smallest rounding error will cause two floating point numbers to not be equal, operator== is at high risk for returning false when a true might be expected. Operator!= has the same kind of problem.</p><p>For this reason, use of these operators with floating point operands should generally be avoided.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Avoid using operator== and operator!= to compare floating point values if there is any chance those values have been calculated.</p></div><p>There is one notable exception case to the above: it is okay to compare a low-precision (few significant digits) floating point literal to the same literal value of the same type.</p><p>For example, if a function returns such a literal (typically <code>0.0</code>, or sometimes <code>1.0</code>), it is safe to do a direct comparison against the same literal value of the same type:</p><pre class="language-cpp line-numbers"><code>if (someFcn() == 0.0) // okay if someFcn() returns 0.0 as a literal only</code><code>    // do something</code></pre><p>Alternatively, if we have a const or constexpr floating point variable that we can guarantee is a literal, it is safe to do a direct comparison:</p><pre class="language-cpp line-numbers"><code>constexpr gravity { 9.8 }</code><code>if (gravity == 9.8) // okay if gravity was initialized with a literal</code><code>    // we're on earth</code></pre><p>Why does this work? Consider the double literal <code>0.0</code>. This literal has some specific and unique representation in memory. Therefore, <code>0.0 == 0.0</code> should always be true. It should also be true that a copy of <code>0.0</code> should always equal <code>0.0</code>. Therefore, we can compare a function returning literal <code>0.0</code> (which is a copy of <code>0.0</code>) or a variable initialized with literal <code>0.0</code> (which is a copy of <code>0.0</code>) to literal <code>0.0</code> safely.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>It is okay to compare a low-precision (few significant digits) floating point literal to the same literal value of the same type.</p></div><br><h3>Comparing floating point numbers (advanced / optional reading)</h3><p>So how can we reasonably compare two floating point operands to see if they are equal?</p><p>The most common method of doing floating point equality involves using a function that looks to see if two numbers are <em>almost</em> the same. If they are “close enough”, then we call them equal. The value used to represent “close enough” is traditionally called <span class="cpp-definition">epsilon</span>. Epsilon is generally defined as a small positive number (e.g. 0.00000001, sometimes written 1e-8).</p><p>New developers often try to write their own “close enough” function like this:</p><pre class="language-cpp line-numbers"><code>#include <cmath> // for std::abs()</cmath></code><code></code><code>// epsilon is an absolute value</code><code>bool approximatelyEqualAbs(double a, double b, double absEpsilon)</code><code>{</code><code>    // if the distance between a and b is less than absEpsilon, then a and b are "close enough"</code><code>    return std::abs(a - b) &lt;= absEpsilon;</code><code>}</code></pre><p>std::abs() is a function in the &lt;cmath&gt; header that returns the absolute value of its argument. So <code>std::abs(a - b) &lt;= absEpsilon</code> checks if the distance between <em>a</em> and <em>b</em> is less than whatever epsilon value representing “close enough” was passed in. If <em>a</em> and <em>b</em> are close enough, the function returns true to indicate they’re equal. Otherwise, it returns false.</p><p>While this function can work, it’s not great. An epsilon of <em>0.00001</em> is good for inputs around <em>1.0</em>, too big for inputs around <em>0.0000001</em>, and too small for inputs like <em>10,000</em>.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>If we say any number that is within 0.00001 of another number should be treated as the same number, then:</p><ul><li>1 and 1.0001 would be different, but 1 and 1.00001 would be the same. That’s not unreasonable.</li><li>0.0000001 and 0.00001 would be the same. That doesn’t seem good, as those numbers are two orders of magnitude apart.</li><li>10000 and 10000.00001 would be different. That also doesn’t seem good, as those numbers are barely different given the magnitude of the number.</li></ul></div><p>This means every time we call this function, we have to pick an epsilon that’s appropriate for our inputs. If we know we’re going to have to scale epsilon in proportion to the magnitude of our inputs, we might as well modify the function to do that for us.</p><p><a href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a>, a famous computer scientist, suggested the following method in his book “The Art of Computer Programming, Volume II: Seminumerical Algorithms (Addison-Wesley, 1969)”:</p><pre class="language-cpp line-numbers"><code>#include <algorithm> // std::max</algorithm></code><code>#include <cmath> // std::abs</cmath></code><code></code><code>// return true if the difference between a and b is within epsilon percent of the larger of a and b</code><code>bool approximatelyEqualRel(double a, double b, double relEpsilon)</code><code>{</code><code>    return (std::abs(a - b) &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));</code><code>}</code></pre><p>In this case, instead of epsilon being an absolute number, epsilon is now relative to the magnitude of <em>a</em> or <em>b</em>.</p><p>Let’s examine in more detail how this crazy looking function works. On the left side of the &lt;= operator, <code>std::abs(a - b)</code> tells us the distance between <em>a</em> and <em>b</em> as a positive number.</p><p>On the right side of the &lt;= operator, we need to calculate the largest value of “close enough” we’re willing to accept. To do this, the algorithm chooses the larger of <em>a</em> and <em>b</em> (as a rough indicator of the overall magnitude of the numbers), and then multiplies it by relEpsilon. In this function, relEpsilon represents a percentage. For example, if we want to say “close enough” means <em>a</em> and <em>b</em> are within 1% of the larger of <em>a</em> and <em>b</em>, we pass in an relEpsilon of 0.01 (1% = 1/100 = 0.01). The value for relEpsilon can be adjusted to whatever is most appropriate for the circumstances (e.g. an epsilon of 0.002 means within 0.2%).</p><p>To do inequality (!=) instead of equality, simply call this function and use the logical NOT operator (!) to flip the result:</p><pre class="language-cpp line-numbers"><code>if (!approximatelyEqualRel(a, b, 0.001))</code><code>    std::cout &lt;&lt; a &lt;&lt; " is not equal to " &lt;&lt; b &lt;&lt; '\n';</code></pre><p>Note that while the approximatelyEqualRel() function will work for most cases, it is not perfect, especially as the numbers approach zero:</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <cmath></cmath></code><code>#include <iostream></iostream></code><code></code><code>// return true if the difference between a and b is within epsilon percent of the larger of a and b</code><code>bool approximatelyEqualRel(double a, double b, double relEpsilon)</code><code>{</code><code>	return (std::abs(a - b) &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	// a is really close to 1.0, but has rounding errors, so it's slightly smaller than 1.0</code><code>	double a{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 };</code><code> </code><code>	// First, let's compare a (almost 1.0) to 1.0.</code><code>	std::cout &lt;&lt; approximatelyEqualRel(a, 1.0, 1e-8) &lt;&lt; '\n';</code><code> </code><code>	// Second, let's compare a-1.0 (almost 0.0) to 0.0</code><code>	std::cout &lt;&lt; approximatelyEqualRel(a-1.0, 0.0, 1e-8) &lt;&lt; '\n';</code><code>}</code></pre><p>Perhaps surprisingly, this returns:</p><pre>1
0
</pre><p>The second call didn’t perform as expected. The math simply breaks down close to zero.</p><p>One way to avoid this is to use both an absolute epsilon (as we did in the first approach) and a relative epsilon (as we did in Knuth’s approach):</p><pre class="language-cpp line-numbers"><code>// return true if the difference between a and b is less than absEpsilon, or within relEpsilon percent of the larger of a and b</code><code>bool approximatelyEqualAbsRel(double a, double b, double absEpsilon, double relEpsilon)</code><code>{</code><code>    // Check if the numbers are really close -- needed when comparing numbers near zero.</code><code>    double diff{ std::abs(a - b) };</code><code>    if (diff &lt;= absEpsilon)</code><code>        return true;</code><code> </code><code>    // Otherwise fall back to Knuth's algorithm</code><code>    return (diff &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));</code><code>}</code></pre><p>In this algorithm, we first check if <em>a</em> and <em>b</em> are close together in absolute terms, which handles the case where <em>a</em> and <em>b</em> are both close to zero. The <em>absEpsilon</em> parameter should be set to something very small (e.g. 1e-12). If that fails, then we fall back to Knuth’s algorithm, using the relative epsilon.</p><p>Here’s our previous code testing both algorithms:</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <cmath></cmath></code><code>#include <iostream></iostream></code><code></code><code>// return true if the difference between a and b is within epsilon percent of the larger of a and b</code><code>bool approximatelyEqualRel(double a, double b, double relEpsilon)</code><code>{</code><code>	return (std::abs(a - b) &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));</code><code>}</code><code></code><code>bool approximatelyEqualAbsRel(double a, double b, double absEpsilon, double relEpsilon)</code><code>{</code><code>    // Check if the numbers are really close -- needed when comparing numbers near zero.</code><code>    double diff{ std::abs(a - b) };</code><code>    if (diff &lt;= absEpsilon)</code><code>        return true;</code><code> </code><code>    // Otherwise fall back to Knuth's algorithm</code><code>    return (diff &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    // a is really close to 1.0, but has rounding errors</code><code>    double a{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 };</code><code></code><code>    std::cout &lt;&lt; approximatelyEqualRel(a, 1.0, 1e-8) &lt;&lt; '\n';     // compare "almost 1.0" to 1.0</code><code>    std::cout &lt;&lt; approximatelyEqualRel(a-1.0, 0.0, 1e-8) &lt;&lt; '\n'; // compare "almost 0.0" to 0.0</code><code></code><code>    std::cout &lt;&lt; approximatelyEqualAbsRel(a, 1.0, 1e-12, 1e-8) &lt;&lt; '\n'; // compare "almost 1.0" to 1.0</code><code>    std::cout &lt;&lt; approximatelyEqualAbsRel(a-1.0, 0.0, 1e-12, 1e-8) &lt;&lt; '\n'; // compare "almost 0.0" to 0.0</code><code>}</code></pre><pre>1
0
1
1
</pre><p>You can see that approximatelyEqualAbsRel() handles the small inputs correctly.</p><p>Comparison of floating point numbers is a difficult topic, and there’s no “one size fits all” algorithm that works for every case. However, the approximatelyEqualAbsRel() with an absEpsilon of 1e-12 and a relEpsilon of 1e-8 should be good enough to handle most cases you’ll encounter.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">5.7 — Logical operators</h1></header><div class="entry-content" itemprop="articleBody"><p>While relational (comparison) operators can be used to test whether a particular condition is true or false, they can only test one condition at a time. Often we need to know whether multiple conditions are true simultaneously. For example, to check whether we’ve won the lottery, we have to compare whether all of the multiple numbers we picked match the winning numbers. In a lottery with 6 numbers, this would involve 6 comparisons, <em>all</em> of which have to be true. In other cases, we need to know whether any one of multiple conditions is true. For example, we may decide to skip work today if we’re sick, or if we’re too tired, or if we won the lottery in our previous example. This would involve checking whether <em>any</em> of 3 comparisons is true.</p><p>Logical operators provide us with the capability to test multiple conditions.</p><p>C++ has 3 logical operators:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Operator</th><th>Symbol</th><th>Form</th><th>Operation</th></tr><tr><td>Logical NOT</td><td>!</td><td>!x</td><td>true if x is false, or false if x is true</td></tr><tr><td>Logical AND</td><td>&amp;&amp;</td><td>x &amp;&amp; y</td><td>true if both x and y are true, false otherwise</td></tr><tr><td>Logical OR</td><td>||</td><td>x || y</td><td>true if either x or y are true, false otherwise</td></tr></tbody></table></div><p><strong>Logical NOT</strong></p><p>You have already run across the logical NOT unary operator in lesson <a href="https://www.learncpp.com/cpp-tutorial/boolean-values/">4.9 -- Boolean values</a>. We can summarize the effects of logical NOT like so:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th colspan="2">Logical NOT (operator !)</th></tr><tr><th>Operand</th><th>Result</th></tr><tr><td>true</td><td>false</td></tr><tr><td>false</td><td>true</td></tr></tbody></table></div><p>If <em>logical NOT’s</em> operand evaluates to true, <em>logical NOT</em> evaluates to false. If <em>logical NOT’s</em> operand evaluates to false, <em>logical NOT</em> evaluates to true. In other words, <em>logical NOT</em> flips a Boolean value from true to false, and vice-versa.</p><p>Logical NOT is often used in conditionals:</p><pre class="language-cpp line-numbers"><code>bool tooLarge { x &gt; 100 }; // tooLarge is true if x &gt; 100</code><code>if (!tooLarge)</code><code>    // do something with x</code><code>else</code><code>    // print an error</code></pre><p>One thing to be wary of is that <em>logical NOT</em> has a very high level of precedence. New programmers often make the following mistake:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    int y{ 7 };</code><code></code><code>    if (!x &gt; y)</code><code>        std::cout &lt;&lt; x &lt;&lt; " is not greater than " &lt;&lt; y &lt;&lt; '\n';</code><code>    else</code><code>        std::cout &lt;&lt; x &lt;&lt; " is greater than " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>5 is greater than 7
</pre><p>But <em>x</em> is not greater than <em>y</em>, so how is this possible? The answer is that because the <em>logical NOT</em> operator has higher precedence than the <em>greater than</em> operator, the expression <code>! x &gt; y</code> actually evaluates as <code>(!x) &gt; y</code>. Since <em>x</em> is 5, !x evaluates to <em>0</em>, and <code>0 &gt; y</code> is false, so the <em>else</em> statement executes!</p><p>The correct way to write the above snippet is:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    int y{ 7 };</code><code></code><code>    if (!(x &gt; y))</code><code>        std::cout &lt;&lt; x &lt;&lt; " is not greater than " &lt;&lt; y &lt;&lt; '\n';</code><code>    else</code><code>        std::cout &lt;&lt; x &lt;&lt; " is greater than " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This way, <code>x &gt; y</code> will be evaluated first, and then logical NOT will flip the Boolean result.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>If <em>logical NOT</em> is intended to operate on the result of other operators, the other operators and their operands need to be enclosed in parentheses.</p></div><p>Simple uses of <em>logical NOT</em>, such as <code>if (!value)</code> do not need parentheses because precedence does not come into play.</p><br><h3>Logical OR</h3><p>The <em>logical OR</em> operator is used to test whether either of two conditions is true. If the left operand evaluates to true, or the right operand evaluates to true, or both are true, then the <em>logical OR</em> operator returns true. Otherwise it will return false.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th colspan="3">Logical OR (operator ||)</th></tr><tr><th>Left operand</th><th>Right operand</th><th>Result</th></tr><tr><td>false</td><td>false</td><td>false</td></tr><tr><td>false</td><td>true</td><td>true</td></tr><tr><td>true</td><td>false</td><td>true</td></tr><tr><td>true</td><td>true</td><td>true</td></tr></tbody></table></div><p>For example, consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number: ";</code><code>    int value {};</code><code>    std::cin &gt;&gt; value;</code><code></code><code>    if (value == 0 || value == 1)</code><code>        std::cout &lt;&lt; "You picked 0 or 1\n";</code><code>    else</code><code>        std::cout &lt;&lt; "You did not pick 0 or 1\n";</code><code>    return 0;</code><code>}</code></pre><p>In this case, we use the logical OR operator to test whether either the left condition (value == 0) or the right condition (value == 1) is true. If either (or both) are true, the <em>logical OR</em> operator evaluates to true, which means the <em>if statement</em> executes. If neither are true, the <em>logical OR</em> operator evaluates to false, which means the <em>else statement</em> executes.</p><p>You can string together many <em>logical OR</em> statements:</p><pre class="language-cpp line-numbers"><code>if (value == 0 || value == 1 || value == 2 || value == 3)</code><code>     std::cout &lt;&lt; "You picked 0, 1, 2, or 3\n";</code></pre><p>New programmers sometimes confuse the <em>logical OR</em> operator (||) with the <em>bitwise OR</em> operator (|) (Covered later). Even though they both have <em>OR</em> in the name, they perform different functions. Mixing them up will probably lead to incorrect results.</p><br><h3>Logical AND</h3><p>The <em>logical AND</em> operator is used to test whether both operands are true. If both operands are true, <em>logical AND</em> returns true. Otherwise, it returns false.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th colspan="3">Logical AND (operator &amp;&amp;)</th></tr><tr><th>Left operand</th><th>Right operand</th><th>Result</th></tr><tr><td>false</td><td>false</td><td>false</td></tr><tr><td>false</td><td>true</td><td>false</td></tr><tr><td>true</td><td>false</td><td>false</td></tr><tr><td>true</td><td>true</td><td>true</td></tr></tbody></table></div><p>For example, we might want to know if the value of variable <em>x</em> is between <em>10</em> and <em>20</em>. This is actually two conditions: we need to know if <em>x</em> is greater than <em>10</em>, and also whether <em>x</em> is less than <em>20</em>.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number: ";</code><code>    int value {};</code><code>    std::cin &gt;&gt; value;</code><code></code><code>    if (value &gt; 10 &amp;&amp; value &lt; 20)</code><code>        std::cout &lt;&lt; "Your value is between 10 and 20\n";</code><code>    else</code><code>        std::cout &lt;&lt; "Your value is not between 10 and 20\n";</code><code>    return 0;</code><code>}</code></pre><p>In this case, we use the <em>logical AND</em> operator to test whether the left condition (value &gt; 10) AND the right condition (value &lt; 20) are both true. If both are true, the <em>logical AND</em> operator evaluates to true, and the <em>if statement</em> executes. If neither are true, or only one is true, the <em>logical AND</em> operator evaluates to false, and the <em>else statement</em> executes.</p><p>As with <em>logical OR</em>, you can string together many <em>logical AND</em> statements:</p><pre class="language-cpp line-numbers"><code>if (value &gt; 10 &amp;&amp; value &lt; 20 &amp;&amp; value != 16)</code><code>    // do something</code><code>else</code><code>    // do something else</code></pre><p>If all of these conditions are true, the <em>if statement</em> will execute. If any of these conditions are false, the <em>else statement</em> will execute.</p><p>As with logical and bitwise OR, new programmers sometimes confuse the <em>logical AND</em> operator (&amp;&amp;) with the <em>bitwise AND</em> operator (&amp;).</p><br><h3>Short circuit evaluation</h3><p>In order for <em>logical AND</em> to return true, both operands must evaluate to true. If the first operand evaluates to false, <em>logical AND</em> knows it must return false regardless of whether the second operand evaluates to true or false. In this case, the <em>logical AND</em> operator will go ahead and return false immediately without even evaluating the second operand! This is known as <span class="cpp-definition">short circuit evaluation</span>, and it is done primarily for optimization purposes.</p><p>Similarly, if the first operand for <em>logical OR</em> is true, then the entire OR condition has to evaluate to true, and the second operand won’t be evaluated.</p><p>Short circuit evaluation presents another opportunity to show why operators that cause side effects should not be used in compound expressions. Consider the following snippet:</p><pre class="language-cpp line-numbers"><code>if (x == 1 &amp;&amp; ++y == 2)</code><code>    // do something</code></pre><p>if <em>x</em> does not equal <em>1</em>, the whole condition must be false, so ++y never gets evaluated! Thus, <em>y</em> will only be incremented if <em>x</em> evaluates to 1, which is probably not what the programmer intended!</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Short circuit evaluation may cause <em>Logical OR</em> and <em>Logical AND</em> to not evaluate one operand. Avoid using expressions with side effects in conjunction with these operators.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>The Logical OR and logical AND operators are an exception to the rule that the operands may evaluate in any order, as the standard explicitly states that the left operand must evaluate first.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>Only the built-in versions of these operators perform short-circuit evaluation. If you overload these operators to make them work with your own types, those overloaded operators will not perform short-circuit evaluation.</p></div><br><h3>Mixing ANDs and ORs</h3><p>Mixing <em>logical AND</em> and <em>logical OR</em> operators in the same expression often can not be avoided, but it is an area full of potential dangers.</p><p>Many programmers assume that <em>logical AND</em> and <em>logical OR</em> have the same precedence (or forget that they don’t), just like addition/subtraction and multiplication/division do. However, <em>logical AND</em> has higher precedence than <em>logical OR</em>, thus <em>logical AND</em> operators will be evaluated ahead of <em>logical OR</em> operators (unless they have been parenthesized).</p><p>New programmers will often write expressions such as <code>value1 || value2 &amp;&amp; value3</code>. Because <em>logical AND</em> has higher precedence, this evaluates as <code>value1 || (value2 &amp;&amp; value3)</code>, not <code>(value1 || value2) &amp;&amp; value3</code>. Hopefully that’s what the programmer wanted! If the programmer was assuming left to right association (as happens with addition/subtraction, or multiplication/division), the programmer will get a result he or she was not expecting!</p><p>When mixing <em>logical AND</em> and <em>logical OR</em> in the same expression, it is a good idea to explicitly parenthesize each operator and its operands. This helps prevent precedence mistakes, makes your code easier to read, and clearly defines how you intended the expression to evaluate. For example, rather than writing <code>value1 &amp;&amp; value2 || value3 &amp;&amp; value4</code>, it is better to write <code>(value1 &amp;&amp; value2) || (value3 &amp;&amp; value4)</code>.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>When mixing <em>logical AND</em> and <em>logical OR</em> in a single expression, explicitly parenthesize each operation to ensure they evaluate how you intend.</p></div><br><h3>De Morgan’s law</h3><p>Many programmers also make the mistake of thinking that <code>!(x &amp;&amp; y)</code> is the same thing as <code>!x &amp;&amp; !y</code>. Unfortunately, you can not “distribute” the <em>logical NOT</em> in that manner.</p><p><a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan’s law</a> tells us how the <em>logical NOT</em> should be distributed in these cases:</p><p><code>!(x &amp;&amp; y)</code> is equivalent to <code>!x || !y</code><br><code>!(x || y)</code> is equivalent to <code>!x &amp;&amp; !y</code></p><p>In other words, when you distribute the <em>logical NOT</em>, you also need to flip <em>logical AND</em> to <em>logical OR</em>, and vice-versa!</p><p>This can sometimes be useful when trying to make complex expressions easier to read.</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>We can show that the first part of De Morgan’s Law is correct by proving that <code>!(x &amp;&amp; y)</code> equals <code>!x || !y</code> for every possible value of <code>x</code> and <code>y</code>. To do so, we’ll use a mathematical concept called a truth table:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>x</th><th>y</th><th>!x</th><th>!y</th><th>!(x &amp;&amp; y)</th><th>!x || !y</th></tr><tr><td>false</td><td>false</td><td>true</td><td>true</td><td>true</td><td>true</td></tr><tr><td>false</td><td>true</td><td>true</td><td>false</td><td>true</td><td>true</td></tr><tr><td>true</td><td>false</td><td>false</td><td>true</td><td>true</td><td>true</td></tr><tr><td>true</td><td>true</td><td>false</td><td>false</td><td>false</td><td>false</td></tr></tbody></table></div><p>In this table, the first and second columns represent our <code>x</code> and <code>y</code> variables. Each row in the table shows one permutation of possible values for <code>x</code> and <code>y</code>. Because <code>x</code> and <code>y</code> are Boolean values, we only need 4 rows to cover every combination of possible values that <code>x</code> and <code>y</code> can hold.</p><p>The rest of the columns in the table represent expressions that we want to evaluate based on the initial values of <code>x</code> and <code>y</code>. The third and fourth columns calculate the values of <code>!x</code> and <code>!y</code> respectively. The fifth column calculates the value of <code>!(x &amp;&amp; y)</code>. Finally, the sixth column calculates the value of <code>!x || !y</code>.</p><p>You’ll notice for each row, the value in the fifth column matches the value in the sixth column. This means for every possible value of <code>x</code> and <code>y</code>, the value of <code>!(x &amp;&amp; y)</code> equals <code>!x || !y</code>, which is what we were trying to prove!</p><p>We can do the same for the second part of De Morgan’s Law:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>x</th><th>y</th><th>!x</th><th>!y</th><th>!(x || y)</th><th>!x &amp;&amp; !y</th></tr><tr><td>false</td><td>false</td><td>true</td><td>true</td><td>true</td><td>true</td></tr><tr><td>false</td><td>true</td><td>true</td><td>false</td><td>false</td><td>false</td></tr><tr><td>true</td><td>false</td><td>false</td><td>true</td><td>false</td><td>false</td></tr><tr><td>true</td><td>true</td><td>false</td><td>false</td><td>false</td><td>false</td></tr></tbody></table></div><p>Similarly, for every possible value of <code>x</code> and <code>y</code>, we can see that the value of <code>!(x || y)</code> equals the value of <code>!x &amp;&amp; !y</code>. Thus, they are equivalent.</p></div><br><h3>Where’s the logical exclusive or (XOR) operator?</h3><p><em>Logical XOR</em> is a logical operator provided in some languages that is used to test whether an odd number of conditions is true.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th colspan="3">Logical XOR</th></tr><tr><th>Left operand</th><th>Right operand</th><th>Result</th></tr><tr><td>false</td><td>false</td><td>false</td></tr><tr><td>false</td><td>true</td><td>true</td></tr><tr><td>true</td><td>false</td><td>true</td></tr><tr><td>true</td><td>true</td><td>false</td></tr></tbody></table></div><p>C++ doesn’t provide a <em>logical XOR</em> operator. Unlike <em>logical OR</em> or <em>logical AND</em>, <em>logical XOR</em> cannot be short circuit evaluated. Because of this, making a <em>logical XOR</em> operator out of <em>logical OR</em> and <em>logical AND</em> operators is challenging. However, you can easily mimic <em>logical XOR</em> using the <em>inequality</em> operator (!=):</p><pre class="language-cpp line-numbers"><code>if (a != b) ... // a XOR b, assuming a and b are Booleans</code></pre><p>This can be extended to multiple operands as follows:</p><pre class="language-cpp line-numbers"><code>if (a != b != c != d) ... // a XOR b XOR c XOR d, assuming a, b, c, and d are Booleans</code></pre><p>Note that the above XOR patterns only work if the operands are Booleans (not integers). If you need a form of <em>logical XOR</em> that works with non-Boolean operands, you can static_cast them to bool:</p><pre class="language-cpp line-numbers"><code>if (static_cast<bool>(a) != static_cast<bool>(b) != static_cast<bool>(c) != static_cast<bool>(d)) ... // a XOR b XOR c XOR d, for any type that can be converted to bool</bool></bool></bool></bool></code></pre><br><h3>Alternative operator representations</h3><p>Many operators in C++ (such as operator ||) have names that are just symbols. Historically, not all keyboards and language standards have supported all of the symbols needed to type these operators. As such, C++ supports an alternative set of keywords for the operators that use words instead of symbols. For example, instead of <code>||</code>, you can use the keyword <code>or</code>.</p><p>The full list can be found <a href="https://en.cppreference.com/w/cpp/language/operator_alternative">here</a>. Of particular note are the following three:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Operator name</th><th>Keyword alternate name</th></tr><tr><td>&amp;&amp;</td><td>and</td></tr><tr><td>||</td><td>or</td></tr><tr><td>!</td><td>not</td></tr></tbody></table></div><p>This means the following are identical:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; !a &amp;&amp; (b || c);</code><code>std::cout &lt;&lt; not a and (b or c);</code></pre><p>While these alternative names might seem easier to understand right now, most experienced C++ developers prefer using the symbolic names over the keyword names. As such, we recommend learning and using the symbolic names, as this is what you will commonly find in existing code.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Evaluate the following expressions.</p><p>Note: in the following answers, we “explain our work” by showing you the steps taken to get to the final answer. The steps are separated by a <em>=&gt;</em> symbol. Expressions that were ignored due to the short circuit rules are placed in square brackets. For example<br>(1 &lt; 2 || 3 != 3) =&gt;<br>(true || [3 != 3]) =&gt;<br>(true) =&gt;<br>true<br>means we evaluated (1 &lt; 2 || 3 != 3) to arrive at (true || [3 != 3]) and evaluated that to arrive at “true”. The 3 != 3 was never executed due to short circuiting.</p><p>a) (true &amp;&amp; true) || false</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>(true &amp;&amp; true) || false =&gt;<br>true || [false] =&gt;<br>true</p></div><p>b) (false &amp;&amp; true) || true</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>(false &amp;&amp; [true]) || true =&gt;<br>false || true =&gt;<br>true</p><p>Short circuiting only takes place if the first operand of <code>||</code> is <code>true</code>.</p></div><p>c) (false &amp;&amp; true) || false || true</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>(false &amp;&amp; [true]) || false || true =&gt;<br>false || false || true =&gt;<br>false || true =&gt;<br>true</p></div><p>d) (5 &gt; 6 || 4 &gt; 3) &amp;&amp; (7 &gt; 8)</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><p>(5 &gt; 6 || 4 &gt; 3) &amp;&amp; (7 &gt; 8) =&gt;<br>(false || true) &amp;&amp; false =&gt;<br>true &amp;&amp; false =&gt;<br>false</p></div><p>e) !(7 &gt; 6 || 3 &gt; 4)</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none">!(7 &gt; 6 || 3 &gt; 4) =&gt;<br>!(true || [3 &gt; 4]) =&gt;<br>!true =&gt;<br>false</div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">5.x — Chapter 5 summary and quiz</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Quick review</h3><p>Always use parentheses to disambiguate the precedence of operators if there is any question or opportunity for confusion.</p><p>The arithmetic operators all work like they do in normal mathematics. The modulus (%) operator returns the remainder from an integer division.</p><p>The increment and decrement operators can be used to easily increment or decrement numbers. Avoid the postfix versions of these operators whenever possible.</p><p>Beware of side effects, particularly when it comes to the order that function parameters are evaluated. Do not use a variable that has a side effect applied more than once in a given statement.</p><p>The comma operator can compress multiple statements into one. Writing the statements separately is usually better.</p><p>The conditional operator is a nice short version of an if-statement, but don’t use it as an alternative to an if-statement. Only use the conditional operator if you use its result.</p><p>Relational operators can be used to compare floating point numbers. Beware using equality and inequality on floating point numbers.</p><p>Logical operators allow us to form compound conditional statements.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Evaluate the following:</p><p>a) (5 &gt; 3 &amp;&amp; 4 &lt; 8)</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>(5 &gt; 3 &amp;&amp; 4 &lt; 8) becomes (true &amp;&amp; true), which is true.</p></div><p>b) (4 &gt; 6 &amp;&amp; true)</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>(4 &gt; 6 &amp;&amp; true) becomes (false &amp;&amp; true), which is false.</p></div><p>c) (3 &gt;= 3 || false)</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>(3 &gt;= 3 || false) becomes (true || false), which is true.</p></div><p>d) (true || false) ? 4 : 5</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><p>(true || false) ? 4 : 5 becomes (true ? 4 : 5), which is 4.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>Evaluate the following:</p><p>a) 7 / 4</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><p>7 / 4 = 1 remainder 3, so this equals 1.</p></div><p>b) 14 % 5</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><p>14 / 5 = 2 remainder 4, so 14 % 5 equals 4.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>Why should you never do the following:</p><p>a) int y{ foo(++x, x) };</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none"><p>Because operator++ applies a side effect to x, we should not use x again in the same expression. In this case, the parameters to function foo() can be evaluated in any order, so it’s indeterminate whether x or ++x gets evaluated first. Because ++x changes the value of x, it’s unclear what values will be passed into the function.</p></div><p>b) double x{ 0.1 + 0.1 + 0.1 }; return (x == 0.3);</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_7'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_7" style="display:none"><p>Floating point rounding errors will cause this to evaluate as false even though it looks like it should be true.</p></div><p>c) int x{ 3 / 0 };</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_8'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_8" style="display:none"><p>Division by 0 causes undefined behavior, which is likely expressed in a crash.</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">O.1 — Bit flags and bit manipulation via std::bitset</h1></header><div class="entry-content" itemprop="articleBody"><p>On modern computer architectures, the smallest addressable unit of memory is a byte. Since all objects need to have unique memory addresses, this means objects must be at least one byte in size. For most variable types, this is fine. However, for Boolean values, this is a bit wasteful (pun intended). Boolean types only have two states: true (1), or false (0). This set of states only requires one bit to store. However, if a variable must be at least a byte, and a byte is 8 bits, that means a Boolean is using 1 bit and leaving the other 7 unused.</p><p>In the majority of cases, this is fine -- we’re usually not so hard-up for memory that we need to care about 7 wasted bits (we’re better off optimizing for understandability and maintainability). However, in some storage-intensive cases, it can be useful to “pack” 8 individual Boolean values into a single byte for storage efficiency purposes.</p><p>Doing these things requires that we can manipulate objects at the bit level. Fortunately, C++ gives us tools to do precisely this. Modifying individual bits within an object is called <span class="cpp-definition">bit manipulation</span>.</p><p>Bit manipulation is also useful in encryption and compression algorithms.</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>This entire chapter is optional reading. Feel free to skip it and come back later.</p></div><br><h3>Bit flags</h3><p>Up to this point, we’ve used variables to hold single values:</p><pre class="language-cpp line-numbers"><code>int foo { 5 }; // assign foo the value 5 (probably uses 32 bits of storage)</code><code>std::cout &lt;&lt; foo; // print the value 5</code></pre><p>However, instead of viewing objects as holding a single value, we can instead view them as a collection of individual bits. When individual bits of an object are used as Boolean values, the bits are called <span class="cpp-definition">bit flags</span>.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>In computing, a flag is a value that acts as a signal for some function or process. Analogously, in real life, a mailbox flag is used to signal that there is something inside the mailbox, so the mailbox doesn’t have to be opened to check.</p></div><p>To define a set of bit flags, we’ll typically use an unsigned integer of the appropriate size (8 bits, 16 bits, 32 bits, etc… depending on how many flags we have), or std::bitset.</p><pre class="language-cpp line-numbers"><code>#include <bitset> // for std::bitset</bitset></code><code></code><code>std::bitset&lt;8&gt; mybitset {}; // 8 bits in size means room for 8 flags</code></pre><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Bit manipulation is one of the few times when you should unambiguously use unsigned integers (or std::bitset).</p></div><p>In this lesson, we’ll show how to do bit manipulation the easy way, via std::bitset. In the next set of lessons, we’ll explore how to do it the more difficult but versatile way.</p><br><h3>Bit numbering and bit positions</h3><p>Given a sequence of bits, we typically number the bits from right to left, starting with 0 (not 1). Each number denotes a <span class="cpp-definition">bit position</span>.</p><pre>76543210  Bit position
00000101  Bit sequence
</pre><p>Given the bit sequence 0000 0101, the bits that are in position 0 and 2 have value 1, and the other bits have value 0.</p><br><h3>Manipulating bits via std::bitset</h3><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/numeral-systems-decimal-binary-hexadecimal-and-octal/">4.16 -- Numeral systems (decimal, binary, hexadecimal, and octal)</a> we already showed how to use a std::bitset to print values in binary. However, this isn’t the only useful thing std::bitset can do.</p><p>std::bitset provides 4 key functions that are useful for doing bit manipulation:</p><ul><li>test() allows us to query whether a bit is a 0 or 1</li><li>set() allows us to turn a bit on (this will do nothing if the bit is already on)</li><li>reset() allows us to turn a bit off (this will do nothing if the bit is already off)</li><li>flip() allows us to flip a bit value from a 0 to a 1 or vice versa</li></ul><p>Each of these functions takes the position of the bit we want to operate on as their only argument.</p><p>Here’s an example:</p><pre class="language-cpp line-numbers"><code>#include <bitset></bitset></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::bitset&lt;8&gt; bits{ 0b0000'0101 }; // we need 8 bits, start with bit pattern 0000 0101</code><code>    bits.set(3); // set bit position 3 to 1 (now we have 0000 1101)</code><code>    bits.flip(4); // flip bit 4 (now we have 0001 1101)</code><code>    bits.reset(4); // set bit 4 back to 0 (now we have 0000 1101)</code><code></code><code>    std::cout &lt;&lt; "All the bits: " &lt;&lt; bits &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "Bit 3 has value: " &lt;&lt; bits.test(3) &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "Bit 4 has value: " &lt;&lt; bits.test(4) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>All the bits: 00001101
Bit 3 has value: 1
Bit 4 has value: 0
</pre><div class="cpp-note cpp-lightgraybackground"><h4>A reminder</h4><p>If you need a refresher on what the <code>0b</code> prefix or the <code>'</code> separator is, review <a href="https://www.learncpp.com/cpp-tutorial/numeral-systems-decimal-binary-hexadecimal-and-octal/">4.16 -- Numeral systems (decimal, binary, hexadecimal, and octal)</a>.</p></div><br><h3>What if we want to get or set multiple bits at once</h3><p>std::bitset doesn’t make this easy. In order to do this, or if we want to use unsigned integer bit flags instead of std::bitset, we need to turn to more traditional methods. We’ll cover these in the next couple of lessons.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">O.2 — Bitwise operators</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>The bitwise operators</h3><p>C++ provides 6 bit manipulation operators, often called <span class="cpp-definition">bitwise</span> operators:</p><p style="clear:both"></p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Operator</th><th>Symbol</th><th>Form</th><th>Operation</th></tr><tr><td>left shift</td><td>&lt;&lt;</td><td>x &lt;&lt; y</td><td>all bits in x shifted left y bits</td></tr><tr><td>right shift</td><td>&gt;&gt;</td><td>x &gt;&gt; y</td><td>all bits in x shifted right y bits</td></tr><tr><td>bitwise NOT</td><td>~</td><td>~x</td><td>all bits in x flipped</td></tr><tr><td>bitwise AND</td><td>&amp;</td><td>x &amp; y</td><td>each bit in x AND each bit in y</td></tr><tr><td>bitwise OR</td><td>|</td><td>x | y</td><td>each bit in x OR each bit in y</td></tr><tr><td>bitwise XOR</td><td>^</td><td>x ^ y</td><td>each bit in x XOR each bit in y</td></tr></tbody></table></div><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>In the following examples, we will largely be working with 4-bit binary values. This is for the sake of convenience and keeping the examples simple. In actual programs, the number of bits used is based on the size of the object (e.g. a 2 byte object would store 16 bits).</p><p>For readability, we’ll also omit the 0b prefix outside of code examples (e.g. instead of 0b0101, we’ll just use 0101).</p></div><p>The bitwise operators are defined for integral types and std::bitset. We’ll use std::bitset in our examples because it’s easier to print the output in binary.</p><p>Avoid using the bitwise operators with signed operands, as many operators will return implementation-defined results prior to C++20 or have other potential gotchas that are easily avoided by using unsigned operands (or std::bitset).</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>To avoid surprises, use the bitwise operators with unsigned operands or std::bitset.</p></div><br><h3>Bitwise left shift (&lt;&lt;) and bitwise right shift (&gt;&gt;) operators</h3><p>The <span class="cpp-definition">bitwise left shift</span> (&lt;&lt;) operator shifts bits to the left. The left operand is the expression to shift the bits of, and the right operand is an integer number of bits to shift left by.</p><p>So when we say <code>x &lt;&lt; 1</code>, we are saying “shift the bits in the variable x left by 1 place”. New bits shifted in from the right side receive the value 0.</p><p>0011 &lt;&lt; 1 is 0110<br>0011 &lt;&lt; 2 is 1100<br>0011 &lt;&lt; 3 is 1000</p><p>Note that in the third case, we shifted a bit off the end of the number! Bits that are shifted off the end of the binary number are lost forever.</p><p>The <span class="cpp-definition">bitwise right shift</span> (&gt;&gt;) operator shifts bits to the right.</p><p>1100 &gt;&gt; 1 is 0110<br>1100 &gt;&gt; 2 is 0011<br>1100 &gt;&gt; 3 is 0001</p><p>Note that in the third case we shifted a bit off the right end of the number, so it is lost.</p><p>Here’s an example of doing some bit shifting:</p><pre class="language-cpp line-numbers"><code>#include <bitset></bitset></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::bitset&lt;4&gt; x { 0b1100 };</code><code></code><code>    std::cout &lt;&lt; x &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; (x &gt;&gt; 1) &lt;&lt; '\n'; // shift right by 1, yielding 0110</code><code>    std::cout &lt;&lt; (x &lt;&lt; 1) &lt;&lt; '\n'; // shift left by 1, yielding 1000</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>1100
0110
1000
</pre><br><h3>What!? Aren’t operator&lt;&lt; and operator&gt;&gt; used for input and output?</h3><p>They sure are.</p><p>Programs today typically do not make much use of the bitwise left and right shift operators to shift bits. Rather, you tend to see the bitwise left shift operator used with std::cout (or other stream objects) to output text. Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <bitset></bitset></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    unsigned int x { 0b0100 };</code><code>    x = x &lt;&lt; 1; // use operator&lt;&lt; for left shift</code><code>    std::cout &lt;&lt; std::bitset&lt;4&gt;{ x } &lt;&lt; '\n'; // use operator&lt;&lt; for output</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>1000
</pre><p>In the above program, how does operator&lt;&lt; know to shift bits in one case and output <em>x</em> in another case? The answer is that std::cout has <strong>overloaded</strong> (provided an alternate definition for) operator&lt;&lt; that does console output rather than bit shifting.</p><p>When the compiler sees that the left operand of operator&lt;&lt; is std::cout, it knows that it should call the version of operator&lt;&lt; that std::cout overloaded to do output. If the left operand is an integral type, then operator&lt;&lt; knows it should do its usual bit-shifting behavior.</p><p>The same applies for operator&gt;&gt;.</p><p>Note that if you’re using operator &lt;&lt; for both output and left shift, parenthesization is required:</p><pre class="language-cpp line-numbers"><code>#include <bitset></bitset></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::bitset&lt;4&gt; x{ 0b0110 };</code><code></code><code>	std::cout &lt;&lt; x &lt;&lt; 1 &lt;&lt; '\n'; // print value of x (0110), then 1</code><code>	std::cout &lt;&lt; (x &lt;&lt; 1) &lt;&lt; '\n'; // print x left shifted by 1 (1100)</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>01101
1100
</pre><p>The first line prints the value of x (0110), and then the literal 1. The second line prints the value of x left-shifted by 1 (1100).</p><p>We will talk more about operator overloading in a future section, including discussion of how to overload operators for your own purposes.</p><br><h3>Bitwise NOT</h3><p>The <span class="cpp-definition">bitwise NOT</span> operator (~) is perhaps the easiest to understand of all the bitwise operators. It simply flips each bit from a 0 to a 1, or vice versa. Note that the result of a <em>bitwise NOT</em> is dependent on what size your data type is.</p><p>Flipping 4 bits:<br>~0100 is 1011</p><p>Flipping 8 bits:<br>~0000 0100 is 1111 1011</p><p>In both the 4-bit and 8-bit cases, we start with the same number (binary 0100 is the same as 0000 0100 in the same way that decimal 7 is the same as 07), but we end up with a different result.</p><p>We can see this in action in the following program:</p><pre class="language-cpp line-numbers"><code>#include <bitset></bitset></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; ~std::bitset&lt;4&gt;{ 0b0100 } &lt;&lt; ' ' &lt;&lt; ~std::bitset&lt;8&gt;{ 0b0100 } &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:<br>1011 11111011</p><br><h3>Bitwise OR</h3><p><span class="cpp-definition">Bitwise OR</span> (|) works much like its <em>logical OR</em> counterpart. However, instead of applying the <em>OR</em> to the operands to produce a single result, <em>bitwise OR</em> applies to each bit! For example, consider the expression <code>0b0101 | 0b0110</code>.</p><p>To do (any) bitwise operations, it is easiest to line the two operands up like this:</p><pre>0 1 0 1 OR
0 1 1 0
</pre><p>and then apply the operation to each <em>column</em> of bits.</p><p>If you remember, <em>logical OR</em> evaluates to <em>true (1)</em> if either the left, right, or both operands are <em>true (1)</em>, and <em>0</em> otherwise. <em>Bitwise OR</em> evaluates to <em>1</em> if either the left, right, or both bits are <em>1</em>, and <em>0</em> otherwise. Consequently, the expression evaluates like this:</p><pre>0 1 0 1 OR
0 1 1 0
-------
0 1 1 1
</pre><p>Our result is 0111 binary.</p><pre class="language-cpp line-numbers"><code>#include <bitset></bitset></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; (std::bitset&lt;4&gt;{ 0b0101 } | std::bitset&lt;4&gt;{ 0b0110 }) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>0111
</pre><p>We can do the same thing to compound OR expressions, such as <code>0b0111 | 0b0011 | 0b0001</code>. If any of the bits in a column are <em>1</em>, the result of that column is <em>1</em>.</p><pre>0 1 1 1 OR
0 0 1 1 OR
0 0 0 1
--------
0 1 1 1
</pre><p>Here’s code for the above:</p><pre class="language-cpp line-numbers"><code>#include <bitset></bitset></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; (std::bitset&lt;4&gt;{ 0b0111 } | std::bitset&lt;4&gt;{ 0b0011 } | std::bitset&lt;4&gt;{ 0b0001 }) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>0111
</pre><br><h3>Bitwise AND</h3><p><span class="cpp-definition">Bitwise AND</span> (&amp;) works similarly to the above. <em>Logical AND</em> evaluates to true if both the left and right operand evaluate to <em>true</em>. <em>Bitwise AND</em> evaluates to <em>true (1)</em> if both bits in the column are <em>1</em>. Consider the expression <code>0b0101 &amp; 0b0110</code>. Lining each of the bits up and applying an AND operation to each column of bits:</p><pre>0 1 0 1 AND
0 1 1 0
--------
0 1 0 0
</pre><pre class="language-cpp line-numbers"><code>#include <bitset></bitset></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; (std::bitset&lt;4&gt;{ 0b0101 } &amp; std::bitset&lt;4&gt;{ 0b0110 }) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>0100
</pre><p>Similarly, we can do the same thing to compound AND expressions, such as <code>0b0001 &amp; 0b0011 &amp; 0b0111</code>. If all of the bits in a column are 1, the result of that column is 1.</p><pre>0 0 0 1 AND
0 0 1 1 AND
0 1 1 1
--------
0 0 0 1
</pre><pre class="language-cpp line-numbers"><code>#include <bitset></bitset></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; (std::bitset&lt;4&gt;{ 0b0001 } &amp; std::bitset&lt;4&gt;{ 0b0011 } &amp; std::bitset&lt;4&gt;{ 0b0111 }) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>0001
</pre><br><h3>Bitwise XOR</h3><p>The last operator is the <span class="cpp-definition">bitwise XOR</span> (^), also known as <span class="cpp-definition">exclusive or</span>.</p><p>When evaluating two operands, XOR evaluates to <em>true (1)</em> if one <em>and only one</em> of its operands is <em>true (1)</em>. If neither or both are true, it evaluates to <em>0</em>. Consider the expression <code>0b0110 ^ 0b0011</code>:</p><pre>0 1 1 0 XOR
0 0 1 1
-------
0 1 0 1
</pre><p>It is also possible to evaluate compound XOR expression column style, such as <code>0b0001 ^ 0b0011 ^ 0b0111</code>. If there are an even number of 1 bits in a column, the result is <em>0</em>. If there are an odd number of 1 bits in a column, the result is <em>1</em>.</p><pre>0 0 0 1 XOR
0 0 1 1 XOR
0 1 1 1
--------
0 1 0 1
</pre><br><h3>Bitwise assignment operators</h3><p>Similar to the arithmetic assignment operators, C++ provides bitwise assignment operators in order to facilitate easy modification of variables.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Operator</th><th>Symbol</th><th>Form</th><th>Operation</th></tr><tr><td>Left shift assignment</td><td>&lt;&lt;=</td><td>x &lt;&lt;= y</td><td>Shift x left by y bits</td></tr><tr><td>Right shift assignment</td><td>&gt;&gt;=</td><td>x &gt;&gt;= y</td><td>Shift x right by y bits</td></tr><tr><td>Bitwise OR assignment</td><td>|=</td><td>x |= y</td><td>Assign x | y to x</td></tr><tr><td>Bitwise AND assignment</td><td>&amp;=</td><td>x &amp;= y</td><td>Assign x &amp; y to x</td></tr><tr><td>Bitwise XOR assignment</td><td>^=</td><td>x ^= y</td><td>Assign x ^ y to x</td></tr></tbody></table></div><p>For example, instead of writing <code>x = x &gt;&gt; 1;</code>, you can write <code>x &gt;&gt;= 1;</code>.</p><pre class="language-cpp line-numbers"><code>#include <bitset></bitset></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::bitset&lt;4&gt; bits { 0b0100 };</code><code>    bits &gt;&gt;= 1;</code><code>    std::cout &lt;&lt; bits &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>0010
</pre><br><h3>Summary</h3><p>Summarizing how to evaluate bitwise operations utilizing the column method:</p><p>When evaluating <em>bitwise OR</em>, if any bit in a column is 1, the result for that column is 1.<br>When evaluating <em>bitwise AND</em>, if all bits in a column are 1, the result for that column is 1.<br>When evaluating <em>bitwise XOR</em>, if there are an odd number of 1 bits in a column, the result for that column is 1.</p><p>In the next lesson, we’ll explore how these operators can be used in conjunction with bit masks to facilitate bit manipulation.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>a) What does 0110 &gt;&gt; 2 evaluate to in binary?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>0110 &gt;&gt; 2 evaluates to 0001</p></div><p>b) What does the following evaluate to in binary: 0011 | 0101?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre>0 0 1 1 OR
0 1 0 1
--------
0 1 1 1
</pre></div><p>c) What does the following evaluate to in binary: 0011 &amp; 0101?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><pre>0 0 1 1 AND
0 1 0 1
--------
0 0 0 1
</pre></div><p>d) What does the following evaluate to in binary (0011 | 0101) &amp; 1001?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><pre>Inside the parenthesis:

0 0 1 1 OR
0 1 0 1
--------
0 1 1 1

Then:

0 1 1 1 AND
1 0 0 1
--------
0 0 0 1
</pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>A bitwise rotation is like a bitwise shift, except that any bits shifted off one end are added back to the other end. For example 0b1001u &lt;&lt; 1 would be 0b0010u, but a left rotate by 1 would result in 0b0011u instead. Implement a function that does a left rotate on a std::bitset&lt;4&gt;. For this one, it’s okay to use test() and set().</p><p>The following code should execute:</p><pre class="language-cpp line-numbers"><code>#include <bitset></bitset></code><code>#include <iostream></iostream></code><code></code><code>// "rotl" stands for "rotate left"</code><code>std::bitset&lt;4&gt; rotl(std::bitset&lt;4&gt; bits)</code><code>{</code><code>// Your code here</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::bitset&lt;4&gt; bits1{ 0b0001 };</code><code>	std::cout &lt;&lt; rotl(bits1) &lt;&lt; '\n';</code><code></code><code>	std::bitset&lt;4&gt; bits2{ 0b1001 };</code><code>	std::cout &lt;&lt; rotl(bits2) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>and print the following:</p><pre>0010
0011
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><pre class="language-cpp line-numbers"><code>#include <bitset></bitset></code><code>#include <iostream></iostream></code><code></code><code>std::bitset&lt;4&gt; rotl(std::bitset&lt;4&gt; bits)</code><code>{</code><code>	const bool leftbit{ bits.test(3) };</code><code></code><code>	bits &lt;&lt;= 1; // do left shift</code><code></code><code>	if (leftbit)</code><code>		bits.set(0);</code><code></code><code>	return bits;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::bitset&lt;4&gt; bits1{ 0b0001 };</code><code>	std::cout &lt;&lt; rotl(bits1) &lt;&lt; '\n';</code><code></code><code>	std::bitset&lt;4&gt; bits2{ 0b1001 };</code><code>	std::cout &lt;&lt; rotl(bits2) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>We have named the function “rotl” rather than “rotateLeft”, because “rotl” is a well-established name in computer science and also the name of the standard function, <a href="https://en.cppreference.com/w/cpp/numeric/rotl"><code>std::rotl</code></a>.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>Extra credit: Redo quiz #2 but don’t use the test and set functions.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><pre class="language-cpp line-numbers"><code>#include <bitset></bitset></code><code>#include <iostream></iostream></code><code></code><code>// h/t to reader Chris for this solution</code><code>std::bitset&lt;4&gt; rotl(std::bitset&lt;4&gt; bits)</code><code>{</code><code>	// bits &lt;&lt; 1 does the left shift</code><code>	// bits &gt;&gt; 3 handle the rotation of the leftmost bit</code><code>	return (bits&lt;&lt;1) | (bits&gt;&gt;3);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::bitset&lt;4&gt; bits1{ 0b0001 };</code><code>	std::cout &lt;&lt; rotl(bits1) &lt;&lt; '\n';</code><code></code><code>	std::bitset&lt;4&gt; bits2{ 0b1001 };</code><code>	std::cout &lt;&lt; rotl(bits2) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">O.3 — Bit manipulation with bitwise operators and bit masks</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson on bitwise operators (<a href="https://www.learncpp.com/cpp-tutorial/bitwise-operators/">O.2 -- Bitwise operators</a>), we discussed how the various bitwise operators apply logical operators to each bit within the operands. Now that we understand how they function, let’s take a look at how they’re more commonly used.</p><br><h3>Bit masks</h3><p>In order to manipulate individual bits (e.g. turn them on or off), we need some way to identify the specific bits we want to manipulate. Unfortunately, the bitwise operators don’t know how to work with bit positions. Instead they work with bit masks.</p><p>A <span class="cpp-definition">bit mask</span> is a predefined set of bits that is used to select which specific bits will be modified by subsequent operations.</p><p>Consider a real-life case where you want to paint a window frame. If you’re not careful, you risk painting not only the window frame, but also the glass itself. You might buy some masking tape and apply it to the glass and any other parts you don’t want painted. Then when you paint, the masking tape blocks the paint from reaching anything you don’t want painted. In the end, only the non-masked parts (the parts you want painted) get painted.</p><p>A bit mask essentially performs the same function for bits -- the bit mask blocks the bitwise operators from touching bits we don’t want modified, and allows access to the ones we do want modified.</p><p>Let’s first explore how to define some simple bit masks, and then we’ll show you how to use them.</p><br><h3>Defining bit masks in C++14</h3><p>The simplest set of bit masks is to define one bit mask for each bit position. We use 0s to mask out the bits we don’t care about, and 1s to denote the bits we want modified.</p><p>Although bit masks can be literals, they’re often defined as symbolic constants so they can be given a meaningful name and easily reused.</p><p>Because C++14 supports binary literals, defining these bit masks is easy:</p><pre class="language-cpp line-numbers"><code>#include <cstdint></cstdint></code><code></code><code>constexpr std::uint8_t mask0{ 0b0000'0001 }; // represents bit 0</code><code>constexpr std::uint8_t mask1{ 0b0000'0010 }; // represents bit 1</code><code>constexpr std::uint8_t mask2{ 0b0000'0100 }; // represents bit 2 </code><code>constexpr std::uint8_t mask3{ 0b0000'1000 }; // represents bit 3</code><code>constexpr std::uint8_t mask4{ 0b0001'0000 }; // represents bit 4</code><code>constexpr std::uint8_t mask5{ 0b0010'0000 }; // represents bit 5</code><code>constexpr std::uint8_t mask6{ 0b0100'0000 }; // represents bit 6</code><code>constexpr std::uint8_t mask7{ 0b1000'0000 }; // represents bit 7</code></pre><p>Now we have a set of symbolic constants that represents each bit position. We can use these to manipulate the bits (which we’ll show how to do in just a moment).</p><br><h3>Defining bit masks in C++11 or earlier</h3><p>Because C++11 doesn’t support binary literals, we have to use other methods to set the symbolic constants. There are two good methods for doing this.</p><p>The first method is to use hexadecimal literals.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We talk about hexadecimal in lesson <a href="https://www.learncpp.com/cpp-tutorial/literals/">4.15 -- Literals</a>.</p></div><p>Here’s how hexadecimal converts to binary:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td>Hexadecimal</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td></tr><tr><td>Binary</td><td>0000</td><td>0001</td><td>0010</td><td>0011</td><td>0100</td><td>0101</td><td>0110</td><td>0111</td><td>1000</td><td>1001</td><td>1010</td><td>1011</td><td>1100</td><td>1101</td><td>1110</td><td>1111</td></tr></tbody></table></div><br>Therefore, we can define bit masks using hexadecimal like this:<pre class="language-cpp line-numbers"><code>constexpr std::uint8_t mask0{ 0x01 }; // hex for 0000 0001</code><code>constexpr std::uint8_t mask1{ 0x02 }; // hex for 0000 0010</code><code>constexpr std::uint8_t mask2{ 0x04 }; // hex for 0000 0100</code><code>constexpr std::uint8_t mask3{ 0x08 }; // hex for 0000 1000</code><code>constexpr std::uint8_t mask4{ 0x10 }; // hex for 0001 0000</code><code>constexpr std::uint8_t mask5{ 0x20 }; // hex for 0010 0000</code><code>constexpr std::uint8_t mask6{ 0x40 }; // hex for 0100 0000</code><code>constexpr std::uint8_t mask7{ 0x80 }; // hex for 1000 0000</code></pre><p>Sometimes leading hexadecimal 0s will be omitted (e.g. instead of <code>0x01</code> you’ll just see <code>0x1</code>). Either way, this can be a little hard to read if you’re not familiar with hexadecimal to binary conversion.</p><p>An easier method is to use the left-shift operator to shift a single bit into the proper location:</p><pre class="language-cpp line-numbers"><code>constexpr std::uint8_t mask0{ 1 &lt;&lt; 0 }; // 0000 0001 </code><code>constexpr std::uint8_t mask1{ 1 &lt;&lt; 1 }; // 0000 0010</code><code>constexpr std::uint8_t mask2{ 1 &lt;&lt; 2 }; // 0000 0100</code><code>constexpr std::uint8_t mask3{ 1 &lt;&lt; 3 }; // 0000 1000</code><code>constexpr std::uint8_t mask4{ 1 &lt;&lt; 4 }; // 0001 0000</code><code>constexpr std::uint8_t mask5{ 1 &lt;&lt; 5 }; // 0010 0000</code><code>constexpr std::uint8_t mask6{ 1 &lt;&lt; 6 }; // 0100 0000</code><code>constexpr std::uint8_t mask7{ 1 &lt;&lt; 7 }; // 1000 0000</code></pre><br><h3>Testing a bit (to see if it is on or off)</h3><p>Now that we have a set of bit masks, we can use these in conjunction with a bit flag variable to manipulate our bit flags.</p><p>To determine if a bit is on or off, we use <em>bitwise AND</em> in conjunction with the bit mask for the appropriate bit:</p><pre class="language-cpp line-numbers"><code>#include <cstdint></cstdint></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	constexpr std::uint8_t mask0{ 0b0000'0001 }; // represents bit 0</code><code>	constexpr std::uint8_t mask1{ 0b0000'0010 }; // represents bit 1</code><code>	constexpr std::uint8_t mask2{ 0b0000'0100 }; // represents bit 2 </code><code>	constexpr std::uint8_t mask3{ 0b0000'1000 }; // represents bit 3</code><code>	constexpr std::uint8_t mask4{ 0b0001'0000 }; // represents bit 4</code><code>	constexpr std::uint8_t mask5{ 0b0010'0000 }; // represents bit 5</code><code>	constexpr std::uint8_t mask6{ 0b0100'0000 }; // represents bit 6</code><code>	constexpr std::uint8_t mask7{ 0b1000'0000 }; // represents bit 7</code><code></code><code>	std::uint8_t flags{ 0b0000'0101 }; // 8 bits in size means room for 8 flags</code><code></code><code>	std::cout &lt;&lt; "bit 0 is " &lt;&lt; ((flags &amp; mask0) ? "on\n" : "off\n");</code><code>	std::cout &lt;&lt; "bit 1 is " &lt;&lt; ((flags &amp; mask1) ? "on\n" : "off\n");</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>bit 0 is on
bit 1 is off
</pre><br><h3>Setting a bit</h3><p>To set (turn on) a bit, we use bitwise OR equals (operator |=) in conjunction with the bit mask for the appropriate bit:</p><pre class="language-cpp line-numbers"><code>#include <cstdint></cstdint></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    constexpr std::uint8_t mask0{ 0b0000'0001 }; // represents bit 0</code><code>    constexpr std::uint8_t mask1{ 0b0000'0010 }; // represents bit 1</code><code>    constexpr std::uint8_t mask2{ 0b0000'0100 }; // represents bit 2 </code><code>    constexpr std::uint8_t mask3{ 0b0000'1000 }; // represents bit 3</code><code>    constexpr std::uint8_t mask4{ 0b0001'0000 }; // represents bit 4</code><code>    constexpr std::uint8_t mask5{ 0b0010'0000 }; // represents bit 5</code><code>    constexpr std::uint8_t mask6{ 0b0100'0000 }; // represents bit 6</code><code>    constexpr std::uint8_t mask7{ 0b1000'0000 }; // represents bit 7</code><code>    </code><code>    std::uint8_t flags{ 0b0000'0101 }; // 8 bits in size means room for 8 flags</code><code></code><code>    std::cout &lt;&lt; "bit 1 is " &lt;&lt; ((flags &amp; mask1) ? "on\n" : "off\n");</code><code></code><code>    flags |= mask1; // turn on bit 1</code><code></code><code>    std::cout &lt;&lt; "bit 1 is " &lt;&lt; ((flags &amp; mask1) ? "on\n" : "off\n");</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>bit 1 is off
bit 1 is on
</pre><p>We can also turn on multiple bits at the same time using <em>Bitwise OR</em>:</p><pre class="language-cpp line-numbers"><code>flags |= (mask4 | mask5); // turn bits 4 and 5 on at the same time</code></pre><br><h3>Resetting a bit</h3><p>To clear a bit (turn off), we use <em>Bitwise AND</em> and <em>Bitwise NOT</em> together:</p><pre class="language-cpp line-numbers"><code>#include <cstdint></cstdint></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    constexpr std::uint8_t mask0{ 0b0000'0001 }; // represents bit 0</code><code>    constexpr std::uint8_t mask1{ 0b0000'0010 }; // represents bit 1</code><code>    constexpr std::uint8_t mask2{ 0b0000'0100 }; // represents bit 2 </code><code>    constexpr std::uint8_t mask3{ 0b0000'1000 }; // represents bit 3</code><code>    constexpr std::uint8_t mask4{ 0b0001'0000 }; // represents bit 4</code><code>    constexpr std::uint8_t mask5{ 0b0010'0000 }; // represents bit 5</code><code>    constexpr std::uint8_t mask6{ 0b0100'0000 }; // represents bit 6</code><code>    constexpr std::uint8_t mask7{ 0b1000'0000 }; // represents bit 7</code><code>    </code><code>    std::uint8_t flags{ 0b0000'0101 }; // 8 bits in size means room for 8 flags</code><code></code><code>    std::cout &lt;&lt; "bit 2 is " &lt;&lt; ((flags &amp; mask2) ? "on\n" : "off\n");</code><code></code><code>    flags &amp;= ~mask2; // turn off bit 2</code><code></code><code>    std::cout &lt;&lt; "bit 2 is " &lt;&lt; ((flags &amp; mask2) ? "on\n" : "off\n");</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>bit 2 is on
bit 2 is off
</pre><p>We can turn off multiple bits at the same time:</p><pre class="language-cpp line-numbers"><code>flags &amp;= ~(mask4 | mask5); // turn bits 4 and 5 off at the same time</code></pre><br><h3>Flipping a bit</h3><p>To toggle a bit state, we use <em>Bitwise XOR</em>:</p><pre class="language-cpp line-numbers"><code>#include <cstdint></cstdint></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    constexpr std::uint8_t mask0{ 0b0000'0001 }; // represents bit 0</code><code>    constexpr std::uint8_t mask1{ 0b0000'0010 }; // represents bit 1</code><code>    constexpr std::uint8_t mask2{ 0b0000'0100 }; // represents bit 2 </code><code>    constexpr std::uint8_t mask3{ 0b0000'1000 }; // represents bit 3</code><code>    constexpr std::uint8_t mask4{ 0b0001'0000 }; // represents bit 4</code><code>    constexpr std::uint8_t mask5{ 0b0010'0000 }; // represents bit 5</code><code>    constexpr std::uint8_t mask6{ 0b0100'0000 }; // represents bit 6</code><code>    constexpr std::uint8_t mask7{ 0b1000'0000 }; // represents bit 7</code><code></code><code>    std::uint8_t flags{ 0b0000'0101 }; // 8 bits in size means room for 8 flags</code><code></code><code>    std::cout &lt;&lt; "bit 2 is " &lt;&lt; ((flags &amp; mask2) ? "on\n" : "off\n");</code><code>    flags ^= mask2; // flip bit 2</code><code>    std::cout &lt;&lt; "bit 2 is " &lt;&lt; ((flags &amp; mask2) ? "on\n" : "off\n");</code><code>    flags ^= mask2; // flip bit 2</code><code>    std::cout &lt;&lt; "bit 2 is " &lt;&lt; ((flags &amp; mask2) ? "on\n" : "off\n");</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>bit 2 is on
bit 2 is off
bit 2 is on
</pre><p>We can flip multiple bits simultaneously:</p><pre class="language-cpp line-numbers"><code>flags ^= (mask4 | mask5); // flip bits 4 and 5 at the same time</code></pre><br><h3>Bit masks and std::bitset</h3><p>std::bitset supports the full set of bitwise operators. So even though it’s easier to use the functions (test, set, reset, and flip) to modify individual bits, you can use bitwise operators and bit masks if you want.</p><p>Why would you want to? The functions only allow you to modify individual bits. The bitwise operators allow you to modify multiple bits at once.</p><pre class="language-cpp line-numbers"><code>#include <cstdint></cstdint></code><code>#include <iostream></iostream></code><code>#include <bitset></bitset></code><code></code><code>int main()</code><code>{</code><code>	constexpr std::bitset&lt;8&gt; mask0{ 0b0000'0001 }; // represents bit 0</code><code>	constexpr std::bitset&lt;8&gt; mask1{ 0b0000'0010 }; // represents bit 1</code><code>	constexpr std::bitset&lt;8&gt; mask2{ 0b0000'0100 }; // represents bit 2 </code><code>	constexpr std::bitset&lt;8&gt; mask3{ 0b0000'1000 }; // represents bit 3</code><code>	constexpr std::bitset&lt;8&gt; mask4{ 0b0001'0000 }; // represents bit 4</code><code>	constexpr std::bitset&lt;8&gt; mask5{ 0b0010'0000 }; // represents bit 5</code><code>	constexpr std::bitset&lt;8&gt; mask6{ 0b0100'0000 }; // represents bit 6</code><code>	constexpr std::bitset&lt;8&gt; mask7{ 0b1000'0000 }; // represents bit 7</code><code></code><code>	std::bitset&lt;8&gt; flags{ 0b0000'0101 }; // 8 bits in size means room for 8 flags</code><code>	std::cout &lt;&lt; "bit 1 is " &lt;&lt; (flags.test(1) ? "on\n" : "off\n");</code><code>	std::cout &lt;&lt; "bit 2 is " &lt;&lt; (flags.test(2) ? "on\n" : "off\n");</code><code></code><code>	flags ^= (mask1 | mask2); // flip bits 1 and 2</code><code>	std::cout &lt;&lt; "bit 1 is " &lt;&lt; (flags.test(1) ? "on\n" : "off\n");</code><code>	std::cout &lt;&lt; "bit 2 is " &lt;&lt; (flags.test(2) ? "on\n" : "off\n");</code><code></code><code>	flags |= (mask1 | mask2); // turn bits 1 and 2 on</code><code>	std::cout &lt;&lt; "bit 1 is " &lt;&lt; (flags.test(1) ? "on\n" : "off\n");</code><code>	std::cout &lt;&lt; "bit 2 is " &lt;&lt; (flags.test(2) ? "on\n" : "off\n");</code><code></code><code>	flags &amp;= ~(mask1 | mask2); // turn bits 1 and 2 off</code><code>	std::cout &lt;&lt; "bit 1 is " &lt;&lt; (flags.test(1) ? "on\n" : "off\n");</code><code>	std::cout &lt;&lt; "bit 2 is " &lt;&lt; (flags.test(2) ? "on\n" : "off\n");</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>bit 1 is off
bit 2 is on
bit 1 is on
bit 2 is off
bit 1 is on
bit 2 is on
bit 1 is off
bit 2 is off
</pre><br><h3>Making bit masks meaningful</h3><p>Naming our bit masks “mask1” or “mask2” tells us what bit is being manipulated, but doesn’t give us any indication of what that bit flag is actually being used for.</p><p>A best practice is to give your bit masks useful names as a way to document the meaning of your bit flags. Here’s an example from a game we might write:</p><pre class="language-cpp line-numbers"><code>#include <cstdint></cstdint></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>        // Define a bunch of physical/emotional states</code><code>	constexpr std::uint8_t isHungry{	1 &lt;&lt; 0 }; // 0000 0001</code><code>	constexpr std::uint8_t isSad{		1 &lt;&lt; 1 }; // 0000 0010</code><code>	constexpr std::uint8_t isMad{		1 &lt;&lt; 2 }; // 0000 0100</code><code>	constexpr std::uint8_t isHappy{		1 &lt;&lt; 3 }; // 0000 1000</code><code>	constexpr std::uint8_t isLaughing{ 	1 &lt;&lt; 4 }; // 0001 0000</code><code>	constexpr std::uint8_t isAsleep{	1 &lt;&lt; 5 }; // 0010 0000</code><code>	constexpr std::uint8_t isDead{		1 &lt;&lt; 6 }; // 0100 0000</code><code>	constexpr std::uint8_t isCrying{	1 &lt;&lt; 7 }; // 1000 0000</code><code></code><code>	std::uint8_t me{}; // all flags/options turned off to start</code><code>	me |= (isHappy | isLaughing); // I am happy and laughing</code><code>	me &amp;= ~isLaughing; // I am no longer laughing</code><code></code><code>	// Query a few states</code><code>	// (we'll use static_cast<bool> to interpret the results as a boolean value)</bool></code><code>	std::cout &lt;&lt; "I am happy? " &lt;&lt; static_cast<bool>(me &amp; isHappy) &lt;&lt; '\n';</bool></code><code>	std::cout &lt;&lt; "I am laughing? " &lt;&lt; static_cast<bool>(me &amp; isLaughing) &lt;&lt; '\n';</bool></code><code></code><code>	return 0;</code><code>}</code></pre><p>Here’s the same example implemented using std::bitset:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <bitset></bitset></code><code></code><code>int main()</code><code>{</code><code>        // Define a bunch of physical/emotional states</code><code>	constexpr std::bitset&lt;8&gt; isHungry{	0b0000'0001 };</code><code>	constexpr std::bitset&lt;8&gt; isSad{		0b0000'0010 };</code><code>	constexpr std::bitset&lt;8&gt; isMad{		0b0000'0100 };</code><code>	constexpr std::bitset&lt;8&gt; isHappy{	0b0000'1000 };</code><code>	constexpr std::bitset&lt;8&gt; isLaughing{	0b0001'0000 };</code><code>	constexpr std::bitset&lt;8&gt; isAsleep{	0b0010'0000 };</code><code>	constexpr std::bitset&lt;8&gt; isDead{	0b0100'0000 };</code><code>	constexpr std::bitset&lt;8&gt; isCrying{	0b1000'0000 };</code><code></code><code></code><code>	std::bitset&lt;8&gt; me{}; // all flags/options turned off to start</code><code>	me |= (isHappy | isLaughing); // I am happy and laughing</code><code>	me &amp;= ~isLaughing; // I am no longer laughing</code><code></code><code>	// Query a few states (we use the any() function to see if any bits remain set)</code><code>	std::cout &lt;&lt; "I am happy? " &lt;&lt; (me &amp; isHappy).any() &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; "I am laughing? " &lt;&lt; (me &amp; isLaughing).any() &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>Two notes here: First, std::bitset doesn’t have a nice function that allows you to query bits using a bit mask. So if you want to use bit masks rather than positional indexes, you’ll have to use <em>Bitwise AND</em> to query bits. Second, we make use of the any() function, which returns true if any bits are set, and false otherwise to see if the bit we queried remains on or off.</p><br><h3>When are bit flags most useful?</h3><p>Astute readers may note that the above examples don’t actually save any memory. 8 booleans would normally take 8 bytes. But the above examples use 9 bytes (8 bytes to define the bit masks, and 1 byte for the flag variable)!</p><p>Bit flags make the most sense when you have many identical flag variables. For example, in the example above, imagine that instead of having one person (me), you had 100. If you used 8 Booleans per person (one for each possible state), you’d use 800 bytes of memory. With bit flags, you’d use 8 bytes for the bit masks, and 100 bytes for the bit flag variables, for a total of 108 bytes of memory -- approximately 8 times less memory.</p><p>For most programs, the amount of memory saved using bit flags is not worth the added complexity. But in programs where there are tens of thousands or even millions of similar objects, using bit flags can reduce memory use substantially. It’s a useful optimization to have in your toolkit if you need it.</p><p>There’s another case where bit flags and bit masks can make sense. Imagine you had a function that could take any combination of 32 different options. One way to write that function would be to use 32 individual Boolean parameters:</p><pre class="language-cpp line-numbers"><code>void someFunction(bool option1, bool option2, bool option3, bool option4, bool option5, bool option6, bool option7, bool option8, bool option9, bool option10, bool option11, bool option12, bool option13, bool option14, bool option15, bool option16, bool option17, bool option18, bool option19, bool option20, bool option21, bool option22, bool option23, bool option24, bool option25, bool option26, bool option27, bool option28, bool option29, bool option30, bool option31, bool option32);</code></pre><p>Hopefully you’d give your parameters more descriptive names, but the point here is to show you how obnoxiously long the parameter list is.</p><p>Then when you wanted to call the function with options 10 and 32 set to true, you’d have to do so like this:</p><pre class="language-cpp line-numbers"><code>someFunction(false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true);</code></pre><p>This is ridiculously difficult to read (is that option 9, 10, or 11 that’s set to true?), and also means you have to remember which argument corresponds to which option (is setting the “edit flag” the 9th, 10th, or 11th parameter?) It may also not be very performant, as every function call has to copy 32 booleans from the caller to the function.</p><p>Instead, if you defined the function using bit flags like this:</p><pre class="language-cpp line-numbers"><code>void someFunction(std::bitset&lt;32&gt; options);</code></pre><p>Then you could use bit flags to pass in only the options you wanted:</p><pre class="language-cpp line-numbers"><code>someFunction(option10 | option32);</code></pre><p>Not only is this much more readable, it’s likely to be more performant as well, since it only involves 2 operations (one <em>Bitwise OR</em> and one parameter copy).</p><p>This is one of the reasons OpenGL, a well regarded 3d graphic library, opted to use bit flag parameters instead of many consecutive Boolean parameters.</p><p>Here’s a sample function call from OpenGL:</p><pre class="language-cpp line-numbers"><code>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the color and the depth buffer</code></pre><p>GL_COLOR_BUFFER_BIT and GL_DEPTH_BUFFER_BIT are bit masks defined as follows (in gl2.h):</p><pre class="language-cpp line-numbers"><code>#define GL_DEPTH_BUFFER_BIT               0x00000100</code><code>#define GL_STENCIL_BUFFER_BIT             0x00000400</code><code>#define GL_COLOR_BUFFER_BIT               0x00004000</code></pre><br><h3>Bit masks involving multiple bits</h3><p>Although bit masks often are used to select a single bit, they can also be used to select multiple bits. Lets take a look at a slightly more complicated example where we do this.</p><p>Color display devices such as TVs and monitors are composed of millions of pixels, each of which can display a dot of color. The dot of color is composed from three beams of light: one red, one green, and one blue (RGB). By varying the intensity of the colors, any color on the color spectrum can be made. Typically, the amount of R, G, and B for a given pixel is represented by an 8-bit unsigned integer. For example, a red pixel would have R=255, G=0, B=0. A purple pixel would have R=255, G=0, B=255. A medium-grey pixel would have R=127, G=127, B=127.</p><p>When assigning color values to a pixel, in addition to R, G, and B, a 4th value called A is often used. “A” stands for “alpha”, and it controls how transparent the color is. If A=0, the color is fully transparent. If A=255, the color is opaque.</p><p>R, G, B, and A are normally stored as a single 32-bit integer, with 8 bits used for each component:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td colspan="4" style="text-align:center">32-bit RGBA value</td></tr><tr><td>bits 31-24</td><td>bits 23-16</td><td>bits 15-8</td><td>bits 7-0</td></tr><tr><td>RRRRRRRR</td><td>GGGGGGGG</td><td>BBBBBBBB</td><td>AAAAAAAA</td></tr><tr><td>red</td><td>green</td><td>blue</td><td>alpha</td></tr></tbody></table></div><p>The following program asks the user to enter a 32-bit hexadecimal value, and then extracts the 8-bit color values for R, G, B, and A.</p><pre class="language-cpp line-numbers"><code>#include <cstdint></cstdint></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	constexpr std::uint32_t redBits{ 0xFF000000 };</code><code>	constexpr std::uint32_t greenBits{ 0x00FF0000 };</code><code>	constexpr std::uint32_t blueBits{ 0x0000FF00 };</code><code>	constexpr std::uint32_t alphaBits{ 0x000000FF };</code><code></code><code>	std::cout &lt;&lt; "Enter a 32-bit RGBA color value in hexadecimal (e.g. FF7F3300): ";</code><code>	std::uint32_t pixel{};</code><code>	std::cin &gt;&gt; std::hex &gt;&gt; pixel; // std::hex allows us to read in a hex value</code><code></code><code>	// use Bitwise AND to isolate red pixels,</code><code>	// then right shift the value into the lower 8 bits</code><code>	std::uint8_t red{ static_cast<std::uint8_t>((pixel &amp; redBits) &gt;&gt; 24) };</std::uint8_t></code><code>	std::uint8_t green{ static_cast<std::uint8_t>((pixel &amp; greenBits) &gt;&gt; 16) };</std::uint8_t></code><code>	std::uint8_t blue{ static_cast<std::uint8_t>((pixel &amp; blueBits) &gt;&gt; 8) };</std::uint8_t></code><code>	std::uint8_t alpha{ static_cast<std::uint8_t>(pixel &amp; alphaBits) };</std::uint8_t></code><code></code><code>	std::cout &lt;&lt; "Your color contains:\n";</code><code>	std::cout &lt;&lt; std::hex; // print the following values in hex</code><code>	std::cout &lt;&lt; static_cast<int>(red)   &lt;&lt; " red\n";</int></code><code>	std::cout &lt;&lt; static_cast<int>(green) &lt;&lt; " green\n";</int></code><code>	std::cout &lt;&lt; static_cast<int>(blue)  &lt;&lt; " blue\n";</int></code><code>	std::cout &lt;&lt; static_cast<int>(alpha) &lt;&lt; " alpha\n";</int></code><code></code><code>	return 0;</code><code>}</code></pre><p>This produces the output:</p><pre>Enter a 32-bit RGBA color value in hexadecimal (e.g. FF7F3300): FF7F3300
Your color contains:
ff red
7f green
33 blue
0 alpha
</pre><p>In the above program, we use a <em>bitwise AND</em> to query the set of 8 bits we’re interested in, and then we <em>right shift</em> them into an 8-bit value so we can print them back as hex values.</p><br><h3>Summary</h3><p>Summarizing how to set, clear, toggle, and query bit flags:</p><p>To query bit states, we use <em>bitwise AND</em>:</p><pre class="language-cpp line-numbers"><code>if (flags &amp; option4) ... // if option4 is set, do something</code></pre><p>To set bits (turn on), we use <em>bitwise OR</em>:</p><pre class="language-cpp line-numbers"><code>flags |= option4; // turn option 4 on.</code><code>flags |= (option4 | option5); // turn options 4 and 5 on.</code></pre><p>To clear bits (turn off), we use <em>bitwise AND</em> with <em>bitwise NOT</em>:</p><pre class="language-cpp line-numbers"><code>flags &amp;= ~option4; // turn option 4 off</code><code>flags &amp;= ~(option4 | option5); // turn options 4 and 5 off</code></pre><p>To flip bit states, we use <em>bitwise XOR</em>:</p><pre class="language-cpp line-numbers"><code>flags ^= option4; // flip option4 from on to off, or vice versa</code><code>flags ^= (option4 | option5); // flip options 4 and 5</code></pre><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Do not use <code>std::bitset</code> in this quiz. We’re only using <code>std::bitset</code> for printing.</p><p>Given the following program:</p><pre class="language-cpp line-numbers"><code>#include <bitset></bitset></code><code>#include <cstdint></cstdint></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    constexpr std::uint8_t option_viewed{ 0x01 };</code><code>    constexpr std::uint8_t option_edited{ 0x02 };</code><code>    constexpr std::uint8_t option_favorited{ 0x04 };</code><code>    constexpr std::uint8_t option_shared{ 0x08 };</code><code>    constexpr std::uint8_t option_deleted{ 0x10 };</code><code></code><code>    std::uint8_t myArticleFlags{ option_favorited };</code><code></code><code>    // ...</code><code></code><code>    std::cout &lt;&lt; std::bitset&lt;8&gt;{ myArticleFlags } &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>a) Write a line of code to set the article as viewed.<br>Expected output:</p><pre>00000101
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>myArticleFlags |= option_viewed;</code></pre></div><p>b) Write a line of code to check if the article was deleted.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>if (myArticleFlags &amp; option_deleted) ...</code></pre></div><p>c) Write a line of code to clear the article as a favorite.<br>Expected output (Assuming you did quiz (a)):</p><pre>00000001
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><pre class="language-cpp line-numbers"><code>myArticleFlags &amp;= ~option_favorited;</code></pre></div><p>1d) Extra credit: why are the following two lines identical?</p><pre class="language-cpp line-numbers"><code>myflags &amp;= ~(option4 | option5); // turn options 4 and 5 off</code><code>myflags &amp;= ~option4 &amp; ~option5; // turn options 4 and 5 off</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><p>De Morgan’s law says that if we distribute a NOT, we need to flip ORs and ANDs to the other. So <code>~(option4 | option5)</code> becomes <code>~option4 &amp; ~option5</code>.</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">O.4 — Converting between binary and decimal</h1></header><div class="entry-content" itemprop="articleBody"><p>Consider a normal decimal number, such as 5623. We intuitively understand that these digits mean (5 * 1000) + (6 * 100) + (2 * 10) + (3 * 1). Because there are 10 decimal numbers, the value of each subsequent digit to the left increases by a factor of 10.</p><p>Binary numbers work the same way, except because there are only 2 binary digits (0 and 1), the value of each digit increases by a factor of 2. Just like commas are often used to make a large decimal number easy to read (e.g. 1,427,435), we often write binary numbers in groups of 4 bits to make them easier to read (e.g. 1101&nbsp;0101).</p><p style="clear:both">The following table counts to 15 in decimal and binary:</p><p></p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Decimal Value</th><th style="text-align:right">Binary Value</th></tr><tr><td>0</td><td style="text-align:right">0</td></tr><tr><td>1</td><td style="text-align:right">1</td></tr><tr><td>2</td><td style="text-align:right">10</td></tr><tr><td>3</td><td style="text-align:right">11</td></tr><tr><td>4</td><td style="text-align:right">100</td></tr><tr><td>5</td><td style="text-align:right">101</td></tr><tr><td>6</td><td style="text-align:right">110</td></tr><tr><td>7</td><td style="text-align:right">111</td></tr><tr><td>8</td><td style="text-align:right">1000</td></tr><tr><td>9</td><td style="text-align:right">1001</td></tr><tr><td>10</td><td style="text-align:right">1010</td></tr><tr><td>11</td><td style="text-align:right">1011</td></tr><tr><td>12</td><td style="text-align:right">1100</td></tr><tr><td>13</td><td style="text-align:right">1101</td></tr><tr><td>14</td><td style="text-align:right">1110</td></tr><tr><td>15</td><td style="text-align:right">1111</td></tr></tbody></table></div><br><h3>Converting binary to decimal</h3><p>In the following examples, we assume that we’re dealing with unsigned integers.</p><p>Consider the 8 bit (1 byte) binary number 0101 1110. Binary 0101 1110 means (0 * 128) + (1 * 64) + (0 * 32) + (1 * 16) + (1 * 8) + (1 * 4) + (1 * 2) + (0 * 1). If we sum up all of these parts, we get the decimal number 64 + 16 + 8 + 4 + 2 = 94.</p><p>Here is the same process in table format. We multiply each binary digit by its digit value (determined by its position). Summing up all these values gives us the total.</p><p>Converting 0101 1110 to decimal:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td>Binary digit</td><td>0&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;</td><td>0&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;</td><td>0&nbsp;&nbsp;</td></tr><tr><td>* Digit value</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td></tr><tr><td>= Total (94)</td><td>0</td><td>64</td><td>0</td><td>16</td><td>8</td><td>4</td><td>2</td><td>0</td></tr></tbody></table></div><p>Let’s convert 1001 0111 to decimal:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td>Binary digit</td><td>1&nbsp;&nbsp;</td><td>0&nbsp;&nbsp;</td><td>0&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;</td><td>0&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;</td></tr><tr><td>* Digit value</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td></tr><tr><td>= Total (151)</td><td>128</td><td>0</td><td>0</td><td>16</td><td>0</td><td>4</td><td>2</td><td>1</td></tr></tbody></table></div><p>1001 0111 binary = 151 in decimal.</p><p>This can easily be extended to 16 or 32 bit binary numbers simply by adding more columns. Note that it’s easiest to start on the right end, and work your way left, multiplying the digit value by 2 as you go.</p><br><h3>Method 1 for converting decimal to binary</h3><p>Converting from decimal to binary is a little more tricky, but still pretty straightforward. There are two good methods to do this.</p><p>The first method involves continually dividing by 2, and writing down the remainders. The binary number is constructed at the end from the remainders, from the bottom up.</p><p>Converting 148 from decimal to binary (using r to denote a remainder):</p><p>148 / 2 = 74 r0<br>74 / 2 = 37 r0<br>37 / 2 = 18 r1<br>18 / 2 = 9 r0<br>9 / 2 = 4 r1<br>4 / 2 = 2 r0<br>2 / 2 = 1 r0<br>1 / 2 = 0 r1</p><p>Writing all of the remainders from the bottom up: 1001 0100</p><p>148 decimal = 1001 0100 binary.</p><p>You can verify this answer by converting the binary back to decimal:</p><p>(1 * 128) + (0 * 64) + (0 * 32) + (1 * 16) + (0 * 8) + (1 * 4) + (0 * 2) + (0 * 1) = 148</p><br><h3>Method 2 for converting decimal to binary</h3><p>The second method involves working backwards to figure out what each of the bits must be. This method can be easier with small binary numbers.</p><p>Consider the decimal number 148 again. What’s the largest power of 2 that’s smaller than 148? 128, so we’ll start there.</p><p>Is 148 &gt;= 128? Yes, so the 128 bit must be 1. 148 - 128 = 20, which means we need to find bits worth 20 more.<br>Is 20 &gt;= 64? No, so the 64 bit must be 0.<br>Is 20 &gt;= 32? No, so the 32 bit must be 0.<br>Is 20 &gt;= 16? Yes, so the 16 bit must be 1. 20 - 16 = 4, which means we need to find bits worth 4 more.</p><p>Is 4 &gt;= 8? No, so the 8 bit must be 0.<br>Is 4 &gt;= 4? Yes, so the 4 bit must be 1. 4 - 4 = 0, which means all the rest of the bits must be 0.</p><p>148 = (1 * 128) + (0 * 64) + (0 * 32) + (1 * 16) + (0 * 8) + (1 * 4) + (0 * 2) + (0 * 1) = 1001 0100</p><p>In table format:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td>Binary number</td><td>1&nbsp;&nbsp;</td><td>0&nbsp;&nbsp;</td><td>0&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;</td><td>0&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;</td><td>0&nbsp;&nbsp;</td><td>0&nbsp;&nbsp;</td></tr><tr><td>* Digit value</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td></tr><tr><td>= Total (148)</td><td>128</td><td>0</td><td>0</td><td>16</td><td>0</td><td>4</td><td>0</td><td>0</td></tr></tbody></table></div><br><h3>Another example</h3><p>Let’s convert 117 to binary using method 1:</p><p>117 / 2 = 58 r1<br>58 / 2 = 29 r0<br>29 / 2 = 14 r1<br>14 / 2 = 7 r0<br>7 / 2 = 3 r1<br>3 / 2 = 1 r1<br>1 / 2 = 0 r1</p><p>Constructing the number from the remainders from the bottom up, 117 = 111 0101 binary</p><p>And using method 2:</p><p>The largest power of 2 less than 117 is 64.</p><p>Is 117 &gt;= 64? Yes, so the 64 bit must be 1. 117 - 64 = 53.<br>Is 53 &gt;= 32? Yes, so the 32 bit must be 1. 53 - 32 = 21.<br>Is 21 &gt;= 16? Yes, so the 16 bit must be 1. 21 - 16 = 5.</p><p>Is 5 &gt;= 8? No, so the 8 bit must be 0.<br>Is 5 &gt;= 4? Yes, so the 4 bit must be 1. 5 - 4 = 1.<br>Is 1 &gt;= 2? No, so the 2 bit must be 0.<br>Is 1 &gt;= 1? Yes, so the 1 bit must be 1.</p><p>117 decimal = 111 0101 binary.</p><br><h3>Adding in binary</h3><p>In some cases (we’ll see one in just a moment), it’s useful to be able to add two binary numbers. Adding binary numbers is surprisingly easy (maybe even easier than adding decimal numbers), although it may seem odd at first because you’re not used to it.</p><p>Consider two small binary numbers:<br>0110 (6 in decimal) +<br>0111 (7 in decimal)</p><p>Let’s add these. First, line them up, as we have above. Then, starting from the right and working left, we add each column of digits, just like we do in a decimal number. However, because a binary digit can only be a 0 or a 1, there are only 4 possibilities:</p><ul><li>0 + 0 = 0</li><li>0 + 1 = 1</li><li>1 + 0 = 1</li><li>1 + 1 = 0, carry a 1 over to the next column</li></ul><p>Let’s do the first column:</p><pre>0110 (6 in decimal) +
0111 (7 in decimal)
----
   1
</pre><p>0 + 1 = 1. Easy.</p><p>Second column:</p><pre> 1
0110 (6 in decimal) +
0111 (7 in decimal)
----
  01
</pre><p>1 + 1 = 0, with a carried one into the next column</p><p>Third column:</p><pre>11
0110 (6 in decimal) +
0111 (7 in decimal)
----
 101
</pre><p>This one is a little trickier. Normally, 1 + 1 = 0, with a carried one into the next column. However, we already have a 1 carried from the previous column, so we need to add 1. Thus, we end up with a 1 in this column, with a 1 carried over to the next column</p><p>Last column:</p><pre>11
0110 (6 in decimal) +
0111 (7 in decimal)
----
1101
</pre><p>0 + 0 = 0, but there’s a carried 1, so we add 1. 1101 = 13 in decimal.</p><p>Now, how do we add 1 to any given binary number (such as 1011 0011)? The same as above, only the bottom number is binary 1.</p><pre>       1  (carry column)
1011 0011 (original binary number)
0000 0001 (1 in binary)
---------
1011 0100
</pre><br><h3>Signed numbers and two’s complement</h3><p>In the above examples, we’ve dealt solely with unsigned integers. In this section, we’ll take a look at how signed numbers (which can be negative) are dealt with.</p><p>Signed integers are typically stored using a method known as <strong>two’s complement</strong>. In two’s complement, the leftmost (most significant) bit is used as the sign bit. A 0 sign bit means the number is positive, and a 1 sign bit means the number is negative.</p><p>Positive signed numbers are represented in binary just like positive unsigned numbers (with the sign bit set to 0).</p><p>Negative signed numbers are represented in binary as the bitwise inverse of the positive number, plus 1.</p><br><h3>Converting decimal to binary (two’s complement)</h3><p>For example, here’s how we represent -5 in binary two’s complement:</p><p>First we figure out the binary representation for 5: 0000 0101<br>Then we invert all of the bits: 1111 1010<br>Then we add 1: 1111 1011</p><p>Converting -76 to binary:</p><p>Positive 76 in binary: 0100 1100<br>Invert all the bits: 1011 0011<br>Add 1: 1011 0100</p><p>Why do we add 1? Consider the number 0. If a negative value was simply represented as the inverse of the positive number, 0 would have two representations: 0000 0000 (positive zero) and 1111 1111 (negative zero). By adding 1, 1111 1111 intentionally overflows and becomes 0000 0000. This prevents 0 from having two representations, and simplifies some of the internal logic needed to do arithmetic with negative numbers.</p><br><h3>Converting binary (two’s complement) to decimal</h3><p>To convert a two’s complement binary number back into decimal, first look at the sign bit.</p><p>If the sign bit is 0, just convert the number as shown for unsigned numbers above.</p><p>If the sign bit is 1, then we invert the bits, add 1, then convert to decimal, then make that decimal number negative (because the sign bit was originally negative).</p><p>For example, to convert 1001 1110 from two’s complement into a decimal number:<br>Given: 1001 1110<br>Invert the bits: 0110 0001<br>Add 1: 0110 0010<br>Convert to decimal: (0 * 128) + (1 * 64) + (1 * 32) + (0 * 16) + (0 * 8) + (0 * 4) + (1 * 2) + (0 * 1) = 64 + 32 + 2 = 98<br>Since the original sign bit was negative, the final value is -98.</p><br><h3>Why types matter</h3><p>Consider the binary value 1011 0100. What value does this represent? You’d probably say 180, and if this were a standard unsigned binary number, you’d be right.</p><p>However, if this value was stored using two’s complement, it would be -76.</p><p>And if the value were encoded some other way, it could be something else entirely.</p><p>So how does C++ know whether to print a variable containing binary 1011 0100 as 180 or -76?</p><p>In case the section title didn’t give it away, this is where types come into play. The type of the variable determines both how a variable’s value is encoded into binary, and decoded back into a value. So if the variable type was an unsigned integer, it would know that 1011 0100 was standard binary, and should be printed as 180. If the variable was a signed integer, it would know that 1011 0100 was encoded using two’s complement (now guaranteed as of C++20), and should be printed as -76.</p><br><h3>What about converting floating point numbers from/to binary?</h3><p>How floating point numbers get converted from/to binary is quite a bit more complicated, and not something you’re likely to ever need to know. However, if you’re curious, see <a href="http://www.tfinley.net/notes/cps104/floating.html">this site</a>, which does a good job of explaining the topic in detail.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Convert 0100 1101 to decimal.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td>Binary digit</td><td>0&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;</td><td>0&nbsp;&nbsp;</td><td>0&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;</td><td>0&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;</td></tr><tr><td>* Digit value</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td></tr><tr><td>= Total (77)</td><td>0</td><td>64</td><td>0</td><td>0</td><td>8</td><td>4</td><td>0</td><td>1</td></tr></tbody></table></div><p>The answer is 77.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>Convert 93 to an 8-bit unsigned binary number. Use both methods above.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>Using method 1:<br>93 / 2 = 46 r1<br>46 / 2 = 23 r0<br>23 / 2 = 11 r1<br>11 / 2 = 5 r1<br>5 / 2 = 2 r1<br>2 / 2 = 1 r0<br>1 / 2 = 0 r1</p><p>Working backwards from the remainders, 101 1101</p><p>Using method 2:<br>The largest power of 2 less than 93 is 64.</p><p>Is 93 &gt;= 64? Yes, so the 64 bit is 1. 93 - 64 = 29.<br>Is 29 &gt;= 32? No, so the 32 bit is 0.<br>Is 29 &gt;= 16? Yes, so the 16 bit is 1. 29 - 16 = 13.<br>Is 13 &gt;= 8? Yes, so the 8 bit is 1. 13 - 8 = 5.<br>Is 5 &gt;= 4? Yes, so the 4 bit is 1. 5 - 4 = 1.<br>Is 1 &gt;= 2? No, so the 2 bit is 0.<br>Is 1 &gt;= 1? Yes, so the 1 bit is 1.</p><p>The answer is 0101 1101.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>Convert -93 to an 8-bit signed binary number (using two’s complement).</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>We already know that 93 is 0101 1101 from the previous answer.<br>For two’s complement, we invert the bits: 1010 0010<br>And add 1: 1010 0011</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #4</p><p>Convert 1010 0010 to an unsigned decimal number.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><p>Working right to left:<br>1010 0010 = (0 * 1) + (1 * 2) + (0 * 4) + (0 * 8) + (0 * 16) + (1 * 32) + (0 * 64) + (1 * 128) = 2 + 32 + 128 = 162.</p><p>The answer is 162.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #5</p><p>Convert 1010 0010 to a signed decimal number (assume two’s complement).</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><p>Since we’re told this number is in two’s complement, we can “undo” the two’s complement by inverting the bits and adding 1.<br>First, start with our binary number: 1010 0010<br>Flip the bits: 0101 1101<br>Add 1: 0101 1110</p><p>Convert to decimal: 64 + 16 + 8 + 4 + 2 = 94<br>Remember that this is a two’s complement #, and the original left bit was negative: -94</p><p>The answer is -94</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #6</p><p>Write a program that asks the user to input a number between 0 and 255. Print this number as an 8-bit binary number (of the form #### ####). Don’t use any bitwise operators. Don’t use <code>std::bitset</code>.</p><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">Hint: Use method 2. Assume the largest power of 2 is 128.</div><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_1'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_1" style="display:none;margin-bottom:1em">Hint: Write a function to test whether your input number is greater than some power of 2. If so, print ‘1’ and return your number minus the power of 2.</div><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int printAndDecrementOne(int x, int pow)</code><code>{</code><code>    std::cout &lt;&lt; '1';</code><code>    return (x - pow);</code><code>}</code><code></code><code>// x is our number to test</code><code>// pow is a power of 2 (e.g. 128, 64, 32, etc...)</code><code>int printAndDecrementBit(int x, int pow)</code><code>{</code><code>    // Test whether our x is greater than some power of 2 and print the bit</code><code>    if (x &gt;= pow)</code><code>        return printAndDecrementOne(x, pow); // If x is greater than our power of 2, subtract the power of 2</code><code></code><code>    // x is less than pow</code><code>    std::cout &lt;&lt; '0';</code><code>    return x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer between 0 and 255: ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    x = printAndDecrementBit(x, 128);</code><code>    x = printAndDecrementBit(x, 64);</code><code>    x = printAndDecrementBit(x, 32);</code><code>    x = printAndDecrementBit(x, 16);</code><code></code><code>    std::cout &lt;&lt; ' ';</code><code></code><code>    x = printAndDecrementBit(x, 8);</code><code>    x = printAndDecrementBit(x, 4);</code><code>    x = printAndDecrementBit(x, 2);</code><code>    x = printAndDecrementBit(x, 1);</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">6.1 — Compound statements (blocks)</h1></header><div class="entry-content" itemprop="articleBody"><p>A <span class="cpp-definition">compound statement</span> (also called a <span class="cpp-definition">block</span>, or <span class="cpp-definition">block statement</span>) is a group of <em>zero or more statements</em> that is treated by the compiler as if it were a single statement.</p><p>Blocks begin with a <code>{</code> symbol, end with a <code>}</code> symbol, with the statements to be executed being placed in between. Blocks can be used anywhere a single statement is allowed. No semicolon is needed at the end of a block.</p><p>You have already seen an example of blocks when writing functions, as the function body is a block:</p><pre class="language-cpp line-numbers"><code>int add(int x, int y)</code><code>{ // start block</code><code>    return x + y;</code><code>} // end block (no semicolon)</code><code></code><code>int main()</code><code>{ // start block</code><code></code><code>    // multiple statements</code><code>    int value {}; // this is initialization, not a block</code><code>    add(3, 4);</code><code></code><code>    return 0;</code><code></code><code>} // end block (no semicolon)</code></pre><br><h3>Blocks inside other blocks</h3><p>Although functions can’t be nested inside other functions, blocks <em>can be</em> nested inside other blocks:</p><pre class="language-cpp line-numbers"><code>int add(int x, int y)</code><code>{ // block</code><code>    return x + y;</code><code>} // end block</code><code></code><code>int main()</code><code>{ // outer block</code><code></code><code>    // multiple statements</code><code>    int value {};</code><code></code><code>    { // inner/nested block</code><code>        add(3, 4);</code><code>    } // end inner/nested block</code><code></code><code>    return 0;</code><code></code><code>} // end outer block</code></pre><p>When blocks are nested, the enclosing block is typically called the <span class="cpp-definition">outer block</span> and the enclosed block is called the <span class="cpp-definition">inner block</span> or <span class="cpp-definition">nested block</span>.</p><br><h3>Using blocks to execute multiple statements conditionally</h3><p>One of the most common use cases for blocks is in conjunction with <code>if statements</code>. By default, an <code>if statement</code> executes a single statement if the condition evaluates to <code>true</code>. However, we can replace this single statement with a block of statements if we want multiple statements to execute when the condition evaluates to <code>true</code>.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{ // start of outer block</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    int value {};</code><code>    std::cin &gt;&gt; value;</code><code>    </code><code>    if (value &gt;= 0)</code><code>    { // start of nested block</code><code>        std::cout &lt;&lt; value &lt;&lt; " is a positive integer (or zero)\n";</code><code>        std::cout &lt;&lt; "Double this number is " &lt;&lt; value * 2 &lt;&lt; '\n';</code><code>    } // end of nested block</code><code>    else</code><code>    { // start of another nested block</code><code>        std::cout &lt;&lt; value &lt;&lt; " is a negative integer\n";</code><code>        std::cout &lt;&lt; "The positive of this number is " &lt;&lt; -value &lt;&lt; '\n';</code><code>    } // end of another nested block</code><code></code><code>    return 0;</code><code>} // end of outer block</code></pre><p>If the user enters the number 3, this program prints:</p><pre>Enter an integer: 3
3 is a positive integer (or zero)
Double this number is 6
</pre><p>If the user enters the number -4, this program prints:</p><pre>Enter an integer: -4
-4 is a negative integer
The positive of this number is 4
</pre><br><h3>Block nesting levels</h3><p>It is even possible to put blocks inside of blocks inside of blocks:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{ // block 1, nesting level 1</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    int value {};</code><code>    std::cin &gt;&gt; value;</code><code>    </code><code>    if (value &gt;  0)</code><code>    { // block 2, nesting level 2</code><code>        if ((value % 2) == 0)</code><code>        { // block 3, nesting level 3</code><code>            std::cout &lt;&lt; value &lt;&lt; " is positive and even\n";</code><code>        }</code><code>        else</code><code>        { // block 4, also nesting level 3</code><code>            std::cout &lt;&lt; value &lt;&lt; " is positive and odd\n";</code><code>        }</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>The <span class="cpp-definition">nesting level</span> (also called the <span class="cpp-definition">nesting depth</span>) of a function is the maximum number of nested blocks you can be inside at any point in the function (including the outer block). In the above function, there are 4 blocks, but the nesting level is 3 since in this program you can never be inside more than 3 blocks at any point.</p><p>The C++ standard says that C++ compilers should support 256 levels of nesting -- however not all do (e.g. as of the time of writing, Visual Studio supports less).</p><p>It’s a good idea to keep your nesting level to 3 or less. Just as overly-long functions are good candidates for refactoring (breaking into smaller functions), overly-nested blocks are hard to read and are good candidates for refactoring (with the most-nested blocks becoming separate functions).</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Keep the nesting level of your functions to 3 or less. If your function has a need for more nested levels, consider refactoring your function into sub-functions.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">6.2 — User-defined namespaces and the scope resolution operator</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/naming-collisions-and-an-introduction-to-namespaces/">2.9 -- Naming collisions and an introduction to namespaces</a>, we introduced the concept of <code>naming collisions</code> and <code>namespaces</code>. As a reminder, a naming collision occurs when two identical identifiers are introduced into the same scope, and the compiler can’t disambiguate which one to use. When this happens, compiler or linker will produce an error because they do not have enough information to resolve the ambiguity. As programs become larger, the number of identifiers increases linearly, which in turn causes the probability of a naming collision occurring to increase exponentially.</p><p>Let’s revisit an example of a naming collision, and then show how we can resolve it using namespaces. In the following example, <code>foo.cpp</code> and <code>goo.cpp</code> are the source files that contain functions that do different things but have the same name and parameters.</p><p style="clear:both"></p><p></p><p>foo.cpp:</p><pre class="language-cpp line-numbers"><code>// This doSomething() adds the value of its parameters</code><code>int doSomething(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code></pre><p>goo.cpp:</p><pre class="language-cpp line-numbers"><code>// This doSomething() subtracts the value of its parameters</code><code>int doSomething(int x, int y)</code><code>{</code><code>    return x - y;</code><code>}</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int doSomething(int x, int y); // forward declaration for doSomething</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; doSomething(4, 3) &lt;&lt; '\n'; // which doSomething will we get?</code><code>    return 0;</code><code>}</code></pre><p>If this project contains only <code>foo.cpp</code> <em>or</em> <code>goo.cpp</code> (but not both), it will compile and run without incident. However, by compiling both into the same program, we have now introduced two different functions with the same name and parameters into the same scope (the global scope), which causes a naming collision. As a result, the linker will issue an error:</p><pre>goo.cpp:3: multiple definition of `doSomething(int, int)'; foo.cpp:3: first defined here
</pre><p>Note that this error happens at the point of redefinition, so it doesn’t matter whether function <code>doSomething</code> is ever called.</p><p>One way to resolve this would be to rename one of the functions, so the names no longer collide. But this would also require changing the names of all the function calls, which can be a pain, and is subject to error. A better way to avoid collisions is to put your functions into your own namespaces. For this reason the standard library was moved into the <code>std</code> namespace.</p><br><h3>Defining your own namespaces</h3><p>C++ allows us to define our own namespaces via the <code>namespace</code> keyword. Namespaces that you create for your own declarations are called <span class="cpp-definition">user-defined namespaces</span>. Namespaces provided by C++ (such as the <code>global namespace</code>) or by libraries (such as <code>namespace std</code>) are not considered user-defined namespaces.</p><p>Namespace identifiers are typically non-capitalized.</p><p>Here is an example of the files in the prior example rewritten using namespaces:</p><p>foo.cpp:</p><pre class="language-cpp line-numbers"><code>namespace foo // define a namespace named foo</code><code>{</code><code>    // This doSomething() belongs to namespace foo</code><code>    int doSomething(int x, int y)</code><code>    {</code><code>        return x + y;</code><code>    }</code><code>}</code></pre><p>goo.cpp:</p><pre class="language-cpp line-numbers"><code>namespace goo // define a namespace named goo</code><code>{</code><code>    // This doSomething() belongs to namespace goo</code><code>    int doSomething(int x, int y)</code><code>    {</code><code>        return x - y;</code><code>    }</code><code>}</code></pre><p>Now <code>doSomething()</code> inside of <code>foo.cpp</code> is inside the <code>foo</code> namespace, and the <code>doSomething()</code> inside of <code>goo.cpp</code> is inside the <code>goo</code> namespace. Let’s see what happens when we recompile our program.</p><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>int doSomething(int x, int y); // forward declaration for doSomething</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; doSomething(4, 3) &lt;&lt; '\n'; // which doSomething will we get?</code><code>    return 0;</code><code>}</code></pre><p>The answer is that we now get another error!</p><pre>ConsoleApplication1.obj : error LNK2019: unresolved external symbol "int __cdecl doSomething(int,int)" (<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="dbe4bfb488b4b6beafb3b2b5bc9b">[email&nbsp;protected]</a>@<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1e475f5656565e44">[email&nbsp;protected]</a>) referenced in function _main
</pre><p>In this case, the compiler was satisfied (by our forward declaration), but the linker could not find a definition for <code>doSomething</code> in the global namespace. This is because both of our versions of <code>doSomething</code> are no longer in the global namespace!</p><p>There are two different ways to tell the compiler which version of <code>doSomething()</code> to use, via the <code>scope resolution operator</code>, or via <code>using statements</code> (which we’ll discuss in a later lesson in this chapter).</p><p>For the subsequent examples, we’ll collapse our examples down to a one-file solution for ease of reading.</p><br><h3>Accessing a namespace with the scope resolution operator (::)</h3><p>The best way to tell the compiler to look in a particular namespace for an identifier is to use the <span class="cpp-definition">scope resolution operator</span> (::). The scope resolution operator tells the compiler that the identifier specified by the right-hand operand should be looked for in the scope of the left-hand operand.</p><p>Here is an example of using the scope resolution operator to tell the compiler that we explicitly want to use the version of <code>doSomething()</code> that lives in the <code>foo</code> namespace:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>namespace foo // define a namespace named foo</code><code>{</code><code>    // This doSomething() belongs to namespace foo</code><code>    int doSomething(int x, int y)</code><code>    {</code><code>        return x + y;</code><code>    }</code><code>}</code><code></code><code>namespace goo // define a namespace named goo</code><code>{</code><code>    // This doSomething() belongs to namespace goo</code><code>    int doSomething(int x, int y)</code><code>    {</code><code>        return x - y;</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; foo::doSomething(4, 3) &lt;&lt; '\n'; // use the doSomething() that exists in namespace foo</code><code>    return 0;</code><code>}</code></pre><p>This produces the expected result:</p><pre>7
</pre><p>If we wanted to use the version of <code>doSomething()</code> that lives in <code>goo</code> instead:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>namespace foo // define a namespace named foo</code><code>{</code><code>    // This doSomething() belongs to namespace foo</code><code>    int doSomething(int x, int y)</code><code>    {</code><code>        return x + y;</code><code>    }</code><code>}</code><code></code><code>namespace goo // define a namespace named goo</code><code>{</code><code>    // This doSomething() belongs to namespace goo</code><code>    int doSomething(int x, int y)</code><code>    {</code><code>        return x - y;</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; goo::doSomething(4, 3) &lt;&lt; '\n'; // use the doSomething() that exists in namespace goo</code><code>    return 0;</code><code>}</code></pre><p>This produces the result:</p><pre>1
</pre><p>The scope resolution operator is great because it allows us to <em>explicitly</em> pick which namespace we want to look in, so there’s no potential ambiguity. We can even do the following:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>namespace foo // define a namespace named foo</code><code>{</code><code>    // This doSomething() belongs to namespace foo</code><code>    int doSomething(int x, int y)</code><code>    {</code><code>        return x + y;</code><code>    }</code><code>}</code><code></code><code>namespace goo // define a namespace named goo</code><code>{</code><code>    // This doSomething() belongs to namespace goo</code><code>    int doSomething(int x, int y)</code><code>    {</code><code>        return x - y;</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; foo::doSomething(4, 3) &lt;&lt; '\n'; // use the doSomething() that exists in namespace foo</code><code>    std::cout &lt;&lt; goo::doSomething(4, 3) &lt;&lt; '\n'; // use the doSomething() that exists in namespace goo</code><code>    return 0;</code><code>}</code></pre><p>This produces the result:</p><pre>7
1
</pre><br><h3>Using the scope resolution operator with no name prefix</h3><p>The scope resolution operator can also be used in front of an identifier without providing a namespace name (e.g. <code>::doSomething</code>). In such a case, the identifier (e.g. <code>doSomething</code>) is looked for in the global namespace.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print() // this print lives in the global namespace</code><code>{</code><code>	std::cout &lt;&lt; " there\n";</code><code>}</code><code></code><code>namespace foo</code><code>{</code><code>	void print() // this print lives in the foo namespace</code><code>	{</code><code>		std::cout &lt;&lt; "Hello";</code><code>	}</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	foo::print(); // call print() in foo namespace</code><code>	::print(); // call print() in global namespace (same as just calling print() in this case)</code><code></code><code>	return 0;</code><code>}</code></pre><p>In the above example, the <code>::print()</code> performs the same as if we’d called <code>print()</code> with no scope resolution, so use of the scope resolution operator is superfluous in this case. But the next example will show a case where the scope resolution operator with no namespace can be useful.</p><br><h3>Identifier resolution from within a namespace</h3><p>If an identifier inside a namespace is used and no scope resolution is provided, the compiler will first try to find a matching declaration in that same namespace. If no matching identifier is found, the compiler will then check each containing namespace in sequence to see if a match is found, with the global namespace being checked last.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print() // this print lives in the global namespace</code><code>{</code><code>	std::cout &lt;&lt; " there\n";</code><code>}</code><code></code><code>namespace foo</code><code>{</code><code>	void print() // this print lives in the foo namespace</code><code>	{</code><code>		std::cout &lt;&lt; "Hello";</code><code>	}</code><code></code><code>	void printHelloThere()</code><code>	{</code><code>		print(); // calls print() in foo namespace</code><code>		::print(); // calls print() in global namespace</code><code>	}</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	foo::printHelloThere();</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>Hello there
</pre><p>In the above example, <code>print()</code> is called with no scope resolution provided. Because this use of <code>print()</code> is inside the <code>foo</code> namespace, the compiler will first see if a declaration for <code>foo::print()</code> can be found. Since one exists, <code>foo::print()</code> is called.</p><p>If <code>foo::print()</code> had not been found, the compiler would have checked the containing namespace (in this case, the global namespace) to see if it could match a <code>print()</code> there.</p><p>Note that we also make use of the scope resolution operator with no namespace (<code>::print()</code>) to explicitly call the global version of <code>print()</code>.</p><br><h3>Multiple namespace blocks are allowed</h3><p>It’s legal to declare namespace blocks in multiple locations (either across multiple files, or multiple places within the same file). All declarations within the namespace are considered part of the namespace.</p><p>circle.h:</p><pre class="language-cpp line-numbers"><code>#ifndef CIRCLE_H</code><code>#define CIRCLE_H</code><code></code><code>namespace basicMath</code><code>{</code><code>    constexpr double pi{ 3.14 };</code><code>}</code><code></code><code>#endif</code></pre><p>growth.h:</p><pre class="language-cpp line-numbers"><code>#ifndef GROWTH_H</code><code>#define GROWTH_H</code><code></code><code>namespace basicMath</code><code>{</code><code>    // the constant e is also part of namespace basicMath</code><code>    constexpr double e{ 2.7 };</code><code>}</code><code></code><code>#endif</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include "circle.h" // for basicMath::pi</code><code>#include "growth.h" // for basicMath::e</code><code></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; basicMath::pi &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; basicMath::e &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This works exactly as you would expect:</p><pre>3.14
2.7
</pre><p>The standard library makes extensive use of this feature, as each standard library header file contains its declarations inside a <code>namespace std</code> block contained within that header file. Otherwise the entire standard library would have to be defined in a single header file!</p><p>Note that this capability also means you could add your own functionality to the <code>std</code> namespace. Doing so causes undefined behavior most of the time, because the <code>std</code> namespace has a special rule, prohibiting extension from user code.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Do not add custom functionality to the std namespace.</p></div><p>When you separate your code into multiple files, you’ll have to use a namespace in the header and source file.</p><p>add.h</p><pre class="language-cpp line-numbers"><code>#ifndef ADD_H</code><code>#define ADD_H</code><code></code><code>namespace basicMath</code><code>{</code><code>    // function add() is part of namespace basicMath</code><code>    int add(int x, int y);</code><code>}</code><code></code><code>#endif</code></pre><p>add.cpp</p><pre class="language-cpp line-numbers"><code>#include "add.h"</code><code></code><code>namespace basicMath</code><code>{</code><code>    // define the function add()</code><code>    int add(int x, int y)</code><code>    {</code><code>        return x + y;</code><code>    }</code><code>}</code></pre><p>main.cpp</p><pre class="language-cpp line-numbers"><code>#include "add.h" // for basicMath::add()</code><code></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; basicMath::add(4, 3) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>If the namespace is omitted in the source file, the linker won’t find a definition of <code>basicMath::add</code>, because the source file only defines <code>add</code> (global namespace). If the namespace is omitted in the header file, “main.cpp” won’t be able to use <code>basicMath::add</code>, because it only sees a declaration for <code>add</code> (global namespace).</p><br><h3>Nested namespaces</h3><p>Namespaces can be nested inside other namespaces. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>namespace foo</code><code>{</code><code>    namespace goo // goo is a namespace inside the foo namespace</code><code>    {</code><code>        int add(int x, int y)</code><code>        {</code><code>            return x + y;</code><code>        }</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; foo::goo::add(1, 2) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>Note that because namespace <code>goo</code> is inside of namespace <code>foo</code>, we access <code>add</code> as <code>foo::goo::add</code>.</p><p>Since C++17, nested namespaces can also be declared this way:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>namespace foo::goo // goo is a namespace inside the foo namespace (C++17 style)</code><code>{</code><code>  int add(int x, int y)</code><code>  {</code><code>    return x + y;</code><code>  }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; foo::goo::add(1, 2) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><br><h3>Namespace aliases</h3><p>Because typing the qualified name of a variable or function inside a nested namespace can be painful, C++ allows you to create <span class="cpp-definition">namespace aliases</span>, which allow us to temporarily shorten a long sequence of namespaces into something shorter:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>namespace foo::goo</code><code>{</code><code>    int add(int x, int y)</code><code>    {</code><code>        return x + y;</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    namespace active = foo::goo; // active now refers to foo::goo</code><code></code><code>    std::cout &lt;&lt; active::add(1, 2) &lt;&lt; '\n'; // This is really foo::goo::add()</code><code></code><code>    return 0;</code><code>} // The active alias ends here</code></pre><p>One nice advantage of namespace aliases: If you ever want to move the functionality within <code>foo::goo</code> to a different place, you can just update the <code>active</code> alias to reflect the new destination, rather than having to find/replace every instance of <code>foo::goo</code>.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code> </code><code>namespace foo::goo</code><code>{</code><code>}</code><code></code><code>namespace v2</code><code>{</code><code>    int add(int x, int y)</code><code>    {</code><code>        return x + y;</code><code>    }</code><code>}</code><code> </code><code>int main()</code><code>{</code><code>    namespace active = v2; // active now refers to v2</code><code> </code><code>    std::cout &lt;&lt; active::add(1, 2) &lt;&lt; '\n'; // We don't have to change this</code><code> </code><code>    return 0;</code><code>}</code></pre><p>It’s worth noting that namespaces in C++ were not originally designed as a way to implement an information hierarchy -- they were designed primarily as a mechanism for preventing naming collisions. As evidence of this, note that the entirety of the standard library lives under the singular namespace <code>std::</code> (with some nested namespaces used for newer library features). Some newer languages (such as C#) differ from C++ in this regard.</p><p>In general, you should avoid deeply nested namespaces.</p><br><h3>When you should use namespaces</h3><p>In applications, namespaces can be used to separate application-specific code from code that might be reusable later (e.g. math functions). For example, physical and math functions could go into one namespace (e.g. <code>math::</code>). Language and localization functions in another (e.g. <code>lang::</code>).</p><p>When you write a library or code that you want to distribute to others, always place your code inside a namespace. The code your library is used in may not follow best practices -- in such a case, if your library’s declarations aren’t in a namespace, there’s an elevated chance for naming conflicts to occur. As an additional advantage, placing library code inside a namespace also allows the user to see the contents of your library by using their editor’s auto-complete and suggestion feature.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">6.3 — Local variables</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/">2.5 -- Introduction to local scope</a>, we introduced <code>local variables</code>, which are variables that are defined inside a function (including function parameters).</p><p>It turns out that C++ actually doesn’t have a single attribute that defines a variable as being a local variable. Instead, local variables have several different properties that differentiate how local variables behave from other kinds of (non-local) variables. We’ll explore these properties in this and upcoming lessons.</p><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/">2.5 -- Introduction to local scope</a>, we also introduced the concept of scope. An identifier’s <code>scope</code> determines where an identifier can be accessed within the source code. When an identifier can be accessed, we say it is <code>in scope</code>. When an identifier can not be accessed, we say it is <code>out of scope</code>. Scope is a compile-time property, and trying to use an identifier when it is out of scope will result in a compile error.</p><br><h3>Local variables have block scope</h3><p>Local variables have <span class="cpp-definition">block scope</span>, which means they are <em>in scope</em> from their point of definition to the end of the block they are defined within.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>Please review lesson <a href="https://www.learncpp.com/cpp-tutorial/compound-statements-blocks/">6.1 -- Compound statements (blocks)</a> if you need a refresher on blocks.</p></div><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int i { 5 }; // i enters scope here</code><code>    double d { 4.0 }; // d enters scope here</code><code></code><code>    return 0;</code><code>} // d and i go out of scope here</code></pre><p>Although function parameters are not defined inside the function body, for typical functions they can be considered to be part of the scope of the function body block.</p><pre class="language-cpp line-numbers"><code>int max(int x, int y) // x and y enter scope here</code><code>{</code><code>    // assign the greater of x or y to max</code><code>    int max{ (x &gt; y) ? x : y }; // max enters scope here</code><code></code><code>    return max;</code><code>} // max, y, and x leave scope here</code></pre><br><h3>All variable names within a scope must be unique</h3><p>Variable names must be unique within a given scope, otherwise any reference to the name will be ambiguous. Consider the following program:</p><pre class="language-cpp line-numbers"><code>void someFunction(int x)</code><code>{</code><code>    int x{}; // compilation failure due to name collision with function parameter</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    return 0;</code><code>}</code></pre><p>The above program doesn’t compile because the variable <code>x</code> defined inside the function body and the function parameter <code>x</code> have the same name and both are in the same block scope.</p><br><h3>Local variables have automatic storage duration</h3><p>A variable’s <span class="cpp-definition">storage duration</span> (usually just called <span class="cpp-definition">duration</span>) determines what rules govern when and how a variable will be created and destroyed. In most cases, a variable’s storage duration directly determines its <code>lifetime</code>.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We discuss what a lifetime is in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/">2.5 -- Introduction to local scope</a>.</p></div><p>For example, local variables have <span class="cpp-definition">automatic storage duration</span>, which means they are created at the point of definition and destroyed at the end of the block they are defined in. For example:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int i { 5 }; // i created and initialized here</code><code>    double d { 4.0 }; // d created and initialized here</code><code></code><code>    return 0;</code><code>} // d and i are destroyed here</code></pre><p>For this reason, local variables are sometimes called <span class="cpp-definition">automatic variables</span>.</p><br><h3>Local variables in nested blocks</h3><p>Local variables can be defined inside nested blocks. This works identically to local variables in function body blocks:</p><pre class="language-cpp line-numbers"><code>int main() // outer block</code><code>{</code><code>    int x { 5 }; // x enters scope and is created here</code><code></code><code>    { // nested block</code><code>        int y { 7 }; // y enters scope and is created here</code><code>    } // y goes out of scope and is destroyed here</code><code></code><code>    // y can not be used here because it is out of scope in this block</code><code></code><code>    return 0;</code><code>} // x goes out of scope and is destroyed here</code></pre><p>In the above example, variable <code>y</code> is defined inside a nested block. Its scope is limited from its point of definition to the end of the nested block, and its lifetime is the same. Because the scope of variable <code>y</code> is limited to the inner block in which it is defined, it’s not accessible anywhere in the outer block.</p><p>Note that nested blocks are considered part of the scope of the outer block in which they are defined. Consequently, variables defined in the outer block <em>can</em> be seen inside a nested block:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{ // outer block</code><code></code><code>    int x { 5 }; // x enters scope and is created here</code><code></code><code>    { // nested block</code><code>        int y { 7 }; // y enters scope and is created here</code><code></code><code>        // x and y are both in scope here</code><code>        std::cout &lt;&lt; x &lt;&lt; " + " &lt;&lt; y &lt;&lt; " = " &lt;&lt; x + y &lt;&lt; '\n';</code><code>    } // y goes out of scope and is destroyed here</code><code></code><code>    // y can not be used here because it is out of scope in this block</code><code></code><code>    return 0;</code><code>} // x goes out of scope and is destroyed here</code></pre><br><h3>Local variables have no linkage</h3><p>Identifiers have another property named <code>linkage</code>. An identifier’s <span class="cpp-definition">linkage</span> determines whether other declarations of that name refer to the same object or not.</p><p>Local variables have <code>no linkage</code>, which means that each declaration refers to a unique object. For example:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int x { 2 }; // local variable, no linkage</code><code></code><code>    {</code><code>        int x { 3 }; // this identifier x refers to a different object than the previous x</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>Scope and linkage may seem somewhat similar. However, scope defines where a single declaration can be seen and used. Linkage defines whether multiple declarations refer to the same object or not.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We discuss what happens when variables with the same name appear in nested blocks in lesson <a href="https://www.learncpp.com/cpp-tutorial/variable-shadowing-name-hiding/">6.5 -- Variable shadowing (name hiding)</a>.</p></div><p>Linkage isn’t very interesting in the context of local variables, but we’ll talk about it more in the next few lessons.</p><br><h3>Variables should be defined in the most limited scope</h3><p>If a variable is only used within a nested block, it should be defined inside that nested block:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    // do not define y here</code><code></code><code>    {</code><code>        // y is only used inside this block, so define it here</code><code>        int y { 5 };</code><code>        std::cout &lt;&lt; y &lt;&lt; '\n';</code><code>    }</code><code></code><code>    // otherwise y could still be used here, where it's not needed</code><code></code><code>    return 0;</code><code>}</code></pre><p>By limiting the scope of a variable, you reduce the complexity of the program because the number of active variables is reduced. Further, it makes it easier to see where variables are used (or aren’t used). A variable defined inside a block can only be used within that block (or nested blocks). This can make the program easier to understand.</p><p>If a variable is needed in an outer block, it needs to be declared in the outer block:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int y { 5 }; // we're declaring y here because we need it in this outer block later</code><code></code><code>    {</code><code>        int x{};</code><code>        std::cin &gt;&gt; x;</code><code></code><code>        // if we declared y here, immediately before its actual first use...</code><code>        if (x == 4)</code><code>            y = 4;</code><code>    } // ... it would be destroyed here</code><code></code><code>    std::cout &lt;&lt; y; // and we need y to exist here</code><code></code><code>    return 0;</code><code>}</code></pre><p>The above example shows one of the rare cases where you may need to declare a variable well before its first use.</p><p>New developers sometimes wonder whether it’s worth creating a nested block just to intentionally limit a variable’s scope (and force it to go out of scope / be destroyed early). Doing so makes that variable simpler, but the overall function becomes longer and more complex as a result. The tradeoff generally isn’t worth it. If creating a nested block seems useful to intentionally limit the scope of a chunk of code, that code might be better to put in a separate function instead.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Define variables in the most limited existing scope. Avoid creating new blocks whose only purpose is to limit the scope of variables.</p></div><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Write a program that asks the user to enter two integers, one named <code>smaller</code>, the other named <code>larger</code>. If the user enters a smaller value for the second integer, use a block and a temporary variable to swap the smaller and larger values. Then print the values of the <code>smaller</code> and <code>larger</code> variables. Add comments to your code indicating where each variable dies. Note: When you print the values, <code>smaller</code> should hold the smaller input and <code>larger</code> the larger input, no matter which order they were entered in.</p><p>The program output should match the following:</p><pre>Enter an integer: 4
Enter a larger integer: 2
Swapping the values
The smaller value is 2
The larger value is 4
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    int smaller{};</code><code>    std::cin &gt;&gt; smaller;</code><code></code><code>    std::cout &lt;&lt; "Enter a larger integer: ";</code><code>    int larger{};</code><code>    std::cin &gt;&gt; larger;</code><code></code><code>    // if user did it wrong</code><code>    if (smaller &gt; larger)</code><code>    {</code><code>        // swap values of smaller and larger</code><code>        std::cout &lt;&lt; "Swapping the values\n";</code><code></code><code>        int temp{ larger };</code><code>        larger = smaller;</code><code>        smaller = temp;</code><code>    } // temp dies here</code><code></code><code>    std::cout &lt;&lt; "The smaller value is: " &lt;&lt; smaller &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "The larger value is: " &lt;&lt; larger &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>} // smaller and larger die here</code></pre><p>In the future, you can use <code>std::swap()</code> from the <code><utility></utility></code> header to swap the values of two variables. For example</p><pre class="language-cpp line-numbers"><code>int temp{ larger };</code><code>larger = smaller;</code><code>smaller = temp;</code><code></code><code>// is the same as</code><code>std::swap(larger, smaller);</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>What’s the difference between a variable’s scope, duration, and lifetime? By default, what kind of scope and duration do local variables have (and what do those mean)?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>A variable’s scope determines where the variable is accessible. Duration defines the rules that govern when a variable is created and destroyed. A variable’s lifetime is the actual time between its creation and destruction.</p><p>Local variables have block scope, which means they can be accessed inside the block in which they are defined.</p><p>Local variables have automatic duration, which means they are created at the point of definition, and destroyed at the end of the block in which they are defined.</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">6.4 — Introduction to global variables</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/local-variables/">6.3 -- Local variables</a>, we covered that local variables are variables defined inside a function (or function parameters). Local variables have block scope (are only visible within the block they are declared in), and have automatic duration (they are created at the point of definition and destroyed when the block is exited).</p><p>In C++, variables can also be declared <em>outside</em> of a function. Such variables are called <span class="cpp-definition">global variables</span>.</p><br><h3>Declaring and naming global variables</h3><p>By convention, global variables are declared at the top of a file, below the includes, but above any code. Here’s an example of a global variable being defined:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// Variables declared outside of a function are global variables</code><code>int g_x {}; // global variable g_x</code><code></code><code>void doSomething()</code><code>{</code><code>    // global variables can be seen and used everywhere in the file</code><code>    g_x = 3;</code><code>    std::cout &lt;&lt; g_x &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    doSomething();</code><code>    std::cout &lt;&lt; g_x &lt;&lt; '\n';</code><code></code><code>    // global variables can be seen and used everywhere in the file</code><code>    g_x = 5;</code><code>    std::cout &lt;&lt; g_x &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code><code>// g_x goes out of scope here</code></pre><p>The above example prints:</p><pre>3
3
5
</pre><p>By convention, many developers prefix global variable identifiers with “g” or “g_” to indicate that they are global.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Consider using a “g” or “g_” prefix for global variables to help differentiate them from local variables.</p></div><br><h3>Global variables have file scope and static duration</h3><p>Global variables have <span class="cpp-definition">file scope</span> (also informally called <span class="cpp-definition">global scope</span> or <span class="cpp-definition">global namespace scope</span>), which means they are visible from the point of declaration until the end of the <em>file</em> in which they are declared. Once declared, a global variable can be used anywhere in the file from that point onward! In the above example, global variable <code>g_x</code> is used in both functions <code>doSomething()</code> and <code>main()</code>.</p><p>Because they are defined outside of a function, global variables are considered to be part of the global namespace (hence the term “global namespace scope”).</p><p>Global variables are created when the program starts, and destroyed when it ends. This is called <span class="cpp-definition">static duration</span>. Variables with <em>static duration</em> are sometimes called <span class="cpp-definition">static variables</span>.</p><br><h3>Global variable initialization</h3><p>Unlike local variables, which are uninitialized by default, variables with static duration are zero-initialized by default.</p><p>Non-constant global variables can be optionally initialized:</p><pre class="language-cpp line-numbers"><code>int g_x;       // no explicit initializer (zero-initialized by default)</code><code>int g_y {};    // zero-initialized</code><code>int g_z { 1 }; // initialized with value</code></pre><br><h3>Constant global variables</h3><p>Just like local variables, global variables can be constant. As with all constants, constant global variables must be initialized.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>const int g_x; // error: constant variables must be initialized</code><code>constexpr int g_w; // error: constexpr variables must be initialized</code><code></code><code>const int g_y { 1 };  // const global variable g_y, initialized with a value</code><code>constexpr int g_z { 2 }; // constexpr global variable g_z, initialized with a value</code><code></code><code>void doSomething()</code><code>{</code><code>    // global variables can be seen and used everywhere in the file</code><code>    std::cout &lt;&lt; g_y &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; g_z &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    doSomething();</code><code></code><code>    // global variables can be seen and used everywhere in the file</code><code>    std::cout &lt;&lt; g_y &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; g_z &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code><code>// g_y and g_z goes out of scope here</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We discuss global constants in more detail in lesson <a href="https://www.learncpp.com/cpp-tutorial/sharing-global-constants-across-multiple-files-using-inline-variables/">6.9 -- Sharing global constants across multiple files (using inline variables)</a>.</p></div><br><h3>A word of caution about (non-constant) global variables</h3><p>New programmers are often tempted to use lots of global variables, because they can be used without having to explicitly pass them to every function that needs them. However, use of non-constant global variables should generally be avoided altogether! We’ll discuss why in upcoming lesson <a href="https://www.learncpp.com/cpp-tutorial/why-non-const-global-variables-are-evil/">6.8 -- Why (non-const) global variables are evil</a>.</p><br><h3>Quick Summary</h3><pre class="language-cpp line-numbers"><code>// Non-constant global variables</code><code>int g_x;                 // defines non-initialized global variable (zero initialized by default)</code><code>int g_x {};              // defines explicitly zero-initialized global variable</code><code>int g_x { 1 };           // defines explicitly initialized global variable</code><code></code><code>// Const global variables</code><code>const int g_y;           // error: const variables must be initialized</code><code>const int g_y { 2 };     // defines initialized global constant</code><code></code><code>// Constexpr global variables</code><code>constexpr int g_y;       // error: constexpr variables must be initialized</code><code>constexpr int g_y { 3 }; // defines initialized global const</code></pre></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">6.5 — Variable shadowing (name hiding)</h1></header><div class="entry-content" itemprop="articleBody"><p>Each block defines its own scope region. So what happens when we have a variable inside a nested block that has the same name as a variable in an outer block? When this happens, the nested variable “hides” the outer variable in areas where they are both in scope. This is called <span class="cpp-definition">name hiding</span> or <span class="cpp-definition">shadowing</span>.</p><br><h3>Shadowing of local variables</h3><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{ // outer block</code><code>    int apples { 5 }; // here's the outer block apples</code><code></code><code>    { // nested block</code><code>        // apples refers to outer block apples here</code><code>        std::cout &lt;&lt; apples &lt;&lt; '\n'; // print value of outer block apples</code><code></code><code>        int apples{ 0 }; // define apples in the scope of the nested block</code><code></code><code>        // apples now refers to the nested block apples</code><code>        // the outer block apples is temporarily hidden</code><code></code><code>        apples = 10; // this assigns value 10 to nested block apples, not outer block apples</code><code></code><code>        std::cout &lt;&lt; apples &lt;&lt; '\n'; // print value of nested block apples</code><code>    } // nested block apples destroyed</code><code></code><code></code><code>    std::cout &lt;&lt; apples &lt;&lt; '\n'; // prints value of outer block apples</code><code></code><code>    return 0;</code><code>} // outer block apples destroyed</code></pre><p>If you run this program, it prints:</p><pre>5
10
5
</pre><p>In the above program, we first declare a variable named <code>apples</code> in the outer block. This variable is visible within the inner block, which we can see by printing its value (<code>5</code>). Then we declare a different variable (also named <code>apples</code>) in the nested block. From this point to the end of the block, the name <code>apples</code> refers to the nested block <code>apples</code>, not the outer block <code>apples</code>.</p><p>Thus, when we assign value <code>10</code> to <code>apples</code>, we’re assigning it to the nested block <code>apples</code>. After printing this value (<code>10</code>), the nested block ends and nested block <code>apples</code> is destroyed. The existence and value of outer block <code>apples</code> is not affected, and we prove this by printing the value of outer block <code>apples</code> (<code>5</code>).</p><p>Note that if the nested block <code>apples</code> had not been defined, the name <code>apples</code> in the nested block would still refer to the outer block <code>apples</code>, so the assignment of value <code>10</code> to <code>apples</code> would have applied to the outer block <code>apples</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{ // outer block</code><code>    int apples{5}; // here's the outer block apples</code><code></code><code>    { // nested block</code><code>        // apples refers to outer block apples here</code><code>        std::cout &lt;&lt; apples &lt;&lt; '\n'; // print value of outer block apples</code><code></code><code>        // no inner block apples defined in this example</code><code></code><code>        apples = 10; // this applies to outer block apples</code><code></code><code>        std::cout &lt;&lt; apples &lt;&lt; '\n'; // print value of outer block apples</code><code>    } // outer block apples retains its value even after we leave the nested block</code><code></code><code>    std::cout &lt;&lt; apples &lt;&lt; '\n'; // prints value of outer block apples</code><code></code><code>    return 0;</code><code>} // outer block apples destroyed</code></pre><p>The above program prints:</p><pre>5
10
10
</pre><p>When inside the nested block, there’s no way to directly access the shadowed variable from the outer block.</p><br><h3>Shadowing of global variables</h3><p>Similar to how variables in a nested block can shadow variables in an outer block, local variables with the same name as a global variable will shadow the global variable wherever the local variable is in scope:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>int value { 5 }; // global variable</code><code></code><code>void foo()</code><code>{</code><code>    std::cout &lt;&lt; "global variable value: " &lt;&lt; value &lt;&lt; '\n'; // value is not shadowed here, so this refers to the global value</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int value { 7 }; // hides the global variable value until the end of this block</code><code></code><code>    ++value; // increments local value, not global value</code><code></code><code>    std::cout &lt;&lt; "local variable value: " &lt;&lt; value &lt;&lt; '\n';</code><code></code><code>    foo();</code><code></code><code>    return 0;</code><code>} // local value is destroyed</code></pre><p>This code prints:</p><pre>local variable value: 8
global variable value: 5
</pre><p>However, because global variables are part of the global namespace, we can use the scope operator (::) with no prefix to tell the compiler we mean the global variable instead of the local variable.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>int value { 5 }; // global variable</code><code></code><code>int main()</code><code>{</code><code>    int value { 7 }; // hides the global variable value</code><code>    ++value; // increments local value, not global value</code><code></code><code>    --(::value); // decrements global value, not local value (parenthesis added for readability)</code><code></code><code>    std::cout &lt;&lt; "local variable value: " &lt;&lt; value &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "global variable value: " &lt;&lt; ::value &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>} // local value is destroyed</code></pre><p>This code prints:</p><pre>local variable value: 8
global variable value: 4
</pre><br><h3>Avoid variable shadowing</h3><p>Shadowing of local variables should generally be avoided, as it can lead to inadvertent errors where the wrong variable is used or modified. Some compilers will issue a warning when a variable is shadowed.</p><p>For the same reason that we recommend avoiding shadowing local variables, we recommend avoiding shadowing global variables as well. This is trivially avoidable if all of your global names use a “g_” prefix.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Avoid variable shadowing.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">6.6 — Internal linkage</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/local-variables/">6.3 -- Local variables</a>, we said, “An identifier’s linkage determines whether other declarations of that name refer to the same object or not”, and we discussed how local variables have <code>no linkage</code>.</p><p>Global variable and functions identifiers can have either <code>internal linkage</code> or <code>external linkage</code>. We’ll cover the internal linkage case in this lesson, and the external linkage case in lesson <a href="https://www.learncpp.com/cpp-tutorial/external-linkage-and-variable-forward-declarations/">6.7 -- External linkage and variable forward declarations</a>.</p><p>An identifier with <span class="cpp-definition">internal linkage</span> can be seen and used within a single file, but it is not accessible from other files (that is, it is not exposed to the linker). This means that if two files have identically named identifiers with internal linkage, those identifiers will be treated as independent.</p><br><h3>Global variables with internal linkage</h3><p>Global variables with internal linkage are sometimes called <span class="cpp-definition">internal variables</span>.</p><p>To make a non-constant global variable internal, we use the <code>static</code> keyword.</p><pre class="language-cpp line-numbers"><code>static int g_x; // non-constant globals have external linkage by default, but can be given internal linkage via the static keyword</code><code></code><code>const int g_y { 1 }; // const globals have internal linkage by default</code><code>constexpr int g_z { 2 }; // constexpr globals have internal linkage by default</code><code></code><code>int main()</code><code>{</code><code>    return 0;</code><code>}</code></pre><p>Const and constexpr global variables have internal linkage by default (and thus don’t need the <code>static</code> keyword -- if it is used, it will be ignored).</p><p>Here’s an example of multiple files using internal variables:</p><p>a.cpp:</p><pre class="language-cpp line-numbers"><code>constexpr int g_x { 2 }; // this internal g_x is only accessible within a.cpp</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>static int g_x { 3 }; // this separate internal g_x is only accessible within main.cpp</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; g_x &lt;&lt; '\n'; // uses main.cpp's g_x, prints 3</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>3
</pre><p>Because <code>g_x</code> is internal to each file, <code>main.cpp</code> has no idea that <code>a.cpp</code> also has a variable named <code>g_x</code> (and vice versa).</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>The use of the <code>static</code> keyword above is an example of a <span class="cpp-definition">storage class specifier</span>, which sets both the name’s linkage and its storage duration (but not its scope). The most commonly used <code>storage class specifiers</code> are <code>static</code>, <code>extern</code>, and <code>mutable</code>. The term <code>storage class specifier</code> is mostly used in technical documentations.</p></div><br><h3>The one-definition rule and internal linkage</h3><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/forward-declarations/">2.7 -- Forward declarations and definitions</a>, we noted that the one-definition rule says that an object or function can’t have more than one definition, either within a file or a program.</p><p>However, it’s worth noting that internal objects (and functions) that are defined in different files are considered to be independent entities (even if their names and types are identical), so there is no violation of the one-definition rule. Each internal object only has one definition.</p><br><h3>Functions with internal linkage</h3><p>Because linkage is a property of an identifier (not of a variable), function identifiers have the same linkage property that variable identifiers do. Functions default to external linkage (which we’ll cover in the next lesson), but can be set to internal linkage via the <code>static</code> keyword:</p><p>add.cpp:</p><pre class="language-cpp line-numbers"><code>// This function is declared as static, and can now be used only within this file</code><code>// Attempts to access it from another file via a function forward declaration will fail</code><code>static int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y); // forward declaration for function add</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; add(3, 4) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program won’t link, because function <code>add</code> is not accessible outside of <code>add.cpp</code>.</p><br><h3>Quick Summary</h3><pre class="language-cpp line-numbers"><code>// Internal global variables definitions:</code><code>static int g_x;          // defines non-initialized internal global variable (zero initialized by default)</code><code>static int g_x{ 1 };     // defines initialized internal global variable</code><code></code><code>const int g_y { 2 };     // defines initialized internal global const variable</code><code>constexpr int g_y { 3 }; // defines initialized internal global constexpr variable</code><code></code><code>// Internal function definitions:</code><code>static int foo() {};     // defines internal function</code></pre><p>We provide a comprehensive summary in lesson <a href="https://www.learncpp.com/cpp-tutorial/scope-duration-and-linkage-summary/">6.11 -- Scope, duration, and linkage summary</a>.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">6.7 — External linkage and variable forward declarations</h1></header><div class="entry-content" itemprop="articleBody"><p>In the prior lesson (<a href="https://www.learncpp.com/cpp-tutorial/internal-linkage/">6.6 -- Internal linkage</a>), we discussed how <code>internal linkage</code> limits the use of an identifier to a single file. In this lesson, we’ll explore the concept of <code>external linkage</code>.</p><p>An identifier with <span class="cpp-definition">external linkage</span> can be seen and used both from the file in which it is defined, and from other code files (via a forward declaration). In this sense, identifiers with external linkage are truly “global” in that they can be used anywhere in your program!</p><br><h3>Functions have external linkage by default</h3><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/programs-with-multiple-code-files/">2.8 -- Programs with multiple code files</a>, you learned that you can call a function defined in one file from another file. This is because functions have external linkage by default.</p><p>In order to call a function defined in another file, you must place a <code>forward declaration</code> for the function in any other files wishing to use the function. The forward declaration tells the compiler about the existence of the function, and the linker connects the function calls to the actual function definition.</p><p>Here’s an example:</p><p>a.cpp:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void sayHi() // this function has external linkage, and can be seen by other files</code><code>{</code><code>    std::cout &lt;&lt; "Hi!\n";</code><code>}</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>void sayHi(); // forward declaration for function sayHi, makes sayHi accessible in this file</code><code></code><code>int main()</code><code>{</code><code>    sayHi(); // call to function defined in another file, linker will connect this call to the function definition</code><code></code><code>    return 0;</code><code>}</code></pre><p>The above program prints:</p><pre>Hi!
</pre><p>In the above example, the forward declaration of function <code>sayHi()</code> in <code>main.cpp</code> allows <code>main.cpp</code> to access the <code>sayHi()</code> function defined in <code>a.cpp</code>. The forward declaration satisfies the compiler, and the linker is able to link the function call to the function definition.</p><p>If function <code>sayHi()</code> had internal linkage instead, the linker would not be able to connect the function call to the function definition, and a linker error would result.</p><br><h3>Global variables with external linkage</h3><p>Global variables with external linkage are sometimes called <span class="cpp-definition">external variables</span>. To make a global variable external (and thus accessible by other files), we can use the <code>extern</code> keyword to do so:</p><pre class="language-cpp line-numbers"><code>int g_x { 2 }; // non-constant globals are external by default</code><code></code><code>extern const int g_y { 3 }; // const globals can be defined as extern, making them external</code><code>extern constexpr int g_z { 3 }; // constexpr globals can be defined as extern, making them external (but this is useless, see the note in the next section)</code><code></code><code>int main()</code><code>{</code><code>    return 0;</code><code>}</code></pre><p>Non-const global variables are external by default (if used, the <code>extern</code> keyword will be ignored).</p><br><h3>Variable forward declarations via the extern keyword</h3><p>To actually use an external global variable that has been defined in another file, you also must place a <code>forward declaration</code> for the global variable in any other files wishing to use the variable. For variables, creating a forward declaration is also done via the <code>extern</code> keyword (with no initialization value).</p><p>Here is an example of using a variable forward declaration:</p><p>a.cpp:</p><pre class="language-cpp line-numbers"><code>// global variable definitions</code><code>int g_x { 2 }; // non-constant globals have external linkage by default</code><code>extern const int g_y { 3 }; // this extern gives g_y external linkage</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>extern int g_x; // this extern is a forward declaration of a variable named g_x that is defined somewhere else</code><code>extern const int g_y; // this extern is a forward declaration of a const variable named g_y that is defined somewhere else</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; g_x &lt;&lt; '\n'; // prints 2</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, <code>a.cpp</code> and <code>main.cpp</code> both reference the same global variable named <code>g_x</code>. So even though <code>g_x</code> is defined and initialized in <code>a.cpp</code>, we are able to use its value in <code>main.cpp</code> via the forward declaration of <code>g_x</code>.</p><p>Note that the <code>extern</code> keyword has different meanings in different contexts. In some contexts, <code>extern</code> means “give this variable external linkage”. In other contexts, <code>extern</code> means “this is a forward declaration for an external variable that is defined somewhere else”. Yes, this is confusing, so we summarize all of these usages in lesson <a href="https://www.learncpp.com/cpp-tutorial/scope-duration-and-linkage-summary/">6.11 -- Scope, duration, and linkage summary</a>.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>If you want to define an uninitialized non-const global variable, do not use the extern keyword, otherwise C++ will think you’re trying to make a forward declaration for the variable.</p></div><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Although constexpr variables can be given external linkage via the <code>extern</code> keyword, they can not be forward declared, so there is no value in giving them external linkage.</p><p>This is because the compiler needs to know the value of the constexpr variable (at compile time). If that value is defined in some other file, the compiler has no visibility on what value was defined in that other file.</p></div><p>Note that function forward declarations don’t need the <code>extern</code> keyword -- the compiler is able to tell whether you’re defining a new function or making a forward declaration based on whether you supply a function body or not. Variables forward declarations <em>do</em> need the <code>extern</code> keyword to help differentiate variables definitions from variable forward declarations (they look otherwise identical):</p><pre class="language-cpp line-numbers"><code>// non-constant </code><code>int g_x; // variable definition (can have initializer if desired)</code><code>extern int g_x; // forward declaration (no initializer)</code><code></code><code>// constant</code><code>extern const int g_y { 1 }; // variable definition (const requires initializers)</code><code>extern const int g_y; // forward declaration (no initializer)</code></pre><br><h3>File scope vs. global scope</h3><p>The terms “file scope” and “global scope” tend to cause confusion, and this is partly due to the way they are informally used. Technically, in C++, <em>all</em> global variables have “file scope”, and the linkage property controls whether they can be used in other files or not.</p><p>Consider the following program:</p><p>global.cpp:</p><pre class="language-cpp line-numbers"><code>int g_x { 2 }; // external linkage by default</code><code>// g_x goes out of scope here</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>extern int g_x; // forward declaration for g_x -- g_x can be used beyond this point in this file</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; g_x &lt;&lt; '\n'; // should print 2</code><code></code><code>    return 0;</code><code>}</code><code>// the forward declaration for g_x goes out of scope here</code></pre><p>Variable <code>g_x</code> has file scope within <code>global.cpp</code> -- it can be used from the point of definition to the end of the file, but it can not be directly seen outside of <code>global.cpp</code>.</p><p>Inside <code>main.cpp</code>, the forward declaration of <code>g_x</code> also has file scope -- it can be used from the point of declaration to the end of the file.</p><p>However, informally, the term “file scope” is more often applied to global variables with internal linkage, and “global scope” to global variables with external linkage (since they can be used across the whole program, with the appropriate forward declarations).</p><br><h3>Quick summary</h3><pre class="language-cpp line-numbers"><code>// External global variable definitions:</code><code>int g_x;                       // defines non-initialized external global variable (zero initialized by default)</code><code>extern const int g_x{ 1 };     // defines initialized const external global variable</code><code>extern constexpr int g_x{ 2 }; // defines initialized constexpr external global variable</code><code></code><code>// Forward declarations</code><code>extern int g_y;                // forward declaration for non-constant global variable</code><code>extern const int g_y;          // forward declaration for const global variable</code><code>extern constexpr int g_y;      // not allowed: constexpr variables can't be forward declared</code></pre><p>We provide a comprehensive summary in lesson <a href="https://www.learncpp.com/cpp-tutorial/scope-duration-and-linkage-summary/">6.11 -- Scope, duration, and linkage summary</a>.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>What’s the difference between a variable’s scope, duration, and linkage? What kind of scope, duration, and linkage do global variables have?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>Scope determines where a variable is accessible. Duration determines when a variable is created and destroyed. Linkage determines whether the variable can be exported to another file or not.</p><p>Global variables have global scope (aka. file scope), which means they can be accessed from the point of declaration to the end of the file in which they are declared.</p><p>Global variables have static duration, which means they are created when the program is started, and destroyed when it ends.</p><p>Global variables can have either internal or external linkage, via the static and extern keywords respectively.</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">6.8 — Why (non-const) global variables are evil</h1></header><div class="entry-content" itemprop="articleBody"><p>If you were to ask a veteran programmer for <em>one</em> piece of advice on good programming practices, after some thought, the most likely answer would be, “Avoid global variables!”. And with good reason: global variables are one of the most historically abused concepts in the language. Although they may seem harmless in small academic programs, they are often problematic in larger ones.</p><p>New programmers are often tempted to use lots of global variables, because they are easy to work with, especially when many calls to different functions are involved (passing data through function parameters is a pain). However, this is generally a bad idea. Many developers believe non-const global variables should be avoided completely!</p><p>But before we go into why, we should make a clarification. When developers tell you that global variables are evil, they’re usually not talking about <em>all</em> global variables. They’re mostly talking about non-const global variables.</p><br><h3>Why (non-const) global variables are evil</h3><p>By far the biggest reason non-const global variables are dangerous is because their values can be changed by <em>any</em> function that is called, and there is no easy way for the programmer to know that this will happen. Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int g_mode; // declare global variable (will be zero-initialized by default)</code><code></code><code>void doSomething()</code><code>{</code><code>    g_mode = 2; // set the global g_mode variable to 2</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    g_mode = 1; // note: this sets the global g_mode variable to 1.  It does not declare a local g_mode variable!</code><code></code><code>    doSomething();</code><code></code><code>    // Programmer still expects g_mode to be 1</code><code>    // But doSomething changed it to 2!</code><code></code><code>    if (g_mode == 1)</code><code>    {</code><code>        std::cout &lt;&lt; "No threat detected.\n";</code><code>    }</code><code>    else</code><code>    {</code><code>        std::cout &lt;&lt; "Launching nuclear missiles...\n";</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note that the programmer set variable <code>g_mode</code> to <em>1</em>, and then called <code>doSomething()</code>. Unless the programmer had explicit knowledge that <code>doSomething()</code> was going to change the value of <code>g_mode</code>, he or she was probably not expecting <code>doSomething()</code> to change the value! Consequently, the rest of <code>main()</code> doesn’t work like the programmer expects (and the world is obliterated).</p><p>In short, global variables make the program’s state unpredictable. Every function call becomes potentially dangerous, and the programmer has no easy way of knowing which ones are dangerous and which ones aren’t! Local variables are much safer because other functions can not affect them directly.</p><p>There are plenty of other good reasons not to use non-const globals.</p><p>With global variables, it’s not uncommon to find a piece of code that looks like this:</p><pre class="language-cpp line-numbers"><code>void someFunction()</code><code>{</code><code>    // useful code</code><code></code><code>    if (g_mode == 4)</code><code>    {</code><code>        // do something good</code><code>    }</code><code>}</code></pre><p>After debugging, you determine that your program isn’t working correctly because <code>g_mode</code> has value <code>3</code>, not <em>4</em>. How do you fix it? Now you need to find all of the places <code>g_mode</code> could possibly be set to <code>3</code>, and trace through how it got set in the first place. It’s possible this may be in a totally unrelated piece of code!</p><p>One of the key reasons to declare local variables as close to where they are used as possible is because doing so minimizes the amount of code you need to look through to understand what the variable does. Global variables are at the opposite end of the spectrum -- because they can be accessed anywhere, you might have to look through the entire program to understand their usage. In small programs, this might not be an issue. In large ones, it will be.</p><p>For example, you might find <code>g_mode</code> is referenced 442 times in your program. Unless <code>g_mode</code> is well documented, you’ll potentially have to look through every use of <code>g_mode</code> to understand how it’s being used in different cases, what its valid values are, and what its overall function is.</p><p>Global variables also make your program less modular and less flexible. A function that utilizes nothing but its parameters and has no side effects is perfectly modular. Modularity helps both in understanding what a program does, as well as with reusability. Global variables reduce modularity significantly.</p><p>In particular, avoid using global variables for important “decision-point” variables (e.g. variables you’d use in a conditional statement, like variable <code>g_mode</code> in the example above). Your program isn’t likely to break if a global variable holding an informational value changes (e.g. like the user’s name). It is much more likely to break if you change a global variable that impacts <em>how</em> your program actually functions.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use local variables instead of global variables whenever possible.</p></div><br><h3>The initialization order problem of global variables</h3><p>Initialization of static variables (which includes global variables) happens as part of program startup, before execution of the <code>main</code> function. This proceeds in two phases.</p><p>The first phase is called <code>static initialization</code>. In the static initialization phase, global variables with constexpr initializers (including literals) are initialized to those values. Also, global variables without initializers are zero-initialized.</p><p>The second phase is called <code>dynamic initialization</code>. This phase is more complex and nuanced, but the gist of it is that global variables with non-constexpr initializers are initialized.</p><p>Here’s an example of a non-constexpr initializer:</p><pre class="language-cpp line-numbers"><code>int init()</code><code>{</code><code>    return 5;</code><code>}</code><code></code><code>int g_something{ init() }; // non-constexpr initialization</code></pre><p>Within a single file, global variables are generally initialized in order of definition (there are a few exceptions to this rule). Given this, you need to be careful not to have variables dependent on the initialization value of other variables that won’t be initialized until later. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int initx();  // forward declaration</code><code>int inity();  // forward declaration</code><code></code><code>int g_x{ initx() }; // g_x is initialized first</code><code>int g_y{ inity() };</code><code></code><code>int initx()</code><code>{</code><code>    return g_y; // g_y isn't initialized when this is called</code><code>}</code><code></code><code>int inity()</code><code>{</code><code>    return 5;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; g_x &lt;&lt; ' ' &lt;&lt; g_y &lt;&lt; '\n';</code><code>}</code></pre><p>This prints:</p><pre>0 5
</pre><p>Much more of a problem, the order of initialization across different files is not defined. Given two files, <code>a.cpp</code> and <code>b.cpp</code>, either could have its global variables initialized first. This means that if the variables in <code>a.cpp</code> are dependent upon the values in <code>b.cpp</code>, there’s a 50% chance that those variables won’t be initialized yet.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Dynamic initialization of global variables causes a lot of problems in C++. Avoid dynamic initialization whenever possible.</p></div><br><h3>So what are very good reasons to use non-const global variables?</h3><p>There aren’t many. In most cases, there are other ways to solve the problem that avoids the use of non-const global variables. But in some cases, judicious use of non-const global variables <em>can</em> actually reduce program complexity, and in these rare cases, their use may be better than the alternatives.</p><p>A good example is a log file, where you can dump error or debug information. It probably makes sense to define this as a global, because you’re likely to only have one log in a program and it will likely be used everywhere in your program.</p><p>For what it’s worth, the std::cout and std::cin objects are implemented as global variables (inside the <em>std</em> namespace).</p><p>As a rule of thumb, any use of a global variable should meet at least the following two criteria: There should only ever be one of the thing the variable represents in your program, and its use should be ubiquitous throughout your program.</p><p>Many new programmers make the mistake of thinking that something can be implemented as a global because only one is needed <em>right now</em>. For example, you might think that because you’re implementing a single player game, you only need one player. But what happens later when you want to add a multiplayer mode (versus or hotseat)?</p><br><h3>Protecting yourself from global destruction</h3><p>If you do find a good use for a non-const global variable, a few useful bits of advice will minimize the amount of trouble you can get into. This advice isn’t only for non-const global variables, but can help with all global variables.</p><p>First, prefix all non-namespaced global variables with “g” or “g_”, or better yet, put them in a namespace (discussed in lesson <a href="https://www.learncpp.com/cpp-tutorial/user-defined-namespaces-and-the-scope-resolution-operator/">6.2 -- User-defined namespaces and the scope resolution operator</a>), to reduce the chance of naming collisions.</p><p>For example, instead of:</p><pre class="language-cpp line-numbers"><code>constexpr double gravity { 9.8 }; // unclear if this is a local or global variable from the name</code><code></code><code>int main()</code><code>{</code><code>    return 0;</code><code>}</code></pre><p>Do this:</p><pre class="language-cpp line-numbers"><code>namespace constants</code><code>{</code><code>    constexpr double gravity { 9.8 };</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    return 0;</code><code>}</code></pre><p>Second, instead of allowing direct access to the global variable, it’s a better practice to “encapsulate” the variable. Make sure the variable can only be accessed from within the file it’s declared in, e.g. by making the variable static or const, then provide external global “access functions” to work with the variable. These functions can ensure proper usage is maintained (e.g. do input validation, range checking, etc…). Also, if you ever decide to change the underlying implementation (e.g. move from one database to another), you only have to update the access functions instead of every piece of code that uses the global variable directly.</p><p>For example, instead of:</p><pre class="language-cpp line-numbers"><code>namespace constants</code><code>{</code><code>    extern const double gravity { 9.8 }; // has external linkage, is directly accessible by other files</code><code>}</code></pre><p>Do this:</p><pre class="language-cpp line-numbers"><code>namespace constants</code><code>{</code><code>    constexpr double gravity { 9.8 }; // has internal linkage, is accessible only by this file</code><code>}</code><code></code><code>double getGravity() // this function can be exported to other files to access the global outside of this file</code><code>{</code><code>    // We could add logic here if needed later</code><code>    // or change the implementation transparently to the callers</code><code>    return constants::gravity;</code><code>} </code></pre><div class="cpp-note cpp-lightgraybackground"><h4>A reminder</h4><p>Global <code>const</code> variables have internal linkage by default, <code>gravity</code> doesn’t need to be <code>static</code>.</p></div><p>Third, when writing an otherwise standalone function that uses the global variable, don’t use the variable directly in your function body. Pass it in as an argument instead. That way, if your function ever needs to use a different value for some circumstance, you can simply vary the argument. This helps maintain modularity.</p><p>Instead of:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>namespace constants</code><code>{</code><code>    constexpr double gravity { 9.8 };</code><code>}</code><code></code><code>// This function is only useful for calculating your instant velocity based on the global gravity</code><code>double instantVelocity(int time)</code><code>{</code><code>    return constants::gravity * time;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; instantVelocity(5);</code><code>}</code></pre><p>Do this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>namespace constants</code><code>{</code><code>    constexpr double gravity { 9.8 };</code><code>}</code><code></code><code>// This function can calculate the instant velocity for any gravity value (more useful)</code><code>double instantVelocity(int time, double gravity)</code><code>{</code><code>    return gravity * time;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; instantVelocity(5, constants::gravity); // pass our constant to the function as a parameter</code><code>}</code></pre><br><h3>A joke</h3><p>What’s the best naming prefix for a global variable?</p><p>Answer: //</p><p>C++ jokes are the best.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">6.9 — Sharing global constants across multiple files (using inline variables)</h1></header><div class="entry-content" itemprop="articleBody"><p>In some applications, certain symbolic constants may need to be used throughout your code (not just in one location). These can include physics or mathematical constants that don’t change (e.g. pi or Avogadro’s number), or application-specific “tuning” values (e.g. friction or gravity coefficients). Instead of redefining these constants in every file that needs them (a violation of the “Don’t Repeat Yourself” rule), it’s better to declare them once in a central location and use them wherever needed. That way, if you ever need to change them, you only need to change them in one place, and those changes can be propagated out.</p><p>This lesson discusses the most common ways to do this.</p><br><h3>Global constants as internal variables</h3><p>Prior to C++17, the following is the easiest and most common solution:</p><ol start="1"><li>Create a header file to hold these constants</li><li>Inside this header file, define a namespace (discussed in lesson <a href="https://www.learncpp.com/cpp-tutorial/user-defined-namespaces-and-the-scope-resolution-operator/">6.2 -- User-defined namespaces and the scope resolution operator</a>)</li><li>Add all your constants inside the namespace (make sure they’re <em>constexpr</em>)</li><li>#include the header file wherever you need it</li></ol><p>For example:</p><p>constants.h:</p><pre class="language-cpp line-numbers"><code>#ifndef CONSTANTS_H</code><code>#define CONSTANTS_H</code><code></code><code>// define your own namespace to hold constants</code><code>namespace constants</code><code>{</code><code>    // constants have internal linkage by default</code><code>    constexpr double pi { 3.14159 };</code><code>    constexpr double avogadro { 6.0221413e23 };</code><code>    constexpr double myGravity { 9.2 }; // m/s^2 -- gravity is light on this planet</code><code>    // ... other related constants</code><code>}</code><code>#endif</code></pre><p>Then use the scope resolution operator (::) with the namespace name to the left, and your variable name to the right in order to access your constants in .cpp files:</p><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include "constants.h" // include a copy of each constant in this file</code><code></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a radius: ";</code><code>    int radius{};</code><code>    std::cin &gt;&gt; radius;</code><code></code><code>    std::cout &lt;&lt; "The circumference is: " &lt;&lt; 2.0 * radius * constants::pi &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>When this header gets #included into a .cpp file, each of these variables defined in the header will be copied into that code file at the point of inclusion. Because these variables live outside of a function, they’re treated as global variables within the file they are included into, which is why you can use them anywhere in that file.</p><p>Because const globals have internal linkage, each .cpp file gets an independent version of the global variable that the linker can’t see. In most cases, because these are const, the compiler will simply optimize the variables away.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>The term “optimizing away” refers to any process where the compiler optimizes the performance of your program by removing things in a way that doesn’t affect the output of your program. For example, lets say you have some const variable <code>x</code> that’s initialized to value <code>4</code>. Wherever your code references variable <code>x</code>, the compiler can just replace <code>x</code> with <code>4</code> (since <code>x</code> is const, we know it won’t ever change to a different value) and avoid having to create and initialize a variable altogether.</p></div><br><h3>Global constants as external variables</h3><p>The above method has a few potential downsides.</p><p>While this is simple (and fine for smaller programs), every time constants.h gets #included into a different code file, each of these variables is copied into the including code file. Therefore, if constants.h gets included into 20 different code files, each of these variables is duplicated 20 times. Header guards won’t stop this from happening, as they only prevent a header from being included more than once into a single including file, not from being included one time into multiple different code files. This introduces two challenges:</p><ol start="1"><li>Changing a single constant value would require recompiling every file that includes the constants header, which can lead to lengthy rebuild times for larger projects.</li><li>If the constants are large in size and can’t be optimized away, this can use a lot of memory.</li></ol><p>One way to avoid these problems is by turning these constants into external variables, since we can then have a single variable (initialized once) that is shared across all files. In this method, we’ll define the constants in a .cpp file (to ensure the definitions only exist in one place), and put forward declarations in the header (which will be included by other files).</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>We use const instead of constexpr in this method because constexpr variables can’t be forward declared, even if they have external linkage. This is because the compiler needs to know the value of the variable at compile time, and a forward declaration does not provide this information.</p></div><p>constants.cpp:</p><pre class="language-cpp line-numbers"><code>#include "constants.h"</code><code></code><code>namespace constants</code><code>{</code><code>    // actual global variables</code><code>    extern const double pi { 3.14159 };</code><code>    extern const double avogadro { 6.0221413e23 };</code><code>    extern const double myGravity { 9.2 }; // m/s^2 -- gravity is light on this planet</code><code>}</code></pre><p>constants.h:</p><pre class="language-cpp line-numbers"><code>#ifndef CONSTANTS_H</code><code>#define CONSTANTS_H</code><code></code><code>namespace constants</code><code>{</code><code>    // since the actual variables are inside a namespace, the forward declarations need to be inside a namespace as well</code><code>    extern const double pi;</code><code>    extern const double avogadro;</code><code>    extern const double myGravity;</code><code>}</code><code></code><code>#endif</code></pre><p>Use in the code file stays the same:</p><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include "constants.h" // include all the forward declarations</code><code></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a radius: ";</code><code>    int radius{};</code><code>    std::cin &gt;&gt; radius;</code><code></code><code>    std::cout &lt;&lt; "The circumference is: " &lt;&lt; 2.0 * radius * constants::pi &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because global symbolic constants should be namespaced (to avoid naming conflicts with other identifiers in the global namespace), the use of a “g_” naming prefix is not necessary.</p><p>Now the symbolic constants will get instantiated only once (in <code>constants.cpp</code>) instead of in each code file where <code>constants.h</code> is #included, and all uses of these constants will be linked to the version instantiated in <code>constants.cpp</code>. Any changes made to <code>constants.cpp</code> will require recompiling only <code>constants.cpp</code>.</p><p>However, there are a couple of downsides to this method. First, these constants are now considered compile-time constants only within the file they are actually defined in (<code>constants.cpp</code>). In other files, the compiler will only see the forward declaration, which doesn’t define a constant value (and must be resolved by the linker). This means in other files, these are treated as runtime constant values, not compile-time constants. Thus outside of <code>constants.cpp</code>, these variables can’t be used anywhere that requires a compile-time constant. Second, because compile-time constants can typically be optimized more than runtime constants, the compiler may not be able to optimize these as much.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>In order for variables to be usable in compile-time contexts, such as array sizes, the compiler has to see the variable’s definition (not just a forward declaration).</p></div><p>Because the compiler compiles each source file individually, it can only see variable definitions that appear in the source file being compiled (which includes any included headers). For example, variable definitions in <code>constants.cpp</code> are not visible when the compiler compiles <code>main.cpp</code>. For this reason, <code>constexpr</code> variables cannot be separated into header and source file, they have to be defined in the header file.</p><p>Given the above downsides, prefer defining your constants in the header file. If you find that for some reason those constants are causing trouble, you can move some or all of them into a .cpp file as needed.</p><br><h3>Global constants as inline variables C++17</h3><p>C++17 introduced a new concept called <code>inline variables</code>. In C++, the term <code>inline</code> has evolved to mean “multiple definitions are allowed”. Thus, an <span class="cpp-definition">inline variable</span> is one that is allowed to be defined in multiple files without violating the one definition rule. Inline global variables have external linkage by default.</p><p>The linker will consolidate all inline definitions of a variable into a single variable definition (thus meeting the one definition rule). This allows us to define variables in a header file and have them treated as if there was only one definition in a .cpp file somewhere. Let’s say you have a normal constant that you’re #including into 10 code files. Without inline, you get 10 definitions. With inline, the compiler picks 1 definition to be the canonical definition, so you only get 1 definition. This means you save 9 constants worth of memory.</p><p>These variables will also retain their constexpr-ness in all files in which they are included, so they can be used anywhere a constexpr value is required. Constexpr values can also be more highly optimized by the compiler than runtime-const (or non-const) variables.</p><p>Inline variables have two primary restrictions that must be obeyed:</p><ol start="1"><li>All definitions of the inline variable must be identical (otherwise, undefined behavior will result).</li><li>The inline variable definition (not a forward declaration) must be present in any file that uses the variable.</li></ol><p>With this, we can go back to defining our globals in a header file without the downside of duplicated variables:</p><p>constants.h:</p><pre class="language-cpp line-numbers"><code>#ifndef CONSTANTS_H</code><code>#define CONSTANTS_H</code><code></code><code>// define your own namespace to hold constants</code><code>namespace constants</code><code>{</code><code>    inline constexpr double pi { 3.14159 }; // note: now inline constexpr</code><code>    inline constexpr double avogadro { 6.0221413e23 };</code><code>    inline constexpr double myGravity { 9.2 }; // m/s^2 -- gravity is light on this planet</code><code>    // ... other related constants</code><code>}</code><code>#endif</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include "constants.h"</code><code></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a radius: ";</code><code>    int radius{};</code><code>    std::cin &gt;&gt; radius;</code><code></code><code>    std::cout &lt;&lt; "The circumference is: " &lt;&lt; 2.0 * radius * constants::pi &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>We can include <code>constants.h</code> into as many code files as we want, but these variables will only be instantiated once and shared across all code files.</p><p>This method does retain the downside of requiring every file that includes the constants header to be recompiled if any constant value is changed. If you find yourself changing constants often (e.g. for tuning purposes) and this is leading to long recompile times, moving the changing constants into their own header (to reduce the number of #includes) may help.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>If you need global constants and your compiler is C++17 capable, prefer defining inline constexpr global variables in a header file.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>A reminder</h4><p>Use <code>std::string_view</code> for <code>constexpr</code> strings. We cover this in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-stdstring_view/">4.18 -- Introduction to std::string_view</a>.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">6.10 — Static local variables</h1></header><div class="entry-content" itemprop="articleBody"><p>The term <code>static</code> is one of the most confusing terms in the C++ language, in large part because <code>static</code> has different meanings in different contexts.</p><p>In prior lessons, we covered that global variables have <code>static duration</code>, which means they are created when the program starts and destroyed when the program ends.</p><p>We also discussed how the <code>static</code> keyword gives a global identifier <code>internal linkage</code>, which means the identifier can only be used in the file in which it is defined.</p><p>In this lesson, we’ll explore the use of the <code>static</code> keyword when applied to a local variable.</p><br><h3>Static local variables</h3><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/">2.5 -- Introduction to local scope</a>, you learned that local variables have <code>automatic duration</code> by default, which means they are created at the point of definition, and destroyed when the block is exited.</p><p>Using the <code>static</code> keyword on a local variable changes its duration from <code>automatic duration</code> to <code>static duration</code>. This means the variable is now created at the start of the program, and destroyed at the end of the program (just like a global variable). As a result, the static variable will retain its value even after it goes out of scope!</p><p>The easiest way to show the difference between <code>automatic duration</code> and <code>static duration</code> variables is by example.</p><p>Automatic duration (default):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void incrementAndPrint()</code><code>{</code><code>    int value{ 1 }; // automatic duration by default</code><code>    ++value;</code><code>    std::cout &lt;&lt; value &lt;&lt; '\n';</code><code>} // value is destroyed here</code><code></code><code>int main()</code><code>{</code><code>    incrementAndPrint();</code><code>    incrementAndPrint();</code><code>    incrementAndPrint();</code><code></code><code>    return 0;</code><code>}</code></pre><p>Each time incrementAndPrint() is called, a variable named value is created and assigned the value of 1. incrementAndPrint() increments value to 2, and then prints the value of 2. When incrementAndPrint() is finished running, the variable goes out of scope and is destroyed. Consequently, this program outputs:</p><pre>2
2
2
</pre><p>Now consider the static version of this program. The only difference between this and the above program is that we’ve changed the local variable from <code>automatic duration</code> to <code>static duration</code> by using the <code>static</code> keyword.</p><p>Static duration (using static keyword):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void incrementAndPrint()</code><code>{</code><code>    static int s_value{ 1 }; // static duration via static keyword.  This initializer is only executed once.</code><code>    ++s_value;</code><code>    std::cout &lt;&lt; s_value &lt;&lt; '\n';</code><code>} // s_value is not destroyed here, but becomes inaccessible because it goes out of scope</code><code></code><code>int main()</code><code>{</code><code>    incrementAndPrint();</code><code>    incrementAndPrint();</code><code>    incrementAndPrint();</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this program, because <code>s_value</code> has been declared as <code>static</code>, it is created at the program start.</p><p>Static local variables that are zero initialized or have a constexpr initializer can be initialized at program start. Static local variables with non-constexpr initializers are initialized the first time the variable definition is encountered (the definition is skipped on subsequent calls, so no reinitialization happens). Because they have static duration, static local variables that are not explicitly initialized will be zero-initialized by default.</p><p>Because <code>s_value</code> has constexpr initializer <code>1</code>, <code>s_value</code> will be initialized at program start.</p><p>When <code>s_value</code> goes out of scope at the end of the function, it is not destroyed. Each time the function incrementAndPrint() is called, the value of <code>s_value</code> remains at whatever we left it at previously. Consequently, this program outputs:</p><pre>2
3
4
</pre><p>Just like we use “g_” to prefix global variables, it’s common to use “s_” to prefix static (static duration) local variables.</p><p>One of the most common uses for static duration local variables is for unique ID generators. Imagine a program where you have many similar objects (e.g. a game where you’re being attacked by many zombies, or a simulation where you’re displaying many triangles). If you notice a defect, it can be near impossible to distinguish which object is having problems. However, if each object is given a unique identifier upon creation, then it can be easier to differentiate the objects for further debugging.</p><p>Generating a unique ID number is very easy to do with a static duration local variable:</p><pre class="language-cpp line-numbers"><code>int generateID()</code><code>{</code><code>    static int s_itemID{ 0 };</code><code>    return s_itemID++; // makes copy of s_itemID, increments the real s_itemID, then returns the value in the copy</code><code>}</code></pre><p>The first time this function is called, it returns 0. The second time, it returns 1. Each time it is called, it returns a number one higher than the previous time it was called. You can assign these numbers as unique IDs for your objects. Because <code>s_itemID</code> is a local variable, it can not be “tampered with” by other functions.</p><p>Static variables offer some of the benefit of global variables (they don’t get destroyed until the end of the program) while limiting their visibility to block scope. This makes them safer for use even if you change their values regularly.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Initialize your static local variables. Static local variables are only initialized the first time the code is executed, not on subsequent calls.</p></div><br><h3>Static local constants</h3><p>Static local variables can be made const. One good use for a const static local variable is when you have a function that needs to use a const value, but creating or initializing the object is expensive (e.g. you need to read the value from a database). If you used a normal local variable, the variable would be created and initialized every time the function was executed. With a const static local variable, you can create and initialize the expensive object once, and then reuse it whenever the function is called.</p><br><h3>Don’t use static local variables to alter flow</h3><p>Consider the following code:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getInteger()</code><code>{</code><code>	static bool s_isFirstCall{ true };</code><code></code><code>	if (s_isFirstCall)</code><code>	{</code><code>		std::cout &lt;&lt; "Enter an integer: ";</code><code>		s_isFirstCall = false;</code><code>	}</code><code>	else</code><code>	{</code><code>		std::cout &lt;&lt; "Enter another integer: ";</code><code>	}</code><code></code><code>	int i{};</code><code>	std::cin &gt;&gt; i;</code><code>	return i;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int a{ getInteger() };</code><code>	int b{ getInteger() };</code><code></code><code>	std::cout &lt;&lt; a &lt;&lt; " + " &lt;&lt; b &lt;&lt; " = " &lt;&lt; (a + b) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>Sample output</p><pre>Enter an integer: 5
Enter another integer: 9
5 + 9 = 14
</pre><p>This code does what it’s supposed to do, but because we used a static local variable, we made the code harder to understand. If someone reads the code in <code>main()</code> without reading the implementation of <code>getInteger()</code>, they’d have no reason to assume that the two calls to <code>getInteger()</code> do something different. But the two calls do something different, which can be very confusing if the difference is more than a changed prompt.</p><p>Say you press the +1 button on your microwave and the microwave adds 1 minute to the remaining time. Your meal is warm and you’re happy. Before you take your meal out of the microwave, you see a cat outside your window and watch it for a moment, because cats are cool. The moment turned out to be longer than you expected and when you take the first bite of your meal, it’s cold again. No problem, just put it back into the microwave and press +1 to run it for a minute. But this time the microwave adds only 1 second and not 1 minute. That’s when you go “I changed nothing and now it’s broken” or “It worked last time”. If you do the same thing again, you’d expect the same behavior as last time. The same goes for functions.</p><p>Suppose we want to add subtraction to the calculator such that the output looks like the following:</p><pre>Addition
Enter an integer: 5
Enter another integer: 9
5 + 9 = 14
Subtraction
Enter an integer: 12
Enter another integer: 3
12 - 3 = 9
</pre><p>We might try to use <code>getInteger()</code> to read in the next two integers like we did for addition.</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>  std::cout &lt;&lt; "Addition\n";</code><code></code><code>  int a{ getInteger() };</code><code>  int b{ getInteger() };</code><code></code><code>  std::cout &lt;&lt; a &lt;&lt; " + " &lt;&lt; b &lt;&lt; " = " &lt;&lt; (a + b) &lt;&lt; '\n';</code><code></code><code>  std::cout &lt;&lt; "Subtraction\n";</code><code></code><code>  int c{ getInteger() };</code><code>  int d{ getInteger() };</code><code></code><code>  std::cout &lt;&lt; c &lt;&lt; " - " &lt;&lt; d &lt;&lt; " = " &lt;&lt; (c - d) &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><p>But this won’t work, the output is</p><pre>Addition
Enter an integer: 5
Enter another integer: 9
5 + 9 = 14
Subtraction
Enter another integer: 12
Enter another integer: 3
12 - 3 = 9
</pre><p>(“Enter another integer” instead of “Enter an integer”)</p><p><code>getInteger()</code> is not reusable, because it has an internal state (The static local variable <code>s_isFirstCall</code>) which cannot be reset from the outside. <code>s_isFirstCall</code> is not a variable that should be unique in the entire program. Although our program worked great when we first wrote it, the static local variable prevents us from reusing the function later on.</p><p>A better way of implementing <code>getInteger</code> is to pass <code>s_isFirstCall</code> as a parameter. This allows the caller to choose which prompt will be printed.</p><p>Static local variables should only be used if in your entire program and in the foreseeable future of your program, the variable is unique and it wouldn’t make sense to reset the variable.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Avoid <code>static</code> local variables unless the variable never needs to be reset.</p></div><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>What effect does using keyword <code>static</code> have on a global variable? What effect does it have on a local variable?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>When applied to a global variable, the static keyword defines the global variable as having internal linkage, meaning the variable cannot be exported to other files.</p><p>When applied to a local variable, the static keyword defines the local variable as having static duration, meaning the variable will only be created once, and will not be destroyed until the end of the program.</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">6.11 — Scope, duration, and linkage summary</h1></header><div class="entry-content" itemprop="articleBody"><p>The concepts of scope, duration, and linkage cause a lot of confusion, so we’re going to take an extra lesson to summarize everything. Some of these things we haven’t covered yet, and they’re here just for completeness / reference later.</p><p style="clear:both"></p><p></p><br><h3>Scope summary</h3><p>An identifier’s <em>scope</em> determines where the identifier can be accessed within the source code.</p><ul><li>Variables with <strong>block (local) scope</strong> can only be accessed within the block in which they are declared (including nested blocks). This includes:<ul><li>Local variables</li><li>Function parameters</li><li>User-defined type definitions (such as enums and classes) declared inside a block</li></ul></li><li>Variables and functions with <strong>file (global) scope</strong> can be accessed from the point of declaration until the end of the file. This includes:<ul><li>Global variables</li><li>Functions</li><li>User-defined type definitions (such as enums and classes) declared inside a namespace or in the global scope</li></ul></li></ul><br><h3>Duration summary</h3><p>A variable’s <em>duration</em> determines when it is created and destroyed.</p><ul><li>Variables with <strong>automatic duration</strong> are created at the point of definition, and destroyed when the block they are part of is exited. This includes:<ul><li>Local variables</li><li>Function parameters</li></ul></li><li>Variables with <strong>static duration</strong> are created when the program begins and destroyed when the program ends. This includes:<ul><li>Global variables</li><li>Static local variables</li></ul></li><li>Variables with <strong>dynamic duration</strong> are created and destroyed by programmer request. This includes:<ul><li>Dynamically allocated variables</li></ul></li></ul><br><h3>Linkage summary</h3><p>An identifier’s <em>linkage</em> determines whether multiple declarations of an identifier refer to the same entity (object, function, reference, etc…) or not.</p><ul><li>An identifier with <strong>no linkage</strong> means the identifier only refers to itself. This includes:<ul><li>Local variables</li><li>User-defined type definitions (such as enums and classes) declared inside a block</li></ul></li><li>An identifier with <strong>internal linkage</strong> can be accessed anywhere within the file it is declared. This includes:<ul><li>Static global variables (initialized or uninitialized)</li><li>Static functions</li><li>Const global variables</li><li>Functions declared inside an unnamed namespace</li><li>User-defined type definitions (such as enums and classes) declared inside an unnamed namespace</li></ul></li><li>An identifier with <strong>external linkage</strong> can be accessed anywhere within the file it is declared, or other files (via a forward declaration). This includes:<ul><li>Functions</li><li>Non-const global variables (initialized or uninitialized)</li><li>Extern const global variables</li><li>Inline const global variables</li><li>User-defined type definitions (such as enums and classes) declared inside a namespace or in the global scope</li></ul></li></ul><p>Identifiers with external linkage will generally cause a duplicate definition linker error if the definitions are compiled into more than one .cpp file (due to violating the one-definition rule). There are some exceptions to this rule (for types, templates, and inline functions and variables) -- we’ll cover these further in future lessons when we talk about those topics.</p><p>Also note that functions have external linkage by default. They can be made internal by using the static keyword.</p><br><h3>Variable scope, duration, and linkage summary</h3><p>Because variables have scope, duration, and linkage, let’s summarize in a chart:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Type</th><th>Example</th><th>Scope</th><th>Duration</th><th>Linkage</th><th>Notes</th></tr><tr><td>Local variable</td><td>int x;</td><td>Block</td><td>Automatic</td><td>None</td><td></td></tr><tr><td>Static local variable</td><td>static int s_x;</td><td>Block</td><td>Static</td><td>None</td><td></td></tr><tr><td>Dynamic variable</td><td>int* x { new int{} };</td><td>Block</td><td>Dynamic</td><td>None</td><td></td></tr><tr><td>Function parameter</td><td>void foo(int x)</td><td>Block</td><td>Automatic</td><td>None</td><td></td></tr><tr><td>External non-constant global variable</td><td>int g_x;</td><td>File</td><td>Static</td><td>External</td><td>Initialized or uninitialized</td></tr><tr><td>Internal non-constant global variable</td><td>static int g_x;</td><td>File</td><td>Static</td><td>Internal</td><td>Initialized or uninitialized</td></tr><tr><td>Internal constant global variable</td><td>constexpr int g_x { 1 };</td><td>File</td><td>Static</td><td>Internal</td><td>Must be initialized</td></tr><tr><td>External constant global variable</td><td>extern const int g_x { 1 };</td><td>File</td><td>Static</td><td>External</td><td>Must be initialized</td></tr><tr><td>Inline constant global variable (C++17)</td><td>inline constexpr int g_x { 1 };</td><td>File</td><td>Static</td><td>External</td><td>Must be initialized</td></tr></tbody></table></div><br><h3>Forward declaration summary</h3><p>You can use a forward declaration to access a function or variable in another file. The scope of the declared variable is as per usual (file scope for globals, block scope for locals).</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Type</th><th>Example</th><th>Notes</th></tr><tr><td>Function forward declaration</td><td>void foo(int x);</td><td>Prototype only, no function body</td></tr><tr><td>Non-constant variable forward declaration</td><td>extern int g_x;</td><td>Must be uninitialized</td></tr><tr><td>Const variable forward declaration</td><td>extern const int g_x;</td><td>Must be uninitialized</td></tr><tr><td>Constexpr variable forward declaration</td><td>extern constexpr int g_x;</td><td>Not allowed, constexpr cannot be forward declared</td></tr></tbody></table></div><br><h3>What the heck is a storage class specifier?</h3><p>When used as part of an identifier declaration, the <code>static</code> and <code>extern</code> keywords are called <span class="cpp-definition">storage class specifiers</span>. In this context, they set the storage duration and linkage of the identifier.</p><p>C++ supports 4 active storage class specifiers:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Specifier</th><th>Meaning</th><th>Note</th></tr><tr><td>extern</td><td>static (or thread_local) storage duration and external linkage</td><td></td></tr><tr><td>static</td><td>static (or thread_local) storage duration and internal linkage</td><td></td></tr><tr><td>thread_local</td><td>thread storage duration</td><td></td></tr><tr><td>mutable</td><td>object allowed to be modified even if containing class is const</td><td></td></tr><tr><td>auto</td><td>automatic storage duration</td><td>Deprecated in C++11</td></tr><tr><td>register</td><td>automatic storage duration and hint to the compiler to place in a register</td><td>Deprecated in C++17</td></tr></tbody></table></div><p>The term <em>storage class specifier</em> is typically only used in formal documentation.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">6.12 — Using declarations and using directives</h1></header><div class="entry-content" itemprop="articleBody"><p>You’ve probably seen this program in a lot of textbooks and tutorials:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>using namespace std;</code><code></code><code>int main()</code><code>{</code><code>    cout &lt;&lt; "Hello world!\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>Some older IDEs will also auto-populate new C++ projects with a similar program (so you can compile something immediately, rather than starting from a blank file).</p><p>If you see this, run. Your textbook, tutorial, or compiler are probably out of date. In this lesson, we’ll explore why.</p><br><h3>A short history lesson</h3><p>Back before C++ had support for namespaces, all of the names that are now in the <code>std</code> namespace were in the global namespace. This caused naming collisions between program identifiers and standard library identifiers. Programs that worked under one version of C++ might have a naming conflict with a newer version of C++.</p><p>In 1995, namespaces were standardized, and all of the functionality from the standard library was moved out of the global namespace and into namespace <code>std</code>. This change broke older code that was still using names without <code>std::</code>.</p><p>As anyone who has worked on a large codebase knows, any change to a codebase (no matter how trivial) risks breaking the program. Updating every name that was now moved into the <code>std</code> namespace to use the <code>std::</code> prefix was a massive risk. A solution was requested.</p><p>Fast forward to today -- if you’re using the standard library a lot, typing <code>std::</code> before everything you use from the standard library can become repetitive, and in some cases, can make your code harder to read.</p><p>C++ provides some solutions to both of these problems, in the form of <code>using statements</code>.</p><p>But first, let’s define two terms.</p><br><h3>Qualified and unqualified names</h3><p>A name can be either qualified or unqualified.</p><p>A <span class="cpp-definition">qualified name</span> is a name that includes an associated scope. Most often, names are qualified with a namespace using the scope resolution operator (::). For example:</p><pre class="language-cpp line-numbers"><code>std::cout // identifier cout is qualified by namespace std</code><code>::foo // identifier foo is qualified by the global namespace</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>A name can also be qualified by a class name using the scope resolution operator (::), or by a class object using the member selection operators (. or -&gt;). For example:</p><pre class="language-cpp line-numbers"><code>class C; // some class</code><code></code><code>C::s_member; // s_member is qualified by class C</code><code>obj.x; // x is qualified by class object obj</code><code>ptr-&gt;y; // y is qualified by pointer to class object ptr</code></pre></div><p>An <span class="cpp-definition">unqualified name</span> is a name that does not include a scoping qualifier. For example, <code>cout</code> and <code>x</code> are unqualified names, as they do not include an associated scope.</p><br><h3>Using declarations</h3><p>One way to reduce the repetition of typing <code>std::</code> over and over is to utilize a <code>using declaration</code> statement. A <span class="cpp-definition">using declaration</span> allows us to use an unqualified name (with no scope) as an alias for a qualified name.</p><p>Here’s our basic Hello world program, using a <code>using declaration</code> on line 5:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>   using std::cout; // this using declaration tells the compiler that cout should resolve to std::cout</code><code>   cout &lt;&lt; "Hello world!\n"; // so no std:: prefix is needed here!</code><code></code><code>   return 0;</code><code>} // the using declaration expires here</code></pre><p>The <code>using declaration</code> <code>using std::cout;</code> tells the compiler that we’re going to be using the object <code>cout</code> from the <code>std namespace</code>. So whenever it sees <code>cout</code>, it will assume that we mean <code>std::cout</code>. If there’s a naming conflict between <code>std::cout</code> and some other use of <code>cout</code>, <code>std::cout</code> will be preferred. Therefore on line 6, we can type <code>cout</code> instead of <code>std::cout</code>.</p><p>This doesn’t save much effort in this trivial example, but if you are using <code>cout</code> many times inside of a function, a <code>using declaration</code> can make your code more readable. Note that you will need a separate <code>using declaration</code> for each name (e.g. one for <code>std::cout</code>, one for <code>std::cin</code>, etc…).</p><p>Although this method is less explicit than using the <code>std::</code> prefix, it’s generally considered safe and acceptable (when used inside a function).</p><br><h3>Using directives</h3><p>Another way to simplify things is to use a <code>using directive</code>. Slightly simplified, a <span class="cpp-definition">using directive</span> imports all of the identifiers from a namespace into the scope of the <code>using directive</code>.</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>For technical reasons, using directives do not actually import names into the current scope -- instead they import the names into an outer scope (more details about which outer scope is picked can be found <a href="https://quuxplusone.github.io/blog/2020/12/21/using-directive/">here</a>. However, these names are not accessible from the outer scope -- they are <em>only</em> accessible via unqualified (non-prefixed) lookup from the scope of the using directive (or a nested scope).</p><p>The practical effect is that (outside of some weird edge cases involving multiple using directives inside nested namespaces), using directives behave as if the names had been imported into the current scope. To keep things simple, we will proceed under the simplification that the names are imported into the current scope.</p></div><p>Here’s our Hello world program again, with a <code>using directive</code> on line 5:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>   using namespace std; // this using directive tells the compiler to import all names from namespace std into the current namespace without qualification</code><code>   cout &lt;&lt; "Hello world!\n"; // so no std:: prefix is needed here</code><code>   return 0;</code><code>}</code></pre><p>The <code>using directive</code> <code>using namespace std;</code> tells the compiler to import <em>all</em> of the names from the <code>std namespace</code> into the current scope (in this case, of function <code>main()</code>). When we then use unqualified identifier <code>cout</code>, it will resolve to the imported <code>std::cout</code>.</p><p><code>Using directives</code> are the solution that was provided for old pre-namespace codebases that used unqualified names for standard library functionality. Rather than having to manually update every unqualified name to a qualified name (which was risky), a single <code>using directive</code> (of <code>using namespace std;</code>) could be placed at the top of the each file, and all of the names that had been moved to the <code>std</code> namespace could still be used unqualified.</p><br><h3>Problems with using directives (a.k.a. why you should avoid “using namespace std;”) </h3><p>In modern C++, <code>using directives</code> generally offer little benefit (saving some typing) compared to the risk. Because using directives import <em>all</em> of the names from a namespace (potentially including lots of names you’ll never use), the possibility for naming collisions to occur increases significantly (especially if you import the <code>std</code> namespace).</p><p>For illustrative purposes, let’s take a look at an example where <code>using directives</code> cause ambiguity:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>namespace a</code><code>{</code><code>	int x{ 10 };</code><code>}</code><code></code><code>namespace b</code><code>{</code><code>	int x{ 20 };</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	using namespace a;</code><code>	using namespace b;</code><code></code><code>	std::cout &lt;&lt; x &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>In the above example, the compiler is unable to determine whether the <code>x</code> in <code>main</code> refers to <code>a::x</code> or <code>b::x</code>. In this case, it will fail to compile with an “ambiguous symbol” error. We could resolve this by removing one of the <code>using</code> statements, employing a <code>using declaration</code> instead, or qualifying <code>x</code> with an explicit scope qualifier (<code>a::</code> or <code>b::</code>).</p><p>Here’s another more subtle example:</p><pre class="language-cpp line-numbers"><code>#include <iostream> // imports the declaration of std::cout</iostream></code><code></code><code>int cout() // declares our own "cout" function</code><code>{</code><code>    return 5;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    using namespace std; // makes std::cout accessible as "cout"</code><code>    cout &lt;&lt; "Hello, world!\n"; // uh oh!  Which cout do we want here?  The one in the std namespace or the one we defined above?</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, the compiler is unable to determine whether our use of <code>cout</code> means <code>std::cout</code> or the <code>cout</code> function we’ve defined, and again will fail to compile with an “ambiguous symbol” error. Although this example is trivial, if we had explicitly prefixed <code>std::cout</code> like this:</p><pre class="language-cpp line-numbers"><code>    std::cout &lt;&lt; "Hello, world!\n"; // tell the compiler we mean std::cout</code></pre><p>or used a <code>using declaration</code> instead of a <code>using directive</code>:</p><pre class="language-cpp line-numbers"><code>    using std::cout; // tell the compiler that cout means std::cout</code><code>    cout &lt;&lt; "Hello, world!\n"; // so this means std::cout</code></pre><p>then our program wouldn’t have any issues in the first place. And while you’re probably not likely to write a function named “cout”, there are hundreds, if not thousands, of other names in the std namespace just waiting to collide with your names. “count”, “min”, “max”, “search”, “sort”, just to name a few.</p><p>Even if a <code>using directive</code> does not cause naming collisions today, it makes your code more vulnerable to future collisions. For example, if your code includes a <code>using directive</code> for some library that is then updated, all of the new names introduced in the updated library are now candidates for naming collisions with your existing code.</p><p>There is a more insidious problem that can occur as well. The updated library may introduce a function that not only has the same name, but is actually a better match for some function call. In such a case, the compiler may decide to prefer the new function instead, and the behavior of your program will change unexpectedly.</p><p>Consider the following program:</p><p>foolib.h (part of some third-party library):</p><pre class="language-cpp line-numbers"><code>#ifndef FOOLIB_H</code><code>#define FOOLIB_H</code><code></code><code>namespace foo</code><code>{</code><code>    // pretend there is some useful code that we use here</code><code>}</code><code>#endif</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <foolib.h> // a third-party library, thus angled brackets used</foolib.h></code><code></code><code>int someFcn(double)</code><code>{</code><code>    return 1;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    using namespace foo; // Because we're lazy and want to access foo:: qualified names without typing the foo:: prefix</code><code>    std::cout &lt;&lt; someFcn(0) &lt;&lt; '\n'; // The literal 0 should be 0.0, but this is an easy mistake to make</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program runs and prints <code>1</code>.</p><p>Now, let’s say we update the foolib library, which includes an updated foolib.h. Our program now looks like this:</p><p>foolib.h (part of some third-party library):</p><pre class="language-cpp line-numbers"><code>#ifndef FOOLIB_H</code><code>#define FOOLIB_H</code><code></code><code>namespace foo</code><code>{</code><code>    // newly introduced function</code><code>    int someFcn(int)</code><code>    {</code><code>        return 2;</code><code>    }</code><code></code><code>    // pretend there is some useful code that we use here</code><code>}</code><code>#endif</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <foolib.h></foolib.h></code><code></code><code>int someFcn(double)</code><code>{</code><code>    return 1;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    using namespace foo; // Because we're lazy and want to access foo:: qualified names without typing the foo:: prefix</code><code>    std::cout &lt;&lt; someFcn(0) &lt;&lt; '\n'; // The literal 0 should be 0.0, but this is an easy mistake to make</code><code></code><code>    return 0;</code><code>}</code></pre><p>Our <code>main.cpp</code> file hasn’t changed at all, but this program now runs and prints <code>2</code>!</p><p>When the compiler encounters a function call, it has to determine what function definition it should match the function call with. In selecting a function from a set of potentially matching functions, it will prefer a function that requires no argument conversions over a function that requires argument conversions. Because the literal <code>0</code> is an integer, C++ will prefer to match <code>someFcn(0)</code> with the newly introduced <code>someFcn(int)</code> (no conversions) over <code>someFcn(double)</code> (requires a conversion from int to double). That causes an unexpected change to our program results.</p><p>This would not have happened if we’d used a <code>using declaration</code> or explicit scope qualifier.</p><p>Finally, the lack of explicit scope prefixes make it harder for a reader to tell what functions are part of a library and what’s part of your program. For example, if we use a using directive:</p><pre class="language-cpp line-numbers"><code>using namespace ns;</code><code></code><code>int main()</code><code>{</code><code>    foo(); // is this foo a user-defined function, or part of the ns library?</code><code>}</code></pre><p>It’s unclear whether the call to <code>foo()</code> is actually a call to <code>ns::foo()</code> or to a <code>foo()</code> that is a user-defined function. Modern IDEs should be able to disambiguate this for you when you hover over a name, but having to hover over each name just to see where it comes from is tedious.</p><p>Without the using directive, it’s much clearer:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    ns::foo(); // clearly part of the ns library</code><code>    foo(); // likely a user-defined function</code><code>}</code></pre><p>In this version, the call to <code>ns::foo()</code> is clearly a library call. The call to plain <code>foo()</code> is probably a call to a user-defined function (some libraries, including certain standard library headers, do put names into the global namespace, so it’s not a guarantee).</p><br><h3>The scope of using declarations and directives</h3><p>If a <code>using declaration</code> or <code>using directive</code> is used within a block, the names are applicable to just that block (it follows normal block scoping rules). This is a good thing, as it reduces the chances for naming collisions to occur to just within that block.</p><p>If a <code>using declaration</code> or <code>using directive</code> is used in the global namespace, the names are applicable to the entire rest of the file (they have file scope).</p><br><h3>Cancelling or replacing a using statement</h3><p>Once a <code>using statement</code> has been declared, there’s no way to cancel or replace it with a different <code>using statement</code> within the scope in which it was declared.</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    using namespace foo;</code><code></code><code>    // there's no way to cancel the "using namespace foo" here!</code><code>    // there's also no way to replace "using namespace foo" with a different using statement</code><code></code><code>    return 0;</code><code>} // using namespace foo ends here</code></pre><p>The best you can do is intentionally limit the scope of the <code>using statement</code> from the outset using the block scoping rules.</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    {</code><code>        using namespace foo;</code><code>        // calls to foo:: stuff here</code><code>    } // using namespace foo expires</code><code> </code><code>    {</code><code>        using namespace Goo;</code><code>        // calls to Goo:: stuff here</code><code>    } // using namespace Goo expires</code><code></code><code>    return 0;</code><code>}</code></pre><p>Of course, all of this headache can be avoided by explicitly using the scope resolution operator (::) in the first place.</p><br><h3>Best practices for using statements</h3><p>Avoid <code>using directives</code> (particularly <code>using namespace std;</code>), except in specific circumstances (such as <code>using namespace std::literals</code> to access the <code>s</code> and <code>sv</code> literal suffixes). <code>Using declarations</code> are generally considered safe to use inside blocks. Limit their use in the global namespace of a code file, and never use them in the global namespace of a header file.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Prefer explicit namespaces over <code>using statements</code>. Avoid <code>using directives</code> whenever possible. <code>Using declarations</code> are okay to use inside blocks.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>The <code>using</code> keyword is also used to define type aliases, which are unrelated to using statements. We cover type aliases in lesson <a href="https://www.learncpp.com/cpp-tutorial/typedefs-and-type-aliases/">8.6 -- Typedefs and type aliases</a>.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">6.13 — Inline functions</h1></header><div class="entry-content" itemprop="articleBody"><p>Consider the case where you need to write some code to perform some discrete task, like reading input from the user, or outputting something to a file, or calculating a particular value. When implementing this code, you essentially have two options:</p><ol start="1"><li>Write the code as part of an existing function (called writing code “in-place” or “inline”).</li><li>Create a function (and possibly sub-functions) to handle the task.</li></ol><p>Writing functions provides many potential benefits, as code in a function:</p><ul><li>Is easier to read and understand in the context of the overall program.</li><li>Is easier to use, as you can call the function without understanding how it is implemented.</li><li>Is easier to update, as the code in a function can be updated in one place.</li><li>Is easier to reuse, as functions are naturally modular.</li></ul><p>However, one downside of using a function is that every time a function is called, there is a certain amount of performance overhead that occurs. Consider the following example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int min(int x, int y)</code><code>{</code><code>    return (x &lt; y) ? x : y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; min(5, 6) &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; min(3, 2) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>When a call to <code>min()</code> is encountered, the CPU must store the address of the current instruction it is executing (so it knows where to return to later) along with the values of various CPU registers (so they can be restored upon returning). Then parameters <code>x</code> and <code>y</code> must be instantiated and then initialized. Then the execution path has to jump to the code in the <code>min()</code> function. When the function ends, the program has to jump back to the location of the function call, and the return value has to be copied so it can be output. In other words, there is a significant amount of overhead cost that is incurred with each function call.</p><p>For functions that are large and/or perform complex tasks, the overhead of the function call is typically insignificant compared to the amount of time the function takes to run. However, for small functions (such as <code>min()</code> above), the overhead costs can be larger than the time needed to actually execute the function’s code! In cases where a small function is called often, using a function can result in a significant performance penalty over writing the same code in-place.</p><br><h3>Inline expansion</h3><p>Fortunately, the C++ compiler has a trick that it can use to avoid such overhead cost: <span class="cpp-definition">Inline expansion</span> is a process where a function call is replaced by the code from the called function’s definition.</p><p>For example, if the compiler expanded the <code>min()</code> calls in the above example, the resulting code would look like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; ((5 &lt; 6) ? 5 : 6) &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; ((3 &lt; 2) ? 3 : 2) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>Note that the two calls to function <code>min()</code> have been replaced by the code in the body of the <code>min()</code> function (with the value of the arguments substituted for the parameters). This allows us to avoid the overhead of those calls, while preserving the results of the code.</p><br><h3>The performance of inline code</h3><p>Beyond removing the cost of function call overhead, inline expansion can also allow the compiler to optimize the resulting code more efficiently -- for example, because the expression <code>((5 &lt; 6) ? 5 : 6)</code> is now a compile-time constant, the compiler could further optimize the first statement in <code>main()</code> to <code>std::cout &lt;&lt; 5 &lt;&lt; '\n';</code>.</p><p>However, inline expansion has its own potential cost: if the body of the function being expanded takes more instructions than the function call being replaced, then each inline expansion will cause the executable to grow larger. Larger executables tend to be slower (due to not fitting as well in caches).</p><p>The decision about whether a function would benefit from being made inline (because removal of the function call overhead outweighs the cost of a larger executable) is not straightforward. Inline expansion could result in performance improvements, performance reductions, or no change to performance at all, depending on the relative cost of a function call, the size of the function, and what other optimizations can be performed.</p><p>Inline expansion is best suited to simple, short functions (e.g. no more than a few statements), especially cases where a single function call is executed more than once (e.g. function calls inside a loop).</p><br><h3>When inline expansion occurs</h3><p>Every function falls into one of three categories, where calls to the function:</p><ul><li>Must be expanded.</li><li>May be expanded (most functions are in this category).</li><li>Can’t be expanded.</li></ul><p>A function that is eligible to have its function calls expanded is called an <span class="cpp-definition">inline function</span>.</p><p>Most functions fall into the “may” category: their function calls can be expanded if and when it is beneficial to do so. For functions in this category, a modern compiler will assess each function and each function call to make a determination about whether that particular function call would benefit from inline expansion. A compiler might decide to expand none, some, or all of the function calls to a given function.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>Modern optimizing compilers make the decision about when functions should be expanded inline.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>Some types of functions are implicitly treated as inline functions. These include:</p><ul><li>Functions defined inside a class, struct, or union type definition.</li><li>Constexpr / consteval functions (<a href="https://www.learncpp.com/cpp-tutorial/constexpr-and-consteval-functions/">6.14 -- Constexpr and consteval functions</a>)</li></ul></div><br><h3>The inline keyword, historically</h3><p>Historically, compilers either didn’t have the capability to determine whether inline expansion would be beneficial, or were not very good at it. For this reason, C++ provides the keyword <code>inline</code>, which was intended to be used as a hint to the compiler that a function would benefit from being expanded inline:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>inline int min(int x, int y) // hint to the compiler that it should do inline expansion of this function</code><code>{</code><code>    return (x &lt; y) ? x : y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; min(5, 6) &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; min(3, 2) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>This is where the term “inline function” comes from (because such functions had the <code>inline</code> specifier as part of the declaration syntax of the function).</p><p>However, in modern C++, the <code>inline</code> keyword is no longer used to request that a function be expanded inline. There are quite a few reasons for this:</p><ul><li>Using <code>inline</code> to request inline expansion is a form of premature optimization, and misuse could actually harm performance.</li><li>The <code>inline</code> keyword is just a hint -- the compiler is completely free to ignore a request to inline a function. This is likely to be the result if you try to inline a lengthy function! The compiler is also free to perform inline expansion of functions that do not use the <code>inline</code> keyword as part of its normal set of optimizations.</li><li>The <code>inline</code> keyword is defined at the wrong level of granularity. We use the <code>inline</code> keyword on a function declaration, but inline expansion is actually determined per function call. It may be beneficial to expand some function calls and detrimental to expand others, and there is no syntax to affect this.</li></ul><p>Modern optimizing compilers are typically very good at determining which functions should be made inline -- better than humans in most cases. As a result, the compiler will likely ignore or devalue any request you make to <code>inline</code> a function anyway.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Do not use the <code>inline</code> keyword to request inline expansion for your functions.</p></div><br><h3>The inline keyword, modernly</h3><p>In previous chapters, we mentioned that you should not implement functions (with external linkage) in header files, because when those headers are included into multiple .cpp files, the function definition will be copied into multiple .cpp files. These files will then be compiled, and the linker will throw an error because it will note that you’ve defined the same function more than once, which is a violation of the one-definition rule.</p><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/sharing-global-constants-across-multiple-files-using-inline-variables/">6.9 -- Sharing global constants across multiple files (using inline variables)</a>, we noted that in modern C++, the <code>inline</code> concept has evolved to have a new meaning: multiple definitions are allowed in the program. This is true for functions as well as variables. Thus, if we mark a function as inline, then that function is allowed to have multiple definitions (in different files), as long as those definitions are identical.</p><p>In order to do inline expansion, the compiler needs to be able to see the full definition of an inline function wherever the function is called. Therefore, inline functions are typically defined in header files, where they can be #included into any code file that needs to see the full definition of the function.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>The compiler needs to be able to see the full definition of an inline function wherever it is called.</p></div><p>For the most part, you should not mark your functions as inline, but we’ll see examples in the future where this is useful.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Avoid the use of the <code>inline</code> keyword for functions unless you have a specific, compelling reason to do so.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">6.14 — Constexpr and consteval functions</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/const-variables-and-symbolic-constants/">4.13 -- Const variables and symbolic constants</a>, we introduced the <code>constexpr</code> keyword, which we used to create compile-time (symbolic) constants. We also introduced constant expressions, which are expressions that can be evaluated at compile-time rather than runtime.</p><p>Consider the following program, which uses two constexpr variables:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    constexpr int x{ 5 };</code><code>    constexpr int y{ 6 };</code><code></code><code>    std::cout &lt;&lt; (x &gt; y ? x : y) &lt;&lt; " is greater!\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This produces the result:</p><pre>6 is greater!
</pre><p>Because <code>x</code> and <code>y</code> are constexpr, the compiler can evaluate the constant expression <code>(x &gt; y ? x : y)</code> at compile-time, reducing it to just <code>6</code>. Because this expression no longer needs to be evaluated at runtime, our program will run faster.</p><p>However, having a non-trivial expression in the middle of our print statement isn’t ideal -- it would be better if the expression were a named function. Here’s the same example using a function:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int greater(int x, int y)</code><code>{</code><code>    return (x &gt; y ? x : y); // here's our expression</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    constexpr int x{ 5 };</code><code>    constexpr int y{ 6 };</code><code></code><code>    std::cout &lt;&lt; greater(x, y) &lt;&lt; " is greater!\n"; // will be evaluated at runtime</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program produces the same output as the prior one. But there’s a downside to putting our expression in a function: the call to <code>greater(x, y)</code> will execute at runtime. By using a function (which is good for modularity and documentation) we’ve lost our ability for that code to be evaluated at compile-time (which is bad for performance).</p><p>So how might we address this?</p><br><h3>Constexpr functions can be evaluated at compile-time</h3><p>A <span class="cpp-definition">constexpr function</span> is a function whose return value may be computed at compile-time. To make a function a constexpr function, we simply use the <code>constexpr</code> keyword in front of the return type. Here’s a similar program to the one above, using a constexpr function:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>constexpr int greater(int x, int y) // now a constexpr function</code><code>{</code><code>    return (x &gt; y ? x : y);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    constexpr int x{ 5 };</code><code>    constexpr int y{ 6 };</code><code></code><code>    // We'll explain why we use variable g here later in the lesson</code><code>    constexpr int g { greater(x, y) }; // will be evaluated at compile-time</code><code></code><code>    std::cout &lt;&lt; g &lt;&lt; " is greater!\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This produces the same output as the prior example, but the function call <code>greater(x, y)</code> will be evaluated at compile-time instead of runtime!</p><p>When a function call is evaluated at compile-time, the compiler will calculate the return value of the function call, and then replace the function call with the return value.</p><p>So in our example, the call to <code>greater(x, y)</code> will be replaced by the result of the function call, which is the integer value <code>6</code>. In other words, the compiler will compile this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    constexpr int x{ 5 };</code><code>    constexpr int y{ 6 };</code><code></code><code>    constexpr int g { 6 }; // greater(x, y) evaluated and replaced with return value 6</code><code></code><code>    std::cout &lt;&lt; g &lt;&lt; " is greater!\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>To be eligible for compile-time evaluation, a function must have a constexpr return type and not call any non-constexpr functions. Additionally, a call to the function must have constexpr arguments (e.g. constexpr variables or literals).</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>We’ll use the term “eligible for compile-time evaluation” later in the article, so remember this definition.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>There are some other lesser encountered criteria as well. These can be found <a href="https://en.cppreference.com/w/cpp/language/constexpr">here</a>.</p></div><p>Our <code>greater()</code> function definition and function call in the above example meets these requirements, so it is eligible for compile-time evaluation.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use a <code>constexpr</code> return type for functions that need to return a compile-time constant.</p></div><br><h3>Constexpr functions are implicitly inline</h3><p>Because constexpr functions may be evaluated at compile-time, the compiler must be able to see the full definition of the constexpr function at all points where the function is called.</p><p>This means that a constexpr function called in multiple files needs to have its definition included into each such file -- which would normally be a violation of the one-definition rule. To avoid such problems, constexpr functions are implicitly inline, which makes them exempt from the one-definition rule.</p><p>As a result, constexpr functions are often defined in header files, so they can be #included into any .cpp file that requires the full definition.</p><br><h3>Constexpr functions can also be evaluated at runtime</h3><p>Functions with a constexpr return value can also be evaluated at runtime, in which case they will return a non-constexpr result. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>constexpr int greater(int x, int y)</code><code>{</code><code>    return (x &gt; y ? x : y);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 }; // not constexpr</code><code>    int y{ 6 }; // not constexpr</code><code></code><code>    std::cout &lt;&lt; greater(x, y) &lt;&lt; " is greater!\n"; // will be evaluated at runtime</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this example, because arguments <code>x</code> and <code>y</code> are not constexpr, the function cannot be resolved at compile-time. However, the function will still be resolved at runtime, returning the expected value as a non-constexpr <code>int</code>.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Allowing functions with a constexpr return type to be evaluated at either compile-time or runtime was allowed so that a single function can serve both cases.</p><p>Otherwise, you’d need to have separate functions (a function with a constexpr return type, and a function with a non-constexpr return type). This would not only require duplicate code, the two functions would also need to have different names!</p></div><br><h3>So when is a constexpr function evaluated at compile-time?</h3><p>You might think that a constexpr function would evaluate at compile-time whenever possible, but unfortunately this is not the case.</p><p>According to the C++ standard, a constexpr function that is eligible for compile-time evaluation <em>must</em> be evaluated at compile-time if the return value is used where a constant expression is required. Otherwise, the compiler is free to evaluate the function at either compile-time or runtime.</p><p>Let’s examine a few cases to explore this further:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>constexpr int greater(int x, int y)</code><code>{</code><code>    return (x &gt; y ? x : y);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    constexpr int g { greater(5, 6) };            // case 1: evaluated at compile-time</code><code>    std::cout &lt;&lt; g &lt;&lt; " is greater!\n";</code><code></code><code>    int x{ 5 }; // not constexpr</code><code>    std::cout &lt;&lt; greater(x, 6) &lt;&lt; " is greater!\n"; // case 2: evaluated at runtime</code><code></code><code>    std::cout &lt;&lt; greater(5, 6) &lt;&lt; " is greater!\n"; // case 3: may be evaluated at either runtime or compile-time</code><code></code><code>    return 0;</code><code>}</code></pre><p>In case 1, we’re calling <code>greater()</code> with constexpr arguments, so it is eligible to be evaluated at compile-time. The initializer of constexpr variable <code>g</code> must be a constant expression, so the return value is used in a context that requires a constant expression. Thus, <code>greater()</code> must be evaluated at compile-time.</p><p>In case 2, we’re calling <code>greater()</code> with one parameter that is non-constexpr. Thus <code>greater()</code> cannot be evaluated at compile-time, and must evaluate at runtime.</p><p>Case 3 is the interesting case. The <code>greater()</code> function is again being called with constexpr arguments, so it is eligible for compile-time evaluation. However, the return value is not being used in a context that requires a constant expression (operator&lt;&lt; always executes at runtime), so the compiler is free to choose whether this call to <code>greater()</code> will be evaluated at compile-time or runtime!</p><p>Note that your compiler’s optimization level setting may have an impact on whether it decides to evaluate a function at compile-time or runtime. This also means that your compiler may make different choices for debug vs. release builds (as debug builds typically have optimizations turned off).</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>A constexpr function that is eligible to be evaluated at compile-time will only be evaluated at compile-time if the return value is used where a constant expression is required. Otherwise, compile-time evaluation is not guaranteed.</p><p>Thus, a constexpr function is better thought of as “can be used in a constant expression”, not “will be evaluated at compile-time”.</p></div><br><h3>Determining if a constexpr function call is evaluating at compile-time or runtime</h3><p>Prior to C++20, there are no standard language tools available to do this.</p><p>In C++20, <code>std::is_constant_evaluated()</code> (defined in the &lt;type_traits&gt; header) returns a <code>bool</code> indicating whether the current function call is executing in a constant context. This can be combined with a conditional statement to allow a function to behave differently when evaluated at compile-time vs runtime.</p><pre class="language-cpp line-numbers"><code>#include <type_traits> // for std::is_constant_evaluated</type_traits></code><code>constexpr int someFunction()</code><code>{</code><code>    if (std::is_constant_evaluated()) // if compile-time evaluation</code><code>        // do something</code><code>    else // runtime evaluation</code><code>        // do something else  </code><code>}</code></pre><p>Used cleverly, you can have your function produce some observable difference (such as returning a special value) when evaluated at compile-time, and then infer how it evaluated from that result.</p><br><h3>Forcing a constexpr function to be evaluated at compile-time</h3><p>There is no way to tell the compiler that a constexpr function should prefer to evaluate at compile-time whenever it can (even in cases where the return value is used in a non-constant expression).</p><p>However, we can force a constexpr function that is eligible to be evaluated at compile-time to actually evaluate at compile-time by ensuring the return value is used where a constant expression is required. This needs to be done on a per-call basis.</p><p>The most common way to do this is to use the return value to initialize a constexpr variable (this is why we’ve been using variable ‘g’ in prior examples). Unfortunately, this requires introducing a new variable into our program just to ensure compile-time evaluation, which is ugly and reduces code readability.</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>There are several hacky ways that people have tried to work around the problem of having to introduce a new constexpr variable each time we want to force compile-time evaluation. See <a href="https://quuxplusone.github.io/blog/2018/08/07/force-constexpr/">here</a> and <a href="https://artificial-mind.net/blog/2020/11/14/cpp17-consteval">here</a>.</p></div><p>However, in C++20, there is a better workaround to this issue, which we’ll present in a moment.</p><br><h3>Consteval C++20</h3><p>C++20 introduces the keyword <span class="cpp-definition">consteval</span>, which is used to indicate that a function <em>must</em> evaluate at compile-time, otherwise a compile error will result. Such functions are called <span class="cpp-definition">immediate functions</span>.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>consteval int greater(int x, int y) // function is now consteval</code><code>{</code><code>    return (x &gt; y ? x : y);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    constexpr int g { greater(5, 6) };            // ok: will evaluate at compile-time</code><code>    std::cout &lt;&lt; greater(5, 6) &lt;&lt; " is greater!\n"; // ok: will evaluate at compile-time</code><code></code><code>    int x{ 5 }; // not constexpr</code><code>    std::cout &lt;&lt; greater(x, 6) &lt;&lt; " is greater!\n"; // error: consteval functions must evaluate at compile-time</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, the first two calls to <code>greater()</code> will evaluate at compile-time. The call to <code>greater(x, 6)</code> cannot be evaluated at compile-time, so a compile error will result.</p><p>Just like constexpr functions, consteval functions are implicitly inline.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use <code>consteval</code> if you have a function that must run at compile-time for some reason (e.g. performance).</p></div><br><h3>Using consteval to make constexpr execute at compile-time C++20</h3><p>The downside of consteval functions is that such functions can’t evaluate at runtime, making them less flexible than constexpr functions, which can do either. Therefore, it would still be useful to have a convenient way to force constexpr functions to evaluate at compile-time (even when the return value is being used where a constant expression is not required), so that we could have compile-time evaluation when possible, and runtime evaluation when we can’t.</p><p>Consteval functions provides a way to make this happen, using a neat helper function:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// Uses abbreviated function template (C++20) and `auto` return type to make this function work with any type of value</code><code>// See 'related content' box below for more info (you don't need to know how these work to use this function)</code><code>consteval auto compileTime(auto value)</code><code>{</code><code>    return value;</code><code>}</code><code></code><code>constexpr int greater(int x, int y) // function is constexpr</code><code>{</code><code>    return (x &gt; y ? x : y);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; greater(5, 6) &lt;&lt; '\n';              // may or may not execute at compile-time</code><code>    std::cout &lt;&lt; compileTime(greater(5, 6)) &lt;&lt; '\n'; // will execute at compile-time</code><code></code><code>    int x { 5 };</code><code>    std::cout &lt;&lt; greater(x, 6) &lt;&lt; '\n';              // we can still call the constexpr version at runtime if we wish</code><code></code><code>    return 0;</code><code>}</code></pre><p>This works because consteval functions require constant expressions as arguments -- therefore, if we use the return value of a constexpr function as an argument to a consteval function, the constexpr function must be evaluated at compile-time! The consteval function just returns this argument as its own return value, so the caller can still use it.</p><p>Note that the consteval function returns by value. While this might be inefficient to do at runtime (if the value was some type that is expensive to copy, e.g. std::string), in a compile-time context, it doesn’t matter because the entire call to the consteval function will simply be replaced with the calculated return value.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We cover <code>auto</code> return types in lesson <a href="https://www.learncpp.com/cpp-tutorial/type-deduction-for-functions/">8.8 -- Type deduction for functions</a>.<br>We cover abbreviated function templates (<code>auto</code> parameters) in lesson <a href="https://www.learncpp.com/cpp-tutorial/function-templates-with-multiple-template-types/">8.15 -- Function templates with multiple template types</a>.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">6.15 — Unnamed and inline namespaces</h1></header><div class="entry-content" itemprop="articleBody"><p>C++ supports two variants of namespaces that are worth at least knowing about. We won’t build on these, so consider this lesson optional for now.</p><br><h3>Unnamed (anonymous) namespaces</h3><p>An <span class="cpp-definition">unnamed namespace</span> (also called an <span class="cpp-definition">anonymous namespace</span>) is a namespace that is defined without a name, like so:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>namespace // unnamed namespace</code><code>{</code><code>    void doSomething() // can only be accessed in this file</code><code>    {</code><code>        std::cout &lt;&lt; "v1\n";</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    doSomething(); // we can call doSomething() without a namespace prefix</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>v1
</pre><p>All content declared in an <code>unnamed namespace</code> is treated as if it is part of the parent namespace. So even though function <code>doSomething</code> is defined in the <code>unnamed namespace</code>, the function itself is accessible from the parent namespace (which in this case is the <code>global namespace</code>), which is why we can call <code>doSomething</code> from <code>main</code> without any qualifiers.</p><p>This might make <code>unnamed namespaces</code> seem useless. But the other effect of <code>unnamed namespaces</code> is that all identifiers inside an <code>unnamed namespace</code> are treated as if they had <code>internal linkage</code>, which means that the content of an <code>unnamed namespace</code> can’t be seen outside of the file in which the <code>unnamed namespace</code> is defined.</p><p>For functions, this is effectively the same as defining all functions in the <code>unnamed namespace</code> as <code>static functions</code>. The following program is effectively identical to the one above:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>static void doSomething() // can only be accessed in this file</code><code>{</code><code>    std::cout &lt;&lt; "v1\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    doSomething(); // we can call doSomething() without a namespace prefix</code><code></code><code>    return 0;</code><code>}</code></pre><p><code>Unnamed namespaces</code> are typically used when you have a lot of content that you want to ensure stays local to a given file, as it’s easier to cluster such content in an <code>unnamed namespace</code> than individually mark all declarations as <code>static</code>. <code>Unnamed namespaces</code> will also keep <code>user-defined types</code> (something we’ll discuss in a later lesson) local to the file, something for which there is no alternative equivalent mechanism to do.</p><br><h3>Inline namespaces</h3><p>Now consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void doSomething()</code><code>{</code><code>    std::cout &lt;&lt; "v1\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    doSomething();</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>v1
</pre><p>Pretty straightforward, right?</p><p>But let’s say you’re not happy with <code>doSomething</code>, and you want to improve it in some way that changes how it behaves. But if you do this, you risk breaking existing programs using the older version. How do you handle this?</p><p>One way would be to create a new version of the function with a different name. But over the course of many changes, you could end up with a whole set of almost-identically named functions (<code>doSomething</code>, <code>doSomething_v2</code>, <code>doSomething_v3</code>, etc…).</p><p>An alternative is to use an inline namespace. An <span class="cpp-definition">inline namespace</span> is a namespace that is typically used to version content. Much like an <code>unnamed namespace</code>, anything declared inside an <code>inline namespace</code> is considered part of the parent namespace. However, <code>inline namespaces</code> don’t give everything <code>internal linkage</code>.</p><p>To define an inline namespace, we use the <code>inline</code> keyword:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>inline namespace v1 // declare an inline namespace named v1</code><code>{</code><code>    void doSomething()</code><code>    {</code><code>        std::cout &lt;&lt; "v1\n";</code><code>    }</code><code>}</code><code></code><code>namespace v2 // declare a normal namespace named v2</code><code>{</code><code>    void doSomething()</code><code>    {</code><code>        std::cout &lt;&lt; "v2\n";</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    v1::doSomething(); // calls the v1 version of doSomething()</code><code>    v2::doSomething(); // calls the v2 version of doSomething()</code><code></code><code>    doSomething(); // calls the inline version of doSomething() (which is v1)</code><code> </code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>v1
v2
v1
</pre><p>In the above example, callers to <code>doSomething</code> will get the v1 (the inline version) of <code>doSomething</code>. Callers who want to use the newer version can explicitly call <code>v2::dosomething()</code>. This preserves the function of existing programs while allowing newer programs to take advantage of newer/better variations.</p><p>Alternatively, if you want to push the newer version:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>namespace v1 // declare a normal namespace named v1</code><code>{</code><code>    void doSomething()</code><code>    {</code><code>        std::cout &lt;&lt; "v1\n";</code><code>    }</code><code>}</code><code></code><code>inline namespace v2 // declare an inline namespace named v2</code><code>{</code><code>    void doSomething()</code><code>    {</code><code>        std::cout &lt;&lt; "v2\n";</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    v1::doSomething(); // calls the v1 version of doSomething()</code><code>    v2::doSomething(); // calls the v2 version of doSomething()</code><code></code><code>    doSomething(); // calls the inline version of doSomething() (which is v2)</code><code> </code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>v1
v2
v2
</pre><p>In this example, all callers to <code>doSomething</code> will get the v2 version by default (the newer and better version). Users who still want the older version of <code>doSomething</code> can explicitly call <code>v1::doSomething()</code> to access the old behavior. This means existing programs who want the v1 version will need to globally replace <code>doSomething</code> with <code>v1::doSomething</code>, but this typically won’t be problematic if the functions are well named.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">6.x — Chapter 6 summary and quiz</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Quick review</h3><p>We covered a lot of material in this chapter. Good job, you’re doing great!</p><p>A <span class="cpp-definition">compound statement</span> or <span class="cpp-definition">block</span> is a group of zero or more statements that is treated by the compiler as if it were a single statement. Blocks begin with a <code>{</code> symbol, end with a <code>}</code> symbol, with the statements to be executed placed in between. Blocks can be used anywhere a single statement is allowed. No semicolon is needed at the end of a block. Blocks are often used in conjunction with <code>if statements</code> to execute multiple statements.</p><p><span class="cpp-definition">User-defined namespaces</span> are namespaces that are defined by you for your own declarations. Namespaces provided by C++ (such as the <code>global namespace</code>) or by libraries (such as <code>namespace std</code>) are not considered user-defined namespaces.</p><p>You can access a declaration in a namespace via the <span class="cpp-definition">scope resolution operator (::)</span>. The scope resolution operator tells the compiler that identifier specified by the right-hand operand should be looked for in the scope of the left-hand operand. If no left-hand operand is provided, the global namespace is assumed.</p><p>Local variables are variables defined within a function (including function parameters). Local variables have <span class="cpp-definition">block scope</span>, meaning they are in-scope from their point of definition to the end of the block they are defined within. Local variables have <span class="cpp-definition">automatic storage duration</span>, meaning they are created at the point of definition and destroyed at the end of the block they are defined in.</p><p>A name declared in a nested block can <span class="cpp-definition">shadow</span> or <span class="cpp-definition">name hide</span> an identically named variable in an outer block. This should be avoided.</p><p>Global variables are variables defined outside of a function. Global variables have <span class="cpp-definition">file scope</span>, which means they are visible from the point of declaration until the end of the file in which they are declared. Global variables have <span class="cpp-definition">static duration</span>, which means they are created when the program starts, and destroyed when it ends. Avoid dynamic initialization of static variables whenever possible.</p><p>An identifier’s <span class="cpp-definition">linkage</span> determines whether other declarations of that name refer to the same object or not. Local variables have no linkage. Identifiers with <span class="cpp-definition">internal linkage</span> can be seen and used within a single file, but it is not accessible from other files. Identifiers with <span class="cpp-definition">external linkage</span> can be seen and used both from the file in which it is defined, and from other code files (via a forward declaration).</p><p>Avoid non-const global variables whenever possible. Const globals are generally seen as acceptable. Use <span class="cpp-definition">inline variables</span> for global constants if your compiler is C++17 capable.</p><p>Local variables can be given static duration via the <span class="cpp-definition">static</span> keyword.</p><p><span class="cpp-definition">Using statements</span> (including <span class="cpp-definition">using declarations</span> and <span class="cpp-definition">using directives</span>) can be used to avoid having to qualify identifiers with an explicit namespace. These should generally be avoided.</p><p><span class="cpp-definition">Inline functions</span> were originally designed as a way to request that the compiler replace your function call with inline expansion of the function code. You should not need to use the inline keyword for this purpose because the compiler will generally determine this for you. In modern C++, the <code>inline</code> keyword is used to exempt a function from the one-definition rule, allowing its definition to be imported into multiple code files. Inline functions are typically defined in header files so they can be #included into any code files that needs them.</p><p>A <span class="cpp-definition">constexpr function</span> is a function whose return value may be computed at compile-time. To make a function a constexpr function, we simply use the <code>constexpr</code> keyword in front of the return type. A constexpr function that is eligible for compile-time evaluation must be evaluated at compile-time if the return value is used in a context that requires a constexpr value. Otherwise, the compiler is free to evaluate the function at either compile-time or runtime.</p><p>C++20 introduces the keyword <code>consteval</code>, which is used to indicate that a function must evaluate at compile-time, otherwise a compile error will result. Such functions are called <span class="cpp-definition">immediate functions</span>.</p><p>Finally, C++ supports <span class="cpp-definition">unnamed namespaces</span>, which implicitly treat all contents of the namespace as if it had internal linkage. C++ also supports <span class="cpp-definition">inline namespaces</span>, which provide some primitive versioning capabilities for namespaces.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Fix the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Enter a positive number: ";</code><code>	int num{};</code><code>	std::cin &gt;&gt; num;</code><code></code><code></code><code>	if (num &lt; 0)</code><code>		std::cout &lt;&lt; "Negative number entered.  Making positive.\n";</code><code>		num = -num;</code><code></code><code>	std::cout &lt;&lt; "You entered: " &lt;&lt; num;</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Enter a positive number: ";</code><code>	int num{};</code><code>	std::cin &gt;&gt; num;</code><code></code><code></code><code>	if (num &lt; 0)</code><code>	{ // block needed here so both statements execute if num is &lt; 0</code><code>		std::cout &lt;&lt; "Negative number entered.  Making positive.\n";</code><code>		num = -num;</code><code>	}</code><code></code><code>	std::cout &lt;&lt; "You entered: " &lt;&lt; num;</code><code></code><code>	return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>Write a file named constants.h that makes the following program run. If your compiler is C++17 capable, use inline constexpr variables. Otherwise, use normal constexpr variables. <code>max_class_size</code> should be <code>35</code>.</p><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include "constants.h"</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "How many students are in your class? ";</code><code>	int students{};</code><code>	std::cin &gt;&gt; students;</code><code></code><code></code><code>	if (students &gt; constants::max_class_size)</code><code>		std::cout &lt;&lt; "There are too many students in this class";</code><code>	else</code><code>		std::cout &lt;&lt; "This class isn't too large";</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>constants.h:</p><pre class="language-cpp line-numbers"><code>#ifndef CONSTANTS_H</code><code>#define CONSTANTS_H</code><code></code><code>namespace constants</code><code>{</code><code>	inline constexpr int max_class_size{ 35 }; // remove inline keyword if not C++17 capable</code><code>}</code><code>#endif</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include "constants.h"</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "How many students are in your class? ";</code><code>	int students{};</code><code>	std::cin &gt;&gt; students;</code><code></code><code></code><code>	if (students &gt; constants::max_class_size)</code><code>		std::cout &lt;&lt; "There are too many students in this class";</code><code>	else</code><code>		std::cout &lt;&lt; "This class isn't too large";</code><code></code><code>	return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>Complete the following program by writing the passOrFail() function, which should return true for the first 3 calls, and false thereafter. Do this without modifying the main() function.</p><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">Hint: Use a static local variable to remember how many times passOrFail() has been called previously.</div><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "User #1: " &lt;&lt; (passOrFail() ? "Pass\n" : "Fail\n");</code><code>	std::cout &lt;&lt; "User #2: " &lt;&lt; (passOrFail() ? "Pass\n" : "Fail\n");</code><code>	std::cout &lt;&lt; "User #3: " &lt;&lt; (passOrFail() ? "Pass\n" : "Fail\n");</code><code>	std::cout &lt;&lt; "User #4: " &lt;&lt; (passOrFail() ? "Pass\n" : "Fail\n");</code><code>	std::cout &lt;&lt; "User #5: " &lt;&lt; (passOrFail() ? "Pass\n" : "Fail\n");</code><code></code><code>	return 0;</code><code>}</code></pre><p>The program should produce the following output:</p><pre>User #1: Pass
User #2: Pass
User #3: Pass
User #4: Fail
User #5: Fail
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// note: It should be mentioned that the following function is poorly designed for two reasons:</code><code>// 1) There's no way to reset s_passes, so the function can't be reused in a program</code><code>// 2) The function inscrutably returns a different value after a certain number of calls</code><code>bool passOrFail()</code><code>{</code><code>	static int s_passes { 3 };</code><code>	--s_passes;</code><code>	return (s_passes &gt;= 0);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "User #1: " &lt;&lt; (passOrFail() ? "Pass\n" : "Fail\n");</code><code>	std::cout &lt;&lt; "User #2: " &lt;&lt; (passOrFail() ? "Pass\n" : "Fail\n");</code><code>	std::cout &lt;&lt; "User #3: " &lt;&lt; (passOrFail() ? "Pass\n" : "Fail\n");</code><code>	std::cout &lt;&lt; "User #4: " &lt;&lt; (passOrFail() ? "Pass\n" : "Fail\n");</code><code>	std::cout &lt;&lt; "User #5: " &lt;&lt; (passOrFail() ? "Pass\n" : "Fail\n");</code><code></code><code>	return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.1 — Control flow introduction</h1></header><div class="entry-content" itemprop="articleBody"><p>When a program is run, the CPU begins execution at the top of <code>main()</code>, executes some number of statements (in sequential order by default), and then the program terminates at the end of <code>main()</code>. The specific sequence of statements that the CPU executes is called the program’s <span class="cpp-definition">execution path</span> (or <span class="cpp-definition">path</span>, for short).</p><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    </code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    std::cout &lt;&lt; "You entered " &lt;&lt; x;</code><code></code><code>    return 0;</code><code>}</code></pre><p>The execution path of this program includes lines 5, 7, 8, 10, and 12, in that order. This is an example of a <span class="cpp-definition">straight-line program</span>. Straight-line programs take the same path (execute the same statements in the same order) every time they are run.</p><p>However, often this is not what we desire. For example, if we ask the user for input, and the user enters something invalid, ideally we’d like to ask the user to make another choice. This is not possible in a straight-line program. In fact, the user may repeatedly enter invalid input, so the number of times we might need to ask them to make another selection isn’t knowable until runtime.</p><p>Fortunately, C++ provides a number of different <span class="cpp-definition">control flow statements</span> (also called <span class="cpp-definition">flow control statements</span>), which are statements that allow the programmer to change the normal path of execution through the program. You’ve already seen an example of this with <code>if statements</code> (introduced in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-if-statements/">4.10 -- Introduction to if statements</a>) that let us execute a statement only if a conditional expression is true.</p><p>When a <code>control flow statement</code> causes point of execution to change to a non-sequential statement, this is called <span class="cpp-definition">branching</span>.</p><br><h3>Categories of flow control statements</h3><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Category</th><th>Meaning</th><th>Implementated in C++ by</th></tr><tr><td>Conditional statements</td><td>Conditional statements cause a sequence of code to execute only if some condition is met.</td><td>If, switch</td></tr><tr><td>Jumps</td><td>Jumps tell the CPU to start executing the statements at some other location.</td><td>Goto, break, continue</td></tr><tr><td>Function calls</td><td>Function calls are jumps to some other location and back.</td><td>Function calls, return</td></tr><tr><td>Loops</td><td>Loops tell the program to repeatedly execute some sequence of code zero or more times, until some condition is met.</td><td>While, do-while, for, ranged-for</td></tr><tr><td>Halts</td><td>Halts tell the program to quit running.</td><td>std::exit(), std::abort()</td></tr><tr><td>Exceptions</td><td>Exceptions are a special kind of flow control structure designed for error handling.</td><td>Try, throw, catch</td></tr></tbody></table></div><p>We’ll cover all of these categories in detail throughout this chapter, with the exception of exceptions (ha) which we’ll devote an entire future chapter to (<a href="https://www.learncpp.com#Chapter20">chapter 20</a>).</p><p>Prior to this chapter, the number of things you could have a program do was fairly limited. Being able to control the flow of your program (particularly using loops) makes any number of interesting things possible! No longer will you be restricted to toy programs and academic exercises -- you will be able to write programs that have real utility.</p><p>This is where the real fun begins. So let’s get to it!</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.2 — If statements and blocks</h1></header><div class="entry-content" itemprop="articleBody"><p>The first category of control flow statements we’ll talk about are the conditional statements. A <span class="cpp-definition">conditional statement</span> is a statement that specifies whether some associated statement(s) should be executed or not.</p><p>C++ supports two basic kinds of conditionals: <code>if statements</code> (which we introduced in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-if-statements/">4.10 -- Introduction to if statements</a>, and will talk about further here) and <code>switch statements</code> (which we’ll cover in a couple of lessons).</p><br><h3>Quick if-statement recap</h3><p>The most basic kind of conditional statement in C++ is the <code>if statement</code>. An <code>if statement</code> takes the form:</p><pre>if (condition)
    true_statement;
</pre><p>or with an optional <code>else statement</code>:</p><pre>if (condition)
    true_statement;
else
    false_statement;
</pre><p>If the <code>condition</code> evaluates to <code>true</code>, the <code>true_statement</code> executes. If the <code>condition</code> evaluates to <code>false</code> and the optional <code>else statement</code> exists, the <code>false_statement</code> executes.</p><p>Here is a simple program that uses an <code>if statement</code> with the optional <code>else statement</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number: ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    if (x &gt; 10)</code><code>        std::cout &lt;&lt; x &lt;&lt; " is greater than 10\n";</code><code>    else</code><code>        std::cout &lt;&lt; x &lt;&lt; " is not greater than 10\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program works just like you’d expect:</p><pre>Enter a number: 15
15 is greater than 10
</pre><pre>Enter a number: 4
4 is not greater than 10
</pre><br><h3>If or else with multiple conditional statements</h3><p>New programmers often try something like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter your height (in cm): ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    if (x &gt; 140)</code><code>        std::cout &lt;&lt; "You are tall enough to ride.\n";</code><code>    else</code><code>        std::cout &lt;&lt; "You are not tall enough to ride.\n";</code><code>        std::cout &lt;&lt; "Too bad!\n"; // focus on this line</code><code></code><code>    return 0;</code><code>}</code></pre><p>However, consider the following run of the program:</p><pre>Enter your height (in cm): 180
You are tall enough to ride.
Too bad!
</pre><p>This program doesn’t work as expected because the <code>true_statement</code> and <code>false_statement</code> can only be a single statement. The indentation is deceiving us here -- the above program executes as if it had been written as follows:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter your height (in cm): ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    if (x &gt; 140)</code><code>        std::cout &lt;&lt; "You are tall enough to ride.\n";</code><code>    else</code><code>        std::cout &lt;&lt; "You are not tall enough to ride.\n";</code><code></code><code>    std::cout &lt;&lt; "Too bad!\n"; // focus on this line</code><code></code><code>    return 0;</code><code>}</code></pre><p>This makes it clearer that “Too bad!” will always execute.</p><p>However, it’s common to want to execute multiple statements based on some condition. To do so, we can use a compound statement (block):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter your height (in cm): ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    if (x &gt; 140)</code><code>        std::cout &lt;&lt; "You are tall enough to ride.\n";</code><code>    else</code><code>    { // note addition of block here</code><code>        std::cout &lt;&lt; "You are not tall enough to ride.\n";</code><code>        std::cout &lt;&lt; "Too bad!\n";</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>Remember that blocks are treated as a single statement, so this now works as expected:</p><pre>Enter your height (in cm): 180
You are tall enough to ride.
</pre><pre>Enter your height (in cm): 130
You are not tall enough to ride.
Too bad!
</pre><br><h3>To block or not to block single statements</h3><p>There is debate within the programmer community as to whether single statements following an <code>if</code> or <code>else</code> should be explicitly enclosed in blocks or not.</p><p>There are two reasons typically given as rationale for doing so. First, consider the following snippet:</p><pre class="language-cpp line-numbers"><code>if (age &gt;= 21)</code><code>    purchaseBeer();</code></pre><p>Now let’s say we’re in a hurry and modify this program to add another ability:</p><pre class="language-cpp line-numbers"><code>if (age &gt;= 21)</code><code>    purchaseBeer();</code><code>    gamble(); // will always execute</code></pre><p>Oops, we’ve just allowed minors to gamble. Have fun in jail!</p><p>Second, it can make programs more difficult to debug. Let’s say we have the following snippet:</p><pre class="language-cpp line-numbers"><code>if (age &gt;= 21)</code><code>    addBeerToCart();</code><code></code><code>checkout();</code></pre><p>Let’s say we suspect something is wrong with the <code>addBeerToCart()</code> function, so we comment it out:</p><pre class="language-cpp line-numbers"><code>if (age &gt;= 21)</code><code>//    addBeerToCart();</code><code></code><code>checkout();</code></pre><p>Now we’ve made <code>checkout()</code> conditional, which we certainly didn’t intend.</p><p>Neither of these problems occur if you always use blocks after an <code>if</code> or <code>else</code> statement.</p><p>The best argument for not using blocks around single statements is that adding blocks makes you able to see less of your code at one time by spacing it out vertically, which makes your code less readable and can lead to other, more serious mistakes.</p><p>The community seems to be more in favor of always using blocks than not, though this recommendation certainly isn’t ubiquitous.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Consider putting single statements associated with an <code>if</code> or <code>else</code> in blocks (particularly while you are learning). More experienced C++ developers sometimes disregard this practice in favor of tighter vertical spacing.</p></div><p>A middle-ground alternative is to put single-lines on the same line as the <code>if</code> or <code>else</code>:</p><pre class="language-cpp line-numbers"><code>if (age &gt;= 21) purchaseBeer();</code></pre><p>This avoids both of the above downsides mentioned above at some minor cost to readability.</p><br><h3>Implicit blocks</h3><p>If the programmer does not declare a block in the statement portion of an <code>if statement</code> or <code>else statement</code>, the compiler will implicitly declare one. Thus:</p><pre>if (condition)
    true_statement;
else
    false_statement;
</pre><p>is actually the equivalent of:</p><pre>if (condition)
{
    true_statement;
}
else
{
    false_statement;
}
</pre><p>Most of the time, this doesn’t matter. However, new programmers sometimes try to do something like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    if (true)</code><code>        int x{ 5 };</code><code>    else</code><code>        int x{ 6 };</code><code></code><code>    std::cout &lt;&lt; x &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This won’t compile, with the compiler generating an error that identifier <code>x</code> isn’t defined. This is because the above example is the equivalent of:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    if (true)</code><code>    {</code><code>        int x{ 5 };</code><code>    } // x destroyed here</code><code>    else</code><code>    {</code><code>        int x{ 6 };</code><code>    } // x destroyed here</code><code></code><code>    std::cout &lt;&lt; x &lt;&lt; '\n'; // x isn't in scope here</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this context, it’s clearer that variable <code>x</code> has block scope and is destroyed at the end of the block. By the time we get to the <code>std::cout</code> line, <code>x</code> doesn’t exist.</p><p>We’ll continue our exploration of <code>if statements</code> in the next lesson.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.3 — Common if statement problems</h1></header><div class="entry-content" itemprop="articleBody"><p>This lesson is a continuation of lesson <a href="https://www.learncpp.com/cpp-tutorial/if-statements-and-blocks/">7.2 -- If statements and blocks</a>. In this lesson, we’ll take a look at some common problems that occur when using <code>if statements</code>.</p><br><h3>Nested if statements and the dangling else problem</h3><p>It is possible to nest <code>if statements</code> within other <code>if statements</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number: ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    if (x &gt;= 0) // outer if statement</code><code>        // it is bad coding style to nest if statements this way</code><code>        if (x &lt;= 20) // inner if statement</code><code>            std::cout &lt;&lt; x &lt;&lt; " is between 0 and 20\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>Now consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number: ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    if (x &gt;= 0) // outer if statement</code><code>        // it is bad coding style to nest if statements this way</code><code>        if (x &lt;= 20) // inner if statement</code><code>            std::cout &lt;&lt; x &lt;&lt; " is between 0 and 20\n";</code><code></code><code>    // which if statement does this else belong to?</code><code>    else</code><code>        std::cout &lt;&lt; x &lt;&lt; " is negative\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>The above program introduces a source of potential ambiguity called a <span class="cpp-definition">dangling else</span> problem. Is the <code>else statement</code> in the above program matched up with the outer or inner <code>if statement</code>?</p><p>The answer is that an <code>else statement</code> is paired up with the last unmatched <code>if statement</code> in the same block. Thus, in the program above, the <code>else</code> is matched up with the inner <code>if statement</code>, as if the program had been written like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number: ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    if (x &gt;= 0) // outer if statement</code><code>    {</code><code>        if (x &lt;= 20) // inner if statement</code><code>            std::cout &lt;&lt; x &lt;&lt; " is between 0 and 20\n";</code><code>        else // attached to inner if statement</code><code>            std::cout &lt;&lt; x &lt;&lt; " is negative\n";</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>This causes the above program to produce incorrect output:</p><pre>Enter a number: 21
21 is negative
</pre><p>To avoid such ambiguities when nesting <code>if statements</code>, it is a good idea to explicitly enclose the inner <code>if statement</code> within a block. This allows us to attach an <code>else</code> to either <code>if statement</code> without ambiguity:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number: ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    if (x &gt;= 0)</code><code>    {</code><code>        if (x &lt;= 20)</code><code>            std::cout &lt;&lt; x &lt;&lt; " is between 0 and 20\n";</code><code>        else // attached to inner if statement</code><code>            std::cout &lt;&lt; x &lt;&lt; " is greater than 20\n";</code><code>    }</code><code>    else // attached to outer if statement</code><code>        std::cout &lt;&lt; x &lt;&lt; " is negative\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>The <code>else statement</code> within the block attaches to the inner <code>if statement</code>, and the <code>else statement</code> outside of the block attaches to the outer <code>if statement</code>.</p><br><h3>Flattening nested if statements</h3><p>Nested <code>if statements</code> can often be flattened by either restructuring the logic or by using logical operators (covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/logical-operators/">5.7 -- Logical operators</a>). Code that is less nested is less error prone.</p><p>For example, the above example can be flattened as follows:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number: ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    if (x &lt; 0)</code><code>        std::cout &lt;&lt; x &lt;&lt; " is negative\n";</code><code>    else if (x &lt;= 20) // only executes if x &gt;= 0</code><code>        std::cout &lt;&lt; x &lt;&lt; " is between 0 and 20\n";</code><code>    else // only executes if x &gt; 20</code><code>        std::cout &lt;&lt; x &lt;&lt; " is greater than 20\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>Here’s another example that uses logical operators to check multiple conditions within a single <code>if statement</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    std::cout &lt;&lt; "Enter another integer: ";</code><code>    int y{};</code><code>    std::cin &gt;&gt; y;</code><code></code><code>    if (x &gt; 0 &amp;&amp; y &gt; 0) // &amp;&amp; is logical and -- checks if both conditions are true</code><code>        std::cout &lt;&lt; "Both numbers are positive\n";</code><code>    else if (x &gt; 0 || y &gt; 0) // || is logical or -- checks if either condition is true</code><code>        std::cout &lt;&lt; "One of the numbers is positive\n";</code><code>    else</code><code>        std::cout &lt;&lt; "Neither number is positive\n";</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>Null statements</h3><p>A <span class="cpp-definition">null statement</span> is an expression statement that consists of just a semicolon:</p><pre class="language-cpp line-numbers"><code>if (x &gt; 10)</code><code>    ; // this is a null statement</code></pre><p><code>Null statements</code> do nothing. They are typically used when the language requires a statement to exist but the programmer doesn’t need one. For readability, <code>null statements</code> are typically placed on their own lines.</p><p>We’ll see examples of intentional <code>null statements</code> later in this chapter, when we cover loops. <code>Null statements</code> are rarely intentionally used with <code>if statements</code>. However, they can unintentionally cause problems for new (or careless) programmers. Consider the following snippet:</p><pre class="language-cpp line-numbers"><code>if (nuclearCodesActivated());</code><code>    blowUpTheWorld();</code></pre><p>In the above snippet, the programmer accidentally put a semicolon on the end of the <code>if statement</code> (a common mistake since semicolons end many statements). This unassuming error compiles fine, and causes the snippet to execute as if it had been written like this:</p><pre class="language-cpp line-numbers"><code>if (nuclearCodesActivated())</code><code>    ; // the semicolon acts as a null statement</code><code>blowUpTheWorld(); // and this line always gets executed!</code></pre><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Be careful not to “terminate” your <code>if statement</code> with a semicolon, otherwise your conditional statement(s) will execute unconditionally (even if they are inside a block).</p></div><br><h3>Operator== vs Operator= inside the conditional</h3><p>Inside your conditional, you should be using <code>operator==</code> when testing for equality, not <code>operator=</code> (which is assignment). Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter 0 or 1: ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code>    if (x = 0) // oops, we used an assignment here instead of a test for equality</code><code>        std::cout &lt;&lt; "You entered 0";</code><code>    else</code><code>        std::cout &lt;&lt; "You entered 1";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program will compile and run, but will produce the wrong result in some cases:</p><pre>Enter 0 or 1: 0
You entered 1
</pre><p>In fact, this program will always produce the result <code>You entered 1</code>. This happens because <code>x = 0</code> first assigns the value <code>0</code> to <code>x</code>, then evaluates to the value of <code>x</code>, which is now <code>0</code>, which is Boolean <code>false</code>. Since the conditional is always <code>false</code>, the <code>else statement</code> always executes.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.4 — Switch statement basics</h1></header><div class="entry-content" itemprop="articleBody"><p>Although it is possible to chain many if-else statements together, this is both difficult to read and inefficient. Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printDigitName(int x)</code><code>{</code><code>    if (x == 1)</code><code>        std::cout &lt;&lt; "One";</code><code>    else if (x == 2)</code><code>        std::cout &lt;&lt; "Two";</code><code>    else if (x == 3)</code><code>        std::cout &lt;&lt; "Three";</code><code>    else</code><code>        std::cout &lt;&lt; "Unknown";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printDigitName(2);</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>While this example isn’t too complex, <code>x</code> is evaluated up to three times (which is inefficient), and the reader has to be sure that it is <code>x</code> being evaluated each time (not some other variable).</p><p>Because testing a variable or expression for equality against a set of different values is common, C++ provides an alternative conditional statement called a <strong>switch statement</strong> that is specialized for this purpose. Here is the same program as above using a switch:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printDigitName(int x)</code><code>{</code><code>    switch (x)</code><code>    {</code><code>        case 1:</code><code>            std::cout &lt;&lt; "One";</code><code>            return;</code><code>        case 2:</code><code>            std::cout &lt;&lt; "Two";</code><code>            return;</code><code>        case 3:</code><code>            std::cout &lt;&lt; "Three";</code><code>            return;</code><code>        default:</code><code>            std::cout &lt;&lt; "Unknown";</code><code>            return;</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printDigitName(2);</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>The idea behind a <span class="cpp-definition">switch statement</span> is simple: an expression (sometimes called the <code>condition</code>) is evaluated to produce a value. If the expression’s value is equal to the value after any of the <code>case labels</code>, the statements after the matching <code>case label</code> are executed. If no matching value can be found and a <code>default label</code> exists, the statements after the <code>default label</code> are executed instead.</p><p>Compared to the original <code>if statement</code>, the <code>switch statement</code> has the advantage of only evaluating the expression once (making it more efficient), and the <code>switch statement</code> also makes it clearer to the reader that it is the same expression being tested for equality in each case.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Prefer <code>switch statements</code> over if-else chains when there is a choice.</p></div><p>Let’s examine each of these concepts in more detail.</p><br><h3>Starting a switch</h3><p>We start a <code>switch statement</code> by using the <code>switch</code> keyword, followed by parentheses with the conditional expression that we would like to evaluate inside. Often the expression is just a single variable, but it can be any valid expression.</p><p>The one restriction is that the condition must evaluate to an integral type (see lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-fundamental-data-types/">4.1 -- Introduction to fundamental data types</a> if you need a reminder which fundamental types are considered integral types) or an enumerated type (covered in future lesson <a href="https://www.learncpp.com/cpp-tutorial/unscoped-enumerations/">10.2 -- Unscoped enumerations</a>), or be convertible to one. Expressions that evaluate to floating point types, strings, and most other non-integral types may not be used here.</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>Why does the switch type only allow for integral (or enumerated) types? The answer is because switch statements are designed to be highly optimized. Historically, the most common way for compilers to implement switch statements is via <a href="https://en.wikipedia.org/wiki/Branch_table">Jump tables</a> -- and jump tables only work with integral values.</p><p>For those of you already familiar with arrays, a jump table works much like an array, an integral value is used as the array index to “jump” directly to a result. This can be much more efficient than doing a bunch of sequential comparisons.</p><p>Of course, compilers don’t have to implement switches using jump tables, and sometimes they don’t. There is technically no reason that C++ couldn’t relax the restriction so that other types could be used as well, they just haven’t done so yet (as of C++20).</p></div><p>Following the conditional expression, we declare a block. Inside the block, we use labels to define all of the values we want to test for equality. There are two kinds of labels.</p><br><h3>Case labels</h3><p>The first kind of label is the <span class="cpp-definition">case label</span>, which is declared using the <code>case</code> keyword and followed by a constant expression. The constant expression must either match the type of the condition or must be convertible to that type.</p><p>If the value of the conditional expression equals the expression after a <code>case label</code>, execution begins at the first statement after that <code>case label</code> and then continues sequentially.</p><p>Here’s an example of the condition matching a <code>case label</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printDigitName(int x)</code><code>{</code><code>    switch (x) // x is evaluated to produce value 2</code><code>    {</code><code>        case 1:</code><code>            std::cout &lt;&lt; "One";</code><code>            return;</code><code>        case 2: // which matches the case statement here</code><code>            std::cout &lt;&lt; "Two"; // so execution starts here</code><code>            return; // and then we return to the caller</code><code>        case 3:</code><code>            std::cout &lt;&lt; "Three";</code><code>            return;</code><code>        default:</code><code>            std::cout &lt;&lt; "Unknown";</code><code>            return;</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printDigitName(2);</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This code prints:</p><pre>Two
</pre><p>In the above program, <code>x</code> is evaluated to produce value <code>2</code>. Because there is a case label with value <code>2</code>, execution jumps to the statement underneath that matching case label. The program prints <code>Two</code>, and then the <code>return statement</code> is executed, which returns back to the caller.</p><p>There is no practical limit to the number of case labels you can have, but all case labels in a switch must be unique. That is, you can not do this:</p><pre class="language-cpp line-numbers"><code>switch (x)</code><code>{</code><code>    case 54:</code><code>    case 54:  // error: already used value 54!</code><code>    case '6': // error: '6' converts to integer value 54, which is already used</code><code>}</code></pre><br><h3>The default label</h3><p>The second kind of label is the <span class="cpp-definition">default label</span> (often called the <span class="cpp-definition">default case</span>), which is declared using the <code>default</code> keyword. If the conditional expression does not match any case label and a default label exists, execution begins at the first statement after the default label.</p><p>Here’s an example of the condition matching the default label:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printDigitName(int x)</code><code>{</code><code>    switch (x) // x is evaluated to produce value 5</code><code>    {</code><code>        case 1:</code><code>            std::cout &lt;&lt; "One";</code><code>            return;</code><code>        case 2:</code><code>            std::cout &lt;&lt; "Two";</code><code>            return;</code><code>        case 3:</code><code>            std::cout &lt;&lt; "Three";</code><code>            return;</code><code>        default: // which does not match to any case labels</code><code>            std::cout &lt;&lt; "Unknown"; // so execution starts here</code><code>            return; // and then we return to the caller</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printDigitName(5);</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This code prints:</p><pre>Unknown
</pre><p>The default label is optional, and there can only be one default label per switch statement. By convention, the <code>default case</code> is placed last in the switch block.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Place the default case last in the switch block.</p></div><br><h3>Taking a break</h3><p>In the above examples, we used <code>return statements</code> to stop execution of the statements after our labels. However, this also exits the entire function.</p><p>A <span class="cpp-definition">break statement</span> (declared using the <code>break</code> keyword) tells the compiler that we are done executing statements within the switch, and that execution should continue with the statement after the end of the switch block. This allows us to exit a <code>switch statement</code> without exiting the entire function.</p><p>Here’s a slightly modified example rewritten using <code>break</code> instead of <code>return</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printDigitName(int x)</code><code>{</code><code>    switch (x) // x evaluates to 3</code><code>    {</code><code>        case 1:</code><code>            std::cout &lt;&lt; "One";</code><code>            break;</code><code>        case 2:</code><code>            std::cout &lt;&lt; "Two";</code><code>            break;</code><code>        case 3:</code><code>            std::cout &lt;&lt; "Three"; // execution starts here</code><code>            break; // jump to the end of the switch block</code><code>        default:</code><code>            std::cout &lt;&lt; "Unknown";</code><code>            break;</code><code>    }</code><code></code><code>    // execution continues here</code><code>    std::cout &lt;&lt; " Ah-Ah-Ah!";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printDigitName(3);</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>The above example prints:</p><pre>Three Ah-Ah-Ah!
</pre><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Each set of statements underneath a label should end in a <code>break statement</code> or a <code>return statement</code>. This includes the statements underneath the last label in the switch.</p></div><p>So what happens if you don’t end a set of statements under a label with a <code>break</code> or <code>return</code>? We’ll explore that topic, and others, in the next lesson.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.5 — Switch fallthrough and scoping</h1></header><div class="entry-content" itemprop="articleBody"><p>This lesson continues our exploration of switch statements that we started in the prior lesson <a href="https://www.learncpp.com/cpp-tutorial/switch-statement-basics/">7.4 -- Switch statement basics</a>. In the prior lesson, we mentioned that each set of statements underneath a label should end in a <code>break statement</code> or a <code>return statement</code>.</p><p>In this lesson, we’ll explore why, and talk about some switch scoping issues that sometimes trip up new programmers.</p><br><h3>Fallthrough</h3><p>When a switch expression matches a case label or optional default label, execution begins at the first statement following the matching label. Execution will then continue sequentially until one of the following termination conditions happens:</p><ol><li>The end of the switch block is reached.</li><li>Another control flow statement (typically a <code>break</code> or <code>return</code>) causes the switch block or function to exit.</li><li>Something else interrupts the normal flow of the program (e.g. the OS shuts the program down, the universe implodes, etc…)</li></ol><p>Note that the presence of another case label is <em>not</em> one of these terminating conditions -- thus, without a <code>break</code> or <code>return</code>, execution will overflow into subsequent cases.</p><p>Here is a program that exhibits this behavior:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    switch (2)</code><code>    {</code><code>    case 1: // Does not match</code><code>        std::cout &lt;&lt; 1 &lt;&lt; '\n'; // Skipped</code><code>    case 2: // Match!</code><code>        std::cout &lt;&lt; 2 &lt;&lt; '\n'; // Execution begins here</code><code>    case 3:</code><code>        std::cout &lt;&lt; 3 &lt;&lt; '\n'; // This is also executed</code><code>    case 4:</code><code>        std::cout &lt;&lt; 4 &lt;&lt; '\n'; // This is also executed</code><code>    default:</code><code>        std::cout &lt;&lt; 5 &lt;&lt; '\n'; // This is also executed</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program outputs the following:</p><pre>2
3
4
5
</pre><p>This is probably not what we wanted! When execution flows from a statement underneath a label into statements underneath a subsequent label, this is called <span class="cpp-definition">fallthrough</span>.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Once the statements underneath a case or default label have started executing, they will overflow (fallthrough) into subsequent cases. <code>Break</code> or <code>return</code> statements are typically used to prevent this.</p></div><p>Since fallthrough is rarely desired or intentional, many compilers and code analysis tools will flag fallthrough as a warning.</p><br><h3>The [[fallthrough]] attribute</h3><p>Commenting intentional fallthrough is a common convention to tell other developers that fallthrough is intended. While this works for other developers, the compiler and code analysis tools don’t know how to interpret comments, so it won’t get rid of the warnings.</p><p>To help address this, C++17 adds a new attribute called <code>[[fallthrough]]</code>.</p><p><span class="cpp-definition">Attributes</span> are a modern C++ feature that allows the programmer to provide the compiler with some additional data about the code. To specify an attribute, the attribute name is placed between double hard braces. Attributes are not statements -- rather, they can be used almost anywhere where they are contextually relevant.</p><p>The <code>[[fallthrough]]</code> attribute modifies a <code>null statement</code> to indicate that fallthrough is intentional (and no warnings should be triggered):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    switch (2)</code><code>    {</code><code>    case 1:</code><code>        std::cout &lt;&lt; 1 &lt;&lt; '\n';</code><code>        break;</code><code>    case 2:</code><code>        std::cout &lt;&lt; 2 &lt;&lt; '\n'; // Execution begins here</code><code>        [[fallthrough]]; // intentional fallthrough -- note the semicolon to indicate the null statement</code><code>    case 3:</code><code>        std::cout &lt;&lt; 3 &lt;&lt; '\n'; // This is also executed</code><code>        break;</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>2
3
</pre><p>And it should not generate any warnings about the fallthrough.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use the <code>[[fallthrough]]</code> attribute (along with a null statement) to indicate intentional fallthrough.</p></div><br><h3>Sequential case labels</h3><p>You can use the logical OR operator to combine multiple tests into a single statement:</p><pre class="language-cpp line-numbers"><code>bool isVowel(char c)</code><code>{</code><code>    return (c=='a' || c=='e' || c=='i' || c=='o' || c=='u' ||</code><code>        c=='A' || c=='E' || c=='I' || c=='O' || c=='U');</code><code>}</code></pre><p>This suffers from the same challenges that we presented in the introduction to switch statements: <code>c</code> gets evaluated multiple times and the reader has to make sure it is <code>c</code> that is being evaluated each time.</p><p>You can do something similar using switch statements by placing multiple case labels in sequence:</p><pre class="language-cpp line-numbers"><code>bool isVowel(char c)</code><code>{</code><code>    switch (c)</code><code>    {</code><code>        case 'a': // if c is 'a'</code><code>        case 'e': // or if c is 'e'</code><code>        case 'i': // or if c is 'i'</code><code>        case 'o': // or if c is 'o'</code><code>        case 'u': // or if c is 'u'</code><code>        case 'A': // or if c is 'A'</code><code>        case 'E': // or if c is 'E'</code><code>        case 'I': // or if c is 'I'</code><code>        case 'O': // or if c is 'O'</code><code>        case 'U': // or if c is 'U'</code><code>            return true;</code><code>        default:</code><code>            return false;</code><code>    }</code><code>}</code></pre><p>Remember, execution begins at the first statement after a matching case label. Case labels aren’t statements (they’re labels), so they don’t count.</p><p>The first statement after <em>all</em> of the case statements in the above program is <code>return true</code>, so if any case labels match, the function will return <code>true</code>.</p><p>Thus, we can “stack” case labels to make all of those case labels share the same set of statements afterward. This is not considered fallthrough behavior, so use of comments or <code>[[fallthrough]]</code> is not needed here.</p><br><h3>Switch case scoping</h3><p>With <code>if statements</code>, you can only have a single statement after the if-condition, and that statement is considered to be implicitly inside a block:</p><pre class="language-cpp line-numbers"><code>if (x &gt; 10)</code><code>    std::cout &lt;&lt; x &lt;&lt; " is greater than 10\n"; // this line implicitly considered to be inside a block</code></pre><p>However, with switch statements, the statements after labels are all scoped to the the switch block. No implicit blocks are created.</p><pre class="language-cpp line-numbers"><code>switch (1)</code><code>{</code><code>    case 1: // does not create an implicit block</code><code>        foo(); // this is part of the switch scope, not an implicit block to case 1</code><code>        break; // this is part of the switch scope, not an implicit block to case 1</code><code>    default:</code><code>        std::cout &lt;&lt; "default case\n";</code><code>        break;</code><code>}</code></pre><p>In the above example, the 2 statements between the <code>case 1</code> and the default label are scoped as part of the switch block, not a block implicit to <code>case 1</code>.</p><br><h3>Variable declaration and initialization inside case statements</h3><p>You can declare or define (but not initialize) variables inside the switch, both before and after the case labels:</p><pre class="language-cpp line-numbers"><code>switch (1)</code><code>{</code><code>    int a; // okay: definition is allowed before the case labels</code><code>    int b{ 5 }; // illegal: initialization is not allowed before the case labels</code><code></code><code>    case 1:</code><code>        int y; // okay but bad practice: definition is allowed within a case</code><code>        y = 4; // okay: assignment is allowed</code><code>        break;</code><code></code><code>    case 2:</code><code>        int z{ 4 }; // illegal: initialization is not allowed if subsequent cases exist</code><code>        y = 5; // okay: y was declared above, so we can use it here too</code><code>        break;</code><code></code><code>    case 3:</code><code>        break;</code><code>}</code></pre><p>Although variable <code>y</code> was defined in <code>case 1</code>, it was used in <code>case 2</code> as well. Because the statements under each case are not inside an implicit block, that means all statements inside the switch are part of the same scope. Thus, a variable declared or defined in one case can be used in a later case, even if the case in which the variable is defined is never executed!</p><p>Put another way, defining a variable without an initializer is just telling the compiler that the variable is now in scope from that point on. This happens at compile time, and doesn’t require the definition to actually be executed at runtime.</p><p>However, initialization of variables <em>does</em> require execution at runtime. Initialization of variables is disallowed in any case that is not the last case (because the initializer could be jumped over, which would leave the variable uninitialized). Initialization is also disallowed before the first case, as those statements will never be executed, as there is no way for the switch to reach them.</p><p>If a case needs to define and/or initialize a new variable, best practice is to do so inside an explicit block underneath the case statement:</p><pre class="language-cpp line-numbers"><code>switch (1)</code><code>{</code><code>    case 1:</code><code>    { // note addition of explicit block here</code><code>        int x{ 4 }; // okay, variables can be initialized inside a block inside a case</code><code>        std::cout &lt;&lt; x;</code><code>        break;</code><code>    }</code><code>    default:</code><code>        std::cout &lt;&lt; "default case\n";</code><code>        break;</code><code>}</code></pre><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>If defining variables used in a case statement, do so in a block inside the case.</p></div><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Write a function called calculate() that takes two integers and a char representing one of the following mathematical operations: +, -, *, /, or % (modulus). Use a switch statement to perform the appropriate mathematical operation on the integers, and return the result. If an invalid operator is passed into the function, the function should print an error. For the division operator, do an integer division.</p><p>Hint: “operator” is a keyword, variables can’t be named “operator”.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int calculate(int x, int y, char op)</code><code>{</code><code>    switch (op)</code><code>    {</code><code>        case '+':</code><code>            return x + y;</code><code>        case '-':</code><code>            return x - y;</code><code>        case '*':</code><code>            return x * y;</code><code>        case '/':</code><code>            return x / y;</code><code>        case '%':</code><code>            return x % y;</code><code>        default:</code><code>            std::cerr &lt;&lt; "calculate(): Unhandled case\n";</code><code>            return 0;</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    std::cout &lt;&lt; "Enter another integer: ";</code><code>    int y{};</code><code>    std::cin &gt;&gt; y;</code><code></code><code>    std::cout &lt;&lt; "Enter a mathematical operator (+, -, *, /, or %): ";</code><code>    char op{};</code><code>    std::cin &gt;&gt; op;</code><code></code><code>    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; op &lt;&lt; ' ' &lt;&lt; y &lt;&lt; " is " &lt;&lt; calculate(x, y, op) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.6 — Goto statements</h1></header><div class="entry-content" itemprop="articleBody"><p>The next kind of control flow statement we’ll cover is the unconditional jump. An unconditional jump causes execution to jump to another spot in the code. The term “unconditional” means the jump always happens (unlike an <code>if statement</code> or <code>switch statement</code>, where the jump only happens conditionally based on the result of an expression).</p><p>In C++, unconditional jumps are implemented via a <span class="cpp-definition">goto statement</span>, and the spot to jump to is identified through use of a <span class="cpp-definition">statement label</span>. The following is an example of a <code>goto statement</code> and <code>statement label</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cmath> // for sqrt() function</cmath></code><code></code><code>int main()</code><code>{</code><code>    double x{};</code><code>tryAgain: // this is a statement label</code><code>    std::cout &lt;&lt; "Enter a non-negative number: "; </code><code>    std::cin &gt;&gt; x;</code><code></code><code>    if (x &lt; 0.0)</code><code>        goto tryAgain; // this is the goto statement</code><code></code><code>    std::cout &lt;&lt; "The square root of " &lt;&lt; x &lt;&lt; " is " &lt;&lt; std::sqrt(x) &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>In this program, the user is asked to enter a non-negative number. However, if a negative number is entered, the program utilizes a <code>goto statement</code> to jump back to the tryAgain label. The user is then asked again to enter a new number. In this way, we can continually ask the user for input until he or she enters something valid.</p><p>Here’s a sample run of this program:</p><pre>Enter a non-negative number: -4
Enter a non-negative number: 4
The square root of 4 is 2
</pre><br><h3>Statement labels have function scope</h3><p>In the chapter on object scope (<a href="https://www.learncpp.com#Chapter6">chapter 6</a>), we covered two kinds of scope: local (block) scope, and file (global) scope. Statement labels utilize a third kind of scope: <span class="cpp-definition">function scope</span>, which means the label is visible throughout the function even before its point of declaration. The <code>goto statement</code> and its corresponding <code>statement label</code> must appear in the same function.</p><p>While the above example shows a <code>goto statement</code> that jumps backwards (to a preceding point in the function), <code>goto statements</code> can also jump forward:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printCats(bool skip)</code><code>{</code><code>    if (skip)</code><code>        goto end; // jump forward; statement label 'end' is visible here due to it having function scope</code><code>    </code><code>    std::cout &lt;&lt; "cats\n";</code><code>end:</code><code>    ; // statement labels must be associated with a statement</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printCats(true);  // jumps over the print statement and doesn't print anything</code><code>    printCats(false); // prints "cats"</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>cats
</pre><p>Beyond the jumping forward, there are a couple of interesting things worth mentioning in the program above.</p><p>First, note that <code>statement labels</code> must be associated with a statement (hence their name: they label a statement). Because the end of the function had no statement, we had to use a <code>null statement</code> so we had a statement to label. Second, we were able to jump to the statement labeled by <code>end</code> even though we hadn’t declared <code>end</code> yet due to <code>statement labels</code> having function scope. No forward declaration of <code>statement labels</code> is necessary. Third, it’s worth explicitly mentioning that the above program is poor form -- it would have been better to use an <code>if statement</code> to skip the print statement than a <code>goto statement</code> to jump over it.</p><p>There are two primary limitations to jumping: You can jump only within the bounds of a single function (you can’t jump out of one function and into another), and if you jump forward, you can’t jump forward over the initialization of any variable that is still in scope at the location being jumped to. For example:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    goto skip;   // error: this jump is illegal because...</code><code>    int x { 5 }; // this initialized variable is still in scope at statement label 'skip'</code><code>skip:</code><code>    x += 3;      // what would this even evaluate to if x wasn't initialized?</code><code>    return 0;</code><code>}</code></pre><p>Note that you can jump backwards over a variable initialization, and the variable will be re-initialized when the initialization is executed.</p><br><h3>Avoid using goto</h3><p>Use of <code>goto</code> is shunned in C++ (and other modern high level languages as well). <a href="https://en.wikipedia.org/wiki/Edsger_Dijkstra">Edsger W. Dijkstra</a>, a noted computer scientist, laid out the case for avoiding <code>goto</code> in a famous but difficult to read paper called <a href="https://www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.PDF">Go To Statement Considered Harmful</a>. The primary problem with <code>goto</code> is that it allows a programmer to jump around the code arbitrarily. This creates what is not-so-affectionately known as <code>spaghetti code</code>. <span class="cpp-definition">Spaghetti code</span> is code that has a path of execution that resembles a bowl of spaghetti (all tangled and twisted), making it extremely difficult to follow the logic of such code.</p><p>As Dijkstra says somewhat humorously, “the quality of programmers is a decreasing function of the density of go to statements in the programs they produce”.</p><p>Almost any code written using a <code>goto statement</code> can be more clearly written using other constructs in C++, such as <code>if statements</code> and loops. One notable exception is when you need to exit a nested loop but not the entire function -- in such a case, a <code>goto</code> to just beyond the loops is probably the cleanest solution.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Avoid <code>goto statements</code> (unless the alternatives are significantly worse for code readability).</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.7 — Introduction to loops and while statements</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Introduction to loops</h3><p>And now the real fun begins -- in the next set of lessons, we’ll cover loops. Loops are control flow constructs that allow a piece of code to execute repeatedly until some condition is met. Loops add a significant amount of flexibility into your programming toolkit, allowing you to do many things that would otherwise be difficult.</p><p>For example, let’s say you wanted to print all the numbers between 1 and 10. Without loops, you might try something like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "1 2 3 4 5 6 7 8 9 10";</code><code>    std::cout &lt;&lt; " done!\n";</code><code>    return 0;</code><code>}</code></pre><p>While that’s doable, it becomes increasingly less so as you want to print more numbers: what if you wanted to print all the numbers between 1 and 1000? That would be quite a bit of typing! But such a program is writable in this way because we know at compile time how many numbers we want to print.</p><p>Now, let’s change the parameters a bit. What if we wanted to ask the user to enter a number and then print all the numbers between 1 and the number the user entered? The number the user will enter isn’t knowable at compile-time. So how might we go about solving this?</p><br><h3>While statements</h3><p>The <span class="cpp-definition">while statement</span> (also called a <span class="cpp-definition">while loop</span>) is the simplest of the three loop types that C++ provides, and it has a definition very similar to that of an <code>if statement</code>:</p><pre>while (condition)
    statement;
</pre><p>A <code>while statement</code> is declared using the <span class="cpp-definition">while</span> keyword. When a <code>while statement</code> is executed, the <code>condition</code> is evaluated. If the condition evaluates to <code>true</code>, the associated statement executes.</p><p>However, unlike an <code>if statement</code>, once the statement has finished executing, control returns to the top of the <code>while statement</code> and the process is repeated. This means a <code>while statement</code> will keep looping for as long as the condition evaluates to <code>true</code>.</p><p>Let’s take a look at a simple while loop that prints all the numbers from 1 to 10:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int count{ 1 };</code><code>    while (count &lt;= 10)</code><code>    {</code><code>        std::cout &lt;&lt; count &lt;&lt; ' ';</code><code>        ++count;</code><code>    }</code><code></code><code>    std::cout &lt;&lt; "done!\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This outputs:</p><pre>1 2 3 4 5 6 7 8 9 10 done!
</pre><p>Let’s take a closer look at what this program is doing. First, <code>count</code> is initialized to <code>1</code>, which is the first number we’ll print. The condition <code>count &lt;= 10</code> is <code>true</code>, so the statement executes. In this case, our statement is a block, so all the statements in the block will execute. The first statement in the block prints <code>1</code> and a space, and the second increments <code>count</code> to 2. Control now returns back to the top of the <code>while statement</code>, and the condition is evaluated again. <code>2 &lt;= 10</code> evaluates to true, so the code block is executed again. The loop will repeatedly execute until <code>count</code> is <code>11</code>, at which point <code>11 &lt;= 10</code> will evaluate to <code>false</code>, and the statement associated with the loop will be skipped. At this point, the loop is done.</p><p>While this program is a bit more code than typing all the numbers between 1 and 10, consider how easy it would be to modify the program to print all the numbers between 1 and 1000: all you’d need to do is change <code>count &lt;= 10</code> to <code>count &lt;= 1000</code>.</p><br><h3>While statements that evaluate to false initially</h3><p>Note that if the condition initially evaluates to <code>false</code>, the associated statement will not execute at all. Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int count{ 15 };</code><code>    while (count &lt;= 10)</code><code>    {</code><code>        std::cout &lt;&lt; count &lt;&lt; ' ';</code><code>        ++count;</code><code>    }</code><code></code><code>    std::cout &lt;&lt; "done!\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>The condition <code>15 &lt;= 10</code> evaluates to <code>false</code>, so the associated statement is skipped. The program continues, and the only thing printed is <code>done!</code>.</p><br><h3>Infinite loops</h3><p>On the other hand, if the expression always evaluates to true, the while loop will execute forever. This is called an <strong>infinite loop</strong>. Here is an example of an infinite loop:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int count{ 1 };</code><code>    while (count &lt;= 10) // this condition will never be false</code><code>    {</code><code>        std::cout &lt;&lt; count &lt;&lt; ' '; // so this line will repeatedly execute</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n'; // this line will never execute</code><code></code><code>    return 0; // this line will never execute</code><code>}</code></pre><p>Because <code>count</code> is never incremented in this program, <code>count &lt;= 10</code> will always be true. Consequently, the loop will never terminate, and the program will print “1 1 1 1 1″… forever.</p><br><h3>Intentional infinite loops</h3><p>We can declare an intentional infinite loop like this:</p><pre class="language-cpp line-numbers"><code>while (true)</code><code>{</code><code>  // this loop will execute forever</code><code>}</code></pre><p>The only way to exit an infinite loop is through a return statement, a break statement, an exit statement, a goto statement, an exception being thrown, or the user killing the program.</p><p>Here’s a silly example demonstrating this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code></code><code>    while (true) // infinite loop</code><code>    {</code><code>        std::cout &lt;&lt; "Loop again (y/n)? ";</code><code>        char c{};</code><code>        std::cin &gt;&gt; c;</code><code></code><code>        if (c == 'n')</code><code>            return 0;</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program will continuously loop until the user enters <code>n</code> as input, at which point the <code>if statement</code> will evaluate to <code>true</code> and the associated <code>return 0;</code> will cause function <code>main()</code> to exit, terminating the program.</p><p>It is common to see this kind of loop in web server applications that run continuously and service web requests.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Favor <code>while(true)</code> for intentional infinite loops.</p></div><br><h3>Loop variables</h3><p>Often, we want a loop to execute a certain number of times. To do this, it is common to use a <span class="cpp-definition">loop variable</span>, often called a <span class="cpp-definition">counter</span>. A loop variable is an integer that is used to count how many times a loop has executed. In the examples above, the variable <code>count</code> is a loop variable.</p><p>Loop variables are often given simple names, such as <code>i</code>, <code>j</code>, or <code>k</code>. However, if you want to know where in your program a loop variable is used, and you use the search function on <code>i</code>, <code>j</code>, or <code>k</code>, the search function will return half of the lines in your program! For this reason, some developers prefer loop variable names like <code>iii</code>, <code>jjj</code>, or <code>kkk</code>. Because these names are more unique, this makes searching for loop variables much easier, and helps them stand out as loop variables. An even better idea is to use “real” variable names, such as <code>count</code>, or a name that gives more detail about what you’re counting (e.g. <code>userCount</code>).</p><br><h3>Loop variables should be signed</h3><p>Loop variables should almost always be signed, as unsigned integers can lead to unexpected issues. Consider the following code:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    unsigned int count{ 10 };</code><code></code><code>    // count from 10 down to 0</code><code>    while (count &gt;= 0)</code><code>    {</code><code>        if (count == 0)</code><code>        {</code><code>            std::cout &lt;&lt; "blastoff!";</code><code>        }</code><code>        else</code><code>        {</code><code>            std::cout &lt;&lt; count &lt;&lt; ' ';</code><code>        }</code><code>        --count;</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Take a look at the above example and see if you can spot the error. It’s not very obvious.</p><p>It turns out, this program is an infinite loop. It starts out by printing <code>10 9 8 7 6 5 4 3 2 1 blastoff!</code> as desired, but then goes off the rails, and starts counting down from <code>4294967295</code>. Why? Because the loop condition <code>count &gt;= 0</code> will never be false! When count is <code>0</code>, <code>0 &gt;= 0</code> is true. Then <code>--count</code> is executed, and count wraps around back to <code>4294967295</code> (Assuming 32-bit integers). And since <code>4294967295 &gt;= 0</code> is true, the program continues. Because <code>count</code> is unsigned, it can never be negative, and because it can never be negative, the loop won’t terminate.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Loop variables should be of type (signed) int.</p></div><br><h3>Doing something every N iterations</h3><p>Each time a loop executes, it is called an <span class="cpp-definition">iteration</span>.</p><p>Often, we want to do something every 2nd, 3rd, or 4th iteration, such as print a newline. This can easily be done by using the modulus operator on our counter:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// Iterate through every number between 1 and 50</code><code>int main()</code><code>{</code><code>    int count{ 1 };</code><code>    while (count &lt;= 50)</code><code>    {</code><code>        // print the number (pad numbers under 10 with a leading 0 for formatting purposes)</code><code>        if (count &lt; 10)</code><code>        {</code><code>            std::cout &lt;&lt; '0';</code><code>        }</code><code></code><code>        std::cout &lt;&lt; count &lt;&lt; ' ';</code><code></code><code>        // if the loop variable is divisible by 10, print a newline</code><code>        if (count % 10 == 0)</code><code>        {</code><code>            std::cout &lt;&lt; '\n';</code><code>        }</code><code>            </code><code>        // increment the loop counter</code><code>        ++count;</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program produces the result:</p><pre>01 02 03 04 05 06 07 08 09 10
11 12 13 14 15 16 17 18 19 20
21 22 23 24 25 26 27 28 29 30
31 32 33 34 35 36 37 38 39 40
41 42 43 44 45 46 47 48 49 50
</pre><br><h3>Nested loops</h3><p>It is also possible to nest loops inside of other loops. In the following example, the nested loop (which we’re calling the inner loop) and the outer loop each have their own counters. Note that the loop expression for the inner loop makes use of the outer loop’s counter as well!</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    // outer loops between 1 and 5</code><code>    int outer{ 1 };</code><code>    while (outer &lt;= 5)</code><code>    {</code><code>        // For each iteration of the outer loop, the code in the body of the loop executes once</code><code></code><code>        // inner loops between 1 and outer</code><code>        int inner{ 1 };</code><code>        while (inner &lt;= outer)</code><code>        {</code><code>            std::cout &lt;&lt; inner &lt;&lt; ' ';</code><code>            ++inner;</code><code>        }</code><code></code><code>        // print a newline at the end of each row</code><code>        std::cout &lt;&lt; '\n';</code><code>        ++outer;</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>1
1 2
1 2 3
1 2 3 4
1 2 3 4 5
</pre><p>Nested loops tend to be hard for new programmers to understand, so don’t be discouraged if you find this a bit confusing. For each iteration of the outer loop, the body of the outer loop will execute once. Because the outer loop body contains an inner loop, the inner loop is executed for each iteration of the outer loop.</p><p>Let’s example how this works in more detail.</p><p>First, we have an outer loop (with loop variable <code>outer</code>) that will loop 5 times (with <code>outer</code> having values <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, and <code>5</code> successively).</p><p>On the first iteration of the outer loop, <code>outer</code> has value <code>1</code>, and then the outer loop body executes. Inside the body of the outer loop, we have another loop with loop variable <code>inner</code>. The inner loop iterates from <code>1</code> to <code>outer</code> (which has value <code>1</code>), so this inner loop will execute once, printing the value <code>1</code>. Then we print a newline, and increment <code>outer</code> to <code>2</code>.</p><p>On the second iteration of the outer loop, <code>outer</code> has value <code>2</code>, and then the outer loop body executes. Inside the body of the outer loop, <code>inner</code> iterates from <code>1</code> to <code>outer</code> (which now has value <code>2</code>), so this inner loop will execute twice, printing the values <code>1</code> and <code>2</code>. Then we print a newline, and increment <code>outer</code> to <code>3</code>.</p><p>This process continues, with the inner loop printing <code>1 2 3</code>, <code>1 2 3 4</code>, and <code>1 2 3 4 5</code> on successive passes. Eventually, <code>outer</code> is incremented to <code>6</code>, and because the outer loop condition (<code>outer &lt;= 5</code>) is then false, the outer loop is finished. Then the program ends.</p><p>If you’re still finding this confusing, stepping through this program in a debugger line-by-line and watching the values of <code>inner</code> and <code>outer</code> is a good way to get a better understanding of what’s happening.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>In the above program, why is variable <code>inner</code> declared inside the while block instead of immediately following the declaration of <code>outer</code>?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>Variable inner is declared inside the while block so that it is recreated (and reinitialized to 1) each time the outer loop executes. If variable inner were declared before the outer while loop, its value would never be reset to 1, or we’d have to do it with an assignment statement. Furthermore, because variable inner is only used inside the outer while loop block, it makes sense to declare it there. Remember, declare your variables in the smallest scope possible!</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>Write a program that prints out the letters a through z along with their ASCII codes.</p><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">Hint: To print characters as integers, you have to use a static_cast.</div><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    char myChar{ 'a' };</code><code>    while (myChar &lt;= 'z')</code><code>    {</code><code>        std::cout &lt;&lt; myChar &lt;&lt; ' ' &lt;&lt; static_cast<int>(myChar) &lt;&lt; '\n';</int></code><code>        ++myChar;</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>Invert the nested loops example so it prints the following:</p><pre>5 4 3 2 1
4 3 2 1
3 2 1
2 1
1
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// Loop between 5 and 1</code><code>int main()</code><code>{</code><code>	int outer{ 5 };</code><code>	while (outer &gt;= 1)</code><code>	{</code><code>		// loop between outer and 1</code><code>		int inner{ outer };</code><code>		while (inner &gt;= 1)</code><code>        {</code><code>			std::cout &lt;&lt; inner-- &lt;&lt; ' ';</code><code>        }</code><code></code><code>		// print a newline at the end of each row</code><code>		std::cout &lt;&lt; '\n';</code><code>		--outer;</code><code>	}</code><code></code><code>	return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #4</p><p>Now make the numbers print like this:</p><pre>        1
      2 1
    3 2 1
  4 3 2 1
5 4 3 2 1
</pre><p>Hint: Figure out how to make it print like this first:</p><pre>X X X X 1
X X X 2 1
X X 3 2 1
X 4 3 2 1
5 4 3 2 1
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><pre class="language-cpp line-numbers"><code>// Thanks to Shiva for this solution</code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	// There are 5 rows, we can loop from 1 to 5</code><code>	int outer{ 1 };</code><code></code><code>	while (outer &lt;= 5)</code><code>	{</code><code>		// Row elements appear in descending order, so start from 5 and loop through to 1</code><code>		int inner{ 5 };</code><code></code><code>		while (inner &gt;= 1)</code><code>		{</code><code>			// The first number in any row is the same as the row number</code><code>			// So number should be printed only if it is &lt;= the row number, space otherwise</code><code>			if (inner &lt;= outer)</code><code>				std::cout &lt;&lt; inner &lt;&lt; ' '; // print the number and a single space</code><code>			else</code><code>				std::cout &lt;&lt; "  "; // don't print a number, but print two spaces</code><code></code><code>			--inner;</code><code>		}</code><code></code><code>		// A row has been printed, move to the next row</code><code>		std::cout &lt;&lt; '\n';</code><code></code><code>		++outer;</code><code>	}</code><code></code><code>	return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.8 — Do while statements</h1></header><div class="entry-content" itemprop="articleBody"><p>Consider the case where we want to show the user a menu and ask them to make a selection -- and if the user chooses an invalid selection, to ask them again. Clearly the menu and selection should go inside a loop of some kind (so we can keep asking the user until they enter valid input), but what kind of loop should we choose?</p><p>Since a while loop evaluates the condition up front, it’s an awkward choice. We could solve the issue like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    // selection must be declared outside while loop so we can use it later</code><code>    int selection{ 0 };</code><code></code><code>    while (selection != 1 &amp;&amp; selection != 2 &amp;&amp;</code><code>        selection != 3 &amp;&amp; selection != 4)</code><code>    {</code><code>        std::cout &lt;&lt; "Please make a selection: \n";</code><code>        std::cout &lt;&lt; "1) Addition\n";</code><code>        std::cout &lt;&lt; "2) Subtraction\n";</code><code>        std::cout &lt;&lt; "3) Multiplication\n";</code><code>        std::cout &lt;&lt; "4) Division\n";</code><code>        std::cin &gt;&gt; selection;</code><code>    }</code><code></code><code>    // do something with selection here</code><code>    // such as a switch statement</code><code></code><code>    std::cout &lt;&lt; "You selected option #" &lt;&lt; selection &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>But this only works because our initial value of <code>0</code> for <code>selection</code> isn’t in the set of valid values (<code>1, 2, 3 or 4</code>). What if <code>0</code> was a valid choice? We’d have to pick a different initializer to represent “invalid” -- and now we’re introducing magic numbers (<a href="https://www.learncpp.com/cpp-tutorial/literals/">4.15 -- Literals</a>) into our code.</p><p>We could instead add a new variable to track validity, like so:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int selection { 0 };</code><code>    bool invalid { true }; // new variable just to gate the loop</code><code></code><code>    while (invalid)</code><code>    {</code><code>        std::cout &lt;&lt; "Please make a selection: \n";</code><code>        std::cout &lt;&lt; "1) Addition\n";</code><code>        std::cout &lt;&lt; "2) Subtraction\n";</code><code>        std::cout &lt;&lt; "3) Multiplication\n";</code><code>        std::cout &lt;&lt; "4) Division\n";</code><code></code><code>        std::cin &gt;&gt; selection;</code><code>        invalid = (selection != 1 &amp;&amp; selection != 2 &amp;&amp;</code><code>            selection != 3 &amp;&amp; selection != 4);</code><code>    }</code><code></code><code>    // do something with selection here</code><code>    // such as a switch statement</code><code></code><code>    std::cout &lt;&lt; "You selected option #" &lt;&lt; selection &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>While this avoids the magic number, it introduces a new variable just to ensure the loop runs once, and that adds complexity and the possibility of additional errors.</p><br><h3>Do while statements</h3><p>To help solve problems like the above, C++ offers the do-while statement:</p><pre>do
    statement; // can be a single statement or a compound statement
while (condition);
</pre><p>A <span class="cpp-definition">do while statement</span> is a looping construct that works just like a while loop, except the statement always executes at least once. After the statement has been executed, the do-while loop checks the condition. If the condition evaluates to <code>true</code>, the path of execution jumps back to the top of the do-while loop and executes it again.</p><p>Here is our example above using a do-while loop instead of a while loop:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    // selection must be declared outside of the do-while so we can use it later</code><code>    int selection{};</code><code></code><code>    do</code><code>    {</code><code>        std::cout &lt;&lt; "Please make a selection: \n";</code><code>        std::cout &lt;&lt; "1) Addition\n";</code><code>        std::cout &lt;&lt; "2) Subtraction\n";</code><code>        std::cout &lt;&lt; "3) Multiplication\n";</code><code>        std::cout &lt;&lt; "4) Division\n";</code><code>        std::cin &gt;&gt; selection;</code><code>    }</code><code>    while (selection != 1 &amp;&amp; selection != 2 &amp;&amp;</code><code>        selection != 3 &amp;&amp; selection != 4);</code><code></code><code>    // do something with selection here</code><code>    // such as a switch statement</code><code></code><code>    std::cout &lt;&lt; "You selected option #" &lt;&lt; selection &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this way, we’ve avoided both magic numbers and additional variables.</p><p>One thing worth discussing in the above example is that the <code>selection</code> variable must be declared outside of the do block. If the <code>selection</code> variable were to be declared inside the do block, it would be destroyed when the do block terminates, which happens before the conditional is evaluated. But we need the variable in the while conditional -- consequently, the <code>selection</code> variable must be declared outside the do block (even if it wasn’t used later in the body of the function).</p><p>In practice, do-while loops aren’t commonly used. Having the condition at the bottom of the loop obscures the loop condition, which can lead to errors. Many developers recommend avoiding do-while loops altogether as a result. We’ll take a softer stance and advocate for preferring while loops over do-while when given an equal choice.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Favor while loops over do-while when given an equal choice.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.9 — For statements</h1></header><div class="entry-content" itemprop="articleBody"><p>By far, the most utilized loop statement in C++ is the <code>for statement</code>. The <span class="cpp-definition">for statement</span> (also called a <span class="cpp-definition">for loop</span>) is preferred when we have an obvious loop variable because it lets us easily and concisely define, initialize, test, and change the value of loop variables.</p><p>As of C++11, there are two different kinds of <code>for loops</code>. We’ll cover the classic <code>for statement</code> in this lesson, and the newer <code>range-based for statement</code> in a future lesson (<a href="https://www.learncpp.com/cpp-tutorial/for-each-loops/">11.13 -- For-each loops</a>) once we’ve covered some other prerequisite topics, such as arrays and iterators.</p><p style="clear:both"></p><p>The <code>for statement</code> looks pretty simple in abstract:</p><pre>for (init-statement; condition; end-expression)
   statement;
</pre><p>The easiest way to initially understand how a <code>for statement</code> works is to convert it into an equivalent <code>while statement</code>:</p><pre>{ // note the block here
    init-statement; // used to define variables used in the loop
    while (condition)
    {
        statement; 
        end-expression; // used to modify the loop variable prior to reassessment of the condition
    }
} // variables defined inside the loop go out of scope here
</pre><br><h3>Evaluation of for statements</h3><p>A <code>for statement</code> is evaluated in 3 parts:</p><p>First, the init-statement is executed. This only happens once when the loop is initiated. The init-statement is typically used for variable definition and initialization. These variables have “loop scope”, which really just is a form of block scope where these variables exist from the point of definition through the end of the loop statement. In our while-loop equivalent, you can see that the init-statement is inside a block that contains the loop, so the variables defined in the init-statement go out of scope when the block containing the loop ends.</p><p>Second, for each loop iteration, the condition is evaluated. If this evaluates to true, the statement is executed. If this evaluates to false, the loop terminates and execution continues with the next statement beyond the loop.</p><p>Finally, after the statement is executed, the end-expression is evaluated. Typically, this expression is used to increment or decrement the loop variables defined in the init-statement. After the end-expression has been evaluated, execution returns to the second step (and the condition is evaluated again).</p><p>Let’s take a look at a sample <em>for loop</em> and discuss how it works:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    for (int count{ 1 }; count &lt;= 10; ++count)</code><code>        std::cout &lt;&lt; count &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>First, we declare a loop variable named <code>count</code>, and initialize it with the value <code>1</code>.</p><p>Second, <code>count &lt;= 10</code> is evaluated, and since count is <code>1</code>, this evaluates to <code>true</code>. Consequently, the statement executes, which prints <code>1</code> and a space.</p><p>Finally, <code>++count</code> is evaluated, which increments <code>count</code> to <code>2</code>. Then the loop goes back to the second step.</p><p>Now, <code>count &lt;= 10</code> is evaluated again. Since <code>count</code> has value <code>2</code>, this evaluates <code>true</code>, so the loop iterates again. The statement prints <code>2</code> and a space, and count is incremented to <code>3</code>. The loop continues to iterate until eventually <code>count</code> is incremented to <code>11</code>, at which point <code>count &lt;= 10</code> evaluates to <code>false</code>, and the loop exits.</p><p>Consequently, this program prints the result:</p><pre>1 2 3 4 5 6 7 8 9 10
</pre><p>For the sake of example, let’s convert the above <code>for loop</code> into an equivalent <code>while loop</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    { // the block here ensures block scope for count</code><code>        int count{ 1 }; // our init-statement</code><code>        while (count &lt;= 10) // our condition</code><code>        {</code><code>            std::cout &lt;&lt; count &lt;&lt; ' '; // our statement</code><code>            ++count; // our end-expression</code><code>        }</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code>}</code></pre><p>That doesn’t look so bad, does it? Note that the outer braces are necessary here, because <code>count</code> goes out of scope when the loop ends.</p><p><code>For loops</code> can be hard for new programmers to read -- however, experienced programmers love them because they are a very compact way to do loops with a counter, with all of the necessary information about the loop variables, loop conditions, and loop count modifiers are presented up front. This helps reduce errors.</p><br><h3>More for loop examples</h3><p>Here’s an example of a function that uses a <code>for loop</code> to calculate integer exponents:</p><pre class="language-cpp line-numbers"><code>#include <cstdint> // for fixed-width integers</cstdint></code><code></code><code>// returns the value base ^ exponent -- watch out for overflow!</code><code>std::int64_t pow(int base, int exponent)</code><code>{</code><code>    std::int64_t total{ 1 };</code><code></code><code>    for (int count{ 0 }; count &lt; exponent; ++count)</code><code>        total *= base;</code><code></code><code>    return total;</code><code>}</code></pre><p>This function returns the value base^exponent (base to the exponent power).</p><p>This is a straightforward incrementing <code>for loop</code>, with <code>count</code> looping from <code>0</code> up to (but excluding) <code>exponent</code>.</p><p>If exponent is 0, the <code>for loop</code> will execute 0 times, and the function will return 1.<br>If exponent is 1, the <code>for loop</code> will execute 1 time, and the function will return 1 * base.<br>If exponent is 2, the <code>for loop</code> will execute 2 times, and the function will return 1 * base * base.</p><p>Although most <code>for loops</code> increment the loop variable by 1, we can decrement it as well:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    for (int count{ 9 }; count &gt;= 0; --count)</code><code>        std::cout &lt;&lt; count &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints the result:</p><pre>9 8 7 6 5 4 3 2 1 0
</pre><p>Alternately, we can change the value of our loop variable by more than 1 with each iteration:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    for (int count{ 0 }; count &lt;= 10; count += 2)</code><code>        std::cout &lt;&lt; count &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints the result:</p><pre>0 2 4 6 8 10
</pre><br><h3>The perils of operator!= in for-loop conditions</h3><p>When writing a loop condition involving a value, we can often write the condition in many different ways. The following two loops execute identically:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    for (int i { 0 }; i &lt; 10; ++i) // uses &lt;</code><code>         std::cout &lt;&lt; i;</code><code></code><code>    for (int i { 0 }; i != 10; ++i) // uses !=</code><code>         std::cout &lt;&lt; i;</code><code></code><code>     return 0;</code><code>}</code></pre><p>So which should we prefer? The former is the better choice, as it will terminate even if <code>i</code> jumps over the value <code>10</code>, whereas the latter will not. The following example demonstrates this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    for (int i { 0 }; i &lt; 10; ++i) // uses &lt;, still terminates</code><code>    {</code><code>         std::cout &lt;&lt; i;</code><code>         if (i == 9) ++i; // jump over value 10</code><code>    }</code><code></code><code>    for (int i { 0 }; i != 10; ++i) // uses !=, infinite loop</code><code>    {</code><code>         std::cout &lt;&lt; i;</code><code>         if (i == 9) ++i; // jump over value 10</code><code>    }</code><code></code><code>     return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Avoid <code>operator!=</code> when doing numeric comparisons in the for-loop condition.</p></div><br><h3>Off-by-one errors</h3><p>One of the biggest problems that new programmers have with <code>for loops</code> (and other loops that utilize counters) are <code>off-by-one errors</code>. <span class="cpp-definition">Off-by-one errors</span> occur when the loop iterates one too many or one too few times to produce the desired result.</p><p>Here’s an example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    // oops, we used operator&lt; instead of operator&lt;=</code><code>    for (int count{ 1 }; count &lt; 5; ++count)</code><code>    {</code><code>        std::cout &lt;&lt; count &lt;&lt; ' ';</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program is supposed to print <code>1 2 3 4 5</code>, but it only prints <code>1 2 3 4</code> because we used the wrong relational operator.</p><p>Although the most common cause for these errors is using the wrong relational operator, they can sometimes occur by using pre-increment or pre-decrement instead of post-increment or post-decrement, or vice-versa.</p><br><h3>Omitted expressions</h3><p>It is possible to write <em>for loops</em> that omit any or all of the statements or expressions. For example, in the following example, we’ll omit the init-statement and end-expression, leaving only the condition:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int count{ 0 };</code><code>    for ( ; count &lt; 10; ) // no init-statement or end-expression</code><code>    {</code><code>        std::cout &lt;&lt; count &lt;&lt; ' ';</code><code>        ++count;</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This <em>for loop</em> produces the result:</p><pre>0 1 2 3 4 5 6 7 8 9
</pre><p>Rather than having the <em>for loop</em> do the initialization and incrementing, we’ve done it manually. We have done so purely for academic purposes in this example, but there are cases where not declaring a loop variable (because you already have one) or not incrementing it in the end-expression (because you’re incrementing it some other way) is desired.</p><p>Although you do not see it very often, it is worth noting that the following example produces an infinite loop:</p><pre class="language-cpp line-numbers"><code>for (;;)</code><code>    statement;</code></pre><p>The above example is equivalent to:</p><pre class="language-cpp line-numbers"><code>while (true)</code><code>    statement;</code></pre><p>This might be a little unexpected, as you’d probably expect an omitted condition-expression to be treated as <code>false</code>. However, the C++ standard explicitly (and inconsistently) defines that an omitted condition-expression in a for loop should be treated as <code>true</code>.</p><p>We recommend avoiding this form of the for loop altogether and using <code>while(true)</code> instead.</p><br><h3>For loops with multiple counters</h3><p>Although <code>for loops</code> typically iterate over only one variable, sometimes <code>for loops</code> need to work with multiple variables. To assist with this, the programmer can define multiple variables in the init-statement, and can make use of the comma operator to change the value of multiple variables in the end-expression:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    for (int x{ 0 }, y{ 9 }; x &lt; 10; ++x, --y)</code><code>        std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This loop defines and initializes two new variables: <code>x</code> and <code>y</code>. It iterates <code>x</code> over the range <code>0</code> to <code>9</code>, and after each iteration <code>x</code> is incremented and <code>y</code> is decremented.</p><p>This program produces the result:</p><pre>0 9
1 8
2 7
3 6
4 5
5 4
6 3
7 2
8 1
9 0
</pre><p>This is about the only place in C++ where defining multiple variables in the same statement, and use of the comma operator is considered an acceptable practice.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Defining multiple variables (in the init-statement) and using the comma operator (in the end-expression) is acceptable inside a <code>for statement</code>.</p></div><br><h3>Nested for loops</h3><p>Like other types of loops, <code>for loops</code> can be nested inside other loops. In the following example, we’re nesting a <code>for loop</code> inside another <code>for loop</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	for (char c{ 'a' }; c &lt;= 'e'; ++c) // outer loop on letters</code><code>	{</code><code>		std::cout &lt;&lt; c; // print our letter first</code><code>		</code><code>		for (int i{ 0 }; i &lt; 3; ++i) // inner loop on all numbers</code><code>			std::cout &lt;&lt; i;</code><code></code><code>		std::cout &lt;&lt; '\n';</code><code>	}</code><code></code><code>	return 0;</code><code>}</code></pre><p>For each iteration of the outer loop, the inner loop runs in its entirety. Consequently, the output is:</p><pre>a012
b012
c012
d012
e012
</pre><p>Here’s some more detail on what’s happening here. The outer loop runs first, and char <code>c</code> is initialized to <code>'a'</code>. Then <code>c &lt;= 'e'</code> is evaluated, which is <code>true</code>, so the loop body executes. Since <code>c</code> is set to <code>'a'</code>, this first prints <code>a</code>. Next the inner loop executes entirely (which prints <code>0</code>, <code>1</code>, and <code>2</code>). Then a newline is printed. Now the outer loop body is finished, so the outer loop returns to the top, <code>c</code> is incremented to <code>'b'</code>, and the loop condition is re-evaluated. Since the loop condition is still <code>true</code> the next iteration of the outer loop begins. This prints <code>b012\n</code>. And so on.</p><br><h3>Conclusion</h3><p><code>For statements</code> are the most commonly used loop in the C++ language. Even though its syntax is typically a bit confusing to new programmers, you will see <code>for loops</code> so often that you will understand them in no time at all!</p><p><code>For statements</code> excel when you have a counter variable. If you do not have a counter, a <code>while statement</code> is probably a better choice.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Prefer <code>for loops</code> over <code>while loops</code> when there is an obvious loop variable.<br>Prefer <code>while loops</code> over <code>for loops</code> when there is no obvious loop variable.</p></div><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Write a <code>for loop</code> that prints every even number from 0 to 20.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>for (int count{ 0 }; count &lt;= 20; count += 2)</code><code>    std::cout &lt;&lt; count &lt;&lt; '\n';</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>Write a function named sumTo() that takes an integer parameter named value, and returns the sum of all the numbers from 1 to value.</p><p>For example, sumTo(5) should return 15, which is 1 + 2 + 3 + 4 + 5.</p><p>Hint: Use a non-loop variable to accumulate the sum as you iterate from 1 to the input value, much like the pow() example above uses the total variable to accumulate the return value each iteration.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>int sumTo(int value)</code><code>{</code><code>    int total{ 0 };</code><code>    for (int count{ 1 }; count &lt;= value; ++count)</code><code>        total += count;</code><code></code><code>    return total;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>What’s wrong with the following for loop?</p><pre class="language-cpp line-numbers"><code>// Print all numbers from 9 to 0</code><code>for (unsigned int count{ 9 }; count &gt;= 0; --count)</code><code>    std::cout &lt;&lt; count &lt;&lt; ' ';</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>This <code>for loop</code> executes as long as <code>count &gt;= 0</code>. In other words, it runs until <code>count</code> is negative. However, because <code>count</code> is unsigned, <code>count</code> can never go negative. Consequently, this loop will run for-ever (ha ha)! Generally, it’s a good idea to avoid looping on unsigned variables unless necessary.</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.10 — Break and continue</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Break</h3><p>Although you have already seen the <code>break statement</code> in the context of <code>switch statements</code> (<a href="https://www.learncpp.com/cpp-tutorial/switch-statement-basics/">7.4 -- Switch statement basics</a>), it deserves a fuller treatment since it can be used with other types of control flow statements as well. The <span class="cpp-definition">break statement</span> causes a while loop, do-while loop, for loop, or switch statement to end, with execution continuing with the next statement after the loop or switch being broken out of.</p><br><h3>Breaking a switch</h3><p>In the context of a <code>switch statement</code>, a <code>break</code> is typically used at the end of each case to signify the case is finished (which prevents fallthrough into subsequent cases):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printMath(int x, int y, char ch)</code><code>{</code><code>    switch (ch)</code><code>    {</code><code>    case '+':</code><code>        std::cout &lt;&lt; x &lt;&lt; " + " &lt;&lt; y &lt;&lt; " = " &lt;&lt; x + y &lt;&lt; '\n';</code><code>        break; // don't fall-through to next case</code><code>    case '-':</code><code>        std::cout &lt;&lt; x &lt;&lt; " - " &lt;&lt; y &lt;&lt; " = " &lt;&lt; x - y &lt;&lt; '\n';</code><code>        break; // don't fall-through to next case</code><code>    case '*':</code><code>        std::cout &lt;&lt; x &lt;&lt; " * " &lt;&lt; y &lt;&lt; " = " &lt;&lt; x * y &lt;&lt; '\n';</code><code>        break; // don't fall-through to next case</code><code>    case '/':</code><code>        std::cout &lt;&lt; x &lt;&lt; " / " &lt;&lt; y &lt;&lt; " = " &lt;&lt; x / y &lt;&lt; '\n';</code><code>        break;</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printMath(2, 3, '+');</code><code></code><code>    return 0;</code><code>}</code></pre><p>See lesson <a href="https://www.learncpp.com/cpp-tutorial/switch-fallthrough-and-scoping/">7.5 -- Switch fallthrough and scoping</a> for more information about fallthrough, along with some additional examples.</p><br><h3>Breaking a loop</h3><p>In the context of a loop, a break statement can be used to end the loop early. Execution continues with the next statement after the end of the loop.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int sum{ 0 };</code><code></code><code>    // Allow the user to enter up to 10 numbers</code><code>    for (int count{ 0 }; count &lt; 10; ++count)</code><code>    {</code><code>        std::cout &lt;&lt; "Enter a number to add, or 0 to exit: ";</code><code>        int num{};</code><code>        std::cin &gt;&gt; num;</code><code></code><code>        // exit loop if user enters 0</code><code>        if (num == 0)</code><code>            break; // exit the loop now</code><code></code><code>        // otherwise add number to our sum</code><code>        sum += num;</code><code>    }</code><code></code><code>    // execution will continue here after the break</code><code>    std::cout &lt;&lt; "The sum of all the numbers you entered is: " &lt;&lt; sum &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program allows the user to type up to 10 numbers, and displays the sum of all the numbers entered at the end. If the user enters 0, the break causes the loop to terminate early (before 10 numbers have been entered).</p><p>Here’s a sample execution of the above program:</p><pre>Enter a number to add, or 0 to exit: 5
Enter a number to add, or 0 to exit: 2
Enter a number to add, or 0 to exit: 1
Enter a number to add, or 0 to exit: 0
The sum of all the numbers you entered is: 8
</pre><p>Break is also a common way to get out of an intentional infinite loop:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    while (true) // infinite loop</code><code>    {</code><code>        std::cout &lt;&lt; "Enter 0 to exit or any other integer to continue: ";</code><code>        int num{};</code><code>        std::cin &gt;&gt; num;</code><code></code><code>        // exit loop if user enters 0</code><code>        if (num == 0)</code><code>            break;</code><code>    }</code><code></code><code>    std::cout &lt;&lt; "We're out!\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>A sample run of the above program:</p><pre>Enter 0 to exit or any other integer to continue: 5
Enter 0 to exit or any other integer to continue: 3
Enter 0 to exit or any other integer to continue: 0
We're out!
</pre><br><h3>Break vs return</h3><p>New programmers sometimes have trouble understanding the difference between <code>break</code> and <code>return</code>. A <code>break statement</code> terminates the switch or loop, and execution continues at the first statement beyond the switch or loop. A <code>return statement</code> terminates the entire function that the loop is within, and execution continues at point where the function was called.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int breakOrReturn()</code><code>{</code><code>    while (true) // infinite loop</code><code>    {</code><code>        std::cout &lt;&lt; "Enter 'b' to break or 'r' to return: ";</code><code>        char ch{};</code><code>        std::cin &gt;&gt; ch;</code><code></code><code>        if (ch == 'b')</code><code>            break; // execution will continue at the first statement beyond the loop</code><code></code><code>        if (ch == 'r')</code><code>            return 1; // return will cause the function to immediately return to the caller (in this case, main())</code><code>    }</code><code></code><code>    // breaking the loop causes execution to resume here</code><code></code><code>    std::cout &lt;&lt; "We broke out of the loop\n";</code><code></code><code>    return 0;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int returnValue{ breakOrReturn() };</code><code>    std::cout &lt;&lt; "Function breakOrReturn returned " &lt;&lt; returnValue &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Here are two runs of this program:</p><pre>Enter 'b' to break or 'r' to return: r
Function breakOrReturn returned 1
</pre><pre>Enter 'b' to break or 'r' to return: b
We broke out of the loop
Function breakOrReturn returned 0
</pre><br><h3>Continue</h3><p>The <span class="cpp-definition">continue statement</span> provides a convenient way to end the current iteration of a loop without terminating the entire loop.</p><p>Here’s an example of using continue:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    for (int count{ 0 }; count &lt; 10; ++count)</code><code>    {</code><code>        // if the number is divisible by 4, skip this iteration</code><code>        if ((count % 4) == 0)</code><code>            continue; // go to next iteration</code><code></code><code>        // If the number is not divisible by 4, keep going</code><code>        std::cout &lt;&lt; count &lt;&lt; '\n';</code><code></code><code>        // The continue statement jumps to here</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints all of the numbers from 0 to 9 that aren’t divisible by 4:</p><pre>1
2
3
5
6
7
9
</pre><p><code>Continue statements</code> work by causing the current point of execution to jump to the bottom of the current loop.</p><p>In the case of a for loop, the end-statement of the for loop still executes after a continue (since this happens after the end of the loop body).</p><p>Be careful when using a <code>continue statement</code> with while or do-while loops. These loops typically change the value of variables used in the condition inside the loop body. If use of a <code>continue statement</code> causes these lines to be skipped, then the loop can become infinite!</p><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int count{ 0 };</code><code>    while (count &lt; 10)</code><code>    {</code><code>        if (count == 5)</code><code>            continue; // jump to end of loop body</code><code></code><code>        std::cout &lt;&lt; count &lt;&lt; '\n';</code><code></code><code>        ++count; // this statement is never executed after count reaches 5</code><code></code><code>        // The continue statement jumps to here</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program is intended to print every number between 0 and 9 except 5. But it actually prints:</p><pre>0
1
2
3
4
</pre><p>and then goes into an infinite loop. When <code>count</code> is <code>5</code>, the <code>if statement</code> evaluates to <code>true</code>, and the <code>continue</code> causes the execution to jump to the bottom of the loop. The <code>count</code> variable is never incremented. Consequently, on the next pass, <code>count</code> is still <code>5</code>, the <code>if statement</code> is still <code>true</code>, and the program continues to loop forever.</p><p>Of course, you already know that if you have an obvious counter variable, you should be using a <code>for loop</code>, not a <code>while</code> or <code>do-while</code> loop.</p><br><h3>The debate over use of break and continue</h3><p>Many textbooks caution readers not to use <code>break</code> and <code>continue</code> in loops, both because it causes the execution flow to jump around, and because it can make the flow of logic harder to follow. For example, a <code>break</code> in the middle of a complicated piece of logic could either be missed, or it may not be obvious under what conditions it should be triggered.</p><p>However, used judiciously, <code>break</code> and <code>continue</code> can help make loops more readable by keeping the number of nested blocks down and reducing the need for complicated looping logic.</p><p>For example, consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int count{ 0 }; // count how many times the loop iterates</code><code>    bool keepLooping { true }; // controls whether the loop ends or not</code><code>    while (keepLooping)</code><code>    {</code><code>        std::cout &lt;&lt; "Enter 'e' to exit this loop or any other character to continue: ";</code><code>        char ch{};</code><code>        std::cin &gt;&gt; ch;</code><code></code><code>        if (ch == 'e')</code><code>            keepLooping = false;</code><code>        else</code><code>        {</code><code>            ++count;</code><code>            std::cout &lt;&lt; "We've iterated " &lt;&lt; count &lt;&lt; " times\n";</code><code>        }</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program uses a boolean variable to control whether the loop continues or not, as well as a nested block that only runs if the user doesn’t exit.</p><p>Here’s a version that’s easier to understand, using a <code>break statement</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int count{ 0 }; // count how many times the loop iterates</code><code>    while (true) // loop until user terminates</code><code>    {</code><code>        std::cout &lt;&lt; "Enter 'e' to exit this loop or any other character to continue: ";</code><code>        char ch{};</code><code>        std::cin &gt;&gt; ch;</code><code></code><code>        if (ch == 'e')</code><code>            break;</code><code></code><code>        ++count;</code><code>        std::cout &lt;&lt; "We've iterated " &lt;&lt; count &lt;&lt; " times\n";</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this version, by using a single <code>break statement</code>, we’ve avoided the use of a Boolean variable (and having to understand both what its intended use is, and where its value is changed), an <code>else statement</code>, and a nested block.</p><p>Minimizing the number of variables used and keeping the number of nested blocks down both improve code comprehensibility more than a <code>break</code> or <code>continue</code> harms it. For that reason, we believe judicious use of <code>break</code> or <code>continue</code> is acceptable.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use break and continue when they simplify your loop logic.</p></div><br><h3>The debate over use of early returns</h3><p>There’s a similar argument to be made for return statements. A return statement that is not the last statement in a function is called an <span class="cpp-definition">early return</span>. Many programmers believe early returns should be avoided. A function that only has one return statement at the bottom of the function has a simplicity to it -- you can assume the function will take its arguments, do whatever logic it has implemented, and return a result without deviation. Having extra returns complicates the logic.</p><p>The counter-argument is that using early returns allows your function to exit as soon as it is done, which reduces having to read through unnecessary logic and minimizes the need for conditional nested blocks, which makes your code more readable.</p><p>Some developers take a middle ground, and only use early returns at the top of a function to do parameter validation (catch bad arguments passed in), and then a single return thereafter.</p><p>Our stance is that early returns are more helpful than harmful, but we recognize that there is a bit of art to the practice.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use early returns when they simplify your function’s logic.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.11 — Halts (exiting your program early)</h1></header><div class="entry-content" itemprop="articleBody"><p>The last category of flow control statement we’ll cover in this chapter is the halt. A <span class="cpp-definition">halt</span> is a flow control statement that terminates the program. In C++, halts are implemented as functions (rather than keywords), so our halt statements will be function calls.</p><p>Let’s take a brief detour, and recap what happens when a program exits normally. When the <code>main()</code> function returns (either by reaching the end of the function, or via a <code>return statement</code>), a number of different things happen.</p><p>First, because we’re leaving the function, all local variables and function parameters are destroyed (as per usual).</p><p>Next, a special function called <code>std::exit()</code> is called, with the return value from <code>main()</code> (the <code>status code</code>) passed in as an argument. So what is <code>std::exit()</code>?</p><br><h3>The std::exit() function</h3><p><code>std::exit()</code> is a function that causes the program to terminate normally. <span class="cpp-definition">Normal termination</span> means the program has exited in an expected way. Note that the term <code>normal termination</code> does not imply anything about whether the program was successful (that’s what the <code>status code</code> is for). For example, let’s say you were writing a program where you expected the user to type in a filename to process. If the user typed in an invalid filename, your program would probably return a non-zero <code>status code</code> to indicate the failure state, but it would still have a <code>normal termination</code>.</p><p><code>std::exit()</code> performs a number of cleanup functions. First, objects with static storage duration are destroyed. Then some other miscellaneous file cleanup is done if any files were used. Finally, control is returned back to the OS, with the argument passed to <code>std::exit()</code> used as the <code>status code</code>.</p><br><h3>Calling std::exit() explicitly</h3><p>Although <code>std::exit()</code> is called implicitly when function <code>main()</code> ends, <code>std::exit()</code> can also be called explicitly to halt the program before it would normally terminate. When <code>std::exit()</code> is called this way, you will need to include the <code>cstdlib</code> header.</p><p>Here is an example of using <code>std::exit()</code> explicitly:</p><pre class="language-cpp line-numbers"><code>#include <cstdlib> // for std::exit()</cstdlib></code><code>#include <iostream></iostream></code><code></code><code>void cleanup()</code><code>{</code><code>    // code here to do any kind of cleanup required</code><code>    std::cout &lt;&lt; "cleanup!\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; 1 &lt;&lt; '\n';</code><code>    cleanup();</code><code></code><code>    std::exit(0); // terminate and return status code 0 to operating system</code><code></code><code>    // The following statements never execute</code><code>    std::cout &lt;&lt; 2 &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>1
cleanup!
</pre><p>Note that the statements after the call to <code>std::exit()</code> never execute because the program has already terminated.</p><p>Although in the program above we call <code>std::exit()</code> from function <code>main()</code>, <code>std::exit()</code> can be called from any function to terminate the program at that point.</p><p>One important note about calling <code>std::exit()</code> explicitly: <code>std::exit()</code> does not clean up any local variables (either in the current function, or in functions up the <code>call stack</code>). Because of this, it’s generally better to avoid calling <code>std::exit()</code>.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>The <code>std::exit()</code> function does not clean up local variables in the current function or up the call stack.</p></div><br><h3>std::atexit</h3><p>Because <code>std::exit()</code> terminates the program immediately, you may want to manually do some cleanup before terminating. In this context, cleanup means things like closing database or network connections, deallocating any memory you have allocated, writing information to a log file, etc…</p><p>In the above example, we called function <code>cleanup()</code> to handle our cleanup tasks. However, remembering to manually call a cleanup function before calling every call to exit() adds burden to the programmer.</p><p>To assist with this, C++ offers the <code>std::atexit()</code> function, which allows you to specify a function that will automatically be called on program termination via <code>std:exit()</code>.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We discuss passing functions as arguments in lesson <a href="https://www.learncpp.com/cpp-tutorial/function-pointers/">12.1 -- Function Pointers</a>.</p></div><p>Here’s an example:</p><pre class="language-cpp line-numbers"><code>#include <cstdlib> // for std::exit()</cstdlib></code><code>#include <iostream></iostream></code><code></code><code>void cleanup()</code><code>{</code><code>    // code here to do any kind of cleanup required</code><code>    std::cout &lt;&lt; "cleanup!\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    // register cleanup() to be called automatically when std::exit() is called</code><code>    std::atexit(cleanup); // note: we use cleanup rather than cleanup() since we're not making a function call to cleanup() right now</code><code></code><code>    std::cout &lt;&lt; 1 &lt;&lt; '\n';</code><code></code><code>    std::exit(0); // terminate and return status code 0 to operating system</code><code></code><code>    // The following statements never execute</code><code>    std::cout &lt;&lt; 2 &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program has the same output as the prior example:</p><pre>1
cleanup!
</pre><p>So why would you want to do this? It allows you to specify a cleanup function in one place (probably in <code>main</code>) and then not have to worry about remembering to call that function explicitly before calling <code>std::exit()</code>.</p><p>A few notes here about <code>std::atexit()</code> and the cleanup function: First, because <code>std::exit()</code> is called implicitly when <code>main()</code> terminates, this will invoke any functions registered by <code>std::atexit()</code> if the program exits that way. Second, the function being registered must take no parameters and have no return value. Finally, you can register multiple cleanup functions using <code>std::atexit()</code> if you want, and they will be called in reverse order of registration (the last one registered will be called first).</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>In multi-threaded programs, calling <code>std::exit()</code> can cause your program to crash (because the thread calling <code>std::exit()</code> will cleanup static objects that may still be accessed by other threads). For this reason, C++ has introduced another pair of functions that work similarly to <code>std::exit()</code> and <code>std::atexit()</code> called <code>std::quick_exit()</code> and <code>std::at_quick_exit()</code>. <code>std::quick_exit()</code> terminates the program normally, but does not clean up static objects, and may or may not do other types of cleanup. <code>std::at_quick_exit()</code> performs the same role as <code>std::atexit()</code> for programs terminated with <code>std::quick_exit()</code>.</p></div><br><h3>std::abort and std::terminate</h3><p>C++ contains two other halt-related functions.</p><p>The <code>std::abort()</code> function causes your program to terminate abnormally. <span class="cpp-definition">Abnormal termination</span> means the program had some kind of unusual runtime error and the program couldn’t continue to run. For example, trying to divide by 0 will result in an abnormal termination. <code>std::abort()</code> does not do any cleanup.</p><pre class="language-cpp line-numbers"><code>#include <cstdlib> // for std::abort()</cstdlib></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; 1 &lt;&lt; '\n';</code><code>    std::abort();</code><code></code><code>    // The following statements never execute</code><code>    std::cout &lt;&lt; 2 &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>We will see cases later in this chapter (<a href="https://www.learncpp.com/cpp-tutorial/assert-and-static_assert/">7.17 -- Assert and static_assert</a>) where <code>std::abort</code> is called implicitly.</p><p>The <code>std::terminate()</code> function is typically used in conjunction with <code>exceptions</code> (we’ll cover exceptions in a later chapter). Although <code>std::terminate</code> can be called explicitly, it is more often called implicitly when an exception isn’t handled (and in a few other exception-related cases). By default, <code>std::terminate()</code> calls <code>std::abort()</code>.</p><br><h3>When should you use a halt?</h3><p>The short answer is “almost never”. Destroying local objects is an important part of C++ (particularly when we get into classes), and none of the above-mentioned functions clean up local variables. Exceptions are a better and safer mechanism for handling error cases.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Only use a halt if there is no safe way to return normally from the main function. If you haven’t disabled exceptions, prefer using exceptions for handling errors safely.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.12 — Introduction to testing your code</h1></header><div class="entry-content" itemprop="articleBody"><p>So, you’ve written a program, it compiles, and it even appears to work! What now?</p><p>Well, it depends. If you’ve written your program to be run once and discarded, then you’re done. In this case, it may not matter that your program doesn’t work for every case -- if it works for the one case you needed it for, and you’re only going to run it once, then you’re done.</p><p>If your program is entirely linear (has no conditionals, such as <code>if statements</code> or <code>switch statements</code>), takes no inputs, and produces the correct answer, then you’re done. In this case, you’ve already tested the entire program by running it and validating the output.</p><p>But more likely you’ve written a program you intend to run many times, that uses loops and conditional logic, and accepts user input of some kind. You’ve possibly written functions that may be reusable in other future programs. You may have experienced a bit of <span class="cpp-definition">scope creep</span>, where you added some new capabilities that were originally not planned for. Maybe you’re even intending to distribute this program to other people (who are likely to try things you haven’t thought of). In this case, you really should be validating that your program works like you think it does under a wide variety of conditions -- and that requires some proactive testing.</p><p>Just because your program worked for one set of inputs doesn’t mean it’s going to work correctly in all cases.</p><p><span class="cpp-definition">Software verification</span> (a.k.a. <span class="cpp-definition">software testing</span>) is the process of determining whether or not the software works as expected in all cases.</p><br><h3>The testing challenge</h3><p>Before we talk about some practical ways to test your code, let’s talk about why testing your program comprehensively is difficult.</p><p>Consider this simple program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void compare(int x, int y)</code><code>{</code><code>    if (x &gt; y)</code><code>        std::cout &lt;&lt; x &lt;&lt; " is greater than " &lt;&lt; y &lt;&lt; '\n'; // case 1</code><code>    else if (x &lt; y)</code><code>        std::cout &lt;&lt; x &lt;&lt; " is less than " &lt;&lt; y &lt;&lt; '\n'; // case 2</code><code>    else</code><code>        std::cout &lt;&lt; x &lt;&lt; " is equal to " &lt;&lt; y &lt;&lt; '\n'; // case 3</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number: ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    std::cout &lt;&lt; "Enter another number: ";</code><code>    int y{};</code><code>    std::cin &gt;&gt; y;</code><code></code><code>    compare(x, y);</code><code></code><code>    return 0;</code><code>}</code></pre><p>Assuming a 4-byte integer, explicitly testing this program with every possible combination of inputs would require that you run the program 18,446,744,073,709,551,616 (~18 quintillion) times. Clearly that’s not a feasible task!</p><p>Every time we ask for user input, or have a conditional in our code, we increase the number of possible ways our program can execute by some multiplicative factor. For all but the simplest programs, explicitly testing every combination of inputs becomes impossible almost immediately.</p><p>Now, your intuition should be telling you that you really shouldn’t need to run the above program 18 quintillion times to ensure it works. You may reasonably conclude that if case 1 works for one pair of <code>x</code> and <code>y</code> values where <code>x &gt; y</code>, it should work for any pair of <code>x</code> and <code>y</code> where <code>x &gt; y</code>. Given that, it becomes apparent that we really only need to run this program about three times (once to exercise each of the three cases in function <code>compare()</code>) to have a high degree of confidence it works as desired. There are other similar tricks we can use to dramatically reduce the number of times we have to test something, in order to make testing manageable.</p><p>There’s a lot that can be written about testing methodologies -- in fact, we could write a whole chapter on it. But since it’s not a C++ specific topic, we’ll stick to a brief and informal introduction, covered from the point of view of you (as the developer) testing your own code. In the next few subsections, we’ll talk about some <em>practical</em> things you should be thinking about as you test your code.</p><br><h3>Test your programs in small pieces</h3><p>Consider an auto manufacturer that is building a custom concept car. Which of the following do you think they do?<br>a) Build (or buy) and test each car component individually before installing it. Once the component has been proven to work, integrate it into the car and retest it to make sure the integration worked. At the end, test the whole car, as a final validation that everything seems good.<br>b) Build a car out of all of the components all in one go, then test the whole thing for the first time right at the end.</p><p>It probably seems obvious that option a) is a better choice. And yet, many new programmers write code like option b)!</p><p>In case b), if any of the car parts were to not work as expected, the mechanic would have to diagnose the entire car to determine what was wrong -- the issue could be anywhere. A symptom might have many causes -- for example, is the car not starting due to a faulty spark plug, battery, fuel pump, or something else? This leads to lots of wasted time trying to identify exactly where the problems are, and what to do about them. And if a problem is found, the consequences can be disastrous -- a change in one area might cause “ripple effects” (changes) in multiple other places. For example, a fuel pump that is too small might lead to an engine redesign, which leads to a redesign of the car frame. In the worst case, you might end up redesigning a huge part of the car, just to accommodate what was initially a small issue!</p><p>In case a), the company tests as they go. If any component is bad right out of the box, they’ll know immediately and can fix/replace it. Nothing is integrated into the car until it’s proven working by itself, and then that part is retested again as soon as it’s been integrated into the car. This way any unexpected issues are discovered as early as possible, while they are still small problems that can be easily fixed.</p><p>By the time they get around to having the whole car assembled, they should have reasonable confidence that the car will work -- after all, all the parts have been tested in isolation and when initially integrated. It’s still possible that unexpected issues will be found at this point, but that risk is minimized by all the prior testing.</p><p>The above analogy holds true for programs as well, though for some reason, new programmers often don’t realize it. You’re much better off writing small functions (or classes), and then compiling and testing them immediately. That way, if you make a mistake, you’ll know it has to be in the small amount of code that you changed since the last time you compiled/tested. That means fewer places to look, and far less time spent debugging.</p><p>Testing a small part of your code in isolation to ensure that “unit” of code is correct is called <span class="cpp-definition">unit testing</span>. Each <span class="cpp-definition">unit test</span> is designed to ensure that a particular behavior of the unit is correct.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Write your program in small, well defined units (functions or classes), compile often, and test your code as you go.</p></div><p>If the program is short and accepts user input, trying a variety of user inputs might be sufficient. But as programs get longer and longer, this becomes less sufficient, and there is more value in testing individual functions or classes before integrating them into the rest of the program.</p><p>So how can we test our code in units?</p><br><h3>Informal testing</h3><p>One way you can test code is to do informal testing as you write the program. After writing a unit of code (a function, a class, or some other discrete “package” of code), you can write some code to test the unit that was just added, and then erase the test once the test passes. As an example, for the following isLowerVowel() function, you might write the following code:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// We want to test the following function</code><code>bool isLowerVowel(char c)</code><code>{</code><code>    switch (c)</code><code>    {</code><code>    case 'a':</code><code>    case 'e':</code><code>    case 'i':</code><code>    case 'o':</code><code>    case 'u':</code><code>        return true;</code><code>    default:</code><code>        return false;</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    // So here's our temporary tests to validate it works</code><code>    std::cout &lt;&lt; isLowerVowel('a'); // temporary test code, should produce 1</code><code>    std::cout &lt;&lt; isLowerVowel('q'); // temporary test code, should produce 0</code><code></code><code>    return 0;</code><code>}</code></pre><p>If the results come back as <code>1</code> and <code>0</code>, then you’re good to go. You know your function works for some basic cases, and you can reasonably infer by looking at the code that it will work for the cases you didn’t test (‘e’, ‘i’, ‘o’, and ‘u’). So you can erase that temporary test code, and continue programming.</p><br><h3>Preserving your tests</h3><p>Although writing temporary tests is a quick and easy way to test some code, it doesn’t account for the fact that at some point, you may want to test that same code again later. Perhaps you modified a function to add a new capability, and want to make sure you didn’t break anything that was already working. For that reason, it can make more sense to preserve your tests so they can be run again in the future. For example, instead of erasing your temporary test code, you could move the tests into a testVowel() function:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>bool isLowerVowel(char c)</code><code>{</code><code>    switch (c)</code><code>    {</code><code>    case 'a':</code><code>    case 'e':</code><code>    case 'i':</code><code>    case 'o':</code><code>    case 'u':</code><code>        return true;</code><code>    default:</code><code>        return false;</code><code>    }</code><code>}</code><code></code><code>// Not called from anywhere right now</code><code>// But here if you want to retest things later</code><code>void testVowel()</code><code>{</code><code>    std::cout &lt;&lt; isLowerVowel('a'); // temporary test code, should produce 1</code><code>    std::cout &lt;&lt; isLowerVowel('q'); // temporary test code, should produce 0</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    return 0;</code><code>}</code></pre><p>As you create more tests, you can simply add them to the <code>testVowel()</code> function.</p><br><h3>Automating your test functions</h3><p>One problem with the above test function is that it relies on you to manually verify the results when you run it. This requires you to remember what the expected answer was at worst (assuming you didn’t document it), and manually compare the actual results to the expected results.</p><p>We can do better by writing a test function that contains both the tests AND the expected answers and compares them so we don’t have to.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>bool isLowerVowel(char c)</code><code>{</code><code>    switch (c)</code><code>    {</code><code>    case 'a':</code><code>    case 'e':</code><code>    case 'i':</code><code>    case 'o':</code><code>    case 'u':</code><code>        return true;</code><code>    default:</code><code>        return false;</code><code>    }</code><code>}</code><code></code><code>// returns the number of the test that failed, or 0 if all tests passed</code><code>int testVowel()</code><code>{</code><code>    if (isLowerVowel('a') != true) return 1;</code><code>    if (isLowerVowel('q') != false) return 2;</code><code></code><code>    return 0;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    return 0;</code><code>}</code></pre><p>Now, you can call <code>testVowel()</code> at any time to re-prove that you haven’t broken anything, and the test routine will do all the work for you, returning either an “all good” signal (return value <code>0</code>), or the test number that didn’t pass, so you can investigate why it broke. This is particularly useful when going back and modifying old code, to ensure you haven’t accidentally broken anything!</p><br><h3>Unit testing frameworks</h3><p>Because writing functions to exercise other functions is so common and useful, there are entire frameworks (called <span class="cpp-definition">unit testing frameworks</span>) that are designed to help simplify the process of writing, maintaining, and executing unit tests. Since these involve third party software, we won’t cover them here, but you should be aware they exist.</p><br><h3>Integration testing</h3><p>Once each of your units has been tested in isolation, they can be integrated into your program and retested to make sure they were integrated properly. This is called an <span class="cpp-definition">integration test</span>. Integration testing tends to be more complicated -- for now, running your program a few times and spot checking the behavior of the integrated unit will suffice.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>When should you start testing your code?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none">As soon as you’ve written a non-trivial function.</div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.13 — Code coverage</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-testing-your-code/">7.12 -- Introduction to testing your code</a>, we discussed how to write and preserve simple tests. In this lesson, we’ll talk about what kind of tests are useful to write to ensure your code is correct.</p><br><h3>Code coverage</h3><p>The term <span class="cpp-definition">code coverage</span> is used to describe how much of the source code of a program is executed while testing. There are many different metrics used for code coverage. We’ll cover a few of the more useful and popular ones in the following sections.</p><br><h3>Statement coverage</h3><p>The term <span class="cpp-definition">statement coverage</span> refers to the percentage of statements in your code that have been exercised by your testing routines.</p><p>Consider the following function:</p><pre class="language-cpp line-numbers"><code>int foo(int x, int y)</code><code>{</code><code>    int z{ y };</code><code>    if (x &gt; y)</code><code>    {</code><code>        z = x;</code><code>    }</code><code>    return z;</code><code>}</code></pre><p>Calling this function as <code>foo(1, 0)</code> will give you complete statement coverage for this function, as every statement in the function will execute.</p><p>For our <code>isLowerVowel()</code> function:</p><pre class="language-cpp line-numbers"><code>bool isLowerVowel(char c)</code><code>{</code><code>    switch (c) // statement 1</code><code>    {</code><code>    case 'a':</code><code>    case 'e':</code><code>    case 'i':</code><code>    case 'o':</code><code>    case 'u':</code><code>        return true; // statement 2</code><code>    default:</code><code>        return false; // statement 3</code><code>    }</code><code>}</code></pre><p>This function will require two calls to test all of the statements, as there is no way to reach statement 2 and 3 in the same function call.</p><p>While aiming for 100% statement coverage is good, it’s not enough to ensure correctness.</p><br><h3>Branch coverage</h3><p><span class="cpp-definition">Branch coverage</span> refers to the percentage of branches that have been executed, each possible branch counted separately. An <code>if statement</code> has two branches -- a branch that executes when the condition is <code>true</code>, and a branch that executes when the condition is <code>false</code> (even if there is no corresponding <code>else statement</code> to execute). A switch statement can have many branches.</p><pre class="language-cpp line-numbers"><code>int foo(int x, int y)</code><code>{</code><code>    int z{ y };</code><code>    if (x &gt; y)</code><code>    {</code><code>        z = x;</code><code>    }</code><code>    return z;</code><code>}</code></pre><p>The previous call to foo(1, 0) gave us 100% statement coverage and exercised the use case where <code>x &gt; y</code>, but that only gives us 50% branch coverage. We need one more call, to <code>foo(0, 1)</code>, to test the use case where the <code>if statement</code> does not execute.</p><pre class="language-cpp line-numbers"><code>bool isLowerVowel(char c)</code><code>{</code><code>    switch (c)</code><code>    {</code><code>    case 'a':</code><code>    case 'e':</code><code>    case 'i':</code><code>    case 'o':</code><code>    case 'u':</code><code>        return true;</code><code>    default:</code><code>        return false;</code><code>    }</code><code>}</code></pre><p>In the isLowerVowel() function, two calls will be needed to give you 100% branch coverage: one (such as <code>isLowerVowel('a')</code>) to test the first cases, and another (such as <code>isLowerVowel('q')</code>) to test the default case. Multiple cases that feed into the same body don’t need to be tested separately -- if one works, they all should.</p><p>Now consider the following function:</p><pre class="language-cpp line-numbers"><code>void compare(int x, int y)</code><code>{</code><code>	if (x &gt; y)</code><code>		std::cout &lt;&lt; x &lt;&lt; " is greater than " &lt;&lt; y &lt;&lt; '\n'; // case 1</code><code>	else if (x &lt; y)</code><code>		std::cout &lt;&lt; x &lt;&lt; " is less than " &lt;&lt; y &lt;&lt; '\n'; // case 2</code><code>	else</code><code>		std::cout &lt;&lt; x &lt;&lt; " is equal to " &lt;&lt; y &lt;&lt; '\n'; // case 3</code><code>}</code></pre><p>3 calls are needed to get 100% branch coverage here: <code>compare(1, 0)</code> tests the positive use case for the first <code>if statement</code>. <code>compare(0, 1)</code> tests the negative use case for the first <code>if statement</code> and the positive use case for the second <code>if statement</code>. <code>compare(0, 0)</code> tests the negative use case for the first and second <code>if statement</code> and executes the <code>else statement</code>. Thus, we can say this function is reliably tested with 3 calls (which is slightly better than 18 quintillion).</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Aim for 100% branch coverage of your code.</p></div><br><h3>Loop coverage</h3><p><span class="cpp-definition">Loop coverage</span> (informally called <span class="cpp-definition">the 0, 1, 2 test</span>) says that if you have a loop in your code, you should ensure it works properly when it iterates 0 times, 1 time, and 2 times. If it works correctly for the 2-iteration case, it should work correctly for all iterations greater than 2. These three tests therefore cover all possibilities (since a loop can’t execute a negative number of times).</p><p>Consider:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void spam(int timesToPrint)</code><code>{</code><code>    for (int count{ 0 }; count &lt; timesToPrint; ++count)</code><code>         std::cout &lt;&lt; "Spam! ";</code><code>}</code></pre><p>To test the loop within this function properly, you should call it three times: <code>spam(0)</code> to test the zero-iteration case, <code>spam(1)</code> to test the one-iteration case, and <code>spam(2)</code> to test the two-iteration case. If <code>spam(2)</code> works, then <code>spam(n)</code> should work, where <code>n &gt; 2</code>.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use the <code>0, 1, 2 test</code> to ensure your loops work correctly with different number of iterations.</p></div><br><h3>Testing different categories of input</h3><p>When writing functions that accept parameters, or when accepting user input, consider what happens with different categories of input. In this context, we’re using the term “category” to mean a set of inputs that have similar characteristics.</p><p>For example, if I wrote a function to produce the square root of an integer, what values would it make sense to test it with? You’d probably start with some normal value, like <code>4</code>. But it would also be a good idea to test with <code>0</code>, and a negative number.</p><p>Here are some basic guidelines for category testing:</p><p>For integers, make sure you’ve considered how your function handles negative values, zero, and positive values. You should also check for overflow if that’s relevant.</p><p>For floating point numbers, make sure you’ve considered how your function handles values that have precision issues (values that are slightly larger or smaller than expected). Good <code>double</code> type values to test with are <code>0.1</code> and <code>-0.1</code> (to test numbers that are slightly larger than expected) and <code>0.6</code> and <code>-0.6</code> (to test numbers that are slightly smaller than expected).</p><p>For strings, make sure you’ve considered how your function handles an empty string (just a null terminator), normal valid strings, strings that have whitespace, and strings that are all whitespace.</p><p>If your function takes a pointer, don’t forget to test <code>nullptr</code> as well (don’t worry if this doesn’t make sense, we haven’t covered it yet).</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Test different categories of input values to make sure your unit handles them properly.</p></div><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>What is branch coverage?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none">Branch coverage is the percentage of branches that have been executed, with the affirmative case and negative case counting separately.</div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>How many tests would the following function need to minimally validate that it works?</p><pre class="language-cpp line-numbers"><code>bool isLowerVowel(char c, bool yIsVowel)</code><code>{</code><code>    switch (c)</code><code>    {</code><code>    case 'a':</code><code>    case 'e':</code><code>    case 'i':</code><code>    case 'o':</code><code>    case 'u':</code><code>        return true;</code><code>    case 'y':</code><code>        return yIsVowel;</code><code>    default:</code><code>        return false;</code><code>    }</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none">4 tests. One to test the a/e/i/o/u case. One to test the default case. One to test <code>isLowerVowel('y', true)</code>. And one to test <code>isLowerVowel('y', false)</code>.</div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.14 — Common semantic errors in C++</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/syntax-and-semantic-errors/">3.1 -- Syntax and semantic errors</a>, we covered <code>syntax errors</code>, which occur when you write code that is not valid according to the grammar of the C++ language. The compiler will notify you of such errors, so they are trivial to catch, and usually straightforward to fix.</p><p>We also covered <code>semantic errors</code>, which occur when you write code that does not do what you intended. The compiler generally will not catch semantic errors (though in some cases, smart compilers may be able to generate a warning).</p><p>Semantic errors can cause most of the same symptoms of <code>undefined behavior</code>, such as causing the program to produce the wrong results, causing erratic behavior, corrupting program data, causing the program to crash -- or they may not have any impact at all.</p><p>When writing programs, it is almost inevitable that you will make semantic errors. You will probably notice some of these just by using the program: for example, if you were writing a maze game, and your character was able to walk through walls. Testing your program (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-testing-your-code/">7.12 -- Introduction to testing your code</a>) can also help surface semantic errors.</p><p>But there’s one other thing that can help -- and that’s knowing which type of semantic errors are most common, so you can spend a little more time ensuring things are right in those cases.</p><p>In this lesson, we’ll cover a bunch of the most common types of semantic errors that occur in C++ (most of which have to do with flow control in some way).</p><br><h3>Conditional logic errors</h3><p>One of the most common types of semantic errors is a conditional logic error. A <span class="cpp-definition">conditional logic error</span> occurs when the programmer incorrectly codes the logic of a conditional statement or loop condition. Here is a simple example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    if (x &gt;= 5) // oops, we used operator&gt;= instead of operator&gt;</code><code>        std::cout &lt;&lt; x &lt;&lt; " is greater than 5\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>Here’s a run of the program that exhibits the conditional logic error:</p><pre>Enter an integer: 5
5 is greater than 5
</pre><p>When the user enters <code>5</code>, the conditional expression <code>x &gt;= 5</code> evaluates to <code>true</code>, so the associated statement is executed.</p><p>Here’s another example, using a for loop:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    // oops, we used operator&gt; instead of operator&lt;</code><code>    for (int count{ 1 }; count &gt; x; ++count)</code><code>    {</code><code>        std::cout &lt;&lt; count &lt;&lt; ' ';</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program is supposed to print all of the numbers between 1 and the number the user entered. But here’s what it actually does:</p><pre>Enter an integer: 5
</pre><p>It didn’t print anything. This happens because on entrance to the for loop, <code>count &gt; x</code> is <code>false</code>, so the loop never iterates at all.</p><br><h3>Infinite loops</h3><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-loops-and-while-statements/">7.7 -- Introduction to loops and while statements</a>, we covered infinite loops, and showed this example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code> </code><code>int main()</code><code>{</code><code>    int count{ 1 };</code><code>    while (count &lt;= 10) // this condition will never be false</code><code>    {</code><code>        std::cout &lt;&lt; count &lt;&lt; ' '; // so this line will repeatedly execute</code><code>    }</code><code> </code><code>    std::cout &lt;&lt; '\n'; // this line will never execute</code><code></code><code>    return 0; // this line will never execute</code><code>}</code></pre><p>In this case, we forgot to increment <code>count</code>, so the loop condition will never be false, and the loop will continue to print:</p><pre>1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
</pre><p>… until the user shuts down the program.</p><p>Here’s another example that teachers love asking as a quiz question. What’s wrong with the following code?</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    for (unsigned int count{ 5 }; count &gt;= 0; --count)</code><code>    {</code><code>        if (count == 0)</code><code>            std::cout &lt;&lt; "blastoff! ";</code><code>        else</code><code>          std::cout &lt;&lt; count &lt;&lt; ' ';</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program is supposed to print <code>5 4 3 2 1 blastoff!</code>, which it does, but it doesn’t stop there. In actuality, it prints:</p><pre>5 4 3 2 1 blastoff! 4294967295 4294967294 4294967293 4294967292 4294967291
</pre><p>and then just keeps decrementing. The program will never terminate, because <code>count &gt;= 0</code> can never be <code>false</code> when <code>count</code> is an unsigned integer.</p><br><h3>Off-by-one errors</h3><p>An <span class="cpp-definition">off-by-one</span> error is an error that occurs when a loop executes one too many or one too few times. Here’s an example that we covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/for-statements/">7.9 -- For statements</a>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    for (unsigned int count{ 1 }; count &lt; 5; ++count)</code><code>    {</code><code>        std::cout &lt;&lt; count &lt;&lt; ' ';</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>The programmer intended for this code to print <code>1 2 3 4 5</code>. However, the wrong relational operator was used (<code>&lt;</code> instead of <code>&lt;=</code>), so the loop executes one fewer times than intended, printing <code>1 2 3 4</code>.</p><br><h3>Incorrect operator precedence</h3><p>From lesson <a href="https://www.learncpp.com/cpp-tutorial/logical-operators/">5.7 -- Logical operators</a>, the following program makes an operator precedence mistake:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    int y{ 7 };</code><code></code><code>    if (!x &gt; y) // oops: operator precedence issue</code><code>        std::cout &lt;&lt; x &lt;&lt; " is not greater than " &lt;&lt; y &lt;&lt; '\n';</code><code>    else</code><code>        std::cout &lt;&lt; x &lt;&lt; " is greater than " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because <code>logical NOT</code> has higher precedence than <code>operator&gt;</code>, the conditional evaluates as if it was written <code>(!x) &gt; y</code>, which isn’t what the programmer intended.</p><p>As a result, this program prints:</p><pre>5 is greater than 7
</pre><p>This can also happen when mixing Logical OR and Logical AND in the same expression (Logical AND takes precedence over Logical OR). Use explicit parenthesization to avoid these kinds of errors.</p><br><h3>Precision issues with floating point types</h3><p>The following floating point variable doesn’t have enough precision to store the entire number:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    float f{ 0.123456789f };</code><code>    std::cout &lt;&lt; f &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because of this lack of precision, the number is rounded slightly:</p><pre>0.123457
</pre><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/relational-operators-and-floating-point-comparisons/">5.6 -- Relational operators and floating point comparisons</a>, we talked about how using <code>operator==</code> and <code>operator!=</code> can be problematic with floating point numbers due to small rounding errors (as well as what to do about it). Here’s an example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    double d{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 }; // should sum to 1.0</code><code></code><code>    if (d == 1.0)</code><code>        std::cout &lt;&lt; "equal\n";</code><code>    else</code><code>        std::cout &lt;&lt; "not equal\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>not equal
</pre><p>The more arithmetic you do with a floating point number, the more it will accumulate small rounding errors.</p><br><h3>Integer division</h3><p>In the following example, we mean to do a floating point division, but because both operands are integers, we end up doing an integer division instead:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    int y{ 3 };</code><code></code><code>    std::cout &lt;&lt; x &lt;&lt; " divided by " &lt;&lt; y &lt;&lt; " is: " &lt;&lt; x / y &lt;&lt; '\n'; // integer division</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>5 divided by 3 is: 1
</pre><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/arithmetic-operators/">5.2 -- Arithmetic operators</a>, we showed that we can use static_cast to convert one of the integral operands to a floating point value in order to do floating point division.</p><br><h3>Accidental null statements</h3><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/common-if-statement-problems/">7.3 -- Common if statement problems</a>, we covered <code>null statements</code>, which are statements that do nothing.</p><p>In the below program, we only want to blow up the world if we have the user’s permission:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void blowUpWorld()</code><code>{</code><code>    std::cout &lt;&lt; "Kaboom!\n";</code><code>} </code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Should we blow up the world again? (y/n): ";</code><code>    char c{};</code><code>    std::cin &gt;&gt; c;</code><code></code><code>    if (c=='y'); // accidental null statement here</code><code>        blowUpWorld(); // so this will always execute since it's not part of the if-statement</code><code> </code><code>    return 0;</code><code>}</code></pre><p>However, because of an accidental <code>null statement</code>, the function call to <code>blowUpWorld()</code> is always executed, so we blow it up regardless:</p><pre>Should we blow up the world again? (y/n): n
Kaboom!
</pre><br><h3>Not using a compound statement when one is required</h3><p>Another variant of the above program that always blows up the world:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void blowUpWorld()</code><code>{</code><code>    std::cout &lt;&lt; "Kaboom!\n";</code><code>} </code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Should we blow up the world again? (y/n): ";</code><code>    char c{};</code><code>    std::cin &gt;&gt; c;</code><code></code><code>    if (c=='y')</code><code>        std::cout &lt;&lt; "Okay, here we go...\n";</code><code>        blowUpWorld(); // oops, will always execute.  Should be inside compound statement.</code><code> </code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>Should we blow up the world again? (y/n): n
Kaboom!
</pre><p>A <code>dangling else</code> (covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/common-if-statement-problems/">7.3 -- Common if statement problems</a>) also falls into this category.</p><br><h3>What else?</h3><p>The above represents a good sample of the most common type of semantic errors new C++ programmers tend to make, but there are plenty more. Readers, if you have any additional ones that you think are common pitfalls, leave a note in the comments.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.15 — Detecting and handling errors</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/common-semantic-errors-in-c/">7.14 -- Common semantic errors in C++</a>, we covered many types of common C++ semantic errors that new C++ programmers run into with the language. If an error is the result of a misused language feature or logic error, the error can simply be corrected.</p><p>But most errors in a program don’t occur as the result of inadvertently misusing language features -- rather, most errors occur due to faulty assumptions made by the programmer and/or a lack of proper error detection/handling.</p><p>For example, in a function designed to look up a grade for a student, you might have assumed:</p><ul><li>The student being looked up will exist.</li><li>All student names will be unique.</li><li>The class uses letter grading (instead of pass/fail).</li></ul><p>What if any of these assumptions aren’t true? If the programmer didn’t anticipate these cases, the program will likely malfunction or crash when such cases arise (usually at some point in the future, well after the function has been written).</p><p>There are three key places where assumption errors typically occur:</p><ul><li>When a function returns, the programmer may have assumed the called function was successful when it was not.</li><li>When a program receives input (either from the user, or a file), the programmer may have assumed the input was in the correct format and semantically valid when it was not.</li><li>When a function has been called, the programmer may have assumed the arguments would be semantically valid when they were not.</li></ul><p>Many new programmers write code and then only test the <span class="cpp-definition">happy path</span>: only the cases where there are no errors. But you should also be planning for and testing your <span class="cpp-definition">sad paths</span>, where things can and will go wrong. In lesson <a href="https://www.learncpp.com/cpp-tutorial/finding-issues-before-they-become-problems/">3.10 -- Finding issues before they become problems</a>, we defined <span class="cpp-definition">defensive programming</span> as the practice of trying to anticipate all of the ways software can be misused, either by end-users, or by developers (either the programmer themselves, or others). Once you’ve anticipated (or discovered) some misuse, the next thing to do is handle it.</p><p>In this lesson, we’ll talk about error handling strategies (what to do when things go wrong) inside a function. In the subsequent lessons, we’ll talk about validating user input, and then introduce a useful tool to help document and validate assumptions.</p><br><h3>Handling errors in functions</h3><p>Functions may fail for any number of reasons -- the caller may have passed in an argument with an invalid value, or something may fail within the body of the function. For example, a function that opens a file for reading might fail if the file cannot be found.</p><p>When this happens, you have quite a few options at your disposal. There is no best way to handle an error -- it really depends on the nature of the problem and whether the problem can be fixed or not.</p><p>There are 4 general strategies that can be used:</p><ul><li>Handle the error within the function</li><li>Pass the error back to the caller to deal with</li><li>Halt the program</li><li>Throw an exception</li></ul><br><h3>Handling the error within the function</h3><p>If possible, the best strategy is to recover from the error in the same function in which the error occurred, so that the error can be contained and corrected without impacting any code outside the function. There are two options here: retry until successful, or cancel the operation being executed.</p><p>If the error has occurred due to something outside of the program’s control, the program can retry until success is achieved. For example, if the program requires an internet connection, and the user has lost their connection, the program may be able to display a warning and then use a loop to periodically recheck for internet connectivity. Alternatively, if the user has entered invalid input, the program can ask the user to try again, and loop until the user is successful at entering valid input. We’ll show examples of handling invalid input and using loops to retry in the next lesson (<a href="https://www.learncpp.com/cpp-tutorial/stdcin-and-handling-invalid-input/">7.16 -- std::cin and handling invalid input</a>).</p><p>An alternate strategy is just to ignore the error and/or cancel the operation. For example:</p><pre class="language-cpp line-numbers"><code>void printDivision(int x, int y)</code><code>{</code><code>    if (y != 0)</code><code>        std::cout &lt;&lt; static_cast<double>(x) / y;</double></code><code>}</code></pre><p>In the above example, if the user passed in an invalid value for <code>y</code>, we just ignore the request to print the result of the division operation. The primary challenge with doing this is that the caller or user have no way to identify that something went wrong. In such case, printing an error message can be helpful:</p><pre class="language-cpp line-numbers"><code>void printDivision(int x, int y)</code><code>{</code><code>    if (y != 0)</code><code>        std::cout &lt;&lt; static_cast<double>(x) / y;</double></code><code>    else</code><code>        std::cerr &lt;&lt; "Error: Could not divide by zero\n";</code><code>}</code></pre><p>However, if the calling function is expecting the called function to produce a return value or some useful side-effect, then just ignoring the error may not be an option.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We discuss std::cerr in lesson <a href="https://www.learncpp.com/cpp-tutorial/basic-debugging-tactics/">3.4 -- Basic debugging tactics</a>.</p></div><br><h3>Passing errors back to the caller</h3><p>In many cases, the error can’t reasonably be handled in the function that detects the error. For example, consider the following function:</p><pre class="language-cpp line-numbers"><code>double doDivision(int x, int y)</code><code>{</code><code>    return static_cast<double>(x) / y;</double></code><code>}</code></pre><p>If <code>y</code> is <code>0</code>, what should we do? We can’t just skip the program logic, because the function needs to return some value. We shouldn’t ask the user to enter a new value for <code>y</code> because this is a calculation function, and introducing input routines into it may or may not be appropriate for the program calling this function.</p><p>In such cases, the best option can be to pass the error back to the caller in hopes that the caller will be able to deal with it.</p><p>How might we do that?</p><p>If the function has a void return type, it can be changed to return a Boolean that indicates success or failure. For example, instead of:</p><pre class="language-cpp line-numbers"><code>void printDivision(int x, int y)</code><code>{</code><code>    if (y != 0)</code><code>        std::cout &lt;&lt; static_cast<double>(x) / y;</double></code><code>    else</code><code>        std::cerr &lt;&lt; "Error: Could not divide by zero\n";</code><code>}</code></pre><p>We can do this:</p><pre class="language-cpp line-numbers"><code>bool printDivision(int x, int y)</code><code>{</code><code>    if (y == 0)</code><code>    {</code><code>        std::cerr &lt;&lt; "Error: could not divide by zero\n";</code><code>        return false;</code><code>    }</code><code>    </code><code>    std::cout &lt;&lt; static_cast<double>(x) / y;</double></code><code></code><code>    return true;</code><code>}</code></pre><p>That way, the caller can check the return value to see if the function failed for some reason.</p><p>If the function returns a normal value, things are a little more complicated. In some cases, the full range of return values isn’t used. In such cases, we can use a return value that wouldn’t otherwise be possible to occur normally to indicate an error. For example, consider the following function:</p><pre class="language-cpp line-numbers"><code>// The reciprocal of x is 1/x</code><code>double reciprocal(double x)</code><code>{</code><code>    return 1.0 / x;</code><code>}</code></pre><p>The reciprocal of some number <code>x</code> is defined as <code>1/x</code>, and a number multiplied by its reciprocal equals 1.</p><p>However, what happens if the user calls this function as <code>reciprocal(0.0)</code>? We get a <code>divide by zero</code> error and a program crash, so clearly we should protect against this case. But this function must return a double value, so what value should we return? It turns out that this function will never produce <code>0.0</code> as a legitimate result, so we can return <code>0.0</code> to indicate an error case.</p><pre class="language-cpp line-numbers"><code>// The reciprocal of x is 1/x, returns 0.0 if x=0</code><code>double reciprocal(double x)</code><code>{</code><code>    if (x == 0.0)</code><code>       return 0.0;</code><code></code><code>    return 1.0 / x;</code><code>}</code></pre><p>However, if the full range of return values are needed, then using the return value to indicate an error will not be possible (because the caller would not be able to tell whether the return value is a valid value or an error value). In such a case, an <code>out parameter</code> (covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/pass-by-lvalue-reference/">9.5 -- Pass by lvalue reference</a>) might be a viable choice.</p><br><h3>Fatal errors</h3><p>If the error is so bad that the program can not continue to operate properly, this is called a <span class="cpp-definition">non-recoverable</span> error (also called a <span class="cpp-definition">fatal error</span>). In such cases, the best thing to do is terminate the program. If your code is in <code>main()</code> or a function called directly from <code>main()</code>, the best thing to do is let <code>main()</code> return a non-zero status code. However, if you’re deep in some nested subfunction, it may not be convenient or possible to propagate the error all the way back to <code>main()</code>. In such a case, a <code>halt statement</code> (such as <code>std::exit()</code>) can be used.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>double doDivision(int x, int y)</code><code>{</code><code>    if (y == 0)</code><code>    {</code><code>        std::cerr &lt;&lt; "Error: Could not divide by zero\n";</code><code>        std::exit(1);</code><code>    }</code><code>    return static_cast<double>(x) / y;</double></code><code>}</code></pre><br><h3>Exceptions</h3><p>Because returning an error from a function back to the caller is complicated (and the many different ways to do so leads to inconsistency, and inconsistency leads to mistakes), C++ offers an entirely separate way to pass errors back to the caller: <code>exceptions</code>.</p><p>The basic idea is that when an error occurs, an exception is “thrown”. If the current function does not “catch” the error, the caller of the function has a chance to catch the error. If the caller does not catch the error, the caller’s caller has a chance to catch the error. The error progressively moves up the call stack until it is either caught and handled (at which point execution continues normally), or until main() fails to handle the error (at which point the program is terminated with an exception error).</p><p>We cover exception handling in <a href="https://www.learncpp.com#Chapter20">chapter 20</a> of this tutorial series.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.16 — std::cin and handling invalid input</h1></header><div class="entry-content" itemprop="articleBody"><p>Most programs that have a user interface of some kind need to handle user input. In the programs that you have been writing, you have been using std::cin to ask the user to enter text input. Because text input is so free-form (the user can enter anything), it’s very easy for the user to enter input that is not expected.</p><p>As you write programs, you should always consider how users will (unintentionally or otherwise) misuse your programs. A well-written program will anticipate how users will misuse it, and either handle those cases gracefully or prevent them from happening in the first place (if possible). A program that handles error cases well is said to be <strong>robust</strong>.</p><p>In this lesson, we’ll take a look specifically at ways the user can enter invalid text input via std::cin, and show you some different ways to handle those cases.</p><p style="clear:both"></p><p></p><br><h3>std::cin, buffers, and extraction</h3><p>In order to discuss how std::cin and operator&gt;&gt; can fail, it first helps to know a little bit about how they work.</p><p>When we use operator&gt;&gt; to get user input and put it into a variable, this is called an “extraction”. The &gt;&gt; operator is accordingly called the extraction operator when used in this context.</p><p>When the user enters input in response to an extraction operation, that data is placed in a buffer inside of std::cin. A <strong>buffer</strong> (also called a data buffer) is simply a piece of memory set aside for storing data temporarily while it’s moved from one place to another. In this case, the buffer is used to hold user input while it’s waiting to be extracted to variables.</p><p>When the extraction operator is used, the following procedure happens:</p><ul><li>If there is data already in the input buffer, that data is used for extraction.</li><li>If the input buffer contains no data, the user is asked to input data for extraction (this is the case most of the time). When the user hits enter, a ‘\n’ character will be placed in the input buffer.</li><li>operator&gt;&gt; extracts as much data from the input buffer as it can into the variable (ignoring any leading whitespace characters, such as spaces, tabs, or ‘\n’).</li><li>Any data that can not be extracted is left in the input buffer for the next extraction.</li></ul><p>Extraction succeeds if at least one character is extracted from the input buffer. Any unextracted input is left in the input buffer for future extractions. For example:</p><pre class="language-cpp line-numbers"><code>int x{};</code><code>std::cin &gt;&gt; x;</code></pre><p>If the user enters “5a”, 5 will be extracted, converted to an integer, and assigned to variable x. “a\n” will be left in the input buffer for the next extraction.</p><p>Extraction fails if the input data does not match the type of the variable being extracted to. For example:</p><pre class="language-cpp line-numbers"><code>int x{};</code><code>std::cin &gt;&gt; x;</code></pre><p>If the user were to enter ‘b’, extraction would fail because ‘b’ can not be extracted to an integer variable.</p><br><h3>Validating input</h3><p>The process of checking whether user input conforms to what the program is expecting is called <strong>input validation</strong>.</p><p>There are three basic ways to do input validation:</p><ul><li>Inline (as the user types)<ul><li>Prevent the user from typing invalid input in the first place.</li></ul></li><li>Post-entry (after the user types)<ul><li>Let the user enter whatever they want into a string, then validate whether the string is correct, and if so, convert the string to the final variable format.</li><li>Let the user enter whatever they want, let std::cin and operator&gt;&gt; try to extract it, and handle the error cases.</li></ul></li></ul><p>Some graphical user interfaces and advanced text interfaces will let you validate input as the user enters it (character by character). Generally speaking, the programmer provides a validation function that accepts the input the user has entered so far, and returns true if the input is valid, and false otherwise. This function is called every time the user presses a key. If the validation function returns true, the key the user just pressed is accepted. If the validation function returns false, the character the user just input is discarded (and not shown on the screen). Using this method, you can ensure that any input the user enters is guaranteed to be valid, because any invalid keystrokes are discovered and discarded immediately. Unfortunately, std::cin does not support this style of validation.</p><p>Since strings do not have any restrictions on what characters can be entered, extraction is guaranteed to succeed (though remember that std::cin stops extracting at the first non-leading whitespace character). Once a string is entered, the program can then parse the string to see if it is valid or not. However, parsing strings and converting string input to other types (e.g. numbers) can be challenging, so this is only done in rare cases.</p><p>Most often, we let std::cin and the extraction operator do the hard work. Under this method, we let the user enter whatever they want, have std::cin and operator&gt;&gt; try to extract it, and deal with the fallout if it fails. This is the easiest method, and the one we’ll talk more about below.</p><br><h3>A sample program</h3><p>Consider the following calculator program that has no error handling:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code> </code><code>double getDouble()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a double value: ";</code><code>    double x{};</code><code>    std::cin &gt;&gt; x;</code><code>    return x;</code><code>}</code><code> </code><code>char getOperator()</code><code>{</code><code>    std::cout &lt;&lt; "Enter one of the following: +, -, *, or /: ";</code><code>    char op{};</code><code>    std::cin &gt;&gt; op;</code><code>    return op;</code><code>}</code><code> </code><code>void printResult(double x, char operation, double y)</code><code>{</code><code>    switch (operation)</code><code>    {</code><code>    case '+':</code><code>        std::cout &lt;&lt; x &lt;&lt; " + " &lt;&lt; y &lt;&lt; " is " &lt;&lt; x + y &lt;&lt; '\n';</code><code>        break;</code><code>    case '-':</code><code>        std::cout &lt;&lt; x &lt;&lt; " - " &lt;&lt; y &lt;&lt; " is " &lt;&lt; x - y &lt;&lt; '\n';</code><code>        break;</code><code>    case '*':</code><code>        std::cout &lt;&lt; x &lt;&lt; " * " &lt;&lt; y &lt;&lt; " is " &lt;&lt; x * y &lt;&lt; '\n';</code><code>        break;</code><code>    case '/':</code><code>        std::cout &lt;&lt; x &lt;&lt; " / " &lt;&lt; y &lt;&lt; " is " &lt;&lt; x / y &lt;&lt; '\n';</code><code>        break;</code><code>    }</code><code>}</code><code> </code><code>int main()</code><code>{</code><code>    double x{ getDouble() };</code><code>    char operation{ getOperator() };</code><code>    double y{ getDouble() };</code><code> </code><code>    printResult(x, operation, y);</code><code> </code><code>    return 0;</code><code>}</code></pre><p>This simple program asks the user to enter two numbers and a mathematical operator.</p><pre>Enter a double value: 5
Enter one of the following: +, -, *, or /: *
Enter a double value: 7
5 * 7 is 35
</pre><p>Now, consider where invalid user input might break this program.</p><p>First, we ask the user to enter some numbers. What if they enter something other than a number (e.g. ‘q’)? In this case, extraction will fail.</p><p>Second, we ask the user to enter one of four possible symbols. What if they enter a character other than one of the symbols we’re expecting? We’ll be able to extract the input, but we don’t currently handle what happens afterward.</p><p>Third, what if we ask the user to enter a symbol and they enter a string like “*q hello”. Although we can extract the ‘*’ character we need, there’s additional input left in the buffer that could cause problems down the road.</p><br><h3>Types of invalid text input</h3><p>We can generally separate input text errors into four types:</p><ul><li>Input extraction succeeds but the input is meaningless to the program (e.g. entering ‘k’ as your mathematical operator).</li><li>Input extraction succeeds but the user enters additional input (e.g. entering ‘*q hello’ as your mathematical operator).</li><li>Input extraction fails (e.g. trying to enter ‘q’ into a numeric input).</li><li>Input extraction succeeds but the user overflows a numeric value.</li></ul><p>Thus, to make our programs robust, whenever we ask the user for input, we ideally should determine whether each of the above can possibly occur, and if so, write code to handle those cases.</p><p>Let’s dig into each of these cases, and how to handle them using std::cin.</p><br><h3>Error case 1: Extraction succeeds but input is meaningless</h3><p>This is the simplest case. Consider the following execution of the above program:</p><pre>Enter a double value: 5
Enter one of the following: +, -, *, or /: k
Enter a double value: 7
</pre><p>In this case, we asked the user to enter one of four symbols, but they entered ‘k’ instead. ‘k’ is a valid character, so std::cin happily extracts it to variable op, and this gets returned to main. But our program wasn’t expecting this to happen, so it doesn’t properly deal with this case (and thus never outputs anything).</p><p>The solution here is simple: do input validation. This usually consists of 3 steps:</p><ol start="1"><li>Check whether the user’s input was what you were expecting.</li><li>If so, return the value to the caller.</li><li>If not, tell the user something went wrong and have them try again.</li></ol><p>Here’s an updated getOperator() function that does input validation.</p><pre class="language-cpp line-numbers"><code>char getOperator()</code><code>{</code><code>    while (true) // Loop until user enters a valid input</code><code>    {</code><code>        std::cout &lt;&lt; "Enter one of the following: +, -, *, or /: ";</code><code>        char operation{};</code><code>        std::cin &gt;&gt; operation;</code><code></code><code>        // Check whether the user entered meaningful input</code><code>        switch (operation)</code><code>        {</code><code>        case '+':</code><code>        case '-':</code><code>        case '*':</code><code>        case '/':</code><code>            return operation; // return it to the caller</code><code>        default: // otherwise tell the user what went wrong</code><code>            std::cerr &lt;&lt; "Oops, that input is invalid.  Please try again.\n";</code><code>        }</code><code>    } // and try again</code><code>}</code></pre><p>As you can see, we’re using a while loop to continuously loop until the user provides valid input. If they don’t, we ask them to try again until they either give us valid input, shutdown the program, or destroy their computer.</p><br><h3>Error case 2: Extraction succeeds but with extraneous input</h3><p>Consider the following execution of the above program:</p><pre>Enter a double value: 5*7
</pre><p>What do you think happens next?</p><pre>Enter a double value: 5*7
Enter one of the following: +, -, *, or /: Enter a double value: 5 * 7 is 35
</pre><p>The program prints the right answer, but the formatting is all messed up. Let’s take a closer look at why.</p><p>When the user enters “5*7” as input, that input goes into the buffer. Then operator&gt;&gt; extracts the 5 to variable x, leaving “*7\n” in the buffer. Next, the program prints “Enter one of the following: +, -, *, or /:”. However, when the extraction operator was called, it sees “*7\n” waiting in the buffer to be extracted, so it uses that instead of asking the user for more input. Consequently, it extracts the ‘*’ character, leaving “7\n” in the buffer.</p><p>After asking the user to enter another double value, the “7” in the buffer gets extracted without asking the user. Since the user never had an opportunity to enter additional data and hit enter (causing a newline), the output prompts all run together on the same line.</p><p>Although the above program works, the execution is messy. It would be better if any extraneous characters entered were simply ignored. Fortunately, it’s easy to ignore characters:</p><pre class="language-cpp line-numbers"><code>std::cin.ignore(100, '\n');  // clear up to 100 characters out of the buffer, or until a '\n' character is removed</code></pre><p>This call would remove up to 100 characters, but if the user entered more than 100 characters we’ll get messy output again. To ignore all characters up to the next ‘\n’, we can pass <code>std::numeric_limits<std::streamsize>::max()</std::streamsize></code> to <code>std::cin.ignore()</code>. <code>std::numeric_limits<std::streamsize>::max()</std::streamsize></code> returns the largest value that can be stored in a variable of type <code>std::streamsize</code>. Passing this value to <code>std::cin.ignore()</code> causes it to disable the count check.</p><p>To ignore everything up to and including the next ‘\n’ character, we call</p><pre class="language-cpp line-numbers"><code>std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');</std::streamsize></code></pre><p>Because this line is quite long for what it does, it’s handy to wrap it in a function which can be called in place of <code>std::cin.ignore()</code>.</p><pre class="language-cpp line-numbers"><code>#include <limits> // for std::numeric_limits</limits></code><code></code><code>void ignoreLine()</code><code>{</code><code>    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');</std::streamsize></code><code>}</code></pre><p>Since the last character the user entered must be a ‘\n’, we can tell std::cin to ignore buffered characters until it finds a newline character (which is removed as well).</p><p>Let’s update our getDouble() function to ignore any extraneous input:</p><pre class="language-cpp line-numbers"><code>double getDouble()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a double value: ";</code><code>    double x{};</code><code>    std::cin &gt;&gt; x;</code><code>    ignoreLine();</code><code>    return x;</code><code>}</code></pre><p>Now our program will work as expected, even if we enter “5*7” for the first input -- the 5 will be extracted, and the rest of the characters will be removed from the input buffer. Since the input buffer is now empty, the user will be properly asked for input the next time an extraction operation is performed!</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>Some lessons still pass 32767 to <code>std::cin.ignore()</code>. This is a magic number with no special meaning to <code>std::cin.ignore()</code> and should be avoided. If you see such an occurrence, feel free to point it out.</p></div><br><h3>Error case 3: Extraction fails</h3><p>Now consider the following execution of our updated calculator program:</p><pre>Enter a double value: a
</pre><p>You shouldn’t be surprised that the program doesn’t perform as expected, but how it fails is interesting:</p><pre>Enter a double value: a
Enter one of the following: +, -, *, or /: Oops, that input is invalid.  Please try again.
Enter one of the following: +, -, *, or /: Oops, that input is invalid.  Please try again.
Enter one of the following: +, -, *, or /: Oops, that input is invalid.  Please try again.
</pre><p>and that last line keeps printing until the program is closed.</p><p>This looks pretty similar to the extraneous input case, but it’s a little different. Let’s take a closer look.</p><p>When the user enters ‘a’, that character is placed in the buffer. Then operator&gt;&gt; tries to extract ‘a’ to variable x, which is of type double. Since ‘a’ can’t be converted to a double, operator&gt;&gt; can’t do the extraction. Two things happen at this point: ‘a’ is left in the buffer, and std::cin goes into “failure mode”.</p><p>Once in “failure mode”, future requests for input extraction will silently fail. Thus in our calculator program, the output prompts still print, but any requests for further extraction are ignored. This means that instead waiting for us to enter an operation, the input prompt is skipped, and we get stuck in an infinite loop because there is no way to reach one of the valid cases.</p><p>Fortunately, we can detect whether an extraction has failed and fix it:</p><pre class="language-cpp line-numbers"><code>if (std::cin.fail()) // has a previous extraction failed?</code><code>{</code><code>    // yep, so let's handle the failure</code><code>    std::cin.clear(); // put us back in 'normal' operation mode</code><code>    ignoreLine(); // and remove the bad input</code><code>}</code></pre><p>Because <code>std::cin</code> has a Boolean conversion indicating whether the last input succeeded, it’s more idiomatic to write the above as following:</p><pre class="language-cpp line-numbers"><code>if (!std::cin) // has a previous extraction failed?</code><code>{</code><code>    // yep, so let's handle the failure</code><code>    std::cin.clear(); // put us back in 'normal' operation mode</code><code>    ignoreLine(); // and remove the bad input</code><code>}</code></pre><p>That’s it!</p><p>Let’s integrate that into our getDouble() function:</p><pre class="language-cpp line-numbers"><code>double getDouble()</code><code>{</code><code>    while (true) // Loop until user enters a valid input</code><code>    {</code><code>        std::cout &lt;&lt; "Enter a double value: ";</code><code>        double x{};</code><code>        std::cin &gt;&gt; x;</code><code></code><code>        if (!std::cin) // has a previous extraction failed?</code><code>        {</code><code>            // yep, so let's handle the failure</code><code>            std::cin.clear(); // put us back in 'normal' operation mode</code><code>            ignoreLine(); // and remove the bad input</code><code>        }</code><code>        else // else our extraction succeeded</code><code>        {</code><code>            ignoreLine();</code><code>            return x; // so return the value we extracted</code><code>        }</code><code>    }</code><code>}</code></pre><p>A failed extraction due to invalid input will cause the variable to be zero-initialized. Zero initialization means the variable is set to 0, 0.0, “”, or whatever value 0 converts to for that type.</p><br><h3>Error case 4: Extraction succeeds but the user overflows a numeric value</h3><p>Consider the following simple example:</p><pre class="language-cpp line-numbers"><code>#include <cstdint></cstdint></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::int16_t x{}; // x is 16 bits, holds from -32768 to 32767</code><code>    std::cout &lt;&lt; "Enter a number between -32768 and 32767: ";</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    std::int16_t y{}; // y is 16 bits, holds from -32768 to 32767</code><code>    std::cout &lt;&lt; "Enter another number between -32768 and 32767: ";</code><code>    std::cin &gt;&gt; y;</code><code></code><code>    std::cout &lt;&lt; "The sum is: " &lt;&lt; x + y &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>What happens if the user enters a number that is too large (e.g. 40000)?</p><pre>Enter a number between -32768 and 32767: 40000
Enter another number between -32768 and 32767: The sum is: 32767
</pre><p>In the above case, std::cin goes immediately into “failure mode”, but also assigns the closest in-range value to the variable. Consequently, x is left with the assigned value of 32767. Additional inputs are skipped, leaving y with the initialized value of 0. We can handle this kind of error in the same way as a failed extraction.</p><p>A failed extraction due to invalid input will cause the variable to be zero-initialized. Zero initialization means the variable is set to 0, 0.0, “”, or whatever value 0 converts to for that type.</p><br><h3>Putting it all together</h3><p>Here’s our example calculator, updated with a few additional bits of error checking:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <limits></limits></code><code></code><code>void ignoreLine()</code><code>{</code><code>    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');</std::streamsize></code><code>}</code><code></code><code>double getDouble()</code><code>{</code><code>    while (true) // Loop until user enters a valid input</code><code>    {</code><code>        std::cout &lt;&lt; "Enter a double value: ";</code><code>        double x{};</code><code>        std::cin &gt;&gt; x;</code><code></code><code>        // Check for failed extraction</code><code>        if (!std::cin) // has a previous extraction failed?</code><code>        {</code><code>            // yep, so let's handle the failure</code><code>            std::cin.clear(); // put us back in 'normal' operation mode</code><code>            ignoreLine(); // and remove the bad input</code><code>            std::cerr &lt;&lt; "Oops, that input is invalid.  Please try again.\n";</code><code>        }</code><code>        else</code><code>        {</code><code>            ignoreLine(); // remove any extraneous input</code><code>            return x;</code><code>        }</code><code>    }</code><code>}</code><code></code><code>char getOperator()</code><code>{</code><code>    while (true) // Loop until user enters a valid input</code><code>    {</code><code>        std::cout &lt;&lt; "Enter one of the following: +, -, *, or /: ";</code><code>        char operation{};</code><code>        std::cin &gt;&gt; operation;</code><code>        ignoreLine(); // // remove any extraneous input</code><code></code><code>        // Check whether the user entered meaningful input</code><code>        switch (operation)</code><code>        {</code><code>        case '+':</code><code>        case '-':</code><code>        case '*':</code><code>        case '/':</code><code>            return operation; // return it to the caller</code><code>        default: // otherwise tell the user what went wrong</code><code>            std::cerr &lt;&lt; "Oops, that input is invalid.  Please try again.\n";</code><code>        }</code><code>    } // and try again</code><code>}</code><code> </code><code>void printResult(double x, char operation, double y)</code><code>{</code><code>    switch (operation)</code><code>    {</code><code>    case '+':</code><code>        std::cout &lt;&lt; x &lt;&lt; " + " &lt;&lt; y &lt;&lt; " is " &lt;&lt; x + y &lt;&lt; '\n';</code><code>        break;</code><code>    case '-':</code><code>        std::cout &lt;&lt; x &lt;&lt; " - " &lt;&lt; y &lt;&lt; " is " &lt;&lt; x - y &lt;&lt; '\n';</code><code>        break;</code><code>    case '*':</code><code>        std::cout &lt;&lt; x &lt;&lt; " * " &lt;&lt; y &lt;&lt; " is " &lt;&lt; x * y &lt;&lt; '\n';</code><code>        break;</code><code>    case '/':</code><code>        std::cout &lt;&lt; x &lt;&lt; " / " &lt;&lt; y &lt;&lt; " is " &lt;&lt; x / y &lt;&lt; '\n';</code><code>        break;</code><code>    default: // Being robust means handling unexpected parameters as well, even though getOperator() guarantees operation is valid in this particular program</code><code>        std::cerr &lt;&lt; "Something went wrong: printResult() got an invalid operator.\n";</code><code>    }</code><code>}</code><code> </code><code>int main()</code><code>{</code><code>    double x{ getDouble() };</code><code>    char operation{ getOperator() };</code><code>    double y{ getDouble() };</code><code> </code><code>    printResult(x, operation, y);</code><code> </code><code>    return 0;</code><code>}</code></pre><br><h3>Conclusion</h3><p>As you write your programs, consider how users will misuse your program, especially around text input. For each point of text input, consider:</p><ul><li>Could extraction fail?</li><li>Could the user enter more input than expected?</li><li>Could the user enter meaningless input?</li><li>Could the user overflow an input?</li></ul><p>You can use if statements and boolean logic to test whether input is expected and meaningful.</p><p>The following code will clear any extraneous input:</p><pre class="language-cpp line-numbers"><code>std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');</std::streamsize></code></pre><p>The following code will test for and fix failed extractions or overflow:</p><pre class="language-cpp line-numbers"><code>if (!std::cin) // has a previous extraction failed or overflowed?</code><code>{</code><code>    // yep, so let's handle the failure</code><code>    std::cin.clear(); // put us back in 'normal' operation mode</code><code>    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // and remove the bad input</std::streamsize></code><code>}</code></pre><p>Finally, use loops to ask the user to re-enter input if the original input was invalid.</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>Input validation is important and useful, but it also tends to make examples more complicated and harder to follow. Accordingly, in future lessons, we will generally not do any kind of input validation unless it’s relevant to something we’re trying to teach.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.17 — Assert and static_assert</h1></header><div class="entry-content" itemprop="articleBody"><p>In a function that takes parameters, the caller may be able to pass in arguments that are syntactically valid but semantically meaningless. For example, in the previous lesson (<a href="https://www.learncpp.com/cpp-tutorial/detecting-and-handling-errors/">7.15 -- Detecting and handling errors</a>), we showed the following sample function:</p><pre class="language-cpp line-numbers"><code>void printDivision(int x, int y)</code><code>{</code><code>    if (y != 0)</code><code>        std::cout &lt;&lt; static_cast<double>(x) / y;</double></code><code>    else</code><code>        std::cerr &lt;&lt; "Error: Could not divide by zero\n";</code><code>}</code></pre><p>This function does an explicit check to see if <code>y</code> is <code>0</code>, since dividing by zero is a semantic error and will cause the program to crash if executed.</p><p>In the prior lesson, we discussed a couple of ways to deal with such problems, including halting the program, or skipping the offending statements.</p><p>Both of those options are problematic though. If a program skips statements due to an error, then it is essentially failing silently. Especially while we are writing and debugging programs, silent failures are bad, because they obscure real problems. Even if we print an error message, that error message may be lost among the other program output, and it may be non-obvious where the error message is being generated or how the conditions that triggered the error message occurred. Some functions may be called tens or hundreds of times, and if only one of those cases is generating a problem, it can be hard to know which one.</p><p>If the program terminates (via <code>std::exit</code>) then we will have lost our call stack and any debugging information that might help us isolate the problem. <code>std::abort</code> is a better option for such cases, as typically the developer will be given the option to start debugging at the point where the program aborted.</p><br><h3>Preconditions, invariants, and postconditions</h3><p>In programming, a <span class="cpp-definition">precondition</span> is any condition that must always be true prior to the execution of component of code. Our check of <code>y</code> is a precondition that ensures <code>y</code> has a valid value before the function continues.</p><p>It’s more common for functions with preconditions to be written like this:</p><pre class="language-cpp line-numbers"><code>void printDivision(int x, int y)</code><code>{</code><code>    if (y == 0)</code><code>    {</code><code>        std::cerr &lt;&lt; "Error: Could not divide by zero\n";</code><code>        return;</code><code>    }</code><code></code><code>    std::cout &lt;&lt; static_cast<double>(x) / y;</double></code><code>}</code></pre><p>An <span class="cpp-definition">invariant</span> is a condition that must be true while some component is executing.</p><p>Similarly, a <span class="cpp-definition">postcondition</span> is something that must be true after the execution of some component of code. Our function doesn’t have any postconditions.</p><br><h3>Assertions</h3><p>Using a conditional statement to detect an invalid parameter (or to validate some other kind of assumption), along with printing an error message and terminating the program, is such a common response to problems that C++ provides a shortcut method for doing this.</p><p>An <span class="cpp-definition">assertion</span> is an expression that will be true unless there is a bug in the program. If the expression evaluates to <code>true</code>, the assertion statement does nothing. If the conditional expression evaluates to <code>false</code>, an error message is displayed and the program is terminated (via <code>std::abort</code>). This error message typically contains the expression that failed as text, along with the name of the code file and the line number of the assertion. This makes it very easy to tell not only what the problem was, but where in the code the problem occurred. This can help with debugging efforts immensely.</p><p>In C++, runtime assertions are implemented via the <span class="cpp-definition">assert</span> preprocessor macro, which lives in the &lt;cassert&gt; header.</p><pre class="language-cpp line-numbers"><code>#include <cassert> // for assert()</cassert></code><code>#include <cmath> // for std::sqrt</cmath></code><code>#include <iostream></iostream></code><code></code><code>double calculateTimeUntilObjectHitsGround(double initialHeight, double gravity)</code><code>{</code><code>  assert(gravity &gt; 0.0); // The object won't reach the ground unless there is positive gravity.</code><code> </code><code>  if (initialHeight &lt;= 0.0)</code><code>  {</code><code>    // The object is already on the ground. Or buried.</code><code>    return 0.0;</code><code>  }</code><code> </code><code>  return std::sqrt((2.0 * initialHeight) / gravity);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  std::cout &lt;&lt; "Took " &lt;&lt; calculateTimeUntilObjectHitsGround(100.0, -9.8) &lt;&lt; " second(s)\n";</code><code></code><code>  return 0;</code><code>}</code></pre><p>When the program calls <code>calculateTimeUntilObjectHitsGround(100.0, -9.8)</code>, <code>assert(gravity &gt; 0.0)</code> will evaluate to <code>false</code>, which will trigger the assert. That will print a message similar to this:</p><pre>dropsimulator: src/main.cpp:6: double calculateTimeUntilObjectHitsGround(double, double): Assertion 'gravity &gt; 0.0' failed.
</pre><p>The actual message varies depending on which compiler you use.</p><p>Although asserts are most often used to validate function parameters, they can be used anywhere you would like to validate that something is true.</p><p>Although we told you previously to avoid preprocessor macros, asserts are one of the few preprocessor macros that are considered acceptable to use. We encourage you to use assert statements liberally throughout your code.</p><br><h3>Making your assert statements more descriptive</h3><p>Sometimes assert expressions aren’t very descriptive. Consider the following statement:</p><pre class="language-cpp line-numbers"><code>assert(found);</code></pre><p>If this assert is triggered, the assert will say:</p><pre>Assertion failed: found, file C:\\VCProjects\\Test.cpp, line 34
</pre><p>What does this even mean? Clearly <code>found</code> was <code>false</code> (since the assert triggered), but what wasn’t found? You’d have to go look at the code to determine that.</p><p>Fortunately, there’s a little trick you can use to make your assert statements more descriptive. Simply add a string literal joined by a logical AND:</p><pre class="language-cpp line-numbers"><code>assert(found &amp;&amp; "Car could not be found in database");</code></pre><p>Here’s why this works: A string literal always evaluates to Boolean <code>true</code>. So if <code>found</code> is <code>false</code>, <code>false &amp;&amp; true</code> is <code>false</code>. If <code>found</code> is <code>true</code>, <code>true &amp;&amp; true</code> is <code>true</code>. Thus, logical AND-ing a string literal doesn’t impact the evaluation of the assert.</p><p>However, when the assert triggers, the string literal will be included in the assert message:</p><pre>Assertion failed: found &amp;&amp; "Car could not be found in database", file C:\\VCProjects\\Test.cpp, line 34
</pre><p>That gives you some additional context as to what went wrong.</p><br><h3>Asserts vs error handling</h3><p>Assertions and error handling are similar enough that their purposes can be confused, so let’s clarify:</p><p>The goal of an assertion is to catch programming errors by documenting something that should never happen. If that thing does happen, then the programmer made an error somewhere, and that error can be identified and fixed. Assertions do not allow recovery from errors (after all, if something should never happen, there’s no need to recover from it), and the program will not produce a friendly error message.</p><p>On the other hand, error handling is designed to gracefully handle cases that could happen (however rarely) in release configurations. These may or may not be recoverable, but one should always assume a user of the program may encounter them.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use assertions to document cases that should be logically impossible.</p></div><p>Assertions are also sometimes used to document cases that were not implemented because they were not needed at the time the programmer wrote the code:</p><pre class="language-cpp line-numbers"><code>// Assert with a message, covered in the next section</code><code>assert(moved &amp;&amp; "Need to handle case where student was just moved to another classroom");</code></pre><p>That way, if a future user of the code does encounter a situation where this case is needed, the code will fail with a useful error message, and the programmer can then determine how to implement that case.</p><br><h3>NDEBUG</h3><p>The <code>assert</code> macro comes with a small performance cost that is incurred each time the assert condition is checked. Furthermore, asserts should (ideally) never be encountered in production code (because your code should already be thoroughly tested). Consequently, many developers prefer that asserts are only active in debug builds. C++ comes with a way to turn off asserts in production code. If the macro <code>NDEBUG</code> is defined, the assert macro gets disabled.</p><p>Some IDEs set <code>NDEBUG</code> by default as part of the project settings for release configurations. For example, in Visual Studio, the following preprocessor definitions are set at the project level: <code>WIN32;NDEBUG;_CONSOLE</code>. If you’re using Visual Studio and want your asserts to trigger in release builds, you’ll need to remove <code>NDEBUG</code> from this setting.</p><p>If you’re using an IDE or build system that doesn’t automatically define <code>NDEBUG</code> in release configuration, you will need to add it in the project or compilation settings manually.</p><br><h3>Some assert limitations and warnings</h3><p>There are a few pitfalls and limitations to asserts. First, the assert itself can have a bug. If this happens, the assert will either report an error where none exists, or fail to report a bug where one does exist.</p><p>Second, your asserts should have no side effects -- that is, the program should run the same with and without the assert. Otherwise, what you are testing in a debug configuration will not be the same as in a release configuration (assuming you ship with NDEBUG).</p><p>Also note that the <code>abort()</code> function terminates the program immediately, without a chance to do any further cleanup (e.g. close a file or database). Because of this, asserts should be used only in cases where corruption isn’t likely to occur if the program terminates unexpectedly.</p><br><h3>static_assert</h3><p>C++ also has another type of assert called <code>static_assert</code>. A <span class="cpp-definition">static_assert</span> is an assertion that is checked at compile-time rather than at runtime, with a failing <code>static_assert</code> causing a compile error. Unlike assert, which is declared in the &lt;cassert&gt; header, static_assert is a keyword, so no header needs to be included to use it.</p><p>A <code>static_assert</code> takes the following form:</p><pre>static_assert(condition, diagnostic_message)
</pre><p>If the condition is not true, the diagnostic message is printed. Here’s an example of using static_assert to ensure types have a certain size:</p><pre class="language-cpp line-numbers"><code>static_assert(sizeof(long) == 8, "long must be 8 bytes");</code><code>static_assert(sizeof(int) == 4, "int must be 4 bytes");</code><code></code><code>int main()</code><code>{</code><code>	return 0;</code><code>} </code></pre><p>On the author’s machine, when compiled, the compiler errors:</p><pre>1&gt;c:\consoleapplication1\main.cpp(19): error C2338: long must be 8 bytes
</pre><p>Because <code>static_assert</code> is evaluated by the compiler, the condition must be able to be evaluated at compile time. Also, unlike normal <code>assert</code> (which is evaluated at runtime), <code>static_assert</code> can be placed anywhere in the code file (even in the global namespace).</p><p>Prior to C++17, the diagnostic message must be supplied as the second parameter. Since C++17, providing a diagnostic message is optional.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.18 — Introduction to random number generation</h1></header><div class="entry-content" itemprop="articleBody"><p>The ability to generate random numbers can be useful in certain kinds of programs, particularly in games, statistical modelling programs, and cryptographic applications that need to encrypt and decrypt things. Take games for example -- without random events, monsters would always attack you the same way, you’d always find the same treasure, the dungeon layout would never change, etc… and that would not make for a very good game.</p><p>In real life, we often produce randomization by doing things like flipping a coin, rolling a dice, or shuffling a deck of cards. These events aren’t actually random, but involve so many physical variables (e.g. gravity, friction, air resistance, momentum, etc…) that they become almost impossible to predict or control, and (unless you’re a magician) produce results that are for all intents and purposes random.</p><p>However, computers aren’t designed to take advantage of physical variables -- your computer can’t toss a coin, throw a dice, or shuffle real cards. Modern computers live in a controlled electrical world where everything is binary (0 or 1) and there is no in-between. By their very nature, computers are designed to produce results that are as predictable as possible. When you tell the computer to calculate 2 + 2, you <em>always</em> want the answer to be 4. Not 3 or 5 on occasion.</p><p>Consequently, computers are generally incapable of generating truly random numbers (at least through software). Instead, modern programs typically <em>simulate</em> randomness using an algorithm.</p><p>In this lesson, we’ll cover a lot of the theory behind how random numbers are generated in programs, and introduce some terminology we’ll use in future lessons.</p><br><h3>Algorithms and state</h3><p>First, let’s take a detour through the concepts of algorithms and states.</p><p>An <span class="cpp-definition">algorithm</span> is a finite sequence of instructions that can be followed to solve some problem or produce some useful result.</p><p>For example, let’s say your boss gives you a small text file containing a bunch of unsorted names (one per line), and asks you to sort the list. Since the list is small, and you don’t expect to do this often, you decide to sort it by hand. There are multiple ways to sort a list, but you might do something like this:</p><ul><li>Create a new empty list to hold the sorted results</li><li>Scan the list of unsorted names to find the name that comes first alphabetically</li><li>Cut that name out of the unsorted list and paste it at the bottom of the sorted list</li><li>Repeat the previous two steps until there are no more names on the unsorted list</li></ul><p>The above set of steps describes a sorting algorithm (using natural language). By nature, algorithms are reusable -- if your boss asks you to sort another list tomorrow, you can just apply the same algorithm to the new list.</p><p>Because computers can execute instructions and manipulate data much more quickly than we can, algorithms are often written using programming languages, allowing us to automate tasks. In C++, algorithms are typically implemented as reusable functions.</p><p>Here’s a simple algorithm for generating a sequence of numbers where each successive number is incremented by 1:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int plusOne()</code><code>{</code><code>    static int s_state { 3 }; // only initialized the first time this function is called</code><code></code><code>    // Generate the next number</code><code></code><code>    ++s_state;      // first we modify the state</code><code>    return s_state; // then we use the new state to generate the next number in the sequence</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; plusOne() &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; plusOne() &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; plusOne() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>4
5
6
</pre><p>This algorithm is pretty simple. The first time we call <code>plusOne()</code>, <code>s_state</code> is initialized to value <code>3</code>. Then the next number in the sequence is generated and returned.</p><p>An algorithm is considered to be <span class="cpp-definition">stateful</span> if it retains some information across calls. Conversely, a <span class="cpp-definition">stateless</span> algorithm does not store any information (and must be given all the information it needs to work with when it is called). Our <code>plusOne()</code> function is stateful, in that it uses the static variable <code>s_state</code> to store the last number that was generated. When applied to algorithms, the term <span class="cpp-definition">state</span> refers to the current values held in stateful variables.</p><p>To generate the next number in the sequence, our algorithm uses a two step process:</p><ul><li>First, the current state (initialized from the start value, or preserved from the prior call) is modified to produce a new state.</li><li>Then, the next number in the sequence is generated from the new state.</li></ul><p>Our algorithm is considered <span class="cpp-definition">deterministic</span>, meaning that for a given input (the value provided for <code>start</code>), it will always produce the same output sequence.</p><br><h3>Pseudo-random number generators (PRNGs)</h3><p>To simulate randomness, programs typically use a pseudo-random number generator. A <span class="cpp-definition">pseudo-random number generator (PRNG)</span> is an algorithm that generates a sequence of numbers whose properties simulate a sequence of random numbers.</p><p>It’s easy to write a basic PRNG algorithm. Here’s a short PRNG example that generates 100 16-bit pseudo-random numbers:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// For illustrative purposes only, don't use this</code><code>unsigned int LCG16() // our PRNG</code><code>{</code><code>    static unsigned int s_state{ 5323 };</code><code></code><code>    // Generate the next number</code><code></code><code>    // Due to our use of large constants and overflow, it would be</code><code>    // hard for someone to casually predict what the next number is</code><code>    // going to be from the previous one.</code><code>    s_state = 8253729 * s_state + 2396403; // first we modify the state</code><code></code><code>    return s_state % 32768; // then we use the new state to generate the next number in the sequence</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    // Print 100 random numbers</code><code>    for (int count{ 1 }; count &lt;= 100; ++count)</code><code>    {</code><code>        std::cout &lt;&lt; LCG16() &lt;&lt; '\t';</code><code></code><code>        // If we've printed 10 numbers, start a new row</code><code>        if (count % 10 == 0)</code><code>            std::cout &lt;&lt; '\n';</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>The result of this program is:</p><pre>23070   27857   22756   10839   27946   11613   30448   21987   22070   1001
27388   5999    5442    28789   13576   28411   10830   29441   21780   23687
5466    2957    19232   24595   22118   14873   5932    31135   28018   32421
14648   10539   23166   22833   12612   28343   7562    18877   32592   19011
13974   20553   9052    15311   9634    27861   7528    17243   27310   8033
28020   24807   1466    26605   4992    5235    30406   18041   3980    24063
15826   15109   24984   15755   23262   17809   2468    13079   19946   26141
1968    16035   5878    7337    23484   24623   13826   26933   1480    6075
11022   19393   1492    25927   30234   17485   23520   18643   5926    21209
2028    16991   3634    30565   2552    20971   23358   12785   25092   30583
</pre><p>Each number appears to be pretty random with respect to the previous one.</p><p>Notice how similar <code>LCG16()</code> is to our <code>plusOne()</code> example above! We can pass <code>LCG16()</code> an initial value that is used to initialize the state. Then to produce the next number in the output sequence, the current state is modified (by applying some mathematical operations) to produce a new state, and the next number in the sequence is generated from that new state.</p><p>As it turns out, this particular algorithm isn’t very good as a random number generator. But most PRNGs work similarly to <code>LCG16()</code> -- they just typically use more state variables and more complex mathematical operations in order to generate better quality results.</p><br><h3>Seeding a PRNG</h3><p>The sequence of “random numbers” generated by a PRNG is not random at all. Just like our <code>plusOne()</code> function, <code>LCG16()</code> is also deterministic. Once the state has been initialized, <code>LCG16()</code> (and all other PRNGs) will generate the same output sequence.</p><p>When a PRNG is instantiated, an initial value (or set of values) called a <span class="cpp-definition">random seed</span> (or <span class="cpp-definition">seed</span> for short) can be provided to initialize the state of the PRNG. When a PRNG has been initialized with a seed, we say it has been <span class="cpp-definition">seeded</span>.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>All of the values that a PRNG will produce are deterministically calculated from the seed value(s).</p></div><p>Most PRNGs that produce quality results use at least 16 bytes of state, if not significantly more. However, the size of the seed value can be smaller than the size of the state of the PRNG. When this happens, we say the PRNG has been <span class="cpp-definition">underseeded</span>.</p><p>Ideally, every bit in the state is initialized from a seed of equal size, and every bit in the seed has been independently determined somehow. However, if a PRNG is underseeded, some number of bits in the state will need to be initialized from the same bits in the seed. If a PRNG is significantly underseeded (meaning the size of the seed is much smaller than the size of the state), the quality of the random results the PRNG produces can be impacted.</p><br><h3>What makes a good PRNG? (optional reading)</h3><p>In order to be a good PRNG, the PRNG needs to exhibit a number of properties:</p><ul><li>The PRNG should generate each number with approximately the same probability.</li></ul><p>This is called distribution uniformity. If some numbers are generated more often than others, the result of the program that uses the PRNG will be biased! To check distribution uniformity, we can use a histogram. A histogram is a graph that tracks how many times each number has been generated. Since our histograms are text-based, we’ll use a * symbol to represent each time a given number was generated.</p><p>Consider a PRNG that generates numbers between 1 and 6. If we generate 36 numbers, a PRNG with distribution uniformity should generate a histogram that looks something like this:</p><pre>1|******
2|******
3|******
4|******
5|******
6|******
</pre><p>A PRNG that is biased in some way will generate a histogram that is uneven, like this:</p><pre>1|***
2|******
3|******
4|******
5|******
6|*********
</pre><p>or this:</p><pre>1|****
2|********
3|******
4|********
5|******
6|****
</pre><p>Let’s say you’re trying to write a random item generator for a game. When a monster is killed, your code generates a random number between 1 and 6, and if the result is a 6, the monster will drop a rare item instead of a common one. You would expect a 1 in 6 chance of this happening. But if the underlying PRNG is not uniform, and generates a lot more 6s than it should (like the second histogram above), your players will end up getting more rare items than you’d intended, possibly trivializing the difficulty of your game, or messing up your in-game economy.</p><p>Finding PRNG algorithms that produce uniform results is difficult.</p><ul><li>The method by which the next number in the sequence is generated shouldn’t be predictable.</li></ul><p>For example, consider the following PRNG algorithm: <code>return ++num</code>. This PRNG is perfectly uniform, but it is also completely predictable -- and not very useful as a sequence of random numbers!</p><p>Even sequences of numbers that seem random to the eye (such as the output of <code>LCG16()</code> above) may be trivially predictable by someone who is motivated. By examining just a few numbers generated from the <code>LCG16()</code> function above, it is possible to determine which constants are used (<code>8253729</code> and <code>2396403</code>) to modify the state. Once that is known, it becomes trivial to calculate all of the future numbers that will be generated from this PRNG.</p><p>Now, imagine you’re running a betting website where users can bet $100. Your website then generates a random number between 0 and 32767. If the number is greater than 20000, the customer wins and you pay them double. Otherwise, they lose. Since the customer wins only 12767/32767 (39%) of the time, your website should make tons of money, right? However, if customers are able to determine which numbers will be generated next, then they can strategically place bets so they always (or usually) win. Congrats, now you get to file for bankruptcy!</p><ul><li>The PRNG should have a good dimensional distribution of numbers.</li></ul><p>This means the PRNG should return numbers across the entire range of possible results at random. For example, the PRNG should generate low numbers, middle numbers, high numbers, even numbers, and odd numbers seemingly at random.</p><p>A PRNG that returned all low numbers, then all high numbers may be uniform and non-predictable, but it’s still going to lead to biased results, particularly if the number of random numbers you actually use is small.</p><ul><li>The PRNG should have a high period for all seeds</li></ul><p>All PRNGs are periodic, which means that at some point the sequence of numbers generated will begin to repeat itself. The length of the sequence before a PRNG begins to repeat itself is known as the <span class="cpp-definition">period</span>.</p><p>For example, here are the first 100 numbers generated from a PRNG with poor periodicity:</p><pre>112	9	130	97	64	31	152	119	86	53	
20	141	108	75	42	9	130	97	64	31	
152	119	86	53	20	141	108	75	42	9	
130	97	64	31	152	119	86	53	20	141	
108	75	42	9	130	97	64	31	152	119	
86	53	20	141	108	75	42	9	130	97	
64	31	152	119	86	53	20	141	108	75	
42	9	130	97	64	31	152	119	86	53	
20	141	108	75	42	9	130	97	64	31	
152	119	86	53	20	141	108	75	42	9
</pre><p>You will note that it generated 9 as the 2nd number, again as the 16th number, and then every 14 numbers after that. This PRNG is stuck generating the following sequence repeatedly: 9-130-97-64-31-152-119-86-53-20-141-108-75-42-(repeat).</p><p>This happens because PRNGs are deterministic. Once the state of a PRNG is identical to a prior state, the PRNG will start producing the same sequence of outputs it has produced before -- resulting in a loop.</p><p>A good PRNG should have a long period for <em>all</em> seed numbers. Designing an algorithm that meets this property can be extremely difficult -- many PRNGs have long periods only for some seeds and not others. If the user happens to pick a seed that results in a state with a short period, then the PRNG won’t do a good job if many random numbers are needed.</p><ul><li>The PRNG should be efficient</li></ul><p>Most PRNGs have a state size of less than 4096 bytes, so total memory usage typically isn’t a concern. However, the larger the internal state, the more likely the PRNG is to be underseeded, and the slower the initial seeding will be (since there’s more state to initialize).</p><p>Second, to generate the next number in sequence, a PRNG has to mix up its internal state by applying various mathematical operations. How much time this takes can vary significantly by PRNG and also by architecture (some PRNGs perform better on certain architectures than others). This doesn’t matter if you only generate random numbers periodically, but can have a huge impact if you need lots of randomness.</p><br><h3>There are many different kinds of PRNG algorithms</h3><p>Over the years, many different kinds of PRNG algorithms have been developed (Wikipedia has a good list <a href="https://en.wikipedia.org/wiki/List_of_random_number_generators">here</a>). Every PRNG algorithm has strengths and weaknesses that might make it more or less suitable for a particular applications, so selecting the right algorithm for your application is important.</p><p>Many PRNGs are now considered relatively poor by modern standards -- and there’s no reason to use a PRNG that doesn’t perform well when it’s just as easy to use one that does.</p><br><h3>Randomization in C++ </h3><p>The randomization capabilities in C++ are accessible via the <code><random></random></code> header of the standard library. Within the random library, there are 6 PRNG families available for use (as of C++20):</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Type name</th><th>Family</th><th>Period</th><th>State size*</th><th>Performance</th><th>Quality</th><th>Should I use this?</th></tr><tr><td>minstd_rand<br>minstd_rand0</td><td>Linear congruential generator</td><td>2^31</td><td>4 bytes</td><td>Bad</td><td>Awful</td><td>No</td></tr><tr><td>mt19937<br>mt19937_64</td><td>Mersenne twister</td><td>2^19937</td><td>2500 bytes</td><td>Decent</td><td>Decent</td><td>Probably (see next section)</td></tr><tr><td>ranlux24<br>ranlux48</td><td>Subtract and carry</td><td>10^171</td><td>96 bytes</td><td>Awful</td><td>Good</td><td>No</td></tr><tr><td>knuth_b</td><td>Shuffled linear congruential generator</td><td>2^31</td><td>1028 bytes</td><td>Awful</td><td>Bad</td><td>No</td></tr><tr><td>default_random_engine</td><td>Any of above (implementation defined)</td><td>Varies</td><td>Varies</td><td>?</td><td>?</td><td>No<sup>2</sup></td></tr><tr><td>rand()</td><td>Linear congruential generator</td><td>2^31</td><td>4 bytes</td><td>Bad</td><td>Awful</td><td>No<sup>no</sup></td></tr></tbody></table></div><br>There is zero reason to use <code>knuth_b</code>, <code>default_random_engine</code>, or <code>rand()</code> (which is a random number generator provided for compatibility with C).<p>As of C++20, the Mersenne Twister algorithm is the only PRNG that ships with C++ that has both decent performance and quality.</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>A test called <a href="http://pracrand.sourceforge.net/">PracRand</a> is often used to assess the performance and quality of PRNGs (to determine whether they have different kinds of biases). You may also see references to SmallCrush, Crush or BigCrush -- these are other tests that are sometimes used for the same purpose.</p><p>If you want to see what the output of Pracrand looks like, <a href="https://arvid.io/2018/06/30/on-cxx-random-number-generator-quality/">this website</a> has output for all of the PRNGs that C++ supports as of C++20.</p></div><br><h3>So we should use Mersenne Twister, right?</h3><p>Probably. For most applications, Mersenne Twister is fine, both in terms of performance and quality.</p><p>However, it’s worth noting that by modern PRNG standards, Mersenne Twister is <a href="https://en.wikipedia.org/wiki/Mersenne_Twister#Disadvantages">a bit outdated</a>. The biggest issue with Mersenne Twister is that its results can be predicted after seeing 624 generated numbers, making it non-suitable for any application that requires non-predictability.</p><p>If you are developing an application that requires the highest quality random results (e.g. a statistical simulation), the fastest results, or one where non-predictability is important (e.g. cryptography), you’ll need to use a 3rd party library.</p><p>Popular choices as of the time of writing:</p><ul><li>The <a href="https://prng.di.unimi.it/">Xoshiro family</a> and <a href="https://github.com/wangyi-fudan/wyhash">Wyrand</a> for non-cryptographic PRNGs.</li><li>The <a href="https://cr.yp.to/chacha.html">Chacha family</a> for cryptographic (non-predictable) PRNGs.</li></ul><p>Okay, now that your eyes are probably bleeding, that’s enough theory. Let’s discuss how to actually generate random numbers with Mersenne Twister in C++.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.19 — Generating random numbers using Mersenne Twister</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-random-number-generation/">7.18 -- Introduction to random number generation</a>, we introduced the concept of random number generation, and discussed how PRNG algorithms are typically used to simulate randomness in programs.</p><p>In this lesson, we’ll take a look at how to generate random numbers in your programs. To access any of the randomization capabilities in C++, we include the <code><random></random></code> header of the standard library.</p><br><h3>Generating random numbers in C++ using Mersenne Twister</h3><p>The Mersenne Twister PRNG, besides having a great name, is probably the most popular PRNG across all programming languages. Although it is a bit old by today’s standards, it generally produces quality results and has decent performance. The random library has support for two Mersenne Twister types:</p><ul><li><code>mt19937</code> is a Mersenne Twister that generates 32-bit unsigned integers</li><li><code>mt19937_64</code> is a Mersenne Twister that generates 64-bit unsigned integers</li></ul><p>Using Mersenne Twister is straightforward:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <random> // for std::mt19937</random></code><code></code><code>int main()</code><code>{</code><code>	std::mt19937 mt; // Instantiate a 32-bit Mersenne Twister</code><code></code><code>	// Print a bunch of random numbers</code><code>	for (int count{ 1 }; count &lt;= 40; ++count)</code><code>	{</code><code>		std::cout &lt;&lt; mt() &lt;&lt; '\t'; // generate a random number</code><code></code><code>		// If we've printed 5 numbers, start a new row</code><code>		if (count % 5 == 0)</code><code>			std::cout &lt;&lt; '\n';</code><code>	}</code><code></code><code>	return 0;</code><code>}</code></pre><p>This produces the result:</p><pre>3499211612      581869302       3890346734      3586334585      545404204
4161255391      3922919429      949333985       2715962298      1323567403
418932835       2350294565      1196140740      809094426       2348838239
4264392720      4112460519      4279768804      4144164697      4156218106
676943009       3117454609      4168664243      4213834039      4111000746
471852626       2084672536      3427838553      3437178460      1275731771
609397212       20544909        1811450929      483031418       3933054126
2747762695      3402504553      3772830893      4120988587      2163214728
</pre><p>First, we include the &lt;random&gt; header, since that’s where all the random number capabilities live. Next, we instantiate a 32-bit Mersenne Twister engine via the statement <code>std::mt19937 mt</code>. Then, each time we want to generate a random 32-bit unsigned integer, we call <code>mt()</code>.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>Since <code>mt</code> is a variable, you may be wondering what <code>mt()</code> means.</p><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-stdstring/">4.17 -- Introduction to std::string</a>, we showed an example where we called the function <code>name.length()</code>, which invoked the <code>length()</code> function on <code>std::string</code> variable <code>name</code>.</p><p><code>mt()</code> is a concise syntax for calling the function <code>mt.operator()</code>, which for these PRNG types has been defined to return the next random result in the sequence. The advantage of using <code>operator()</code> instead of a named function is that we don’t need to remember the function’s name, and the concise syntax is less typing.</p></div><br><h3>Rolling a dice using Mersenne Twister</h3><p>A 32-bit PRNG will generate random numbers between 0 and 4,294,967,295, but we do not always want numbers in that range. If our program was simulating a board game or a dice game, we’d probably want to simulate the roll of a 6-sided dice by generating random numbers between 1 and 6. If our program was a dungeon adventure, and the player had a sword that did between 7 and 11 damage to monsters, then we’d want to generate random numbers between 7 and 11 whenever the player hit a monster.</p><p>Unfortunately, PRNGs can’t do this. They can only generate numbers that use the full range. What we need is some way to convert a number that is output from our PRNG into a value in the smaller range we want (with an even probability of each value occurring). While we could write a function to do this ourselves, doing so in a way that produces non-biased results is non-trivial.</p><p>Fortunately, the random library can help us here, in the form of random number distributions. A <span class="cpp-definition">random number distribution</span> converts the output of a PRNG into some other distribution of numbers.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>For the stats geeks: a random number distribution is just a probability distribution designed to take PRNG values as input.</p></div><p>The random library has many random numbers distributions, most of which you will never use unless you’re doing some kind of statistical analysis. But there’s one random number distribution that’s extremely useful: a <span class="cpp-definition">uniform distribution</span> is a random number distribution that produces outputs between two numbers X and Y (inclusive) with equal probability.</p><p>Here’s a similar program to the one above, using a uniform distribution to simulate the roll of a 6-sided dice:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <random> // for std::mt19937 and std::uniform_int_distribution</random></code><code></code><code>int main()</code><code>{</code><code>	std::mt19937 mt;</code><code></code><code>	// Create a reusable random number generator that generates uniform numbers between 1 and 6</code><code>	std::uniform_int_distribution die6{ 1, 6 }; // for C++14, use std::uniform_int_distribution&lt;&gt; die6{ 1, 6 };</code><code></code><code>	// Print a bunch of random numbers</code><code>	for (int count{ 1 }; count &lt;= 40; ++count)</code><code>	{</code><code>		std::cout &lt;&lt; die6(mt) &lt;&lt; '\t'; // generate a roll of the die here</code><code></code><code>		// If we've printed 10 numbers, start a new row</code><code>		if (count % 10 == 0)</code><code>			std::cout &lt;&lt; '\n';</code><code>	}</code><code></code><code>	return 0;</code><code>}</code></pre><p>This produces the result:</p><pre>3       1       3       6       5       2       6       6       1       2
2       6       1       1       6       1       4       5       2       5
6       2       6       2       1       3       5       4       5       6
1       4       2       3       1       2       2       6       2       1
</pre><p>There are only two noteworthy differences in this example compared to the previous one. First, we’ve created a uniform distribution variable (named <code>die6</code>) to generate numbers between 1 and 6. Second, instead of calling <code>mt()</code> to generate 32-bit unsigned integer random numbers, we’re now calling <code>die6(mt)</code> to generate a value between 1 and 6.</p><br><h3>The above program isn’t as random as it seems</h3><p>Although the results of our dice rolling example above are pretty random, there’s a major flaw with the program. Run the program 3 times and see if you can figure out what it is. Go ahead, we’ll wait.</p><p><em>Jeopardy music</em></p><p>If you run the program multiple times, you will note that it prints the same numbers every time! While each number in the sequence is random with regards to the previous one, the entire sequence is not random at all! Each run of our program produces the exact same result.</p><p>Imagine that you’re writing a game of hi-lo, where the user has 10 tries to guess a number that has been picked randomly, and the computer tells the user whether their guess is too high or too low. If the computer picks the same random number every time, the game won’t be interesting past the first time it is played. So let’s take a deeper look at why this is happening, and how we can fix it.</p><p>In the prior lesson (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-random-number-generation/">7.18 -- Introduction to random number generation</a>), we covered that each number in a PRNG sequence is in a deterministic way. And that the state of the PRNG is initialized from the seed value. Thus, given any starting seed number, PRNGs will always generate the same sequence of numbers from that seed as a result.</p><p>Because we are default initializing our Mersenne Twister, it is being initialized with the same seed every time the program is run. And because the seed is the same, the random numbers being generated are also the same.</p><p>In order to make our entire sequence randomized differently each time the program is run, we need to pick a seed that’s not a fixed number. The first answer that probably comes to mind is that we need a random number for our seed! That’s a good thought, but if we need a random number to generate random numbers, then we’re in a catch-22. It turns out, we really don’t need our seed to be a random number -- we just need to pick something that changes each time the program is run. Then we can use our PRNG to generate a unique sequence of pseudo-random numbers from that seed.</p><p>There are two methods that are commonly used to do this:</p><ul><li>Use the system clock</li><li>Use the system’s random device</li></ul><br><h3>Seeding with the system clock</h3><p>What’s one thing that’s different every time you run your program? Unless you manage to run your program twice at exactly the same moment in time, the answer is that the current time is different. Therefore, if we use the current time as our seed value, then our program will produce a different set of random numbers each time it is run. C and C++ have a long history of PRNGs being seeded using the current time (using the <code>std::time()</code> function), so you will probably see this in a lot of existing code.</p><p>Fortunately, C++ has a high resolution clock that we can use to generate a seed value. To minimize the chance of two time values being identical if the program is run quickly in succession, we want to use some time measure that changes as quickly as possible. For this, we’ll ask the clock how much time has passed since the earliest time it can measure. This time is measured in “ticks”, which is a very small unit of time (usually nanoseconds, but could be milliseconds).</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <random> // for std::mt19937</random></code><code>#include <chrono> // for std::chrono</chrono></code><code></code><code>int main()</code><code>{</code><code>	// Seed our Mersenne Twister using the </code><code>	std::mt19937 mt{ static_cast<unsigned int="">(</unsigned></code><code>		std::chrono::steady_clock::now().time_since_epoch().count()</code><code>		) };</code><code></code><code>	// Create a reusable random number generator that generates uniform numbers between 1 and 6</code><code>	std::uniform_int_distribution die6{ 1, 6 }; // for C++14, use std::uniform_int_distribution&lt;&gt; die6{ 1, 6 };</code><code></code><code>	// Print a bunch of random numbers</code><code>	for (int count{ 1 }; count &lt;= 40; ++count)</code><code>	{</code><code>		std::cout &lt;&lt; die6(mt) &lt;&lt; '\t'; // generate a roll of the die here</code><code></code><code>		// If we've printed 10 numbers, start a new row</code><code>		if (count % 10 == 0)</code><code>			std::cout &lt;&lt; '\n';</code><code>	}</code><code></code><code>	return 0;</code><code>}</code></pre><p>The above program has only two changes from the prior. First, we’re including &lt;chrono&gt;, which gives us access to the clock. Second, we’re using the current time from the clock as a seed value for our Mersenne Twister.</p><p>The results generated by this program should now be different each time it is run, which you can verify experimentally by running it several times.</p><p>The downside of this approach is that if the program is run several times in quick succession, the seeds generated for each run won’t be that different, which can impact the quality of the random results from a statistical standpoint. For normal programs, this doesn’t matter, but for programs that require high quality, independent results, this method of seeding may be insufficient.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p><code>std::chrono::high_resolution_clock</code> is a popular choice instead of <code>std::chrono::steady_clock</code>. <code>std::chrono::high_resolution_clock</code> is the clock that uses the most granular unit of time, but it may use the system clock for the current time, which can be changed or rolled back by users. <code>std::chrono::steady_clock</code> may have a less granular tick time, but is the only clock with a guarantee that users can not adjust it.</p></div><br><h3>Seeding with the random device</h3><p>The random library contains a type called <code>std::random_device</code> that is an implementation-defined PRNG. Normally we avoid implementation-defined capabilities because they have no guarantees about quality or portability, but this is one of the exception cases. Typically <code>std::random_device</code> will ask the OS for a random number (how it does this depends on the OS).</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <random> // for std::mt19937 and std::random_device</random></code><code></code><code>int main()</code><code>{</code><code>	std::mt19937 mt{ std::random_device{}() };</code><code></code><code>	// Create a reusable random number generator that generates uniform numbers between 1 and 6</code><code>	std::uniform_int_distribution die6{ 1, 6 }; // for C++14, use std::uniform_int_distribution&lt;&gt; die6{ 1, 6 };</code><code></code><code>	// Print a bunch of random numbers</code><code>	for (int count{ 1 }; count &lt;= 40; ++count)</code><code>	{</code><code>		std::cout &lt;&lt; die6(mt) &lt;&lt; '\t'; // generate a roll of the die here</code><code></code><code>		// If we've printed 10 numbers, start a new row</code><code>		if (count % 10 == 0)</code><code>			std::cout &lt;&lt; '\n';</code><code>	}</code><code></code><code>	return 0;</code><code>}</code></pre><p>In the above program, we’re seeding our Mersenne Twister with one random number generated from a temporary instance of <code>std::random_device</code>. If you run this program multiple times, it should also produce different results each time.</p><p>One potential problem with <code>std::random_device</code>: it isn’t required to be non-deterministic, meaning it <em>could</em>, on some systems, produce the same sequence every time the program is run, which is exactly what we’re trying to avoid. There was a <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85494">bug in MinGW</a> (fixed in GCC 9.2) that would do exactly this, making <code>std::random_device</code> useless.</p><p>However, the latest versions of the most popular compilers (GCC/MinGW, Clang, Visual Studio) support proper implementations of <code>std::random_device</code>.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use <code>std::random_device</code> to seed your PRNGs (unless it’s not implemented properly for your target compiler/architecture).</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Q: What does std::random_device{}() mean?</h4><p><code>std::random_device{}</code> creates an value-initialized temporary object of type <code>std::random_device</code>. The <code>()</code> then calls <code>operator()</code> on that temporary object, which returns a randomized value (which we use as an initializer for our Mersenne Twister)</p><p>It’s the equivalent of the calling the following function, which uses a syntax you should be more familiar with:</p><pre class="language-cpp line-numbers"><code>unsigned int getRandomDeviceValue()</code><code>{</code><code>   std::random_device rd{}; // create a value initialized std::random_device object</code><code>   return rd(); // return the result of operator() to the caller</code><code>}</code></pre><p>Using <code>std::random_device{}()</code> allows us to get the same result without creating a named function or named variable, so it’s much more concise.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Q: If std::random_device is random itself, why don’t we just use that instead of Mersenne Twister?</h4><p>Because std::random_device is implementation defined, we can’t assume much about it. It may be expensive to access or it may cause our program to pause while waiting for more random numbers to become available. The pool of numbers that it draws from may also be depleted quickly, which would impact the random results for other applications requesting random numbers via the same method. For this reason, std::random_device is better used to seed other PRNGs rather than as a PRNG itself.</p></div><br><h3>Only seed a PRNG once</h3><p>Many PRNGs can be reseeded after the initial seeding. This essentially re-initializes the state of the random number generator, causing it to generate results starting from the new seed state. Reseeding should generally be avoided unless you have a specific reason to do so, as it can cause the results to be less random, or not random at all.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Only seed a given pseudo-random number generator once, and do not reseed it.</p></div><p>Here’s an example of a common mistake that new programmers make:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <random></random></code><code></code><code>int getCard()</code><code>{</code><code>    std::mt19937 mt{ std::random_device{}() }; // this gets created and seeded every time the function is called</code><code>    std::uniform_int_distribution card{ 1, 52 };</code><code>    return card(mt);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; getCard();</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the <code>getCard()</code> function, the random number generator is being created and seeded every time the function is called. This is inefficient at best, and will likely cause poor random results.</p><br><h3>Random numbers across multiple functions</h3><p>What happens if we want to use a random number generator in multiple functions? One way is to create (and seed) our PRNG in our <code>main()</code> function, and then pass it everywhere we need it. But that’s a lot of passing for something we may only use sporadically, and in different places.</p><p>Although you can create a static local std::mt19937 variable in each function that needs it (static so that it only gets seeded once), it’s overkill to have every function that uses a random number generator define and seed its own local generator. A better option in most cases is to create a global random number generator (inside a namespace!). Remember how we told you to avoid non-const global variables? This is an exception.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <random> // for std::mt19937 and std::random_device</random></code><code></code><code>namespace Random // capital R to avoid conflicts with functions named random()</code><code>{</code><code>	std::mt19937 mt{ std::random_device{}() };</code><code></code><code>	int get(int min, int max)</code><code>	{</code><code>		std::uniform_int_distribution die{ min, max }; // we can create a distribution in any function that needs it</code><code>		return die(mt); // and then generate a random number from our global generator</code><code>	}</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; Random::get(1, 6) &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; Random::get(1, 10) &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; Random::get(1, 20) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>In the above example, <code>Random::mt</code> is a global variable that can be accessed from any function. We’ve created <code>Random::get()</code> as an easy way to get a random number between <code>min</code> and <code>max</code>. <code>std::uniform_int_distribution</code> is typically cheap to create, so it’s fine to create when we need it.</p><br><h3>Mersenne Twister and underseeding issues</h3><p>The internal state of a Mersenne Twister is 624 bytes in size. In the examples above, where we seed from the clock or std::random_device, our seed is only a single 32-bit integer. This means we’re essentially initializing a 624-byte object with a 4-byte value, which is significantly underseeding the Mersenne Twister PRNG. The random library does the best it can to fill in the remaining 620 bytes with “random” data… but it can’t work magic. Underseeded PRNG can generate results that are suboptimal for applications that need the highest quality results. For example, seeding <code>std::mt19937</code> with a single 32-bit value will never generate the number <code>42</code> as its first output.</p><p>So how do we fix this? As of C++20, there’s no easy way. But we do have some suggestions.</p><p>First, let’s talk about <code>std::seed_seq</code> (which stands for “seed sequence”). In the prior lesson, we mentioned that a seed can be either a single value, or a set of values. <code>std::seed_seq</code> is a type that performs two functions. First, it can hold multiple seed values, so we can use it to seed our PRNG with more than one value. Second, it will generate as many additional unbiased seed values as needed to initialize a PRNG’s state. So if you initialize <code>std::seed_seq</code> with a single 32-bit integer (e.g. from std::random_device) and then initialize a Mersenne Twister with the <code>std::seed_seq</code> object, <code>std::seed_seq</code> will generate 620 bytes of additional seed data. The results won’t be amazingly high quality, but it’s better than nothing.</p><p>Now on to the ideas.</p><p>First, the more pieces of random data we can give <code>std::seed_seq</code> to work with, the better. So the easiest idea is to simply use <code>std::random_device</code> to give <code>std::seed_seq</code> more data to work with. If we initialize <code>std::seed_seq</code> with 8 numbers from <code>std::random_device</code> instead of 1, then the remaining numbers generated by <code>std::seed_seq</code> should be that much better:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <random></random></code><code></code><code>int main()</code><code>{</code><code>	std::random_device rd;</code><code>	std::seed_seq ss{ rd(), rd(), rd(), rd(), rd(), rd(), rd(), rd() }; // get 8 integers of random numbers from std::random_device for our seed</code><code>	std::mt19937 mt{ ss }; // initialize our Mersenne Twister with the std::seed_seq</code><code></code><code>	// Create a reusable random number generator that generates uniform numbers between 1 and 6</code><code>	std::uniform_int_distribution die6{ 1, 6 }; // for C++14, use std::uniform_int_distribution&lt;&gt; die6{ 1, 6 };</code><code></code><code>	// Print a bunch of random numbers</code><code>	for (int count{ 1 }; count &lt;= 40; ++count)</code><code>	{</code><code>		std::cout &lt;&lt; die6(mt) &lt;&lt; '\t'; // generate a roll of the die here</code><code></code><code>		// If we've printed 10 numbers, start a new row</code><code>		if (count % 10 == 0)</code><code>			std::cout &lt;&lt; '\n';</code><code>	}</code><code></code><code>	return 0;</code><code>}</code></pre><p>This is pretty straightforward so there isn’t much reason not to do this at a minimum.</p><div class="cpp-note cpp-lightbluebackground"><h4>Q: Why not give std::seed_seq 156 integers (624 bytes) from std::random_device?</h4><p>You can! However, this may be slow, and risks depleting the pool of random numbers that <code>std::random_device</code> uses.</p></div><p>Second, you can use other “random” inputs to <code>std::seed_seq</code>. We’ve already shown you how to get a value from the clock, so you can throw that in easily. Other things that are sometimes used include the current thread id,the address of particular functions, the user’s id, the process id, etc… Doing that is beyond the scope of this article, but <a href="https://www.pcg-random.org/posts/ease-of-use-without-loss-of-power.html">this article</a> has some context and a link to <a href="https://gist.github.com/imneme/540829265469e673d045">randutils.hpp</a> that implements this.</p><p>An alternate path is to use a different PRNG with a smaller state. Many good PRNGs use 64 or 128 bits of state, which can easily be initialized using <code>std::seed_seq</code> filled with 8 calls to <code>std::random_device</code>.</p><br><h3>Debugging programs that use random numbers</h3><p>Programs that use random numbers can be difficult to debug because the program may exhibit different behaviors each time it is run. Sometimes it may work, and sometimes it may not. When debugging, it’s helpful to ensure your program executes the same (incorrect) way each time. That way, you can run the program as many times as needed to isolate where the error is.</p><p>For this reason, when debugging, it’s a useful technique to seed your PRNG with a specific value (e.g. <code>5</code>) that causes the erroneous behavior to occur. This will ensure your program generates the same results each time, making debugging easier. Once you’ve found the error, you can use your normal seeding method to start generating randomized results again.</p><br><h3>Random FAQ</h3><div class="cpp-note cpp-lightbluebackground"><h4>Q: Help! My random number generator is generating the same sequence of random numbers.</h4><p>If your random number generator is generating the same sequence of random numbers every time your program is run, you probably didn’t seed it properly (or at all). Make sure you’re seeding it with a value that changes each time the program is run.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Q: Help! My random number generator keeps generating the same number over and over.</h4><p>If your random number generator is generating the same number every time you ask it for a random number, then you are probably either reseeding the random number generator before generating a random number, or you’re creating a new random generator for each random number.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">7.x — Chapter 7 summary and quiz</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Chapter Review</h3><p>The specific sequence of statements that the CPU executes in a program is called the program’s <span class="cpp-definition">execution path</span>. A <span class="cpp-definition">straight-line program</span> takes the same path every time it is run.</p><p><span class="cpp-definition">Control flow statements</span> (also called <span class="cpp-definition">Flow control statements</span>) allow the programmer to change the normal path of execution. When a control flow statement causes the program to begin executing some non-sequential instruction sequence, this is called a <span class="cpp-definition">branch</span>.</p><p>A <span class="cpp-definition">conditional statement</span> is a statement that specifies whether some associated statement(s) should be executed or not.</p><p><span class="cpp-definition">If statements</span> allow us to execute an associated statement based on whether some condition is <code>true</code>. <span class="cpp-definition">Else statements</span> execute if the associated condition is <code>false</code>. You can chain together multiple if and else statements.</p><p>A <span class="cpp-definition">dangling else</span> occurs when it is ambiguous which <code>if statement</code> an <code>else statement</code> is connected to. <code>Dangling else</code> statements are matched up with the last unmatched <code>if statement</code> in the same block. Thus, we trivially avoid <code>dangling else</code> statements by ensuring the body of an <code>if statement</code> is placed in a block.</p><p>A <span class="cpp-definition">null statement</span> is a statement that consists of just a semicolon. It does nothing, and is used when the language requires a statement to exist but the programmer does not need the statement to do anything.</p><p><span class="cpp-definition">Switch statements</span> provide a cleaner and faster method for selecting between a number of matching items. Switch statements only work with integral types. <span class="cpp-definition">Case labels</span> are used to identify the values for the evaluated condition to match. The statements beneath a <span class="cpp-definition">default label</span> are executed if no matching case label can be found.</p><p>When execution flows from a statement underneath a label into statements underneath a subsequent label, this is called <span class="cpp-definition">fallthrough</span>. A <code>break statement</code> (or <code>return statement</code>) can be used to prevent fallthrough. The [[fallthrough]] attribute can be used to document intentional fallthrough.</p><p><span class="cpp-definition">Goto statements</span> allow the program to jump to somewhere else in the code, either forward or backwards. These should generally be avoided, as they can create <span class="cpp-definition">spaghetti code</span>, which occurs when a program has a path of execution that resembles a bowl of spaghetti.</p><p><span class="cpp-definition">While loops</span> allow the program to loop as long as a given condition evaluates to <code>true</code>. The condition is evaluated before the loop executes.</p><p>An <span class="cpp-definition">infinite loop</span> is a loop that has a condition that always evaluates to <code>true</code>. These loops will loop forever unless another control flow statement is used to stop them.</p><p>A <span class="cpp-definition">loop variable</span> (also called a <span class="cpp-definition">counter</span>) is an integer variable used to count how many times a loop has executed. Each execution of a loop is called an <span class="cpp-definition">iteration</span>.</p><p><span class="cpp-definition">Do while loops</span> are similar to while loops, but the condition is evaluated after the loop executes instead of before.</p><p><span class="cpp-definition">For loops</span> are the most used loop, and are ideal when you need to loop a specific number of times. An <span class="cpp-definition">off-by-one error</span> occurs when the loop iterates one too many or one too few times.</p><p><span class="cpp-definition">Break statements</span> allow us to break out of a switch, while, do while, or for loop (also <code>range-based for loops</code>, which we haven’t covered yet). <span class="cpp-definition">Continue statements</span> allow us to move immediately to the next loop iteration.</p><p><span class="cpp-definition">Halts</span> allow us to terminate our program. <span class="cpp-definition">Normal termination</span> means the program has exited in an expected way (and the <code>status code</code> will indicate whether it succeeded or not). <span class="cpp-definition">std::exit()</span> is automatically called at the end of <code>main</code>, or it can be called explicitly to terminate the program. It does some cleanup, but does not cleanup any local variables, or unwind the call stack.</p><p><span class="cpp-definition">Abnormal termination</span> occurs when the program encountered some kind of unexpected error and had to be shut down. <span class="cpp-definition">std::abort</span> can be called for an abnormal termination.</p><p><span class="cpp-definition">Scope creep</span> occurs when a project’s capabilities grow beyond what was originally intended at the start of the project or project phase.</p><p><span class="cpp-definition">Software verification</span> is the process of testing whether or not the software works as expected in all cases. A <span class="cpp-definition">unit test</span> is a test designed to test a small portion of the code (typically a function or call) in isolation to ensure a particular behavior occurs as expected. <span class="cpp-definition">Unit test frameworks</span> can help you organize your unit tests. <span class="cpp-definition">Integration testing</span> tests the integration of a bunch of units together to ensure they work properly.</p><p><span class="cpp-definition">Code coverage</span> refers to how much of the source code is executed while testing. <span class="cpp-definition">Statement coverage</span> refers to the percentage of statements in a program that have been exercised by testing routines. <span class="cpp-definition">Branch coverage</span> refers to the percentage of branches that have been executed by testing routines. <span class="cpp-definition">Loop coverage</span> (also called the <span class="cpp-definition">0, 1, 2 test</span>) means that if you have a loop, you should ensure it works properly when it iterates 0 times, 1 time, and 2 times.</p><p>The <span class="cpp-definition">happy path</span> is the path of execution that occurs when there are no errors encountered. A <span class="cpp-definition">sad path</span> is one where an error or failure state occurs. A <span class="cpp-definition">non-recoverable error</span> (also called a <span class="cpp-definition">fatal error</span>) is an error that is severe enough that the program can’t continue running. A program that handles error cases well is <span class="cpp-definition">robust</span>.</p><p>A <span class="cpp-definition">buffer</span> is a piece of memory set aside for storing data temporarily while it is moved from one place to another.</p><p>The process of checking whether user input conforms to what the program is expecting is called <span class="cpp-definition">input validation</span>.</p><p><span class="cpp-definition">std::cerr</span> is an output stream (like <code>std::cout</code>) designed to be used for error messages.</p><p>A <span class="cpp-definition">precondition</span> is any condition that must always be true prior to the execution of some segment of code. An <span class="cpp-definition">invariant</span> is a condition that must be true while some component is executing. A <span class="cpp-definition">postcondition</span> is any condition that must always be true after the execution of some code.</p><p>An <span class="cpp-definition">assertion</span> is an expression that will be true unless there is a bug in the program. In C++, runtime assertions are typically implemented using the <span class="cpp-definition">assert</span> preprocessor macro. Assertions are usually turned off in non-debug code. A <span class="cpp-definition">static_assert</span> is an assertion that is evaluated at compile-time.</p><p>Assertions should be used to document cases that should be logically impossible. Error handling should be used to handle cases that are possible.</p><p>An <span class="cpp-definition">algorithm</span> is a finite sequence of instructions that can be followed to solve some problem or produce some useful result. An algorithm is considered to be <span class="cpp-definition">stateful</span> if it retains some information across calls. Conversely, a <span class="cpp-definition">stateless</span> algorithm does not store any information (and must be given all the information it needs to work with when it is called). When applied to algorithms, the term <span class="cpp-definition">state</span> refers to the current values held in stateful variables.</p><p>An algorithm is considered <span class="cpp-definition">deterministic</span> if for a given input (the value provided for <code>start</code>) it will always produce the same output sequence.</p><p>A <span class="cpp-definition">pseudo-random number generator (PRNG)</span> is an algorithm that generates a sequence of numbers whose properties simulate a sequence of random numbers. When a PRNG is instantiated, an initial value (or set of values) called a <span class="cpp-definition">random seed</span> (or <span class="cpp-definition">seed</span> for short) can be provided to initialize the state of the PRNG. When a PRNG has been initialized with a seed, we say it has been <span class="cpp-definition">seeded</span>. The size of the seed value can be smaller than the size of the state of the PRNG. When this happens, we say the PRNG has been <span class="cpp-definition">underseeded</span>. The length of the sequence before a PRNG begins to repeat itself is known as the <span class="cpp-definition">period</span>.</p><p>A <span class="cpp-definition">random number distribution</span> converts the output of a PRNG into some other distribution of numbers. A <span class="cpp-definition">uniform distribution</span> is a random number distribution that produces outputs between two numbers X and Y (inclusive) with equal probability.</p><br><h3>Quiz time</h3><p>Warning: The quizzes start getting harder from this point forward, but you can do it. Let’s rock these quizzes!</p><p class="cpp-quiz-question" style="clear:both">Question #1</p><p>In the <a href="https://www.learncpp.com#Chapter4">chapter 4</a> comprehensive quiz, we wrote a program to simulate a ball falling off of a tower. Because we didn’t have loops yet, the ball could only fall for 5 seconds.</p><p>Take the program below and modify it so that the ball falls for as many seconds as needed until it reaches the ground.</p><p>In constants.h:</p><pre class="language-cpp line-numbers"><code>#ifndef CONSTANTS_H</code><code>#define CONSTANTS_H</code><code></code><code>namespace myConstants</code><code>{</code><code>    inline constexpr double gravity { 9.8 }; // in meters/second squared</code><code>}</code><code>#endif</code></pre><p>In your main code file:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include "constants.h"</code><code></code><code>double calculateHeight(double initialHeight, int seconds)</code><code>{</code><code>    double distanceFallen { myConstants::gravity * seconds * seconds / 2 };</code><code>    double heightNow { initialHeight - distanceFallen };</code><code></code><code>    // Check whether we've gone under the ground</code><code>    // If so, set the height to ground-level</code><code>    if (heightNow &lt; 0.0)</code><code>        return 0.0;</code><code>    else</code><code>        return heightNow;</code><code>}</code><code></code><code>void calculateAndPrintHeight(double initialHeight, int time)</code><code>{</code><code>    std::cout &lt;&lt; "At " &lt;&lt; time &lt;&lt; " seconds, the ball is at height: " &lt;&lt; calculateHeight(initialHeight, time) &lt;&lt; "\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter the initial height of the tower in meters: ";</code><code>    double initialHeight {};</code><code>    std::cin &gt;&gt; initialHeight;</code><code>	</code><code>    calculateAndPrintHeight(initialHeight, 0);</code><code>    calculateAndPrintHeight(initialHeight, 1);</code><code>    calculateAndPrintHeight(initialHeight, 2);</code><code>    calculateAndPrintHeight(initialHeight, 3);</code><code>    calculateAndPrintHeight(initialHeight, 4);</code><code>    calculateAndPrintHeight(initialHeight, 5);</code><code>	</code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>In constants.h:</p><pre class="language-cpp line-numbers"><code>#ifndef CONSTANTS_H</code><code>#define CONSTANTS_H</code><code></code><code>namespace myConstants</code><code>{</code><code>    inline constexpr double gravity{ 9.8 }; // in meters/second squared</code><code>}</code><code>#endif</code></pre><p>In your main code file:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include "constants.h"</code><code></code><code>double calculateHeight(double initialHeight, int seconds)</code><code>{</code><code>    double distanceFallen { myConstants::gravity * seconds * seconds / 2 };</code><code>    double heightNow { initialHeight - distanceFallen };</code><code></code><code>    // Check whether we've gone under the ground</code><code>    // If so, set the height to ground-level</code><code>    if (heightNow &lt; 0.0)</code><code>        return 0.0;</code><code>    else</code><code>        return heightNow;</code><code>}</code><code></code><code>// Returns true if the ball hit the ground, false if the ball is still falling</code><code>bool calculateAndPrintHeight(double initialHeight, int time)</code><code>{</code><code>    double currentHeight { calculateHeight(initialHeight, time) };</code><code>    std::cout &lt;&lt; "At " &lt;&lt; time &lt;&lt; " seconds, the ball is at height: " &lt;&lt; currentHeight &lt;&lt; "\n";</code><code></code><code>    return (currentHeight == 0.0);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter the initial height of the tower in meters: ";</code><code>    double initialHeight;</code><code>    std::cin &gt;&gt; initialHeight;</code><code></code><code>    int seconds { 0 };</code><code></code><code>    // returns true if the ground was hit</code><code>    while (!calculateAndPrintHeight(initialHeight, seconds))</code><code>        ++seconds;</code><code></code><code>    return 0;</code><code>}</code></pre></div><p class="cpp-quiz-question cpp-topline" style="clear:both">Question #2</p><p>A prime number is a natural number greater than 1 that is evenly divisible (with no remainder) only by 1 and itself. Complete the following program by writing the <code>isPrime()</code> function using a for-loop. When successful, the program will print “Success!”.</p><p>If you want to optimize your answer: <a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">Hint: A non-prime number must have at least one divisor less than or equal to its square root. <code>std::sqrt(x)</code> (in the &lt;cmath&gt; header) returns the square root of <code>x</code>.</div><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cassert></cassert></code><code></code><code>bool isPrime(int x)</code><code>{</code><code>    // write this function using a for loop</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    assert(!isPrime(0));</code><code>    assert(!isPrime(1));</code><code>    assert(isPrime(2));</code><code>    assert(isPrime(3));</code><code>    assert(!isPrime(4));</code><code>    assert(isPrime(5));</code><code>    assert(isPrime(7));</code><code>    assert(!isPrime(9));</code><code>    assert(isPrime(11));</code><code>    assert(isPrime(13));</code><code>    assert(!isPrime(15));</code><code>    assert(!isPrime(16));</code><code>    assert(isPrime(17));</code><code>    assert(isPrime(19));</code><code>    assert(isPrime(97));</code><code>    assert(!isPrime(99));</code><code>    assert(isPrime(13417));</code><code></code><code>    std::cout &lt;&lt; "Success!\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cassert></cassert></code><code>#include <cmath> // for std::sqrt</cmath></code><code></code><code>bool isPrime(int x)</code><code>{</code><code>    // if x is negative, 0, or 1, the number is not prime</code><code>    if (x &lt;= 1)</code><code>        return false;</code><code></code><code>    // If the number is 2 or higher, we need to see if we can find a divisor</code><code>    // We only need to test the numbers between 2 and sqrt(x)</code><code>    // since a non-prime number must have at least one divisor</code><code>    // less than or equal to its square root.</code><code>    // It's fine (just less efficient) if you used test &lt;= x for this exercise</code><code></code><code>    for (int test{ 2 }; test &lt;= std::sqrt(x); ++test) </code><code>    {</code><code>        if (x % test == 0) // if x is evenly divisible</code><code>            return false; // then this number isn't prime</code><code>    }</code><code></code><code>    return true; // if we didn't find any divisors, then x must be prime</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    assert(!isPrime(0));</code><code>    assert(!isPrime(1));</code><code>    assert(isPrime(2));</code><code>    assert(isPrime(3));</code><code>    assert(!isPrime(4));</code><code>    assert(isPrime(5));</code><code>    assert(isPrime(7));</code><code>    assert(!isPrime(9));</code><code>    assert(isPrime(11));</code><code>    assert(isPrime(13));</code><code>    assert(!isPrime(15));</code><code>    assert(!isPrime(16));</code><code>    assert(isPrime(17));</code><code>    assert(isPrime(19));</code><code>    assert(isPrime(97));</code><code>    assert(!isPrime(99));</code><code>    assert(isPrime(13417));</code><code></code><code>    std::cout &lt;&lt; "Success!\n";</code><code></code><code>    return 0;</code><code>}</code></pre></div><p class="cpp-quiz-question cpp-topline" style="clear:both">Question #3</p><p>Implement a game of hi-lo. First, your program should pick a random integer between 1 and 100. The user is given 7 tries to guess the number.</p><p>If the user does not guess the correct number, the program should tell them whether they guessed too high or too low. If the user guesses the right number, the program should tell them they won. If they run out of guesses, the program should tell them they lost, and what the correct number is. At the end of the game, the user should be asked if they want to play again. If the user doesn’t enter ‘y’ or ‘n’, ask them again.</p><p>For this quiz, assume the user enters a valid number. Use a Mersenne Twister PRNG, and seed it using a <code>std::seed_seq</code> with 8 results from <code>std::random_device</code>. See lesson <a href="https://www.learncpp.com/cpp-tutorial/generating-random-numbers-using-mersenne-twister/">7.19 -- Generating random numbers using Mersenne Twister</a> for more details.</p><p>Here’s what your output should look like:</p><pre>Let's play a game. I'm thinking of a number between 1 and 100. You have 7 tries to guess what it is.
Guess #1: 64
Your guess is too high.
Guess #2: 32
Your guess is too low.
Guess #3: 54
Your guess is too high.
Guess #4: 51
Correct! You win!
Would you like to play again (y/n)? y
Let's play a game. I'm thinking of a number between 1 and 100. You have 7 tries to guess what it is.
Guess #1: 64
Your guess is too high.
Guess #2: 32
Your guess is too low.
Guess #3: 54
Your guess is too high.
Guess #4: 51
Your guess is too high.
Guess #5: 36
Your guess is too low.
Guess #6: 45
Your guess is too low.
Guess #7: 48
Your guess is too low.
Sorry, you lose. The correct number was 49.
Would you like to play again (y/n)? q
Would you like to play again (y/n)? n
Thank you for playing.
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <random> // for std::mt19937</random></code><code></code><code>// returns true if the user won, false if they lost</code><code>bool playGame(int guesses, int number)</code><code>{</code><code>	// Loop through all of the guesses</code><code>	for (int count{ 1 }; count &lt;= guesses; ++count)</code><code>	{</code><code>		std::cout &lt;&lt; "Guess #" &lt;&lt; count &lt;&lt; ": ";</code><code></code><code>		int guess {};</code><code>		std::cin &gt;&gt; guess;</code><code></code><code>		if (guess &gt; number)</code><code>			std::cout &lt;&lt; "Your guess is too high.\n";</code><code>		else if (guess &lt; number)</code><code>			std::cout &lt;&lt; "Your guess is too low.\n";</code><code>		else // guess == number</code><code>			return true;</code><code>	}</code><code></code><code>	return false; // if the user lost</code><code>}</code><code></code><code>bool playAgain()</code><code>{</code><code>	// Keep asking the user if they want to play again until they pick y or n.</code><code>	while (true)</code><code>	{</code><code>		char ch {};</code><code>		std::cout &lt;&lt; "Would you like to play again (y/n)? ";</code><code>		std::cin &gt;&gt; ch;</code><code></code><code>		switch (ch)</code><code>		{</code><code>		case 'y': return true;</code><code>		case 'n': return false;</code><code>		}</code><code>	}</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::random_device rd;</code><code>	std::seed_seq seq{ rd(), rd(), rd(), rd(), rd(), rd(), rd(), rd() };</code><code>	std::mt19937 mt{ seq }; // Create a mersenne twister, seeded using the seed sequence</code><code>	std::uniform_int_distribution die{ 1, 100 }; // generate random numbers between 1 and 100</code><code></code><code>	constexpr int guesses{ 7 }; // the user has this many guesses</code><code></code><code>	do</code><code>	{</code><code>		int number{ die(mt) }; // this is the number the user needs to guess</code><code></code><code>		std::cout &lt;&lt; "Let's play a game. I'm thinking of a number between 1 and 100. You have " &lt;&lt; guesses &lt;&lt; " tries to guess what it is.\n";</code><code></code><code>		bool won{ playGame(guesses, number) };</code><code>		if (won)</code><code>			std::cout &lt;&lt; "Correct! You win!\n";</code><code>		else</code><code>			std::cout &lt;&lt; "Sorry, you lose. The correct number was " &lt;&lt; number &lt;&lt; "\n";</code><code>	} while (playAgain());</code><code></code><code>	std::cout &lt;&lt; "Thank you for playing.\n";</code><code></code><code>	return 0;</code><code>}</code></pre></div><p class="cpp-quiz-question cpp-topline" style="clear:both">Question #4</p><p>Update your previous solution to handle invalid guesses (e.g. ‘x’), out of bounds guesses (e.g. <code>0</code> or <code>101</code>), or valid guesses that have extraneous characters (e.g. <code>43x</code>).</p><p>Hint: Write a separate function to handle the user inputting their guess (along with the associated error handling).</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <random> // for std::mt19937</random></code><code>#include <limits></limits></code><code></code><code>int getGuess(int count)</code><code>{</code><code>	while (true) // loop until user enters valid input</code><code>	{</code><code>		std::cout &lt;&lt; "Guess #" &lt;&lt; count &lt;&lt; ": ";</code><code></code><code>		int guess{};</code><code>		std::cin &gt;&gt; guess;</code><code></code><code>		if (std::cin.fail()) // did the extraction fail?</code><code>		{</code><code>			// yep, so let's handle the failure</code><code>			std::cin.clear(); // put us back in 'normal' operation mode</code><code>			std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // remove the bad input</std::streamsize></code><code>			continue; // and try again</code><code>		}</code><code></code><code>		// If the guess was out of bounds</code><code>		if (guess &lt; 1 || guess &gt; 100)</code><code>		{</code><code>			std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // remove the bad input</std::streamsize></code><code>			continue; // and try again</code><code>		}</code><code></code><code>		// We may have gotten a partial extraction (e.g. user entered '43x')</code><code>		// We'll remove any extraneous input before we proceed</code><code>		// so the next extraction doesn't fail</code><code>		std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');</std::streamsize></code><code>		return guess;</code><code>	}</code><code>}</code><code></code><code>// returns true if the user won, false if they lost</code><code>bool playGame(int guesses, int number)</code><code>{</code><code>	// Loop through all of the guesses</code><code>	for (int count{ 1 }; count &lt;= guesses; ++count)</code><code>	{</code><code>		int guess{ getGuess(count) };</code><code></code><code>		if (guess &gt; number)</code><code>			std::cout &lt;&lt; "Your guess is too high.\n";</code><code>		else if (guess &lt; number)</code><code>			std::cout &lt;&lt; "Your guess is too low.\n";</code><code>		else // guess == number</code><code>			return true;</code><code>	}</code><code>	return false;</code><code>}</code><code></code><code>bool playAgain()</code><code>{</code><code>	// Keep asking the user if they want to play again until they pick y or n.</code><code>	while (true)</code><code>	{</code><code>		char ch{};</code><code>		std::cout &lt;&lt; "Would you like to play again (y/n)? ";</code><code>		std::cin &gt;&gt; ch;</code><code></code><code>		switch (ch)</code><code>		{</code><code>		case 'y': return true;</code><code>		case 'n': return false;</code><code>		}</code><code>	}</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::random_device rd;</code><code>	std::seed_seq seq{ rd(), rd(), rd(), rd(), rd(), rd(), rd(), rd() };</code><code>	std::mt19937 mt{ seq }; // Create a mersenne twister, seeded using the seed sequence</code><code></code><code>	std::uniform_int_distribution die{ 1, 100 }; // generate random numbers between 1 and 100</code><code>	constexpr int guesses{ 7 }; // the user has this many guesses</code><code>	do</code><code>	{</code><code>		int number{ die(mt) }; // this is the number the user needs to guess</code><code>		std::cout &lt;&lt; "Let's play a game. I'm thinking of a number between 1 and 100. You have " &lt;&lt; guesses &lt;&lt; " tries to guess what it is.\n";</code><code>		bool won{ playGame(guesses, number) };</code><code>		if (won)</code><code>			std::cout &lt;&lt; "Correct! You win!\n";</code><code>		else</code><code>			std::cout &lt;&lt; "Sorry, you lose. The correct number was " &lt;&lt; number &lt;&lt; "\n";</code><code>	} while (playAgain());</code><code></code><code>	std::cout &lt;&lt; "Thank you for playing.\n";</code><code>	return 0;</code><code>}</code></pre></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">8.1 — Implicit type conversion (coercion)</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Introduction to type conversion</h3><p>The value of an object is stored as a sequence of bits, and the data type of the object tells the compiler how to interpret those bits into meaningful values. Different data types may represent the “same” number differently. For example, the integer value 3 might be stored as binary <code>0000 0000 0000 0000 0000 0000 0000 0011</code>, whereas floating point value 3.0 might be stored as binary <code>0100 0000 0100 0000 0000 0000 0000 0000</code>.</p><p style="clear:both"></p><p>So what happens when we do something like this?</p><pre class="language-cpp line-numbers"><code>float f{ 3 }; // initialize floating point variable with int 3</code></pre><p>In such a case, the compiler can’t just copy the bits representing the <code>int</code> value <code>3</code> into the memory allocated for <code>float</code> variable <code>f</code>. Instead, it needs to convert the integer value <code>3</code> to the equivalent floating point number, which can then be stored in the memory allocated for <code>f</code>.</p><p>The process of converting a value from one data type to another data type is called a <span class="cpp-definition">type conversion</span>.</p><p>Type conversion can be invoked in one of two ways: either implicitly (as needed by the compiler), or explicitly (when requested by the programmer). We’ll cover implicit type conversion in this lesson, and explicit type conversions (casting) in upcoming lesson <a href="https://www.learncpp.com/cpp-tutorial/explicit-type-conversion-casting-and-static-cast/">8.5 -- Explicit type conversion (casting) and static_cast</a>.</p><br><h3>Implicit type conversion</h3><p><span class="cpp-definition">Implicit type conversion</span> (also called <span class="cpp-definition">automatic type conversion</span> or <span class="cpp-definition">coercion</span>) is performed automatically by the compiler when one data type is required, but a different data type is supplied. The vast majority of type conversions in C++ are implicit type conversions. For example, implicit type conversion happens in all of the following cases:</p><p>When initializing (or assigning a value to) a variable with a value of a different data type:</p><pre class="language-cpp line-numbers"><code>double d{ 3 }; // int value 3 implicitly converted to type double</code><code>d = 6; // int value 6 implicitly converted to type double</code></pre><p>When the type of a return value is different from the function’s declared return type:</p><pre class="language-cpp line-numbers"><code>float doSomething()</code><code>{</code><code>    return 3.0; // double value 3.0 implicitly converted to type float</code><code>}</code></pre><p>When using certain binary operators with operands of different types:</p><pre class="language-cpp line-numbers"><code>double division{ 4.0 / 3 }; // int value 3 implicitly converted to type double</code></pre><p>When using a non-Boolean value in an if-statement:</p><pre class="language-cpp line-numbers"><code>if (5) // int value 5 implicitly converted to type bool</code><code>{</code><code>}</code></pre><p>When an argument passed to a function is a different type than the function parameter:</p><pre class="language-cpp line-numbers"><code>void doSomething(long l)</code><code>{</code><code>}</code><code></code><code>doSomething(3); // int value 3 implicitly converted to type long</code></pre><br><h3>What happens when a type conversion is invoked</h3><p>When a type conversion is invoked (whether implicitly or explicitly), the compiler will determine whether it can convert the value from the current type to the desired type. If a valid conversion can be found, then the compiler will produce a new value of the desired type. Note that type conversions don’t change the value or type of the value or object being converted.</p><p>If the compiler can’t find an acceptable conversion, then the compilation will fail with a compile error. Type conversions can fail for any number of reasons. For example, the compiler might not know how to convert a value between the original type and the desired type. In other cases, statements may disallow certain types of conversions. For example:</p><pre class="language-cpp line-numbers"><code>int x { 3.5 }; // brace-initialization disallows conversions that result in data loss</code></pre><p>Even though the compiler knows how to convert a <code>double</code> value to an <code>int</code> value, such conversions are disallowed when using brace-initialization.</p><p>There are also cases where the compiler may not be able to figure out which of several possible type conversions is unambiguously the best one to use. We’ll see examples of this in lesson <a href="https://www.learncpp.com/cpp-tutorial/function-overload-resolution-and-ambiguous-matches/">8.11 -- Function overload resolution and ambiguous matches</a>.</p><p>So how does the compiler actually determine whether it can convert a value from one type to another?</p><br><h3>The standard conversions</h3><p>The C++ language standard defines how different fundamental types (and in some cases, compound types) can be converted to other types. These conversion rules are called the <span class="cpp-definition">standard conversions</span>.</p><p>The standard conversions can be broadly divided into 4 categories, each covering different types of conversions:</p><ul><li>Numeric promotions (covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/floating-point-and-integral-promotion/">8.2 -- Floating-point and integral promotion</a>)</li><li>Numeric conversions (covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/numeric-conversions/">8.3 -- Numeric conversions</a>)</li><li>Arithmetic conversions (covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/arithmetic-conversions/">8.4 -- Arithmetic conversions</a>)</li><li>Other conversions (which includes various pointer and reference conversions)</li></ul><p>When a type conversion is needed, the compiler will see if there are standard conversions that it can use to convert the value to the desired type. The compiler may apply zero, one, or more than one standard conversions in the conversion process.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>How do you have a type conversion with zero conversions? As an example, on architectures where <code>int</code> and <code>long</code> both have the same size and range, the same sequence of bits is used to represent values of both types. Therefore, no actual conversion is needed to convert a value between those types -- the value can simply be copied.</p></div><p>The full set of rules describing how type conversions work is both lengthy and complicated, and for the most part, type conversion “just works”. In the next set of lessons, we’ll cover the most important things you need to know about type conversions. If finer detail is required for some uncommon case, the full rules are detailed in <a href="https://en.cppreference.com/w/cpp/language/implicit_conversion">technical reference documentation for implicit conversions</a>.</p><p>Let’s get to it!</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">8.2 — Floating-point and integral promotion</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/object-sizes-and-the-sizeof-operator/">4.3 -- Object sizes and the sizeof operator</a>, we noted that C++ has minimum size guarantees for each of the fundamental types. However, the actual size of these types can vary based on the compiler and architecture.</p><p>This variability was allowed so that the <code>int</code> and <code>double</code> data types could be set to the size that maximizes performance on a given architecture. For example, a 32-bit computer will typically be able to process 32-bits of data at a time. In such cases, an <code>int</code> would likely be set to a width of 32-bits, since this is the “natural” size of the data that the CPU operates on (and likely to be the most performant).</p><div class="cpp-note cpp-lightgraybackground"><h4>A reminder</h4><p>The number of bits a data type uses is called its width. A wider data type is one that uses more bits, and a narrower data type is one that uses less bits.</p></div><p>But what happens when we want our 32-bit CPU to modify an 8-bit value (such as a <code>char</code>) or a 16-bit value? Some 32-bit processors (such as the x86 series) can manipulate 8-bit or 16-bit values directly. However, doing so is often slower than manipulating 32-bit values! Other 32-bit CPUs (like the PowerPC), can only operate on 32-bit values, and additional tricks must be employed to manipulate narrower values.</p><br><h3>Numeric promotion</h3><p>Because C++ is designed to be portable and performant across a wide range of architectures, the language designers did not want to assume a given CPU would be able to efficiently manipulate values that were narrower than the natural data size for that CPU.</p><p>To help address this challenge, C++ defines a category of type conversions informally called the <code>numeric promotions</code>. A <span class="cpp-definition">numeric promotion</span> is the type conversion of a narrower numeric type (such as a <code>char</code>) to a wider numeric type (typically <code>int</code> or <code>double</code>) that can be processed efficiently and is less likely to have a result that overflows.</p><p>All numeric promotions are <span class="cpp-definition">value-preserving</span>, which means that all values in the original type are representable without loss of data or precision in the new type. Because such promotions are safe, the compiler will freely use numeric promotion as needed, and will not issue a warning when doing so.</p><br><h3>Numeric promotion reduces redundancy</h3><p>Numeric promotion solves another problem as well. Consider the case where you wanted to write a function to print a value of type <code>int</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printInt(int x)</code><code>{</code><code>    std::cout &lt;&lt; x &lt;&lt; '\n';</code><code>}</code></pre><p>While this is straightforward, what happens if we want to also be able to print a value of type <code>short</code>, or type <code>char</code>? If type conversions did not exist, we’d have to write a different print function for <code>short</code> and another one for <code>char</code>. And don’t forget another version for <code>unsigned char</code>, <code>signed char</code>, <code>unsigned short</code>, <code>wchar_t</code>, <code>char8_t</code>, <code>char16_t</code>, and <code>char32_t</code>! You can see how this quickly becomes unmanageable.</p><p>Numeric promotion comes to the rescue here: we can write functions that have <code>int</code> and/or <code>double</code> parameters (such as the <code>printInt()</code> function above). That same code can then be called with arguments of types that can be numerically promoted to match the types of the function parameters.</p><br><h3>Numeric promotion categories</h3><p>The numeric promotion rules are divided into two subcategories: <code>integral promotions</code> and <code>floating point promotions</code>.</p><br><h3>Floating point promotions</h3><p>We’ll start with the easier one.</p><p>Using the <span class="cpp-definition">floating point promotion</span> rules, a value of type <code>float</code> can be converted to a value of type <code>double</code>.</p><p>This means we can write a function that takes a <code>double</code> and then call it with either a <code>double</code> or a <code>float</code> value:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printDouble(double d)</code><code>{</code><code>    std::cout &lt;&lt; d &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printDouble(5.0); // no conversion necessary</code><code>    printDouble(4.0f); // numeric promotion of float to double</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the second call to <code>printDouble()</code>, the <code>float</code> literal <code>4.0f</code> is promoted into a <code>double</code>, so that the type of argument matches the type of the function parameter.</p><br><h3>Integral promotions</h3><p>The integral promotion rules are more complicated.</p><p>Using the <span class="cpp-definition">integral promotion</span> rules, the following conversions can be made:</p><ul><li>signed char or signed short can be converted to int.</li><li>unsigned char, char8_t, and unsigned short can be converted to int if int can hold the entire range of the type, or unsigned int otherwise.</li><li>If char is signed by default, it follows the signed char conversion rules above. If it is unsigned by default, it follows the unsigned char conversion rules above.</li><li>bool can be converted to int, with false becoming 0 and true becoming 1.</li></ul><p>There are a few other integral promotion rules that are used less often. These can be found at <a href="https://en.cppreference.com/w/cpp/language/implicit_conversion#Integral_promotion">https://en.cppreference.com/w/cpp/language/implicit_conversion#Integral_promotion</a>.</p><p>In most cases, this lets us write a function taking an <code>int</code> parameter, and then use it with a wide variety of other integral types. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printInt(int x)</code><code>{</code><code>    std::cout &lt;&lt; x &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printInt(2);</code><code></code><code>    short s{ 3 }; // there is no short literal suffix, so we'll use a variable for this one</code><code>    printInt(s); // numeric promotion of short to int</code><code></code><code>    printInt('a'); // numeric promotion of char to int</code><code>    printInt(true); // numeric promotion of bool to int</code><code></code><code>    return 0;</code><code>}</code></pre><p>There are two things worth noting here. First, on some systems, some of the integral types may be converted to <code>unsigned int</code> rather than <code>int</code>. Second, some narrower unsigned types (such as <code>unsigned char</code>) will be converted to larger signed types (such as <code>int</code>). So while integral promotion is value-preserving, it does not necessarily preserve the signedness (signed/unsigned) of the type.</p><br><h3>Not all value-preserving conversions are numeric promotions</h3><p>Some value-preserving type conversions (such as <code>char</code> to <code>short</code>, <code>int</code> to <code>long</code>, or <code>int</code> to <code>double</code>) are not considered to be numeric promotions in C++ (they are <code>numeric conversions</code>, which we’ll cover shortly in lesson <a href="https://www.learncpp.com/cpp-tutorial/numeric-conversions/">8.3 -- Numeric conversions</a>). This is because such conversions do not assist in the goal of converting smaller types to larger types that can be processed more efficiently.</p><p>The distinction is mostly academic. However, in certain cases, the compiler will favor numeric promotions over numeric conversions. We’ll see examples where this makes a difference when we cover function overload resolution (in upcoming lesson <a href="https://www.learncpp.com/cpp-tutorial/function-overload-resolution-and-ambiguous-matches/">8.11 -- Function overload resolution and ambiguous matches</a>).</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">8.3 — Numeric conversions</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson (<a href="https://www.learncpp.com/cpp-tutorial/floating-point-and-integral-promotion/">8.2 -- Floating-point and integral promotion</a>), we covered numeric promotions, which are conversions of specific narrower numeric types to wider numeric types (typically <code>int</code> or <code>double</code>) that can be processed efficiently.</p><p>C++ supports another category of numeric type conversions, called <span class="cpp-definition">numeric conversions</span>, that cover additional type conversions not covered by the numeric promotion rules.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Any type conversion covered by the numeric promotion rules (<a href="https://www.learncpp.com/cpp-tutorial/floating-point-and-integral-promotion/">8.2 -- Floating-point and integral promotion</a>) is a numeric promotion, not a numeric conversion.</p></div><p>There are five basic types of numeric conversions.</p><ol start="1"><li>Converting an integral type to any other integral type (excluding integral promotions):</li></ol><pre class="language-cpp line-numbers"><code>short s = 3; // convert int to short</code><code>long l = 3; // convert int to long</code><code>char ch = s; // convert short to char</code></pre><ol start="2"><li>Converting a floating point type to any other floating point type (excluding floating point promotions):</li></ol><pre class="language-cpp line-numbers"><code>float f = 3.0; // convert double to float</code><code>long double ld = 3.0; // convert double to long double</code></pre><ol start="3"><li>Converting a floating point type to any integral type:</li></ol><pre class="language-cpp line-numbers"><code>int i = 3.5; // convert double to int</code></pre><ol start="4"><li>Converting an integral type to any floating point type:</li></ol><pre class="language-cpp line-numbers"><code>double d = 3; // convert int to double</code></pre><ol start="5"><li>Converting an integral type or a floating point type to a bool:</li></ol><pre class="language-cpp line-numbers"><code>bool b1 = 3; // convert int to bool</code><code>bool b2 = 3.0; // convert double to bool</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>Because brace initialization disallows some numeric conversions (more on this in a moment), we use copy initialization in this lesson (which does not have any such limitations) in order to keep the examples simple.</p></div><br><h3>Narrowing conversions</h3><p>Unlike a numeric promotion (which is always safe), a numeric conversion may (or may not) result in the loss of data or precision.</p><p>Some numeric conversions are always safe (such as <code>int</code> to <code>long</code>, or <code>int</code> to <code>double</code>). Other numeric conversions, such as <code>double</code> to <code>int</code>, may result in the loss of data (depending on the specific value being converted and/or the range of the underlying types):</p><pre class="language-cpp line-numbers"><code>int i1 = 3.5; // the 0.5 is dropped, resulting in lost data</code><code>int i2 = 3.0; // okay, will be converted to value 3, so no data is lost</code></pre><p>In C++, a <span class="cpp-definition">narrowing conversion</span> is a numeric conversion that may result in the loss of data. Such narrowing conversions include:</p><ul><li>From a floating point type to an integral type.</li><li>From a wider floating point type to a narrower floating point type, unless the value being converted is constexpr and is in range of the destination type (even if the narrower type doesn’t have the precision to store the whole number).</li><li>From an integral to a floating point type, unless the value being converted is constexpr and is in range of the destination type and can be converted back into the original type without data loss.</li><li>From a wider integral type to a narrower integral type, unless the value being converted is constexpr and after integral promotion will fit into the destination type.</li></ul><p>The good news is that you don’t need to remember these. Your compiler will usually issue a warning (or error) when it determines that an implicit narrowing conversion is required.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Compilers will often <em>not</em> warn when converting a signed int to an unsigned int, or vice-versa, even though these are narrowing conversions. Be extra careful of inadvertent conversions between these types (particularly when passing an argument to a function taking a parameter of the opposite sign).</p></div><p>For example, when compiling the following program:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int i = 3.5;</code><code>}</code></pre><p>Visual Studio produces the following warning:</p><pre>warning C4244: 'initializing': conversion from 'double' to 'int', possible loss of data
</pre><p>In general, narrowing conversions should be avoided, but there are situational cases where you might need to do one. In such cases, you should make the implicit narrowing conversion explicit by using <code>static_cast</code>. For example:</p><pre class="language-cpp line-numbers"><code>void someFcn(int i)</code><code>{</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    double d{ 5.0 };</code><code>    </code><code>    someFcn(d); // bad: will generate compiler warning about narrowing conversion</code><code>    someFcn(static_cast<int>(d)); // good: we're explicitly telling the compiler this narrowing conversion is expected, no warning generated</int></code><code>    </code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Avoid narrowing conversions whenever possible. If you do need to perform one, use <code>static_cast</code> to make it an explicit conversion.</p></div><br><h3>Brace initialization disallows narrowing conversions</h3><p>Narrowing conversions are strictly disallowed when using brace initialization (which is one of the primary reasons this initialization form is preferred):</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int i { 3.5 }; // won't compile</code><code>}</code></pre><p>Visual Studio produces the following error:</p><pre>error C2397: conversion from 'double' to 'int' requires a narrowing conversion
</pre><br><h3>More on numeric conversions</h3><p>The specific rules for numeric conversions are complicated and numerous, so here are the most important things to remember.</p><p>In <em>all</em> cases, converting a value into a type whose range doesn’t support that value will lead to results that are probably unexpected. For example:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int i{ 30000 };</code><code>    char c = i; // chars have range -128 to 127</code><code></code><code>    std::cout &lt;&lt; static_cast<int>(c);</int></code><code></code><code>    return 0;</code><code>}</code></pre><p>In this example, we’ve assigned a large integer to a variable with type <code>char</code> (that has range -128 to 127). This causes the char to overflow, and produces an unexpected result:</p><pre>48
</pre><p>Converting from a larger integral or floating point type to a smaller type from the same family will generally work so long as the value fits in the range of the smaller type. For example:</p><pre class="language-cpp line-numbers"><code>    int i{ 2 };</code><code>    short s = i; // convert from int to short</code><code>    std::cout &lt;&lt; s &lt;&lt; '\n';</code><code></code><code>    double d{ 0.1234 };</code><code>    float f = d;</code><code>    std::cout &lt;&lt; f &lt;&lt; '\n';</code></pre><p>This produces the expected result:</p><pre>2
0.1234
</pre><p>In the case of floating point values, some rounding may occur due to a loss of precision in the smaller type. For example:</p><pre class="language-cpp line-numbers"><code>    float f = 0.123456789; // double value 0.123456789 has 9 significant digits, but float can only support about 7</code><code>    std::cout &lt;&lt; std::setprecision(9) &lt;&lt; f &lt;&lt; '\n'; // std::setprecision defined in iomanip header</code></pre><p>In this case, we see a loss of precision because the <code>float</code> can’t hold as much precision as a <code>double</code>:</p><pre>0.123456791
</pre><p>Converting from an integer to a floating point number generally works as long as the value fits within the range of the floating point type. For example:</p><pre class="language-cpp line-numbers"><code>    int i{ 10 };</code><code>    float f = i;</code><code>    std::cout &lt;&lt; f;</code></pre><p>This produces the expected result:</p><pre>10
</pre><p>Converting from a floating point to an integer works as long as the value fits within the range of the integer, but any fractional values are lost. For example:</p><pre class="language-cpp line-numbers"><code>    int i = 3.5;</code><code>    std::cout &lt;&lt; i &lt;&lt; '\n';</code></pre><p>In this example, the fractional value (.5) is lost, leaving the following result:</p><pre>3
</pre><p>While the numeric conversion rules might seem scary, in reality the compiler will generally warn you if you try to do something dangerous (excluding some signed/unsigned conversions).</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">8.4 — Arithmetic conversions</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/operator-precedence-and-associativity/">5.1 -- Operator precedence and associativity</a>, we discussed how expressions are evaluated according to the precedence and associativity of their operators.</p><p>Consider the following expression:</p><pre class="language-cpp line-numbers"><code>int x { 2 + 3 };</code></pre><p>When binary operator+ is invoked, it is given two operands, both of type <code>int</code>. Because both operands are of the same type, that type will be used to perform the calculation and to return the result. Thus, <code>2 + 3</code> will evaluate to <code>int</code> value <code>5</code>.</p><p>But what happens when the operands of a binary operator are of different types?</p><pre class="language-cpp line-numbers"><code>??? y { 2 + 3.5 };</code></pre><p>In this case, operator+ is being given one operand of type <code>int</code> and another of type <code>double</code>. Should the result of the operator be returned as an <code>int</code>, a <code>double</code>, or possibly something else altogether? When defining a variable, we can choose what type it has. In other cases, for example when using <code>std::cout &lt;&lt;</code>, the type the calculation evaluates to changes the behavior of what is output.</p><p>In C++, certain operators require that their operands be of the same type. If one of these operators is invoked with operands of different types, one or both of the operands will be implicitly converted to matching types using a set of rules called the <span class="cpp-definition">usual arithmetic conversions</span>.</p><br><h3>The operators that require operands of the same type</h3><p>The following operators require their operands to be of the same type:</p><ul><li>The binary arithmetic operators: +, -, *, /, %</li><li>The binary relational operators: &lt;, &gt;, &lt;=, &gt;=, ==, !=</li><li>The binary bitwise arithmetic operators: &amp;, ^, |</li><li>The conditional operator ?: (excluding the condition, which is expected to be of type <code>bool</code>)</li></ul><br><h3>The usual arithmetic conversion rules</h3><p>The usual arithmetic conversion rules are pretty simple. The compiler has a prioritized list of types that looks something like this:</p><ul><li>long double (highest)</li><li>double</li><li>float</li><li>unsigned long long</li><li>long long</li><li>unsigned long</li><li>long</li><li>unsigned int</li><li>int (lowest)</li></ul><p>There are only two rules:</p><ul><li>If the type of at least one of the operands is on the priority list, the operand with lower priority is converted to the type of the operand with higher priority.</li><li>Otherwise (the type of neither operand is on the list), both operands are numerically promoted (see <a href="https://www.learncpp.com/cpp-tutorial/floating-point-and-integral-promotion/">8.2 -- Floating-point and integral promotion</a>).</li></ul><br><h3>Some examples</h3><p>In the following examples, we’ll use the <code>typeid</code> operator (included in the <code><typeinfo></typeinfo></code> header), to show the resulting type of an expression.</p><p>First, let’s add an <code>int</code> and a <code>double</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <typeinfo> // for typeid()</typeinfo></code><code></code><code>int main()</code><code>{</code><code>    int i{ 2 };</code><code>    double d{ 3.5 };</code><code>    std::cout &lt;&lt; typeid(i + d).name() &lt;&lt; ' ' &lt;&lt; i + d &lt;&lt; '\n'; // show us the type of i + d</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this case, the <code>double</code> operand has the highest priority, so the lower priority operand (of type <code>int</code>) is type converted to <code>double</code> value <code>2.0</code>. Then <code>double</code> values <code>2.0</code> and <code>3.5</code> are added to produce <code>double</code> result <code>5.5</code>.</p><p>On the author’s machine, this prints:</p><pre>double 5.5
</pre><p>Note that your compiler may display something slightly different, as the output of <code>typeid.name()</code> is left up to the compiler.</p><p>Now let’s add two values of type <code>short</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <typeinfo> // for typeid()</typeinfo></code><code></code><code>int main()</code><code>{</code><code>    short a{ 4 };</code><code>    short b{ 5 };</code><code>    std::cout &lt;&lt; typeid(a + b).name() &lt;&lt; ' ' &lt;&lt; a + b &lt;&lt; '\n'; // show us the type of a + b</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because neither operand appears on the priority list, both operands undergo integral promotion to type <code>int</code>. The result of adding two <code>ints</code> is an <code>int</code>, as you would expect:</p><pre>int 9
</pre><br><h3>Signed and unsigned issues</h3><p>This prioritization hierarchy can cause some problematic issues when mixing signed and unsigned values. For example, take a look at the following code:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <typeinfo> // for typeid()</typeinfo></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; typeid(5u-10).name() &lt;&lt; ' ' &lt;&lt; 5u - 10 &lt;&lt; '\n'; // 5u means treat 5 as an unsigned integer</code><code></code><code>    return 0;</code><code>}</code></pre><p>You might expect the expression <code>5u - 10</code> to evaluate to <code>-5</code> since <code>5 - 10</code> = <code>-5</code>. But here’s what actually results:</p><pre>unsigned int 4294967291
</pre><p>Because the <code>unsigned int</code> operand has higher priority, the <code>int</code> operand is converted to an <code>unsigned int</code>. And since the value <code>-5</code> is out of range of an <code>unsigned int</code>, we get a result we don’t expect.</p><p>Here’s another example showing a counterintuitive result:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; std::boolalpha &lt;&lt; (-3 &lt; 5u) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>While it’s clear to us that <code>5</code> is greater than <code>-3</code>, when this expression evaluates, <code>-3</code> is converted to a large <code>unsigned int</code> that is larger than <code>5</code>. Thus, the above prints <code>false</code> rather than the expected result of <code>true</code>.</p><p>This is one of the primary reasons to avoid unsigned integers -- when you mix them with signed integers in arithmetic expressions, you’re at risk for unexpected results. And the compiler probably won’t even issue a warning.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">8.5 — Explicit type conversion (casting) and static_cast</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/implicit-type-conversion-coercion/">8.1 -- Implicit type conversion (coercion)</a>, we discussed that the compiler can implicitly convert a value from one data type to another through a system called <code>implicit type conversion</code>. When you want to numerically promote a value from one data type to a wider data type, using implicit type conversion is fine.</p><p>Many new C++ programmers try something like this:</p><pre class="language-cpp line-numbers"><code>double d = 10 / 4; // does integer division, initializes d with value 2.0</code></pre><p>Because <code>10</code> and <code>4</code> are both of type <code>int</code>, integer division is performed, and the expression evaluates to <code>int</code> value <code>2</code>. This value then undergoes numeric conversion to <code>double</code> value <code>2.0</code> before being used to initialize variable <code>d</code>. Most likely, this isn’t what was intended.</p><p>In the case where you are using literal operands, replacing one or both of the integer literals with double literals will cause floating point division to happen instead:</p><pre class="language-cpp line-numbers"><code>double d = 10.0 / 4.0; // does floating point division, initializes d with value 2.5</code></pre><p>But what if you are using variables instead of literals? Consider this case:</p><pre class="language-cpp line-numbers"><code>int x { 10 };</code><code>int y { 4 };</code><code>double d = x / y; // does integer division, initializes d with value 2.0</code></pre><p>Because integer division is used here, variable <code>d</code> will end up with the value of <code>2.0</code>. How do we tell the compiler that we want to use floating point division instead of integer division in this case? Literal suffixes can’t be used with variables. We need some way to convert one (or both) of the variable operands to a floating point type, so that floating point division will be used instead.</p><p>Fortunately, C++ comes with a number of different <span class="cpp-definition">type casting operators</span> (more commonly called <span class="cpp-definition">casts</span>) that can be used by the programmer to request that the compiler perform a type conversion. Because casts are explicit requests by the programmer, this form of type conversion is often called an <span class="cpp-definition">explicit type conversion</span> (as opposed to implicit type conversion, where the compiler performs a type conversion automatically).</p><br><h3>Type casting</h3><p>C++ supports 5 different types of casts: <code>C-style casts</code>, <code>static casts</code>, <code>const casts</code>, <code>dynamic casts</code>, and <code>reinterpret casts</code>. The latter four are sometimes referred to as <span class="cpp-definition">named casts</span>.</p><p>We’ll cover <code>C-style casts</code> and <code>static casts</code> in this lesson.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We discuss dynamic casts in lesson <a href="https://www.learncpp.com/cpp-tutorial/dynamic-casting/">18.10 -- Dynamic casting</a>, after we’ve covered other prerequisite topics.</p></div><p><code>Const casts</code> and <code>reinterpret casts</code> should generally be avoided because they are only useful in rare cases and can be harmful if used incorrectly.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Avoid const casts and reinterpret casts unless you have a very good reason to use them.</p></div><br><h3>C-style casts</h3><p>In standard C programming, casts are done via the () operator, with the name of the type to convert the value placed inside the parenthesis. You may still see these used in code (or by programmers) that have been converted from C.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x { 10 };</code><code>    int y { 4 };</code><code></code><code>    </code><code>    double d { (double)x / y }; // convert x to a double so we get floating point division</code><code>    std::cout &lt;&lt; d; // prints 2.5</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above program, we use a C-style cast to tell the compiler to convert <code>x</code> to a <code>double</code>. Because the left operand of operator/ now evaluates to a floating point value, the right operand will be converted to a floating point value as well, and the division will be done using floating point division instead of integer division!</p><p>C++ will also let you use a <code>C-style cast</code> with a more function-call like syntax:</p><pre class="language-cpp line-numbers"><code>    double d { double(x) / y }; // convert x to a double so we get floating point division</code></pre><p>This performs identically to the prior example, but has the benefit of parenthesizing the value being converted (making it easier to tell what is being converted).</p><p>Although a <code>C-style cast</code> appears to be a single cast, it can actually perform a variety of different conversions depending on context. This can include a <code>static cast</code>, a <code>const cast</code> or a <code>reinterpret cast</code> (the latter two of which we mentioned above you should avoid). As a result, <code>C-style casts</code> are at risk for being inadvertently misused and not producing the expected behavior, something which is easily avoidable by using the C++ casts instead.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>If you’re curious, <a href="https://anteru.net/blog/2007/c-background-static-reinterpret-and-c-style-casts/">this article</a> has more information on how C-style casts actually work.</p></div><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Avoid using C-style casts.</p></div><br><h3>static_cast</h3><p>C++ introduces a casting operator called <span class="cpp-definition">static_cast</span>, which can be used to convert a value of one type to a value of another type.</p><p>You’ve previously seen <code>static_cast</code> used to convert a <code>char</code> into an <code>int</code> so that std::cout prints it as an integer instead of a <code>char</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    char c { 'a' };</code><code>    std::cout &lt;&lt; c &lt;&lt; ' ' &lt;&lt; static_cast<int>(c) &lt;&lt; '\n'; // prints a 97</int></code><code></code><code>    return 0;</code><code>}</code></pre><p>The <code>static_cast</code> operator takes an expression as input, and returns the evaluated value converted to the type specified inside the angled brackets. <code>static_cast</code> is best used to convert one fundamental type into another.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x { 10 };</code><code>    int y { 4 };</code><code></code><code>    // static cast x to a double so we get floating point division</code><code>    double d { static_cast<double>(x) / y };  </double></code><code>    std::cout &lt;&lt; d; // prints 2.5</code><code></code><code>    return 0;</code><code>}</code></pre><p>The main advantage of <code>static_cast</code> is that it provides compile-time type checking, making it harder to make an inadvertent error. <code>static_cast</code> is also (intentionally) less powerful than <code>C-style casts</code>, so you can’t inadvertently remove <code>const</code> or do other things you may not have intended to do.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Favor static_cast when you need to convert a value from one type to another type.</p></div><br><h3>Using static_cast to make narrowing conversions explicit</h3><p>Compilers will often issue warnings when a potentially unsafe (narrowing) implicit type conversion is performed. For example, consider the following program:</p><pre class="language-cpp line-numbers"><code>int i { 48 };</code><code>char ch = i; // implicit narrowing conversion</code></pre><p>Casting an <code>int</code> (2 or 4 bytes) to a <code>char</code> (1 byte) is potentially unsafe (as the compiler can’t tell whether the integer value will overflow the range of the <code>char</code> or not), and so the compiler will typically print a warning. If we used list initialization, the compiler would yield an error.</p><p>To get around this, we can use a static cast to explicitly convert our integer to a <code>char</code>:</p><pre class="language-cpp line-numbers"><code>int i { 48 };</code><code></code><code>// explicit conversion from int to char, so that a char is assigned to variable ch</code><code>char ch { static_cast<char>(i) };</char></code></pre><p>When we do this, we’re explicitly telling the compiler that this conversion is intended, and we accept responsibility for the consequences (e.g. overflowing the range of a <code>char</code> if that happens). Since the output of this <code>static_cast</code> is of type <code>char</code>, the initialization of variable <code>ch</code> doesn’t generate any type mismatches, and hence no warnings or errors.</p><p>Here’s another example where the compiler will typically complain that converting a <code>double</code> to an <code>int</code> may result in loss of data:</p><pre class="language-cpp line-numbers"><code>int i { 100 };</code><code>i = i / 2.5;</code></pre><p>To tell the compiler that we explicitly mean to do this:</p><pre class="language-cpp line-numbers"><code>int i { 100 };</code><code>i = static_cast<int>(i / 2.5);</int></code></pre><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>What’s the difference between implicit and explicit type conversion?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>Implicit type conversion is automatically performed whenever one data type is expected, but a different data type is supplied.<br>Explicit type conversion happens when the programmer uses a type cast to explicitly convert a value from one type to another type.</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">8.6 — Typedefs and type aliases</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Type aliases</h3><p>In C++, <span class="cpp-definition">using</span> is a keyword that creates an alias for an existing data type. To create such a type alias, we use the <code>using</code> keyword, followed by a name for the type alias, followed by an equals sign and an existing data type. For example:</p><pre class="language-cpp line-numbers"><code>using Distance = double; // define Distance as an alias for type double</code></pre><p>Once defined, a type alias can be used anywhere a type is needed. For example, we can create a variable with the type alias name as the type:</p><pre class="language-cpp line-numbers"><code>Distance milesToDestination{ 3.4 }; // defines a variable of type double</code></pre><p>When the compiler encounters a type alias name, it will substitute in the aliased type. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    using Distance = double; // define Distance as an alias for type double</code><code></code><code>    Distance milesToDestination{ 3.4 }; // defines a variable of type double</code><code></code><code>    std::cout &lt;&lt; milesToDestination &lt;&lt; '\n'; // prints a double value</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>3.4
</pre><p>In the above program, we first define <code>Distance</code> as an alias for type <code>double</code>.</p><p>Next, we define a variable named <code>milesToDestination</code> of type alias <code>Distance</code>. Because the compiler knows <code>Distance</code> is a type alias, it will use the aliased type, which is <code>double</code>. Thus, variable <code>milesToDestination</code> is actually compiled to be a variable of type <code>double</code>, and it will behave as a <code>double</code> in all regards.</p><p>Finally, we print the value of <code>milesToDestination</code>, which prints as a <code>double</code> value.</p><br><h3>Naming type aliases</h3><p>Historically, there hasn’t been a lot of consistency in how type aliases have been named. There are three common naming conventions (and you will run across all of them):</p><ul><li>Type aliases that end in a “_t” suffix (the “_t” is short for “type”). This convention is often used by the standard library for globally scoped type names (like <code>size_t</code> and <code>nullptr_t</code>).</li></ul><p>This convention was inherited from C, and used to be the most popular when defining your own type aliases (and sometimes other types), but has fallen out of favor in modern C++. Note that <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a> reserves the “_t” suffix for globally scoped type names, so using this convention may cause type naming conflicts on POSIX systems.</p><ul><li>Type aliases that end in a “_type” suffix. This convention is used by some standard library types (like <code>std::string</code>) to name nested type aliases (e.g. <code>std::string::size_type</code>).</li></ul><p>But many such nested type aliases do not use a suffix at all (e.g. <code>std::string::iterator</code>), so this usage is inconsistent at best.</p><ul><li>Type aliases that use no suffix.</li></ul><p>In modern C++, the convention is to name type aliases (or any other type) that you define yourself starting with a capital letter, and using no suffix. The capital letter helps differentiate the names of types from the names of variables and functions (which start with a lower case letter), and prevents naming collisions between them.</p><p>When using this naming convention, it is common to see this usage:</p><pre class="language-cpp line-numbers"><code>void printDistance(Distance distance); // Distance is some defined type</code></pre><p>In this case, <code>Distance</code> is the type, and <code>distance</code> is the parameter name. C++ is case-sensitive, so this is fine.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Name your type aliases starting with a capital letter and do not use a suffix (unless you have a specific reason to do otherwise).</p></div><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>Some future lessons in this tutorial series still use the “_t” or “_type” suffix. Please feel free to leave a comment on those lessons so we can make them consistent with best practices.</p></div><br><h3>Type aliases are not distinct types</h3><p>An alias does not actually define a new, distinct type (one that is considered separate from other types) -- it just introduces a new identifier for an existing type. A type alias is completely interchangeable with the aliased type.</p><p>This allows us to do things that are syntactically valid but semantically meaningless. For example:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    using Miles = long; // define Miles as an alias for type long</code><code>    using Speed = long; // define Speed as an alias for type long</code><code></code><code>    Miles distance { 5 }; // distance is actually just a long</code><code>    Speed mhz  { 3200 };  // mhz is actually just a long</code><code></code><code>    // The following is syntactically valid (but semantically meaningless)</code><code>    distance = mhz;</code><code></code><code>    return 0;</code><code>}</code></pre><p>Although conceptually we intend <code>Miles</code> and <code>Speed</code> to have distinct meanings, both are just aliases for type <code>long</code>. This effectively means <code>Miles</code>, <code>Speed</code>, and <code>long</code> can all be used interchangeably. And indeed, when we assign a value of type <code>Speed</code> to a variable of type <code>Miles</code>, the compiler only sees that we’re assigning a value of type <code>long</code> to a variable of type <code>long</code>, and it will not complain.</p><p>Because the compiler does not prevent these kinds of semantic errors for type aliases, we say that aliases are not <span class="cpp-definition">type safe</span>. In spite of that, they are still useful.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Care must be taken not to mix values of aliases that are intended to be semantically distinct.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>Some languages support the concept of a <span class="cpp-definition">strong typedef</span> (or strong type alias). A strong typedef actually creates a new type that has all the original properties of the original type, but the compiler will throw an error if you try to mix values of the aliased type and the strong typedef. As of C++20, C++ does not directly support strong typedefs (though enum classes, covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/scoped-enumerations-enum-classes/">10.4 -- Scoped enumerations (enum classes)</a>, are similar), but there are quite a few 3rd party C++ libraries that implement strong typedef-like behavior.</p></div><br><h3>The scope of a type alias</h3><p>Because scope is a property of an identifier, type alias identifiers follow the same scoping rules as variable identifiers: a type alias defined inside a block has block scope and is usable only within that block, whereas a type alias defined in the global namespace has file scope and is usable to the end of the file. In the above example, <code>Miles</code> and <code>Speed</code> are only usable in the <code>main()</code> function.</p><p>If you need to use one or more type aliases across multiple files, they can be defined in a header file and #included into any code files that needs to use the definition:</p><p>mytypes.h:</p><pre class="language-cpp line-numbers"><code>#ifndef MYTYPES</code><code>#define MYTYPES</code><code></code><code>    using Miles = long;</code><code>    using Speed = long;</code><code></code><code>#endif</code></pre><p>Type aliases #included this way will be imported into the global namespace and thus have global scope.</p><br><h3>Typedefs</h3><p>A <span class="cpp-definition">typedef</span> (which is short for “type definition”) is an older way of creating an alias for a type. To create a typedef alias, we use the <code>typedef</code> keyword:</p><pre class="language-cpp line-numbers"><code>// The following aliases are identical</code><code>typedef long Miles;</code><code>using Miles = long;</code></pre><p>Typedefs are still in C++ for backwards compatibility reasons, but they have been largely replaced by type aliases in modern C++.</p><p>Typedefs have a few syntactical issues. First, it’s easy to forget whether the name of the typedef or the name of the type to alias comes first. Which is correct?</p><pre class="language-cpp line-numbers"><code>typedef Distance double; // incorrect (typedef name first)</code><code>typedef double Distance; // correct (aliased type name first)</code></pre><p>It’s easy to get backwards. Fortunately, in such cases, the compiler will complain.</p><p>Second, the syntax for typedefs can get ugly with more complex types. For example, here is a hard-to-read typedef, along with an equivalent (and slightly easier to read) type alias:</p><pre class="language-cpp line-numbers"><code>typedef int (*FcnType)(double, char); // FcnType hard to find</code><code>using FcnType = int(*)(double, char); // FcnType easier to find</code></pre><p>In the above typedef definition, the name of the new type (<code>FcnType</code>) is buried in the middle of the definition, whereas in the type alias, the name of the new type and the rest of the definition are separated by an equals sign.</p><p>Third, the name “typedef” suggests that a new type is being defined, but that’s not true. A typedef is just an alias.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Prefer type aliases over typedefs.</p></div><br><h3>When should we use type aliases?</h3><p>Now that we’ve covered what type aliases are, let’s talk about what they are useful for.</p><br><h3>Using type aliases for platform independent coding</h3><p>One of the primary uses for type aliases is to hide platform specific details. On some platforms, an <code>int</code> is 2 bytes, and on others, it is 4 bytes. Thus, using <code>int</code> to store more than 2 bytes of information can be potentially dangerous when writing platform independent code.</p><p>Because <code>char</code>, <code>short</code>, <code>int</code>, and <code>long</code> give no indication of their size, it is fairly common for cross-platform programs to use type aliases to define aliases that include the type’s size in bits. For example, <code>int8_t</code> would be an 8-bit signed integer, <code>int16_t</code> a 16-bit signed integer, and <code>int32_t</code> a 32-bit signed integer. Using type aliases in this manner helps prevent mistakes and makes it more clear about what kind of assumptions have been made about the size of the variable.</p><p>In order to make sure each aliased type resolves to a type of the right size, type aliases of this kind are typically used in conjunction with preprocessor directives:</p><pre class="language-cpp line-numbers"><code>#ifdef INT_2_BYTES</code><code>using int8_t = char;</code><code>using int16_t = int;</code><code>using int32_t = long;</code><code>#else</code><code>using int8_t = char;</code><code>using int16_t = short;</code><code>using int32_t = int;</code><code>#endif</code></pre><p>On machines where integers are only 2 bytes, <code>INT_2_BYTES</code> can be #defined, and the program will be compiled with the top set of type aliases. On machines where integers are 4 bytes, leaving <code>INT_2_BYTES</code> undefined will cause the bottom set of type aliases to be used. In this way, as long as <code>INT_2_BYTES</code> is #defined correctly, <code>int8_t</code> will resolve to a 1 byte integer, <code>int16_t</code> will resolve to a 2 bytes integer, and <code>int32_t</code> will resolve to a 4 byte integer (using the combination of <code>char</code>, <code>short</code>, <code>int</code>, and <code>long</code> that is appropriate for the machine the program is being compiled on.</p><p>The fixed-width integer types (such as <code>std::int16_t</code> and <code>std::uint32_t</code>) and the <code>size_t</code> type (both covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/fixed-width-integers-and-size-t/">4.6 -- Fixed-width integers and size_t</a>) are actually just type aliases to various fundamental types.</p><p>This is also why when you print an 8-bit fixed-width integer using <code>std::cout</code>, you’re likely to get a character value. For example:</p><pre class="language-cpp line-numbers"><code>#include <cstdint> // for fixed-width integers</cstdint></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::int8_t x{ 97 }; // int8_t is actually a type alias for a char type</code><code>    std::cout &lt;&lt; x &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>a
</pre><p>Because <code>std::int8_t</code> is typically defined as a type alias for one of the char types, variable <code>x</code> will be defined as a char type. And char types print their values as ASCII characters rather than as integer values.</p><br><h3>Using type aliases to make complex types easier to read</h3><p>Although we have only dealt with simple data types so far, in advanced C++, types can be complicated and lengthy to manually enter on your keyboard. For example, you might see a function and variable defined like this:</p><pre class="language-cpp line-numbers"><code>#include <string> // for std::string</string></code><code>#include <vector> // for std::vector</vector></code><code>#include <utility> // for std::pair</utility></code><code></code><code>bool hasDuplicates(std::vector<std::pair<std::string, int="">&gt; pairlist)</std::pair<std::string,></code><code>{</code><code>    // some code here</code><code>    return false;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>     std::vector<std::pair<std::string, int="">&gt; pairlist;</std::pair<std::string,></code><code></code><code>     return 0;</code><code>}</code></pre><p>Typing <code>std::vector<std::pair<std::string, int="">&gt;</std::pair<std::string,></code> everywhere you need to use that type is cumbersome, and it is easy to make a typing mistake. It’s much easier to use a type alias:</p><pre class="language-cpp line-numbers"><code>#include <string> // for std::string</string></code><code>#include <vector> // for std::vector</vector></code><code>#include <utility> // for std::pair</utility></code><code></code><code>using VectPairSI = std::vector<std::pair<std::string, int="">&gt;; // make VectPairSI an alias for this crazy type</std::pair<std::string,></code><code></code><code>bool hasDuplicates(VectPairSI pairlist) // use VectPairSI in a function parameter</code><code>{</code><code>    // some code here</code><code>    return false;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>     VectPairSI pairlist; // instantiate a VectPairSI variable</code><code></code><code>     return 0;</code><code>}</code></pre><p>Much better! Now we only have to type <code>VectPairSI</code> instead of <code>std::vector<std::pair<std::string, int="">&gt;</std::pair<std::string,></code>.</p><p>Don’t worry if you don’t know what <code>std::vector</code>, <code>std::pair</code>, or all these crazy angle brackets are yet. The only thing you really need to understand here is that type aliases allow you to take complex types and give them a simpler name, which makes your code easier to read and saves typing.</p><p>This is probably the best use for type aliases.</p><br><h3>Using type aliases for legibility</h3><p>Type aliases can also help with code documentation and comprehension.</p><p>With variables, we have the variable’s identifier to help document the purpose of the variable. But consider the case of a function’s return value. Data types such as <code>char</code>, <code>int</code>, <code>long</code>, <code>double</code>, and <code>bool</code> are describe what <em>type</em> a function returns, but more often we want to know what <em>purpose</em> a return value serves.</p><p>For example, given the following function:</p><pre class="language-cpp line-numbers"><code>int gradeTest();</code></pre><p>We can see that the return value is an integer, but what does the integer mean? A letter grade? The number of questions missed? The student’s ID number? An error code? Who knows! The return type of <code>int</code> does not tell us much. If we’re lucky, documentation for the function exists somewhere that we can reference. If we’re unlucky, we have to read the code and infer the purpose.</p><p>Now let’s do an equivalent version using a type alias:</p><pre class="language-cpp line-numbers"><code>using TestScore = int;</code><code>TestScore gradeTest();</code></pre><p>The return type of <code>TestScore</code> makes it a little more obvious that the function is returning a type that represents a test score.</p><p>In our experience, creating a type alias just to document the return type of a single function isn’t worth it (use a comment instead). But if you have multiple functions passing or returning such a type, creating a type alias might be worthwhile.</p><br><h3>Using type aliases for easier code maintenance</h3><p>Type aliases also allow you to change the underlying type of an object without having to update lots of hardcoded types. For example, if you were using a <code>short</code> to hold a student’s ID number, but then later decided you needed a <code>long</code> instead, you’d have to comb through lots of code and replace <code>short</code> with <code>long</code>. It would probably be difficult to figure out which objects of type <code>short</code> were being used to hold ID numbers and which were being used for other purposes.</p><p>However, if you use type aliases, then changing types becomes as simple as updating the type alias (e.g. from <code>using StudentID = short;</code> to <code>using StudentId = long;</code>).</p><p>While this seems like a nice benefit, caution is necessary whenever a type is changed, as the behavior of the program may also change. This is especially true when changing the type of a type alias to a type in a different type family (e.g. an integer to a floating point value, or a sign to )! The new type may have comparison or integer/floating point division issues, or other issues that the old type did not. If you change an existing type to some other type, your code should be thoroughly retested.</p><br><h3>Downsides and conclusion</h3><p>While type aliases offer some benefits, they also introduce yet another identifier into your code that needs to be understood. If this isn’t offset by some benefit to readability or comprehension, then the type alias is doing more harm than good.</p><p>A poorly utilized type alias can take a familiar type (such as <code>std::string</code>) and hide it behind a custom name that needs to be looked up. In some cases (such as with smart pointers, which we’ll cover in a future chapter), obscuring the type information can also be harmful to understanding how the type should be expected to work.</p><p>For this reason, type aliases should be used primarily in cases where there is a clear benefit to code readability or code maintenance. This is as much of an art as a science. Type aliases are most useful when they can be used in many places throughout your code, rather than in fewer places.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use type aliases judiciously, when they provide a clear benefit to code readability or code maintenance.</p></div><br><h3>Quiz time</h3><p class="cpp-quiz-question" style="clear:both">Question #1</p><p>Given the following function prototype:</p><pre class="language-cpp line-numbers"><code>int printData();</code></pre><p>Convert the <code>int</code> return value to a type alias named <code>PrintError</code>. Include both the type alias statement and the updated function prototype.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>using PrintError = int;</code><code></code><code>PrintError printData();</code></pre></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">8.7 — Type deduction for objects using the auto keyword</h1></header><div class="entry-content" itemprop="articleBody"><p>There’s a subtle redundancy lurking in this simple variable definition:</p><pre class="language-cpp line-numbers"><code>double d{ 5.0 };</code></pre><p>Because C++ is a strongly-typed language, we are required to provide an explicit type for all objects. Thus, we’ve specified that variable <code>d</code> is of type double.</p><p>However, the literal value <code>5.0</code> used to initialize <code>d</code> also has type double (implicitly determined via the format of the literal).</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We discuss how literal types are determined in lesson <a href="https://www.learncpp.com/cpp-tutorial/literals/">4.15 -- Literals</a>.</p></div><p>In cases where we want a variable and its initializer to have the same type, we’re effectively providing the same type information twice.</p><br><h3>Type deduction for initialized variables</h3><p><span class="cpp-definition">Type deduction</span> (also sometimes called <span class="cpp-definition">type inference</span>) is a feature that allows the compiler to deduce the type of an object from the object’s initializer. To use type deduction, the <code>auto</code> keyword is used in place of the variable’s type:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    auto d{ 5.0 }; // 5.0 is a double literal, so d will be type double</code><code>    auto i{ 1 + 2 }; // 1 + 2 evaluates to an int, so i will be type int</code><code>    auto x { i }; // i is an int, so x will be type int too</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the first case, because <code>5.0</code> is a double literal, the compiler will deduce that variable <code>d</code> should be of type <code>double</code>. In the second case, the expression <code>1 + 2</code> yields an int result, so variable <code>i</code> will be of type <code>int</code>. In the third case, <code>i</code> was previously deduced to be of type <code>int</code>, so <code>x</code> will also be deduced to be of type <code>int</code>.</p><p>Because function calls are valid expressions, we can even use type deduction when our initializer is a function call:</p><pre class="language-cpp line-numbers"><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    auto sum { add(5, 6) }; // add() returns an int, so sum's type will be deduced to int</code><code>    return 0;</code><code>}</code></pre><p>The <code>add()</code> function returns an int value, so the compiler will deduce that variable <code>sum</code> should have type <code>int</code>.</p><p>Type deduction will not work for objects that do not have initializers or empty initializers. Thus, the following is not valid:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    auto x; // The compiler is unable to deduce the type of x</code><code>    auto y{ }; // The compiler is unable to deduce the type of y</code><code></code><code>    return 0;</code><code>}</code></pre><p>Although using type deduction for fundamental data types only saves a few (if any) keystrokes, in future lessons we will see examples where the types get complex and lengthy (and in some cases, can be hard to figure out). In those cases, using <code>auto</code> can save a lot of typing (and typos).</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>The type deduction rules for pointers and references are a bit more complex. We discuss these in <a href="https://www.learncpp.com/cpp-tutorial/type-deduction-with-pointers-references-and-const/">9.12 -- Type deduction with pointers, references, and const</a>.</p></div><br><h3>Type deduction drops const qualifiers</h3><p>In most cases, type deduction will drop the <code>const</code> qualifier from deduced types. For example:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    const int x { 5 }; // x has type const int</code><code>    auto y { x };      // y will be type int (const is dropped)</code><code>}</code></pre><p>In the above example, <code>x</code> has type <code>const int</code>, but when deducing a type for variable <code>y</code> using <code>x</code> as the initializer, type deduction deduces the type as <code>int</code>, not <code>const int</code>.</p><p>If you want a deduced type to be const, you must supply the const yourself. To do so, simply use the <code>const</code> keyword in conjunction with the <code>auto</code> keyword:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    const int x { 5 };  // x has type const int</code><code>    auto y { x };       // y will be type int (const is dropped)</code><code></code><code>    const auto z { x }; // z will be type const int (const is reapplied)</code><code>}</code></pre><p>In this example, the type deduced from <code>x</code> will be <code>int</code> (the <code>const</code> is dropped), but because we’ve re-added a <code>const</code> qualifier during the definition of variable <code>z</code>, variable <code>z</code> will be a <code>const int</code>.</p><br><h3>Type deduction for string literals</h3><p>For historical reasons, string literals in C++ have a strange type. Therefore, the following probably won’t work as expected:</p><pre class="language-cpp line-numbers"><code>auto s { "Hello, world" }; // s will be type const char*, not std::string</code></pre><p>If you want the type deduced from a string literal to be <code>std::string</code> or <code>std::string_view</code>, you’ll need to use the <code>s</code> or <code>sv</code> literal suffixes (covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/literals/">4.15 -- Literals</a>):</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>int main()</code><code>{</code><code>    using namespace std::literals; // easiest way to access the s and sv suffixes</code><code></code><code>    auto s1 { "goo"s };  // "goo"s is a std::string literal, so s1 will be deduced as a std::string</code><code>    auto s2 { "moo"sv }; // "moo"sv is a std::string_view literal, so s2 will be deduced as a std::string_view</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>Type deduction benefits and downsides</h3><p>Type deduction is not only convenient, but also has a number of other benefits.</p><p>First, if two or more variables are defined on sequential lines, the names of the variables will be lined up, helping to increase readability:</p><pre class="language-cpp line-numbers"><code>// harder to read</code><code>int a { 5 };</code><code>double b { 6.7 };</code><code></code><code>// easier to read</code><code>auto c { 5 };</code><code>auto d { 6.7 };</code></pre><p>Second, type deduction only works on variables that have initializers, so if you are in the habit of using type deduction, it can help avoid unintentionally uninitialized variables:</p><pre class="language-cpp line-numbers"><code>int x; // oops, we forgot to initialize x, but the compiler may not complain</code><code>auto y; // the compiler will error out because it can't deduce a type for y</code></pre><p>Third, you are guaranteed that there will be no unintended performance-impacting conversions:</p><pre class="language-cpp line-numbers"><code>double x { 5 }; // bad: implicitly converts 5 from an int to a double</code><code>auto y { 5 }; // good: y is an int (hopefully that's what you wanted) and no conversion takes place </code></pre><p>Type deduction also has a few downsides.</p><p>First, type deduction obscures an object’s type information in the code. Although a good IDE should be able to show you the deduced type (e.g. when hovering a variable), it’s still a bit easier to make type-based mistakes when using type deduction.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>auto y { 5 }; // oops, we wanted a double here but we accidentally provided an int literal</code></pre><p>In the above code, if we’d explicitly specified <code>y</code> as type double, <code>y</code> would have been a double even though we accidentally provided an int literal initializer. With type deduction, <code>y</code> will be deduced to be of type int.</p><p>Here’s another example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>     auto x { 3 };</code><code>     auto y { 2 };</code><code></code><code>     std::cout &lt;&lt; x / y &lt;&lt; '\n'; // oops, we wanted floating point division here</code><code></code><code>     return 0;</code><code>}</code></pre><p>In this example, it’s less clear that we’re getting an integer division rather than a floating-point division.</p><p>Second, if the type of an initializer changes, the type of a variable using type deduction will also change, perhaps unexpectedly. Consider:</p><pre class="language-cpp line-numbers"><code>auto sum { add(5, 6) + gravity };</code></pre><p>If the return type of <code>add</code> changes from int to double, or <code>gravity</code> changes from int to double, <code>sum</code> will also change types from int to double.</p><p>Overall, the modern consensus is that type deduction is generally safe to use for objects, and that doing so can help make your code more readable by de-emphasizing type information so the logic of your code stands out better.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use type deduction for your variables, unless you need to commit to a specific type.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>In future lessons, we’ll continue to use explicit types instead of type deduction when we feel showing the type information is helpful to understanding a concept or example.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">8.8 — Type deduction for functions</h1></header><div class="entry-content" itemprop="articleBody"><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code></pre><p>When this function is compiled, the compiler will determine that <code>x + y</code> evaluates to an <code>int</code>, then ensure that type of the return value matches the declared return type of the function (or that the return value type can be converted to the declared return type).</p><p>Since the compiler already has to deduce the return type from the return statement, in C++14, the <code>auto</code> keyword was extended to do function return type deduction. This works by using the <code>auto</code> keyword in place of the function’s return type.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>auto add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code></pre><p>Because the return statement is returning an <code>int</code> value, the compiler will deduce that the return type of this function is <code>int</code>.</p><p>When using an <code>auto</code> return type, all return statements within the function must return values of the same type, otherwise an error will result. For example:</p><pre class="language-cpp line-numbers"><code>auto someFcn(bool b)</code><code>{</code><code>    if (b)</code><code>        return 5; // return type int</code><code>    else</code><code>        return 6.7; // return type double</code><code>}</code></pre><p>In the above function, the two return statements return values of different types, so the compiler will give an error.</p><p>If such a case is desired for some reason, you can either explicitly specify a return type for your function (in which case the compiler will try to implicitly convert any non-matching return expressions to the explicit return type), or you can explicitly convert all of your return statements to the same type. In the example above, the latter could be done by changing <code>5</code> to <code>5.0</code>, but <code>static_cast</code> can also be used for non-literal types.</p><p>A major downside of functions that use an <code>auto</code> return type is that such functions must be fully defined before they can be used (a forward declaration is not sufficient). For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>auto foo();</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; foo() &lt;&lt; '\n'; // the compiler has only seen a forward declaration at this point</code><code>    return 0;</code><code>}</code><code></code><code>auto foo()</code><code>{</code><code>    return 5;</code><code>}</code></pre><p>On the author’s machine, this gives the following compile error:</p><pre>error C3779: 'foo': a function that returns 'auto' cannot be used before it is defined.
</pre><p>This makes sense: a forward declaration does not have enough information for the compiler to deduce the function’s return type. This means normal functions that return <code>auto</code> are typically only callable from within the file in which they are defined.</p><p>Unlike type deduction for objects, there isn’t as much consensus on best practices for function return type deduction. When using type deduction with objects, the initializer is always present as part of the same statement, so it’s usually not overly burdensome to determine what type will be deduced. With functions, that is not the case -- when looking at a function’s prototype, there is no context to help indicate what type the function returns. A good programming IDE should make clear what the deduced type of the function is, but in absence of having that available, a user would actually have to dig into the function body itself to determine what type the function returned. The odds of mistakes being made are higher. And the inability for such functions to be forward declared limits their usefulness in multi-file programs.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Favor explicit return types over function return type deduction for normal functions.</p></div><br><h3>Trailing return type syntax</h3><p>The <code>auto</code> keyword can also be used to declare functions using a <span class="cpp-definition">trailing return syntax</span>, where the return type is specified after the rest of the function prototype.</p><p>Consider the following function:</p><pre class="language-cpp line-numbers"><code>int add(int x, int y)</code><code>{</code><code>  return (x + y);</code><code>}</code></pre><p>Using the trailing return syntax, this could be equivalently written as:</p><pre class="language-cpp line-numbers"><code>auto add(int x, int y) -&gt; int</code><code>{</code><code>  return (x + y);</code><code>}</code></pre><p>In this case, <code>auto</code> does not perform type deduction -- it is just part of the syntax to use a trailing return type.</p><p>Why would you want to use this?</p><p>One nice thing is that it makes all of your function names line up:</p><pre class="language-cpp line-numbers"><code>auto add(int x, int y) -&gt; int;</code><code>auto divide(double x, double y) -&gt; double;</code><code>auto printSomething() -&gt; void;</code><code>auto generateSubstring(const std::string &amp;s, int start, int len) -&gt; std::string;</code></pre><p>The trailing return syntax is also required for some advanced features of C++, such as lambdas (which we cover in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-lambdas-anonymous-functions/">12.7 -- Introduction to lambdas (anonymous functions)</a>).</p><p>For now, we recommend the continued use of the traditional function return syntax except in situations that require the trailing return syntax.</p><br><h3>Type deduction can’t be used for function parameter types</h3><p>Many new programmers who learn about type deduction try something like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void addAndPrint(auto x, auto y)</code><code>{</code><code>    std::cout &lt;&lt; x + y &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    addAndPrint(2, 3); // case 1: call addAndPrint with int parameters</code><code>    addAndPrint(4.5, 6.7); // case 2: call addAndPrint with double parameters</code><code>}</code></pre><p>Unfortunately, type deduction doesn’t work for function parameters, and prior to C++20, the above program won’t compile (you’ll get an error about function parameters not being able to have an auto type).</p><p>In C++20, the <code>auto</code> keyword was extended so that the above program will compile and function correctly -- however, <code>auto</code> is not invoking type deduction in this case. Rather, it is triggering a different feature called <code>function templates</code> that was designed to actually handle such cases.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We introduce function templates in lesson <a href="https://www.learncpp.com/cpp-tutorial/function-templates/">8.13 -- Function templates</a>, and discuss use of <code>auto</code> in the context of function templates in lesson <a href="https://www.learncpp.com/cpp-tutorial/function-templates-with-multiple-template-types/">8.15 -- Function templates with multiple template types</a>.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">8.9 — Introduction to function overloading</h1></header><div class="entry-content" itemprop="articleBody"><p>Consider the following function:</p><pre class="language-cpp line-numbers"><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code></pre><p>This trivial function adds two integers and returns an integer result. However, what if we also want a function that can add two floating point numbers? This <code>add()</code> function is not suitable, as any floating point parameters would be converted to integers, causing the floating point arguments to lose their fractional values.</p><p>One way to work around this issue is to define multiple functions with slightly different names:</p><pre class="language-cpp line-numbers"><code>int addInteger(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code><code></code><code>double addDouble(double x, double y)</code><code>{</code><code>    return x + y;</code><code>}</code></pre><p>However, for best effect, this requires that you define a consistent function naming standard for similar functions that have parameters of different types, remember the names of these functions, and actually call the correct one.</p><p>And then what happens when we want to have a similar function that adds 3 integers instead of 2? Managing unique names for each function quickly becomes burdensome.</p><br><h3>Introduction to function overloading</h3><p>Fortunately, C++ has an elegant solution to handle such cases. <span class="cpp-definition">Function overloading</span> allows us to create multiple functions with the same name, so long as each identically named function has different parameter types (or the functions can be otherwise differentiated). Each function sharing a name (in the same scope) is called an <span class="cpp-definition">overloaded function</span> (sometimes called an <span class="cpp-definition">overload</span> for short).</p><p>To overload our <code>add()</code> function, we can simply declare another <code>add()</code> function that takes double parameters:</p><pre class="language-cpp line-numbers"><code>double add(double x, double y)</code><code>{</code><code>    return x + y;</code><code>}</code></pre><p>We now have two versions of <code>add()</code> in the same scope:</p><pre class="language-cpp line-numbers"><code>int add(int x, int y) // integer version</code><code>{</code><code>    return x + y;</code><code>}</code><code></code><code>double add(double x, double y) // floating point version</code><code>{</code><code>    return x + y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    return 0;</code><code>}</code></pre><p>The above program will compile. Although you might expect these functions to result in a naming conflict, that is not the case here. Because the parameter types of these functions differ, the compiler is able to differentiate these functions, and will treat them as separate functions that just happen to share a name.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Functions can be overloaded so long as each overloaded function can be differentiated by the compiler. If an overloaded function can not be differentiated, a compile error will result.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>Because operators in C++ are just functions, operators can also be overloaded. We’ll discuss this in <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-operator-overloading/">14.1 -- Introduction to operator overloading</a>.</p></div><br><h3>Introduction to overload resolution</h3><p>Additionally, when a function call is made to a function that has been overloaded, the compiler will try to match the function call to the appropriate overload based on the arguments used in the function call. This is called <span class="cpp-definition">overload resolution</span>.</p><p>Here’s a simple example demonstrating this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code><code></code><code>double add(double x, double y)</code><code>{</code><code>    return x + y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; add(1, 2); // calls add(int, int)</code><code>    std::cout &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; add(1.2, 3.4); // calls add(double, double)</code><code></code><code>    return 0;</code><code>}</code></pre><p>The above program compiles and produces the result:</p><pre>3
4.6
</pre><p>When we provide integer arguments in the call to <code>add(1, 2)</code>, the compiler will determine that we’re trying to call <code>add(int, int)</code>. And when we provide floating point arguments in the call to <code>add(1.2, 3.4)</code>, the compiler will determine that we’re trying to call <code>add(double, double)</code>.</p><br><h3>Making it compile</h3><p>In order for a program using overloaded functions to compile, two things have to be true:</p><ol><li>Each overloaded function has to be differentiated from the others. We discuss how functions can be differentiated in lesson <a href="https://www.learncpp.com/cpp-tutorial/function-overload-differentiation/">8.10 -- Function overload differentiation</a>.</li><li>Each call to an overloaded function has to resolve to an overloaded function. We discuss how the compiler matches function calls to overloaded functions in lesson <a href="https://www.learncpp.com/cpp-tutorial/function-overload-resolution-and-ambiguous-matches/">8.11 -- Function overload resolution and ambiguous matches</a>.</li></ol><p>If an overloaded function is not differentiated, or if a function call to an overloaded function can not be resolved to an overloaded function, then a compile error will result.</p><p>In the next lesson, we’ll explore how overloaded functions can be differentiated from each other. Then, in the following lesson, we’ll explore how the compiler resolves function calls to overloaded functions.</p><br><h3>Conclusion</h3><p>Function overloading provides a great way to reduce the complexity of your program by reducing the number of function names you need to remember. It can and should be used liberally.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use function overloading to make your program simpler.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">8.10 — Function overload differentiation</h1></header><div class="entry-content" itemprop="articleBody"><p>In the prior lesson (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-function-overloading/">8.9 -- Introduction to function overloading</a>), we introduced the concept of function overloading, which allows us to create multiple functions with the same name, so long as each identically named function has different parameter types (or the functions can be otherwise differentiated).</p><p>In this lesson, we’ll take a closer look at how overloaded functions are differentiated. Overloaded functions that are not properly differentiated will cause the compiler to issue a compile error.</p><br><h3>How overloaded functions are differentiated</h3><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Function property</th><th>Used for differentiation</th><th>Notes</th></tr><tr><td>Number of parameters</td><td>Yes</td><td></td></tr><tr><td>Type of parameters</td><td>Yes</td><td>Excludes typedefs, type aliases, and const qualifier on value parameters. Includes ellipses.</td></tr><tr><td>Return type</td><td>No</td><td></td></tr></tbody></table></div><p>Note that a function’s return type is not used to differentiate overloaded functions. We’ll discuss this more in a bit.</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>For member functions, additional function-level qualifiers are also considered:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Function-level qualifier</th><th>Used for overloading</th></tr><tr><td>const or volatile</td><td>Yes</td></tr><tr><td>Ref-qualifiers</td><td>Yes</td></tr></tbody></table></div><p>As an example, a const member function can be differentiated from an otherwise identical non-const member function (even if they share the same set of parameters).</p></div><br><h3>Overloading based on number of parameters</h3><p>An overloaded function is differentiated so long as each overloaded function has a different number of parameters. For example:</p><pre class="language-cpp line-numbers"><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code><code></code><code>int add(int x, int y, int z)</code><code>{</code><code>    return x + y + z;</code><code>}</code></pre><p>The compiler can easily tell that a function call with two integer parameters should go to <code>add(int, int)</code> and a function call with three integer parameters should go to <code>add(int, int, int)</code>.</p><br><h3>Overloading based on type of parameters</h3><p>A function can also be differentiated so long as each overloaded function’s list of parameter types is distinct. For example, all of the following overloads are differentiated:</p><pre class="language-cpp line-numbers"><code>int add(int x, int y); // integer version</code><code>double add(double x, double y); // floating point version</code><code>double add(int x, double y); // mixed version</code><code>double add(double x, int y); // mixed version</code></pre><p>Because type aliases (or typedefs) are not distinct types, overloaded functions using type aliases are not distinct from overloads using the aliased type. For example, all of the following overloads are not differentiated (and will result in a compile error):</p><pre class="language-cpp line-numbers"><code>typedef int Height; // typedef</code><code>using Age = int; // type alias</code><code></code><code>void print(int value);</code><code>void print(Age value); // not differentiated from print(int)</code><code>void print(Height value); // not differentiated from print(int)</code></pre><p>For parameters passed by value, the const qualifier is also not considered. Therefore, the following functions are not considered to be differentiated:</p><pre class="language-cpp line-numbers"><code>void print(int);</code><code>void print(const int); // not differentiated from print(int)</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>We haven’t covered ellipsis yet, but ellipsis parameters are considered to be a unique type of parameter:</p><pre class="language-cpp line-numbers"><code>void foo(int x, int y);</code><code>void foo(int x, ...); // differentiated from foo(int, int)</code></pre></div><br><h3>The return type of a function is not considered for differentiation</h3><p>A function’s return type is not considered when differentiating overloaded functions.</p><p>Consider the case where you want to write a function that returns a random number, but you need a version that will return an int, and another version that will return a double. You might be tempted to do this:</p><pre class="language-cpp line-numbers"><code>int getRandomValue();</code><code>double getRandomValue();</code></pre><p>On Visual Studio 2019, this results in the following compiler error:</p><pre>error C2556: 'double getRandomValue(void)': overloaded function differs only by return type from 'int getRandomValue(void)'
</pre><p>This makes sense. If you were the compiler, and you saw this statement:</p><pre class="language-cpp line-numbers"><code>getRandomValue();</code></pre><p>Which of the two overloaded functions would you call? It’s not clear.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>This was an intentional choice, as it ensures the behavior of a function call can be determined independently from the rest of the expression, making understanding complex expressions much simpler. Put another way, we can always determine which version of a function will be called based solely on the arguments in the function call. If return values were used for differentiation, then we wouldn’t have an easy syntactic way to tell which overload of a function was being called -- we’d also have to understand how the return value was being used, which requires a lot more analysis.</p></div><p>The best way to address this is to give the functions different names:</p><pre class="language-cpp line-numbers"><code>int getRandomInt();</code><code>double getRandomDouble();</code></pre><br><h3>Type signature</h3><p>A function’s <span class="cpp-definition">type signature</span> (generally called a <span class="cpp-definition">signature</span>) is defined as the parts of the function header that are used for differentiation of the function. In C++, this includes the function name, number of parameter, parameter type, and function-level qualifiers. It notably does <em>not</em> include the return type.</p><br><h3>Name mangling</h3><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>When the compiler compiles a function, it performs <span class="cpp-definition">name mangling</span>, which means the compiled name of the function is altered (“mangled”) based on various criteria, such as the number and type of parameters, so that the linker has unique names to work with.</p><p>For example, some function with prototype <code>int fcn()</code> might compile to name <code>__fcn_v</code>, whereas <code>int fcn(int)</code> might compile to name <code>__fcn_i</code>. So while in the source code, two overloaded functions share a name, in compiled code, the names are actually unique.</p><p>There is no standardization on how names should be mangled, so different compilers will produce different mangled names.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">8.11 — Function overload resolution and ambiguous matches</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson (<a href="https://www.learncpp.com/cpp-tutorial/function-overload-differentiation/">8.10 -- Function overload differentiation</a>), we discussed which attributes of a function are used to differentiate overloaded functions from each other. If an overloaded function is not properly differentiated from the other overloads of the same name, then the compiler will issue a compile error.</p><p>However, having a set of differentiated overloaded functions is only half of the picture. When any function call is made, the compiler must also ensure that a matching function declaration can be found.</p><p>With non-overloaded functions (functions with unique names), there is only one function that can potentially match a function call. That function either matches (or can be made to match after type conversions are applied), or it doesn’t (and a compile error results). With overloaded functions, there can be many functions that can potentially match a function call. Since a function call can only resolve to one of them, the compiler has to determine which overloaded function is the best match. The process of matching function calls to a specific overloaded function is called <span class="cpp-definition">overload resolution</span>.</p><p>In simple cases where the type of the function arguments and type of the function parameters match exactly, this is (usually) straightforward:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print(int x)</code><code>{</code><code>     std::cout &lt;&lt; x &lt;&lt; '\n';</code><code>}</code><code></code><code>void print(double d)</code><code>{</code><code>     std::cout &lt;&lt; d &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>     print(5); // 5 is an int, so this matches print(int)</code><code>     print(6.7); // 6.7 is a double, so this matches print(double)</code><code></code><code>     return 0;</code><code>}</code></pre><p>But what happens in cases where the argument types in the function call don’t exactly match the parameter types in any of the overloaded functions? For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print(int x)</code><code>{</code><code>     std::cout &lt;&lt; x &lt;&lt; '\n';</code><code>}</code><code></code><code>void print(double d)</code><code>{</code><code>     std::cout &lt;&lt; d &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>     print('a'); // char does not match int or double</code><code>     print(5L); // long does not match int or double</code><code></code><code>     return 0;</code><code>}</code></pre><p>Just because there is no exact match here doesn’t mean a match can’t be found -- after all, a <code>char</code> or <code>long</code> can be implicitly type converted to an <code>int</code> or a <code>double</code>. But which is the best conversion to make in each case?</p><p>In this lesson, we’ll explore how the compiler matches a given function call to a specific overloaded function.</p><br><h3>Resolving overloaded function calls</h3><p>When a function call is made to an overloaded function, the compiler steps through a sequence of rules to determine which (if any) of the overloaded functions is the best match.</p><p>At each step, the compiler applies a bunch of different type conversions to the argument(s) in the function call. For each conversion applied, the compiler checks if any of the overloaded functions are now a match. After all the different type conversions have been applied and checked for matches, the step is done. The result will be one of three possible outcomes:</p><ul><li>No matching functions were found. The compiler moves to the next step in the sequence.</li><li>A single matching function was found. This function is considered to be the best match. The matching process is now complete, and subsequent steps are not executed.</li><li>More than one matching function was found. The compiler will issue an ambiguous match compile error. We’ll discuss this case further in a bit.</li></ul><p>If the compiler reaches the end of the entire sequence without finding a match, it will generate a compile error that no matching overloaded function could be found for the function call.</p><br><h3>The argument matching sequence</h3><p>Step 1) The compiler tries to find an exact match. This happens in two phases. First, the compiler will see if there is an overloaded function where the type of the arguments in the function call exactly matches the type of the parameters in the overloaded functions. For example:</p><pre class="language-cpp line-numbers"><code>void print(int)</code><code>{</code><code>}</code><code></code><code>void print(double)</code><code>{</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    print(0); // exact match with print(int)</code><code>    print(3.4); // exact match with print(double)</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because the <code>0</code> in the function call <code>print(0)</code> is an int, the compiler will look to see if a <code>print(int)</code> overload has been declared. Since it has, the compiler determines that <code>print(int)</code> is an exact match.</p><p>Second, the compiler will apply a number of trivial conversions to the arguments in the function call. The <span class="cpp-definition">trivial conversions</span> are a set of specific conversion rules that will modify types (without modifying the value) for purposes of finding a match. For example, a non-const type can be trivially converted to a const type:</p><pre class="language-cpp line-numbers"><code>void print(const int)</code><code>{</code><code>}</code><code></code><code>void print(double)</code><code>{</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x { 0 };</code><code>    print(x); // x trivially converted to const int</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, we’ve called <code>print(x)</code>, where <code>x</code> is an <code>int</code>. The compiler will trivially convert <code>x</code> from an <code>int</code> into a <code>const int</code>, which then matches <code>print(const int)</code>.</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>Converting a non-reference type to a reference type (or vice-versa) is also a trivial conversion.</p></div><p>Matches made via the trivial conversions are considered exact matches.</p><p>Step 2) If no exact match is found, the compiler tries to find a match by applying numeric promotion to the argument(s). In lesson (<a href="https://www.learncpp.com/cpp-tutorial/implicit-type-conversion-coercion/">8.1 -- Implicit type conversion (coercion)</a>), we covered how certain narrow integral and floating point types can be automatically promoted to wider types, such as <code>int</code> or <code>double</code>. If, after numeric promotion, a match is found, the function call is resolved.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>void print(int)</code><code>{</code><code>}</code><code></code><code>void print(double)</code><code>{</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    print('a'); // promoted to match print(int)</code><code>    print(true); // promoted to match print(int)</code><code>    print(4.5f); // promoted to match print(double)</code><code></code><code>    return 0;</code><code>}</code></pre><p>For <code>print('a')</code>, because an exact match for <code>print(char)</code> could not be found in the prior step, the compiler promotes the char <code>'a'</code> to an <code>int</code>, and looks for a match. This matches <code>print(int)</code>, so the function call resolves to <code>print(int)</code>.</p><p>Step 3) If no match is found via numeric promotion, the compiler tries to find a match by applying numeric conversions (<a href="https://www.learncpp.com/cpp-tutorial/numeric-conversions/">8.3 -- Numeric conversions</a>) to the arguments.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#include <string> // for std::string</string></code><code></code><code>void print(double)</code><code>{</code><code>}</code><code></code><code>void print(std::string)</code><code>{</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    print('a'); // 'a' converted to match print(double)</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this case, because there is no <code>print(char)</code> (exact match), and no <code>print(int)</code> (promotion match), the <code>'a'</code> is numerically converted to a double and matched with <code>print(double)</code>.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Matches made by applying numeric promotions take precedence over any matches made by applying numeric conversions.</p></div><p>Step 4) If no match is found via numeric conversion, the compiler tries to find a match through any user-defined conversions. Although we haven’t covered user-defined conversions yet, certain types (e.g. classes) can define conversions to other types that can be implicitly invoked. Here’s a example, just to illustrate the point:</p><pre class="language-cpp line-numbers"><code>// We haven't covered classes yet, so don't worry if this doesn't make sense</code><code>class X // this defines a new type called X</code><code>{</code><code>public:</code><code>    operator int() { return 0; } // Here's a user-defined conversion from X to int</code><code>};</code><code></code><code>void print(int)</code><code>{</code><code>}</code><code></code><code>void print(double)</code><code>{</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    X x; // Here, we're creating an object of type X (named x)</code><code>    print(x); // x is converted to type int using the user-defined conversion from X to int</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this example, the compiler will first check whether an exact match to <code>print(X)</code> exists. We haven’t defined one. Next the compiler will check whether <code>x</code> can be numerically promoted, which it can’t. The compiler will then check if <code>x</code> can be numerically converted, which it also can’t. Finally, the compiler will then look for any user-defined conversions. Because we’ve defined a user-defined conversion from <code>X</code> to <code>int</code>, the compiler will convert <code>X</code> to an <code>int</code> to match <code>print(int)</code>.</p><p>After applying a user-defined conversion, the compiler may apply additional implicit promotions or conversions to find a match. So if our user-defined conversion had been to type <code>char</code> instead of <code>int</code>, the compiler would have used the user-defined conversion to <code>char</code> and then promoted the result into an <code>int</code> to match.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We discuss how to create user-defined conversions for class types (by overloading the typecast operators) in lesson <a href="https://www.learncpp.com/cpp-tutorial/overloading-typecasts/">14.11 -- Overloading typecasts</a>.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>The constructor of a class also acts as a user-defined conversion from other types to that class type, and can be used during this step to find matching functions.</p></div><p>Step 5) If no match is found via user-defined conversion, the compiler will look for a matching function that uses ellipsis.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We cover ellipses in lesson <a href="https://www.learncpp.com/cpp-tutorial/ellipsis-and-why-to-avoid-them/">12.6 -- Ellipsis (and why to avoid them)</a>.</p></div><p>Step 6) If no matches have been found by this point, the compiler gives up and will issue a compile error about not being able to find a matching function.</p><br><h3>Ambiguous matches</h3><p>With non-overloaded functions, each function call will either resolve to a function, or no match will be found and the compiler will issue a compile error:</p><pre class="language-cpp line-numbers"><code>void foo()</code><code>{</code><code>}</code><code></code><code>int main()</code><code>{</code><code>     foo(); // okay: match found</code><code>     goo(); // compile error: no match found</code><code></code><code>     return 0;</code><code>}</code></pre><p>With overloaded functions, there is a third possible outcome: an <code>ambiguous match</code> may be found. An <span class="cpp-definition">ambiguous match</span> occurs when the compiler finds two or more functions that can be made to match in the same step. When this occurs, the compiler will stop matching and issue a compile error stating that it has found an ambiguous function call.</p><p>Since every overloaded function must be differentiated in order to compile, you might be wondering how it is possible that a function call could result in more than one match. Let’s take a look at an example that illustrates this:</p><pre class="language-cpp line-numbers"><code>void print(int x)</code><code>{</code><code>}</code><code></code><code>void print(double d)</code><code>{</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    print(5L); // 5L is type long</code><code></code><code>    return 0;</code><code>}</code></pre><p>Since literal <code>5L</code> is of type <code>long</code>, the compiler will first look to see if it can find an exact match for <code>print(long)</code>, but it will not find one. Next, the compiler will try numeric promotion, but values of type <code>long</code> can’t be promoted, so there is no match here either.</p><p>Following that, the compiler will try to find a match by applying numeric conversions to the <code>long</code> argument. In the process of checking all the numeric conversion rules, the compiler will find two potential matches. If the <code>long</code> argument is numerically converted into an <code>int</code>, then the function call will match <code>print(int)</code>. If the <code>long</code> argument is instead converted into a <code>double</code>, then it will match <code>print(double)</code> instead. Since two possible matches via numeric conversion have been found, the function call is considered ambiguous.</p><p>On Visual Studio 2019, this results in the following error message:</p><pre>error C2668: 'print': ambiguous call to overloaded function
message : could be 'void print(double)'
message : or       'void print(int)'
message : while trying to match the argument list '(long)'
</pre><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>If the compiler finds multiple matches in a given step, an ambiguous function call will result. This means no match from a given step is considered to be better than any other match from the same step.</p></div><p>Here’s another example that yields ambiguous matches:</p><pre class="language-cpp line-numbers"><code>void print(unsigned int x)</code><code>{</code><code>}</code><code></code><code>void print(float y)</code><code>{</code><code>}</code><code></code><code>int main()</code><code>{ </code><code>    print(0); // int can be numerically converted to unsigned int or to float</code><code>    print(3.14159); // double can be numerically converted to unsigned int or to float</code><code></code><code>    return 0;</code><code>}</code></pre><p>Although you might expect <code>0</code> to resolve to <code>print(unsigned int)</code> and <code>3.14159</code> to resolve to <code>print(float)</code>, both of these calls result in an ambiguous match. The <code>int</code> value <code>0</code> can be numerically converted to either an <code>unsigned int</code> or a <code>float</code>, so either overload matches equally well, and the result is an ambiguous function call.</p><p>The same applies for the conversion of a <code>double</code> to either a <code>float</code> or <code>unsigned int</code>. Both are numeric conversions, so either overload matches equally well, and the result is again ambiguous.</p><br><h3>Resolving ambiguous matches</h3><p>Because ambiguous matches are a compile-time error, an ambiguous match needs to be disambiguated before your program will compile. There are a few ways to resolve ambiguous matches:</p><ol start="1"><li>Often, the best way is simply to define a new overloaded function that takes parameters of exactly the type you are trying to call the function with. Then C++ will be able to find an exact match for the function call.</li><li>Alternatively, explicitly cast the ambiguous argument(s) to match the type of the function you want to call. For example, to have <code>print(0)</code> match <code>print(unsigned int)</code> in the above example, you would do this:</li></ol><pre class="language-cpp line-numbers"><code>int x{ 0 };</code><code>print(static_cast<unsigned int="">(x)); // will call print(unsigned int)</unsigned></code></pre><ol start="3"><li>If your argument is a literal, you can use the literal suffix to ensure your literal is interpreted as the correct type:</li></ol><pre class="language-cpp line-numbers"><code>print(0u); // will call print(unsigned int) since 'u' suffix is unsigned int, so this is now an exact match</code></pre><p>The list of the most used suffixes can be found in lesson <a href="https://www.learncpp.com/cpp-tutorial/literals/">4.15 -- Literals</a>.</p><br><h3>Matching for functions with multiple arguments</h3><p>If there are multiple arguments, the compiler applies the matching rules to each argument in turn. The function chosen is the one for which each argument matches at least as well as all the other functions, with at least one argument matching better than all the other functions. In other words, the function chosen must provide a better match than all the other candidate functions for at least one parameter, and no worse for all of the other parameters.</p><p>In the case that such a function is found, it is clearly and unambiguously the best choice. If no such function can be found, the call will be considered ambiguous (or a non-match).</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print(char c, int x)</code><code>{</code><code>	std::cout &lt;&lt; 'a' &lt;&lt; '\n';</code><code>}</code><code></code><code>void print(char c, double x)</code><code>{</code><code>	std::cout &lt;&lt; 'b' &lt;&lt; '\n';</code><code>}</code><code></code><code>void print(char c, float x)</code><code>{</code><code>	std::cout &lt;&lt; 'c' &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	print('x', 'a');</code><code>}</code></pre><p>In the above program, all functions match the first argument exactly. However, the top function matches the second parameter via promotion, whereas the other functions require a conversion. Therefore, <code>print(char, int)</code> is unambiguously the best match.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">8.12 — Default arguments</h1></header><div class="entry-content" itemprop="articleBody"><p>A <span class="cpp-definition">default argument</span> is a default value provided for a function parameter. For example:</p><pre class="language-cpp line-numbers"><code>void print(int x, int y=10) // 10 is the default argument</code><code>{</code><code>    std::cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "y: " &lt;&lt; y &lt;&lt; '\n';</code><code>}</code></pre><p>When making a function call, the caller can optionally provide an argument for any function parameter that has a default argument. If the caller provides an argument, the value of the argument in the function call is used. If the caller does not provide an argument, the value of the default argument is used.</p><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print(int x, int y=4) // 4 is the default argument</code><code>{</code><code>    std::cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "y: " &lt;&lt; y &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    print(1, 2); // y will use user-supplied argument 2</code><code>    print(3); // y will use default argument 4</code><code></code><code>}</code></pre><p>This program produces the following output:</p><pre>x: 1
y: 2
x: 3
y: 4
</pre><p>In the first function call, the caller supplied explicit arguments for both parameters, so those argument values are used. In the second function call, the caller omitted the second argument, so the default value of <code>4</code> was used.</p><p>Note that you must use the equals sign to specify a default argument. Using parenthesis or brace initialization won’t work:</p><pre class="language-cpp line-numbers"><code>void foo(int x = 5);   // ok</code><code>void goo(int x ( 5 )); // compile error</code><code>void boo(int x { 5 }); // compile error</code></pre><br><h3>When to use default arguments</h3><p>Default arguments are an excellent option when a function needs a value that has a reasonable default value, but for which you want to let the caller override if they wish.</p><p>For example, here are a couple of function prototypes for which default arguments might be commonly used:</p><pre class="language-cpp line-numbers"><code>int rollDie(int sides=6);</code><code>void openLogFile(std::string filename="default.log");</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>Because the user can choose whether to supply a specific argument value or use the default value, a parameter with a default value provided is sometimes called an <span class="cpp-definition">optional parameter</span>. However, the term <em>optional parameter</em> is also used to refer to several other types of parameters (including parameters passed by address, and parameters using <code>std::optional</code>), so we recommend avoiding this term.</p></div><br><h3>Multiple default arguments</h3><p>A function can have multiple parameters with default arguments:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print(int x=10, int y=20, int z=30)</code><code>{</code><code>    std::cout &lt;&lt; "Values: " &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; z &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    print(1, 2, 3); // all explicit arguments</code><code>    print(1, 2); // rightmost argument defaulted</code><code>    print(1); // two rightmost arguments defaulted</code><code>    print(); // all arguments defaulted</code><code></code><code>    return 0;</code><code>}</code></pre><p>The following output is produced:</p><pre>Values: 1 2 3
Values: 1 2 30
Values: 1 20 30
Values: 10 20 30
</pre><p>C++ does not (as of C++20) support a function call syntax such as <code>print(,,3)</code> (as a way to provide an explicit value for <code>z</code> while using the default arguments for <code>x</code> and <code>y</code>. This has two major consequences:</p><ol start="1"><li>Default arguments can only be supplied for the rightmost parameters. The following is not allowed:</li></ol><pre class="language-cpp line-numbers"><code>void print(int x=10, int y); // not allowed</code></pre><div class="cpp-note cpp-lightgreenbackground"><h4>Rule</h4><p>Default arguments can only be provided for the rightmost parameters.</p></div><ol start="2"><li>If more than one default argument exists, the leftmost default argument should be the one most likely to be explicitly set by the user.</li></ol><br><h3>Default arguments can not be redeclared</h3><p>Once declared, a default argument can not be redeclared (in the same file). That means for a function with a forward declaration and a function definition, the default argument can be declared in either the forward declaration or the function definition, but not both.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print(int x, int y=4); // forward declaration</code><code></code><code>void print(int x, int y=4) // error: redefinition of default argument</code><code>{</code><code>    std::cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "y: " &lt;&lt; y &lt;&lt; '\n';</code><code>}</code></pre><p>Best practice is to declare the default argument in the forward declaration and not in the function definition, as the forward declaration is more likely to be seen by other files (particularly if it’s in a header file).</p><p>in foo.h:</p><pre class="language-cpp line-numbers"><code>#ifndef FOO_H</code><code>#define FOO_H</code><code>void print(int x, int y=4);</code><code>#endif</code></pre><p>in main.cpp:</p><pre class="language-cpp line-numbers"><code>#include "foo.h"</code><code>#include <iostream></iostream></code><code></code><code>void print(int x, int y)</code><code>{</code><code>    std::cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "y: " &lt;&lt; y &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    print(5);</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note that in the above example, we’re able to use the default argument for function <code>print()</code> because <code>main.cpp</code> #includes <code>foo.h</code>, which has the forward declaration that defines the default argument.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>If the function has a forward declaration (especially one in a header file), put the default argument there. Otherwise, put the default argument in the function definition.</p></div><br><h3>Default arguments and function overloading</h3><p>Functions with default arguments may be overloaded. For example, the following is allowed:</p><pre class="language-cpp line-numbers"><code>void print(std::string string)</code><code>{</code><code>}</code><code></code><code>void print(char ch=' ')</code><code>{</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    print("Hello, world"); // resolves to print(std::string)</code><code>    print('a'); // resolves to print(char)</code><code>    print(); // resolves to print(char)</code><code></code><code>    return 0;</code><code>}</code></pre><p>The function call to <code>print()</code> acts as if the user had explicitly called <code>print(' ')</code>, which resolves to <code>print(char)</code>.</p><p>Now consider this case:</p><pre class="language-cpp line-numbers"><code>void print(int x);</code><code>void print(int x, int y = 10);</code><code>void print(int x, double y = 20.5);</code></pre><p>Parameters with default values will differentiate a function overload (meaning the above will compile).<br>However, such functions can lead to potentially ambiguous function calls. For example:</p><pre class="language-cpp line-numbers"><code>print(1, 2); // will resolve to print(int, int)</code><code>print(1, 2.5); // will resolve to print(int, double) </code><code>print(1); // ambiguous function call</code></pre><p>In the last case, the compiler is unable to tell whether <code>print(1)</code> should resolve to <code>print(int)</code> or one of the two functions where the second parameter has a default value. The result is an ambiguous function call.</p><br><h3>Summary</h3><p>Default arguments provide a useful mechanism to specify values for parameters that the user may or may not want to override. They are frequently used in C++, and you’ll see them a lot in future lessons.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">8.13 — Function templates</h1></header><div class="entry-content" itemprop="articleBody"><p>Let’s say you wanted to write a function to calculate the maximum of two numbers. You might do so like this:</p><pre class="language-cpp line-numbers"><code>int max(int x, int y)</code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code></pre><p>While the caller can pass different values into the function, the type of the parameters is fixed, so the caller can only pass in <code>int</code> values. That means this function really only works well for integers (and types that can be promoted to <code>int</code>).</p><p>So what happens later when you want to find the max of two <code>double</code> values? Because C++ requires us to specify the type of all function parameters, the solution is to create a new overloaded version of <code>max()</code> with parameters of type <code>double</code>:</p><pre class="language-cpp line-numbers"><code>double max(double x, double y)</code><code>{</code><code>    return (x &gt; y) ? x: y;</code><code>}</code></pre><p>Note that the code for the implementation of the <code>double</code> version of <code>max()</code> is exactly the same as for the <code>int</code> version of <code>max()</code>! In fact, this implementation works for many different types: including <code>int</code>, <code>double</code>, <code>long</code>, <code>long double</code>, and even new types that you’ve created yourself (which we’ll cover how to do in future lessons).</p><p>Having to create overloaded functions with the same implementation for each set of parameter types we want to support is a maintenance headache, a recipe for errors, and a clear violation of the DRY (don’t repeat yourself) principle. There’s a less-obvious challenge here as well: a programmer who wishes to use the <code>max()</code> function may wish to call it with a parameter type that the author of the <code>max()</code> did not anticipate (and thus did not write an overloaded function for).</p><p>What we are really missing is some way to write a single version of <code>max()</code> that can work with arguments of any type (even types that may not have been anticipated when the code for <code>max()</code> was written). Normal functions are simply not up to the task here. Fortunately, C++ supports another feature that was designed specifically to solve this kind of problem.</p><p>Welcome to the world of C++ templates.</p><br><h3>Introduction to C++ templates</h3><p>In C++, the template system was designed to simplify the process of creating functions (or classes) that are able to work with different data types.</p><p>Instead of manually creating a bunch of mostly-identical functions or classes (one for each set of different types), we instead create a single <code>template</code>. Just like a normal definition, a <span class="cpp-definition">template</span> describes what a function or class looks like. Unlike a normal definition (where all types must be specified), in a template we can use one or more placeholder types. A placeholder type represents some type that is not known at the time the template is written, but that will be provided later.</p><p>Once a template is defined, the compiler can use the template to generate as many overloaded functions (or classes) as needed, each using different actual types!</p><p>The end result is the same -- we end up with a bunch of mostly-identical functions or classes (one for each set of different types). But we only have to create and maintain a single template, and the compiler does all the hard work for us.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>The compiler can use a single template to generate a family of related functions or classes, each using a different set of types.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>Because the concept behind templates can be hard to describe in words, let’s try an analogy.</p><p>If you were to look up the word “template” in the dictionary, you’d find a definition that was similar to the following: “a template is a model that serves as a pattern for creating similar objects”. One type of template that is very easy to understand is that of a stencil. A stencil is a thin piece of material (such as a piece of cardboard or plastic) with a shape cut out of it (e.g. a happy face). By placing the stencil on top of another object, then spraying paint through the hole, you can very quickly replicate the cut-out shape. The stencil itself only needs to be created once, and then it can be reused as many times as desired, to create the cut out shape in as many different colors as you like. Even better, the color of a shape made with the stencil doesn’t have to be determined until the stencil is actually used.</p><p>A template is essentially a stencil for creating functions or classes. We create the template (our stencil) once, and then we can use it as many times as needed, to stencil out a function or class for a specific set of actual types. Those actual types don’t need to be determined until the template is actually used.</p></div><p>Because the actual types aren’t determined until the template is used in a program (not when the template is written), the author of the template doesn’t have to try to anticipate all of the actual types that might be used. This means template code can be used with types that didn’t even exist when the template was written! We’ll see how this comes in handy later, when we start exploring the C++ standard library, which is absolutely full of template code!</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Templates can work with types that didn’t even exist when the template was written. This helps make template code both flexible and future proof!</p></div><p>In the rest of this lesson, we’ll introduce and explore how to create templates for functions, and describe how they work in more detail. We’ll save discussion of class templates until after we’ve covered what classes are.</p><br><h3>Function templates</h3><p>A <span class="cpp-definition">function template</span> is a function-like definition that is used to generate one or more overloaded functions, each with a different set of actual types. This is what will allow us to create functions that can work with many different types.</p><p>When we create our function template, we use placeholder types (also called <span class="cpp-definition">template types</span>) for any parameter types, return types, or types used in the function body that we want to be specified later.</p><p>Function templates are something that is best taught by example, so let’s convert our normal <code>max(int, int)</code> function from the example above into a function template. It’s surprisingly easy, and we’ll explain what’s happening along the way.</p><br><h3>Creating a templated max function</h3><p>Here’s the <code>int</code> version of <code>max()</code> again:</p><pre class="language-cpp line-numbers"><code>int max(int x, int y)</code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code></pre><p>Note that we use type <code>int</code> three times in this function: once for parameter <code>x</code>, once for parameter <code>y</code>, and once for the return type of the function.</p><p>To create a function template, we’re going to do two things. First, we’re going to replace our specific types with template types. In this case, because we have only one type that needs replacing (<code>int</code>), we only need one template type. It’s common convention to use single capital letters (starting with T) to represent template types.</p><p>Here’s our new function that uses a single template type:</p><pre class="language-cpp line-numbers"><code>T max(T x, T y) // won't compile because we haven't defined T</code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code></pre><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use a single capital letter (starting with T) to name your template types (e.g. T, U, V, etc…)</p></div><p>This is a good start -- however, it won’t compile because the compiler doesn’t know what <code>T</code> is! And this is still a normal function, not a function template.</p><p>Second, we’re going to tell the compiler that this is a function template, and that <code>T</code> is a template type. This is done using what is called a <span class="cpp-definition">template parameter declaration</span>:</p><pre class="language-cpp line-numbers"><code>template <typename t=""> // this is the template parameter declaration</typename></code><code>T max(T x, T y) // this is the function template definition for max<t></t></code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code></pre><p>Let’s take a slightly closer look at the template parameter declaration. We start with the keyword <code>template</code>, which tells the compiler that we’re creating a template. Next, we specify all of the template types that our template will use inside angled brackets (<code>&lt;&gt;</code>). For each template type, we use the keyword <code>typename</code> or <code>class</code>, followed by the name of the template type (e.g. <code>T</code>).</p><p>Each template function (or template class) needs its own template parameter declaration.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>There is no difference between the <code>typename</code> and <code>class</code> keywords in this context. You will often see people use the <code>class</code> keyword since it was introduced into the language earlier. However, we prefer the newer <code>typename</code> keyword, because it makes it clearer that the template type can be replaced by any type (such as a fundamental type), not just class types.</p></div><p>Because this function template has one template type named <code>T</code>, we’ll refer to it as <code>max<t></t></code>.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We discuss how to create function templates with multiple template types in lesson <a href="https://www.learncpp.com/cpp-tutorial/function-templates-with-multiple-template-types/">8.15 -- Function templates with multiple template types</a>.</p></div><p>Believe it or not, we’re done!</p><p>In the next lesson, we’ll look at how we use our <code>max<t></t></code> function template to generate <code>max()</code> functions with parameters of different types.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">8.14 — Function template instantiation</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson (<a href="https://www.learncpp.com/cpp-tutorial/function-templates/">8.13 -- Function templates</a>), we introduced function templates, and converted a normal <code>max()</code> function into a <code>max<t></t></code> function template:</p><pre class="language-cpp line-numbers"><code>template <typename t=""></typename></code><code>T max(T x, T y)</code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code></pre><p>In this lesson, we’ll focus on how function templates are used.</p><br><h3>Using a function template</h3><p>Function templates are not actually functions -- their code isn’t compiled or executed directly. Instead, function templates have one job: to generate functions (that are compiled and executed).</p><p>To use our <code>max<t></t></code> function template, we can make a function call with the following syntax:</p><pre>max&lt;actual_type&gt;(arg1, arg2); // actual_type is some actual type, like int or double
</pre><p>This looks a lot like a normal function call -- the primary difference is the addition of the type in angled brackets (called a <span class="cpp-definition">template argument</span>), which specifies the actual type that will be used in place of template type <code>T</code>.</p><p>Let’s take a look at this in a simple example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>T max(T x, T y)</code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; max<int>(1, 2) &lt;&lt; '\n'; // instantiates and calls function max<int>(int, int)</int></int></code><code></code><code>    return 0;</code><code>}</code></pre><p>When the compiler encounters the function call <code>max<int>(1, 2)</int></code>, it will determine that a function definition for <code>max<int>(int, int)</int></code> does not already exist. Consequently, the compiler will use our <code>max<t></t></code> function template to create one.</p><p>The process of creating functions (with specific types) from function templates (with template types) is called <span class="cpp-definition">function template instantiation</span> (or <span class="cpp-definition">instantiation</span> for short). When this process happens due to a function call, it’s called <span class="cpp-definition">implicit instantiation</span>. An instantiated function is often called a <span class="cpp-definition">function instance</span> (<span class="cpp-definition">instance</span> for short) or a <span class="cpp-definition">template function</span>. Function instances are normal functions in all regards.</p><p>The process for instantiating a function is simple: the compiler essentially clones the function template and replaces the template type (<code>T</code>) with the actual type we’ve specified (<code>int</code>).</p><p>So when we call <code>max<int>(1, 2)</int></code>, the function that gets instantiated looks something like this:</p><pre class="language-cpp line-numbers"><code>template&lt;&gt; // ignore this for now</code><code>int max<int>(int x, int y) // the generated function max<int>(int, int)</int></int></code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code></pre><p>Here’s the same example as above, showing what the compiler actually compiles after all instantiations are done:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// a declaration for our function template (we don't need the definition any more)</code><code>template <typename t=""> </typename></code><code>T max(T x, T y);</code><code></code><code>template&lt;&gt;</code><code>int max<int>(int x, int y) // the generated function max<int>(int, int)</int></int></code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; max<int>(1, 2) &lt;&lt; '\n'; // instantiates and calls function max<int>(int, int)</int></int></code><code></code><code>    return 0;</code><code>}</code></pre><p>You can compile this yourself and see that it works. An instantiated function is only instantiated the first time a function call is made. Further calls to the function are routed to the already instantiated function.</p><p>Let’s do another example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>T max(T x, T y) // function template for max(T, T)</code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; max<int>(1, 2) &lt;&lt; '\n';    // instantiates and calls function max<int>(int, int)</int></int></code><code>    std::cout &lt;&lt; max<int>(4, 3) &lt;&lt; '\n';    // calls already instantiated function max<int>(int, int)</int></int></code><code>    std::cout &lt;&lt; max<double>(1, 2) &lt;&lt; '\n'; // instantiates and calls function max<double>(double, double)</double></double></code><code></code><code>    return 0;</code><code>}</code></pre><p>This works similarly to the previous example, but our function template will be used to generate two functions this time: one time replacing <code>T</code> with <code>int</code>, and the other time replacing <code>T</code> with <code>double</code>. After all instantiations, the program will look something like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// a declaration for our function template (we don't need the definition any more)</code><code>template <typename t=""></typename></code><code>T max(T x, T y); </code><code></code><code>template&lt;&gt;</code><code>int max<int>(int x, int y) // the generated function max<int>(int, int)</int></int></code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code><code></code><code>template&lt;&gt;</code><code>double max<double>(double x, double y) // the generated function max<double>(double, double)</double></double></code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; max<int>(1, 2) &lt;&lt; '\n';    // instantiates and calls function max<int>(int, int)</int></int></code><code>    std::cout &lt;&lt; max<int>(4, 3) &lt;&lt; '\n';    // calls already instantiated function max<int>(int, int)</int></int></code><code>    std::cout &lt;&lt; max<double>(1, 2) &lt;&lt; '\n'; // instantiates and calls function max<double>(double, double)</double></double></code><code></code><code>    return 0;</code><code>}</code></pre><p>One additional thing to note here: when we instantiate <code>max<double></double></code>, the instantiated function has parameters of type <code>double</code>. Because we’ve provided <code>int</code> arguments, those arguments will be implicitly converted to <code>double</code>.</p><br><h3>Template argument deduction</h3><p>In most cases, the actual types we want to use for instantiation will match the type of our function parameters. For example:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; max<int>(1, 2) &lt;&lt; '\n'; // specifying we want to call max<int></int></int></code></pre><p>In this function call, we’ve specified that we want to replace <code>T</code> with <code>int</code>, but we’re also calling the function with <code>int</code> arguments.</p><p>In cases where the type of the arguments match the actual type we want, we do not need to specify the actual type -- instead, we can use <span class="cpp-definition">template argument deduction</span> to have the compiler deduce the actual type that should be used from the argument types in the function call.</p><p>For example, instead of making a function call like this:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; max<int>(1, 2) &lt;&lt; '\n'; // specifying we want to call max<int></int></int></code></pre><p>We can do one of these instead:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; max&lt;&gt;(1, 2) &lt;&lt; '\n';</code><code>std::cout &lt;&lt; max(1, 2) &lt;&lt; '\n';</code></pre><p>In either case, the compiler will see that we haven’t provided an actual type, so it will attempt to deduce an actual type from the function arguments that will allow it to generate a <code>max()</code> function where all template parameters match the type of the provided arguments. In this example, the compiler will deduce that using function template <code>max<t></t></code> with actual type <code>int</code> allows it to instantiate function <code>max<int>(int, int)</int></code> where the type of both template parameters (<code>int</code>) matches the type of the provided arguments (<code>int</code>).</p><p>The difference between the two cases has to do with how the compiler resolves the function call from a set of overloaded functions. In the top case (with the empty angled brackets), the compiler will only consider <code>max<int></int></code> template function overloads when determining which overloaded function to call. In the bottom case (with no angled brackets), the compiler will consider both <code>max<int></int></code> template function overloads and <code>max</code> non-template function overloads.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>T max(T x, T y)</code><code>{</code><code>    std::cout &lt;&lt; "called max<int>(int, int)\n";</int></code><code>    return (x &gt; y) ? x : y;</code><code>}</code><code></code><code>int max(int x, int y)</code><code>{</code><code>    std::cout &lt;&lt; "called max(int, int)\n";</code><code>    return (x &gt; y) ? x : y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; max<int>(1, 2) &lt;&lt; '\n'; // selects max<int>(int, int)</int></int></code><code>    std::cout &lt;&lt; max&lt;&gt;(1, 2) &lt;&lt; '\n';    // deduces max<int>(int, int) (non-template functions not considered)</int></code><code>    std::cout &lt;&lt; max(1, 2) &lt;&lt; '\n';      // calls function max(int, int)</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note how the syntax in the bottom case looks identical to a normal function call! This is usually the preferred syntax used when invoking function templates (and the one we’ll default to in future examples, unless required to do otherwise).</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Favor the normal function call syntax when using function templates.</p></div><br><h3>Function templates with non-template parameters</h3><p>It’s possible to create function templates that have both template types and non-template type parameters. The template parameters can be matched to any type, and the non-template parameters work like the parameters of normal functions.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>template <typename t=""></typename></code><code>int someFcn (T x, double y)</code><code>{</code><code>    return 5;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    someFcn(1, 3.4); // matches someFcn(int, double)</code><code>    someFcn(1, 3.4f); // matches someFcn(int, double) -- the float is promoted to a double</code><code>    someFcn(1.2, 3.4); // matches someFcn(double, double)</code><code>    someFcn(1.2f, 3.4); // matches someFcn(float, double)</code><code>    someFcn(1.2f, 3.4f); // matches someFcn(float, double) -- the float is promoted to a double</code><code></code><code>    return 0;</code><code>}</code></pre><p>This function template has a templated first parameter, but the second parameter is fixed with type <code>double</code>. Note that the return type can also be any type. In this case, our function will always return an <code>int</code> value.</p><br><h3>Instantiated functions may not always compile</h3><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>T addOne(T x)</code><code>{</code><code>    return x + 1;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; addOne(1) &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; addOne(2.3) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>The compiler will effectively compile and execute this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>T addOne(T x);</code><code></code><code>template&lt;&gt;</code><code>int addOne<int>(int x)</int></code><code>{</code><code>    return x + 1;</code><code>}</code><code></code><code>template&lt;&gt;</code><code>double addOne<double>(double x)</double></code><code>{</code><code>    return x + 1;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; addOne(1) &lt;&lt; '\n';   // calls addOne<int>(int)</int></code><code>    std::cout &lt;&lt; addOne(2.3) &lt;&lt; '\n'; // calls addOne<double>(double)</double></code><code></code><code>    return 0;</code><code>}</code></pre><p>which will produce the result:</p><pre>2
3.3
</pre><p>But what if we try something like this?</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>template <typename t=""></typename></code><code>T addOne(T x)</code><code>{</code><code>    return x + 1;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::string hello { "Hello, world!" };</code><code>    std::cout &lt;&lt; addOne(hello) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>When the compiler tries to resolve <code>addOne(hello)</code> it won’t find a non-template function match for <code>addOne(std::string)</code>, but it will find our function template for <code>addOne(T)</code>, and determine that it can generate an <code>addOne(std::string)</code> function from it. Thus, the compiler will generate and compile this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>template <typename t=""></typename></code><code>T addOne(T x);</code><code></code><code>template&lt;&gt;</code><code>std::string addOne<std::string>(std::string x)</std::string></code><code>{</code><code>    return x + 1;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::string hello{ "Hello, world!" };</code><code>    std::cout &lt;&lt; addOne(hello) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>However, this will generate a compile error, because <code>x + 1</code> doesn’t make sense when <code>x</code> is a <code>std::string</code>. The obvious solution here is simply not to call <code>addOne()</code> with an argument of type <code>std::string</code>.</p><br><h3>Using function templates in multiple files</h3><p>In order to instantiate a template, the compiler needs to see the full definition of the template. This means that if we want to use a function template in multiple code files, each code file needs a copy of the definition of the function template. For this reason, templates are typically written in header files, where they can be #included into any code file that wants to use them.</p><p>Template definitions are not subject to the one-definition rule, and functions instantiated from function templates are implicitly inline, so they are exempt from the one-definition rule.</p><p>Max.h:</p><pre class="language-cpp line-numbers"><code>#ifndef MAX_H</code><code>#define MAX_H</code><code></code><code>template <typename t=""></typename></code><code>T max(T x, T y)</code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code><code></code><code>#endif</code></pre><p>Foo.cpp:</p><pre class="language-cpp line-numbers"><code>#include "Max.h" // import template definition for max<t, t="">()</t,></code><code>#include <iostream></iostream></code><code></code><code>void foo()</code><code>{</code><code>	std::cout &lt;&lt; max(3, 2) &lt;&lt; '\n';</code><code>}</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include "Max.h" // import template definition for max<t, t="">()</t,></code><code>#include <iostream></iostream></code><code></code><code>void foo(); // forward declaration for function foo</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; max(3, 5) &lt;&lt; '\n';</code><code>    foo();</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, both main.cpp and foo.cpp <code>#include "Max.h"</code> so the code in both files can make use of the <code>max<t, t=""></t,></code> function template.</p><br><h3>Generic programming</h3><p>Because template types can be replaced with any actual type, template types are sometimes called <span class="cpp-definition">generic types</span>. And because templates can be written agnostically of specific types, programming with templates is sometimes called <span class="cpp-definition">generic programming</span>. Whereas C++ typically has a strong focus on types and type checking, in contrast, generic programming lets us focus on the logic of algorithms and design of data structures without having to worry so much about type information.</p><br><h3>Conclusion</h3><p>Once you get used to writing function templates, you’ll find they actually don’t take much longer to write than functions with actual types. Function templates can significantly reduce code maintenance and errors by minimizing the amount of code that needs to be written and maintained.</p><p>Function templates do have a few drawbacks, and we would be remiss not to mention them. First, the compiler will create (and compile) a function for each function call with a unique set of argument types. So while function templates are compact to write, they can expand into a crazy amount of code, which can lead to code bloat and slow compile times. The bigger downside of function templates is that they tend to produce crazy-looking, borderline unreadable error messages that are much harder to decipher than those of regular functions. These error messages can be quite intimidating, but once you understand what they are trying to tell you, the problems they are pinpointing are often quite straightforward to resolve.</p><p>These drawbacks are fairly minor compared with the power and safety that templates bring to your programming toolkit, so use templates liberally anywhere you need type flexibility! A good rule of thumb is to create normal functions at first, and then convert them into function templates if you find you need an overload for different parameter types.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use function templates to write generic code that can work with a wide variety of types whenever you have the need.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">8.15 — Function templates with multiple template types</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/function-templates/">8.13 -- Function templates</a>, we wrote a function template to calculate the maximum of two values:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>T max(T x, T y)</code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; max(1, 2) &lt;&lt; '\n';   // will instantiate max(int, int)</code><code>    std::cout &lt;&lt; max(1.5, 2.5) &lt;&lt; '\n'; // will instantiate max(double, double)</code><code></code><code>    return 0;</code><code>}</code></pre><p>Now consider the following similar program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>T max(T x, T y)</code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; max(2, 3.5) &lt;&lt; '\n';  // compile error</code><code></code><code>    return 0;</code><code>}</code></pre><p>You may be surprised to find that this program won’t compile. Instead, the compiler will issue a bunch of (probably crazy looking) error messages. On Visual Studio, the author got the following:</p><pre>Project3.cpp(11,18): error C2672: 'max': no matching overloaded function found
Project3.cpp(11,28): error C2782: 'T max(T,T)': template parameter 'T' is ambiguous
Project3.cpp(4): message : see declaration of 'max'
Project3.cpp(11,28): message : could be 'double'
Project3.cpp(11,28): message : or       'int'
Project3.cpp(11,28): error C2784: 'T max(T,T)': could not deduce template argument for 'T' from 'double'
Project3.cpp(4): message : see declaration of 'max'
</pre><p>In our function call <code>max(2, 3.5)</code>, we’re passing arguments of two different types: one <code>int</code> and one <code>double</code>. Because we’re making a function call without using angled brackets to specify an actual type, the compiler will first look to see if there is a non-template match for <code>max(int, double)</code>. It won’t find one.</p><p>Next, the compiler will see if it can find a function template match (using template argument deduction, which we covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/function-template-instantiation/">8.14 -- Function template instantiation</a>). However, this will also fail, for a simple reason: <code>T</code> can only represent a single type. There is no type for <code>T</code> that would allow the compiler to instantiate function template <code>max<t>(T, T)</t></code> into a function with two different parameter types. Put another way, because both parameters in the function template are of type <code>T</code>, they must resolve to the same actual type.</p><p>Since no non-template match was found, and no template match was found, the function call fails to resolve, and we get a compile error.</p><p>You might wonder why the compiler didn’t generate function <code>max<double>(double, double)</double></code> and then use numeric conversion to type convert the <code>int</code> argument to a <code>double</code>. The answer is simple: type conversion is done only when resolving function overloads, not when performing template argument deduction.</p><p>This lack of type conversion is intentional for at least two reasons. First, it helps keep things simple: we either find an exact match between the function call arguments and template type parameters, or we don’t. Second, it allows us to create function templates for cases where we want to ensure that two or more parameters have the same type (as in the example above).</p><p>We’ll have to find another solution. Fortunately, we can solve this problem in (at least) three ways.</p><br><h3>Use static_cast to convert the arguments to matching types</h3><p>The first solution is to put the burden on the caller to convert the arguments into matching types. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>T max(T x, T y)</code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; max(static_cast<double>(2), 3.5) &lt;&lt; '\n'; // convert our int to a double so we can call max(double, double)</double></code><code></code><code>    return 0;</code><code>}</code></pre><p>Now that both arguments are of type <code>double</code>, the compiler will be able to instantiate <code>max(double, double)</code> that will satisfy this function call.</p><p>However, this solution is awkward and hard to read.</p><br><h3>Provide an actual type</h3><p>If we had written a non-template <code>max(double, double)</code> function, then we would be able to call <code>max(int, double)</code> and let the implicit type conversion rules convert our <code>int</code> argument into a <code>double</code> so the function call could be resolved:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>double max(double x, double y)</code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; max(2, 3.5) &lt;&lt; '\n'; // the int argument will be converted to a double</code><code></code><code>    return 0;</code><code>}</code></pre><p>However, when the compiler is doing template argument deduction, it won’t do any type conversions. Fortunately, we don’t have to use template argument deduction if we specify an actual type to be used instead:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>T max(T x, T y)</code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; max<double>(2, 3.5) &lt;&lt; '\n'; // we've provided actual type double, so the compiler won't use template argument deduction</double></code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, we call <code>max<double>(2, 3.5)</double></code>. Because we’ve explicitly specified that <code>T</code> should be replaced with <code>double</code>, the compiler won’t use template argument deduction. Instead, it will just instantiate the function <code>max<double>(double, double)</double></code>, and then type convert any mismatched arguments. Our <code>int</code> parameter will be implicitly converted to a <code>double</code>.</p><p>While this is more readable than using <code>static_cast</code>, it would be even nicer if we didn’t even have to think about the types when making a function call to <code>max</code> at all.</p><br><h3>Functions templates with multiple template type parameters</h3><p>The root of our problem is that we’ve only defined the single template type (<code>T</code>) for our function template, and then specified that both parameters must be of this same type.</p><p>The best way to solve this problem is to rewrite our function template in such a way that our parameters can resolve to different types. Rather than using one template type parameter <code>T</code>, we’ll now use two (<code>T</code> and <code>U</code>):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t,="" typename="" u=""> // We're using two template type parameters named T and U</typename></code><code>T max(T x, U y) // x can resolve to type T, and y can resolve to type U</code><code>{</code><code>    return (x &gt; y) ? x : y; // uh oh, we have a narrowing conversion problem here</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; max(2, 3.5) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because we’ve defined <code>x</code> with template type <code>T</code>, and <code>y</code> with template type <code>U</code>, <code>x</code> and <code>y</code> can now resolve their types independently. When we call <code>max(2, 3.5)</code>, <code>T</code> can be an <code>int</code> and <code>U</code> can be a <code>double</code>. The compiler will happily instantiate <code>max<int, double="">(int, double)</int,></code> for us.</p><p>However, the above code still has a problem: using the usual arithmetic rules (<a href="https://www.learncpp.com/cpp-tutorial/arithmetic-conversions/">8.4 -- Arithmetic conversions</a>), <code>double</code> takes precedence over <code>int</code>, so our conditional operator will return a <code>double</code>. But our function is defined as returning a <code>T</code> -- in cases where <code>T</code> resolves to an <code>int</code>, our <code>double</code> return value will undergo a narrowing conversion to an <code>int</code>, which will produce a warning (and possible loss of data).</p><p>Making the return type a <code>U</code> instead doesn’t solve the problem, as we can always flip the order of the operands in the function call to flip the types of <code>T</code> and <code>U</code>.</p><p>How do we solve this? This is a good use for an <code>auto</code> return type -- we’ll let the compiler deduce what the return type should be from the return statement:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t,="" typename="" u=""></typename></code><code>auto max(T x, U y)</code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; max(2, 3.5) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This version of <code>max</code> now works fine with operands of different types.</p><br><h3>Abbreviated function templates C++20</h3><p>C++20 introduces a new use of the <code>auto</code> keyword: When the <code>auto</code> keyword is used as a parameter type in a normal function, the compiler will automatically convert the function into a function template with each auto parameter becoming an independent template type parameter. This method for creating a function template is called an <span class="cpp-definition">abbreviated function template</span>.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>auto max(auto x, auto y)</code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code></pre><p>is shorthand in C++20 for the following:</p><pre class="language-cpp line-numbers"><code>template <typename t,="" typename="" u=""></typename></code><code>auto max(T x, U y)</code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code></pre><p>which is the same as the <code>max</code> function template we wrote above.</p><p>In cases where you want each template type parameter to be an independent type, this form is preferred as the removal of the template parameter declaration line makes your code more concise and readable.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Feel free to use abbreviated function templates if each auto parameter should be an independent template type (and your language standard is set to C++20 or newer).</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">8.x — Chapter 8 summary and quiz</h1></header><div class="entry-content" itemprop="articleBody"><p>You made it! The topics in this chapter (particularly type aliases, overloaded functions, and function templates) appear everywhere in the C++ standard library. We’ve got one more chapter to go (introducing compound types), and then we’ll be ready to dig into some of the most useful pieces of the standard library!</p><br><h3>Quick review</h3><p>The process of converting a value from one data type to another data type is called a <span class="cpp-definition">type conversion</span>.</p><p><span class="cpp-definition">Implicit type conversion</span> (also called <span class="cpp-definition">automatic type conversion</span> or <span class="cpp-definition">coercion</span>) is performed whenever one data type is expected, but a different data type is supplied. If the compiler can figure out how to do the conversion between the two types, it will. If it doesn’t know how, then it will fail with a compile error.</p><p>The C++ language defines a number of built-in conversions between its fundamental types (as well as a few conversions for more advanced types) called <span class="cpp-definition">standard conversions</span>. These include numeric promotions, numeric conversions, and arithmetic conversions.</p><p>A <span class="cpp-definition">numeric promotion</span> is the conversion of smaller numeric types to larger numeric types (typically <code>int</code> or <code>double</code>), so that the CPU can operate on data that matches the natural data size for the processor. Numeric promotions include both integral promotions and floating-point promotions. Numeric promotions are <span class="cpp-definition">value-preserving</span>, meaning there is no loss of value or precision.</p><p>A <span class="cpp-definition">numeric conversion</span> is a type conversion between fundamental types that isn’t a numeric promotion. A <span class="cpp-definition">narrowing conversion</span> is a numeric conversion that may result in the loss of value or precision.</p><p>In C++, certain binary operators require that their operands be of the same type. If operands of different types are provided, one or both of the operands will be implicitly converted to matching types using a set of rules called the <span class="cpp-definition">usual arithmetic conversions</span>.</p><p><span class="cpp-definition">Explicit type conversion</span> is performed when the programmer explicitly requests conversion via a cast. A <span class="cpp-definition">cast</span> represents a request by the programmer to do an explicit type conversion. C++ supports 5 types of casts: <code>C-style casts</code>, <code>static casts</code>, <code>const casts</code>, <code>dynamic casts</code>, and <code>reinterpret casts</code>. Generally you should avoid <code>C-style casts</code>, <code>const casts</code>, and <code>reinterpret casts</code>. <code>static_cast</code> is used to convert a value from one type to a value of another type, and is by far the most used cast in C++.</p><p><span class="cpp-definition">Typedefs</span> and <span class="cpp-definition">Type aliases</span> allow the programmer to create an alias for a data type. These aliases are not new types, and act identically to the aliased type. Typedefs and type aliases do not provide any kind of type safety, and care needs to be taken to not assume the alias is different than the type it is aliasing.</p><p>The <span class="cpp-definition">auto</span> keyword has a number of uses. First, auto can be used to do <span class="cpp-definition">type deduction</span> (also called <span class="cpp-definition">type inference</span>), which will deduce a variable’s type from its initializer. Type deduction drops const and references, so be sure to add those back if you want them.</p><p>Auto can also be used as a function return type to have the compiler infer the function’s return type from the function’s return statements, though this should be avoided for normal functions. Auto is used as part of the <span class="cpp-definition">trailing return syntax</span>.</p><p><span class="cpp-definition">Function overloading</span> allows us to create multiple functions with the same name, so long as each identically named function has different set of parameter types (or the functions can be otherwise differentiated). Such a function is called an <span class="cpp-definition">overloaded function</span> (or <span class="cpp-definition">overload</span> for short). Return types are not considered for differentiation.</p><p>When resolving overloaded functions, if an exact match isn’t found, the compiler will favor overloaded functions that can be matched via numeric promotions over those that require numeric conversions. When a function call is made to function that has been overloaded, the compiler will try to match the function call to the appropriate overload based on the arguments used in the function call. This is called <span class="cpp-definition">overload resolution</span>.</p><p>An <span class="cpp-definition">ambiguous match</span> occurs when the compiler finds two or more functions that can match a function call to an overloaded function and can’t determine which one is best.</p><p>A <span class="cpp-definition">default argument</span> is a default value provided for a function parameter. Parameters with default arguments must always be the rightmost parameters, and they are not used to differentiate functions when resolving overloaded functions.</p><p><span class="cpp-definition">Function templates</span> allow us to create a function-like definition that serves as a pattern for creating related functions. In a function template, we use <span class="cpp-definition">template types</span> as placeholders for any types we want to be specified later. The syntax that tells the compiler we’re defining a template and declares the template types is called a <span class="cpp-definition">template parameter declaration</span>.</p><p>The process of creating functions (with specific types) from function templates (with template types) is called <span class="cpp-definition">function template instantiation</span> (or <span class="cpp-definition">instantiation</span>) for short. When this process happens due to a function call, it’s called <span class="cpp-definition">implicit instantiation</span>. An instantiated function is called a <span class="cpp-definition">function instance</span> (or <span class="cpp-definition">instance</span> for short, or sometimes a <span class="cpp-definition">template function</span>).</p><p><span class="cpp-definition">Template argument deduction</span> allows the compiler to deduce the actual type that should be used to instantiate a function from the arguments of the function call. Template argument deduction does not do type conversion.</p><p>Template types are sometimes called <span class="cpp-definition">generic types</span>, and programming using templates is sometimes called <span class="cpp-definition">generic programming</span>.</p><p>In C++20, when the auto keyword is used as a parameter type in a normal function, the compiler will automatically convert the function into a function template with each auto parameter becoming an independent template type parameter. This method for creating a function template is called an <span class="cpp-definition">abbreviated function template</span>.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>What type of conversion happens in each of the following cases? Valid answers are: No conversion needed, numeric promotion, numeric conversion, won’t compile due to narrowing conversion. Assume <code>int</code> and <code>long</code> are both 4 bytes.</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int a { 5 }; // 1a</code><code>    int b { 'a' }; // 1b</code><code>    int c { 5.4 }; // 1c</code><code>    int d { true }; // 1d</code><code>    int e { static_cast<int>(5.4) }; // 1e</int></code><code></code><code>    double f { 5.0f }; // 1f</code><code>    double g { 5 }; // 1g</code><code></code><code>    // Extra credit section</code><code>    long h { 5 }; // 1h</code><code></code><code>    float i { f }; // 1i (uses previously defined variable f)</code><code>    float j { 5.0 }; // 1j</code><code></code><code>}</code></pre><p>1a) <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none">No conversion needed</div><p>1b) <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none">Numeric promotion of char ‘a’ to int</div><p>1c) <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none">Won’t compile due to narrowing conversion</div><p>1d) <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none">Numeric promotion of bool true to int</div><p>1e) <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none">Numeric conversion of double 5.4 to int</div><p>1f) <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none">Numeric promotion of float to double</div><p>1g) <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none">Numeric conversion of int to double</div><p>1h) <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_7'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_7" style="display:none">Numeric conversion of int to long (this conversion is trivial, but it’s still a conversion)</div><p>1i) <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_8'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_8" style="display:none">Won’t compile due to narrowing conversion from double to float</div><p>1j) <a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_9'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_9" style="display:none">Numeric conversion of double to float (this is allowed since 5.0 is constexpr and fits in the range of the float)</div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>2a) Upgrade the following program using type aliases:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>namespace constants</code><code>{</code><code>    inline constexpr double pi { 3.14159 };</code><code>}</code><code></code><code>double convertToRadians(double degrees)</code><code>{</code><code>    return degrees * constants::pi / 180;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number of degrees: ";</code><code>    double degrees{};</code><code>    std::cin &gt;&gt; degrees;</code><code></code><code>    double radians { convertToRadians(degrees) };</code><code>    std::cout &lt;&lt; degrees &lt;&lt; " degrees is " &lt;&lt; radians &lt;&lt; " radians.\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_10'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_10" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>namespace constants</code><code>{</code><code>    inline constexpr double pi{ 3.14159 };</code><code>}</code><code></code><code>using Degrees = double;</code><code>using Radians = double;</code><code></code><code>Radians convertToRadians(Degrees degrees)</code><code>{</code><code>    return degrees * constants::pi / 180;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number of degrees: ";</code><code>    Degrees degrees{};</code><code>    std::cin &gt;&gt; degrees;</code><code></code><code>    Radians radians{ convertToRadians(degrees) };</code><code>    std::cout &lt;&lt; degrees &lt;&lt; " degrees is " &lt;&lt; radians &lt;&lt; " radians.\n";</code><code></code><code>    return 0;</code><code>}</code></pre></div><p>2b) Building on quiz 2a, explain why the following statement will or won’t compile:</p><pre class="language-cpp line-numbers"><code>radians = degrees;</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_11'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_11" style="display:none"><p>It will compile. <code>radians</code> has type <code>Radians</code>, which is a type alias for <code>double</code>. <code>degrees</code> has type <code>Degrees</code>, which is also a type alias for <code>double</code>. So this just the assignment of a <code>double</code> value to a variable of type <code>double</code>.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>3a) What is the output of this program and why?</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print(int x)</code><code>{</code><code>    std::cout &lt;&lt; "int " &lt;&lt; x &lt;&lt; '\n';</code><code>}</code><code></code><code>void print(double x)</code><code>{</code><code>    std::cout &lt;&lt; "double " &lt;&lt; x &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    short s { 5 };</code><code>    print(s);</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_12'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_12" style="display:none"><p>The output is <code>int 5</code>. Converting a <code>short</code> to an <code>int</code> is a numeric promotion, whereas converting a <code>short</code> to a <code>double</code> is a numeric conversion. The compiler will favor the option that is a numeric promotion over the option that is a numeric conversion.</p></div><p>3b) Why won’t the following compile?</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print()</code><code>{</code><code>    std::cout &lt;&lt; "void\n";</code><code>}</code><code></code><code>void print(int x=0)</code><code>{</code><code>    std::cout &lt;&lt; "int " &lt;&lt; x &lt;&lt; '\n';</code><code>}</code><code></code><code>void print(double x)</code><code>{</code><code>    std::cout &lt;&lt; "double " &lt;&lt; x &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    print(5.0f);</code><code>    print();</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_13'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_13" style="display:none"><p>Because parameters with default arguments aren’t counted for resolving overloaded functions, the compiler can’t tell whether the call to <code>print()</code> should resolve to <code>print()</code> or <code>print(int x=0)</code>.</p></div><p>3c) Why won’t the following compile?</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print(long x)</code><code>{</code><code>    std::cout &lt;&lt; "long " &lt;&lt; x &lt;&lt; '\n';</code><code>}</code><code></code><code>void print(double x)</code><code>{</code><code>    std::cout &lt;&lt; "double " &lt;&lt; x &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    print(5);</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_14'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_14" style="display:none"><p>The value 5 is an <code>int</code>. Converting an <code>int</code> to a <code>long</code> or a <code>double</code> is a numeric conversion, and the compiler will be unable to determine which function is a better match.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #4</p><p>What is the output of this program and why?</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>int count(T) // This is the same as int count(T x), except we're not giving the parameter a name since we don't use the parameter</code><code>{</code><code>    static int c { 0 };</code><code>    return ++c;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; count(1) &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; count(1) &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; count(2.3) &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; count<double>(1) &lt;&lt; '\n';</double></code><code>    </code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_15'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_15" style="display:none"><pre>1
2
1
2
</pre><p>When <code>count(1)</code> is called, the compiler will instantiate the function <code>count<int>(int)</int></code> and call it. This will return 1.<br>When <code>count(1)</code> is called again, the compiler will see that <code>count<int>(int)</int></code> already exists, and call it again. This will return 2.<br>When <code>count(2.3)</code> is called, the compiler will instantiate the function with prototype <code>count<double>(double)</double></code> and call it. This is a new function with its own <code>static c</code> variable, so this will return 1.<br>When <code>count<double>(1)</double></code> is called, the compiler will see that we’re explicitly requesting the double version of count(). This function already exists due to the prior statement, so <code>count<double>(double)</double></code> will be called and the <code>int</code>argument will be implicitly converted to a <code>double</code>. This function will return 2.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #5</p><p>5a) Write a function template named <code>add</code> that allows the users to add 2 values of the same type. The following program should run:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// write your add function template here</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; add(2, 3) &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; add(1.2, 3.4) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>and produce the following output:</p><pre>5
4.6
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_16'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_16" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>T add(T x, T y)</code><code>{</code><code>	return x + y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; add(2, 3) &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; add(1.2, 3.4) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre></div><p>5b) Write a function template named <code>mult</code> that allows the user to multiply one value of any type (first parameter) and an integer (second parameter). The function should return the same type as the first parameter. The following program should run:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// write your mult function template here</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; mult(2, 3) &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; mult(1.2, 3) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>and produce the following output:</p><pre>6
3.6
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_17'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_17" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>T mult(T x, int y)</code><code>{</code><code>	return x * y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; mult(2, 3) &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; mult(1.2, 3) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre></div><p>5c) Write a function template named <code>sub</code> that allows the user to subtract two values of different types. The following program should run:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// write your sub function template here</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; sub(3, 2) &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; sub(3.5, 2) &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; sub(4, 1.5) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>and produce the following output:</p><pre>1
1.5
2.5
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_18'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_18" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t,="" typename="" u=""></typename></code><code>auto sub(T x, U y)</code><code>{</code><code>	return x - y;</code><code>}</code><code></code><code>/* </code><code>//If C++20 capable, you can use an abbreviated function template instead</code><code>auto sub(auto x, auto y)</code><code>{</code><code>	return x - y;</code><code>}</code><code>*/</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; sub(3, 2) &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; sub(3.5, 2) &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; sub(4, 1.5) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">9.1 — Introduction to compound data types</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-fundamental-data-types/">4.1 -- Introduction to fundamental data types</a>, we introduced the fundamental data types, which are the basic data types that C++ provides as part of the core language.</p><p>We’ve made much use of these fundamental types in our programs so far, especially the <code>int</code> data type. And while these fundamental types are extremely useful for straightforward uses, they don’t cover our full range of needs as we begin to do more complicated things.</p><p>For example, imagine you were writing a math program to multiply two fractions. How would you represent a fraction in your program? You might use a pair of integers (one for the numerator, one for the denominator), like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    // Our first fraction</code><code>    int num1 {};</code><code>    int den1 {};</code><code></code><code>    // Our second fraction</code><code>    int num2 {};</code><code>    int den2 {};</code><code></code><code>    // Used to eat the slash between the numerator and denominator</code><code>    char ignore {};</code><code></code><code>    std::cout &lt;&lt; "Enter a fraction: ";</code><code>    std::cin &gt;&gt; num1 &gt;&gt; ignore &gt;&gt; den1;</code><code></code><code>    std::cout &lt;&lt; "Enter a fraction: ";</code><code>    std::cin &gt;&gt; num2 &gt;&gt; ignore &gt;&gt; den2;</code><code></code><code>    std::cout &lt;&lt; "The two fractions multiplied: "</code><code>        &lt;&lt; num1 * num2 &lt;&lt; '/' &lt;&lt; den1 * den2 &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>And a run of this program:</p><pre>Enter a fraction: 1/2
Enter a fraction: 3/4
The two fractions multiplied: 3/8
</pre><p>While this program works, it introduces a couple of challenges for us to improve upon. First, each pair of integers is only loosely linked -- outside of comments and the context of how they are used in the code, there’s little to suggest that each numerator and denominator pair are related. Second, following the DRY (don’t repeat yourself) principle, we should create a function to handle the user inputting a fraction (along with some error handling). However, functions can only return a single value, so how would we return the numerator and denominator back to the caller?</p><p>Now imagine another case where you’re writing a program that needs to keep a list of employee IDs. How might you do so? You might try something like this:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int id1 { 42 };</code><code>    int id2 { 57 };</code><code>    int id3 { 162 };</code><code>    // and so on</code><code>}</code></pre><p>But what if you had 100 employees? First, you’d need to type in 100 variable names. And what if you needed to print them all? Or pass them to a function? We’d be in for a lot of typing. This simply doesn’t scale.</p><p>Clearly fundamental types will only carry us so far.</p><br><h3>Compound data types</h3><p>Fortunately, C++ supports a second set of data types called <code>compound data types</code>. <span class="cpp-definition">Compound data types</span> (also sometimes called <span class="cpp-definition">composite data types</span>) are data types that can be constructed from fundamental data types (or other compound data types). Each compound data type has its own unique properties as well.</p><p>As we’ll show in this chapter and future chapters, we can use compound data types to elegantly solve all of the challenges we presented above.</p><p>C++ supports the following compound types:</p><ul><li>Functions</li><li>Arrays</li><li>Pointer types:<ul><li>Pointer to object</li><li>Pointer to function</li></ul></li><li>Pointer to member types:<ul><li>Pointer to data member</li><li>Pointer to member function</li></ul></li><li>Reference types:<ul><li>L-value references</li><li>R-value references</li></ul></li><li>Enumerated types:<ul><li>Unscoped enumerations</li><li>Scoped enumerations</li></ul></li><li>Class types:<ul><li>Structs</li><li>Classes</li><li>Unions</li></ul></li></ul><p>You’ve already been using a one compound type regularly: functions. For example, consider this function:</p><pre class="language-cpp line-numbers"><code>void doSomething(int x, double y)</code><code>{</code><code>}</code></pre><p>The type of this function is <code>void(int, double)</code>. Note that this type is composed of fundamental types, making it a compound type. Of course, functions also have their own special behaviors as well (e.g. being callable).</p><p>Because there’s a lot of material to cover here, we’ll do it over three chapters. In this chapter, we’ll cover some of the more straightforward compound types, including <code>l-value references</code>, and <code>pointers</code>. Next chapter, we’ll cover <code>unscoped enumerations</code>, <code>scoped enumerations</code>, and basic <code>structs</code>. Then, in the chapter beyond that, we’ll introduce class types and dig into some of the more useful <code>array</code> types. This includes <code>std::string</code> (introduced in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-stdstring/">4.17 -- Introduction to std::string</a>), which is actually a class type!</p><p>Got your game face on? Let’s go!</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">9.2 — Value categories (lvalues and rvalues)</h1></header><div class="entry-content" itemprop="articleBody"><p>Before we talk about our first compound type (lvalue references), we’re going to take a little detour and talk about what an <code>lvalue</code> is.</p><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-expressions/">1.10 -- Introduction to expressions</a>, we defined an expression as “a combination of literals, variables, operators, and function calls that can be executed to produce a singular value”.<br>For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; 2 + 3 &lt;&lt; '\n'; // The expression 2 + 3 produces the value 5</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above program, the expression <code>2 + 3</code> is evaluated to produce the value 5, which is then printed to the console.</p><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/increment-decrement-operators-and-side-effects/">5.4 -- Increment/decrement operators, and side effects</a>, we also noted that expressions can produce side effects that outlive the expression:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x { 5 };</code><code>    ++x; // This expression statement has the side-effect of incrementing x</code><code>    std::cout &lt;&lt; x &lt;&lt; '\n'; // prints 6</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above program, the expression <code>++x</code> increments the value of <code>x</code>, and that value remains changed even after the expression has finished evaluating.</p><p>Besides producing values and side effects, expressions can do one more thing: they can evaluate to objects or functions. We’ll explore this point further in just a moment.</p><br><h3>The properties of an expression</h3><p>To help determine how expressions should evaluate and where they can be used, all expressions in C++ have two properties: a type and a value category.</p><br><h3>The type of an expression</h3><p>The type of an expression is equivalent to the type of the value, object, or function that results from the evaluated expression. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    auto v1 { 12 / 4 }; // int / int =&gt; int</code><code>    auto v2 { 12.0 / 4 }; // double / int =&gt; double</code><code></code><code>    return 0;</code><code>}</code></pre><p>For <code>v1</code>, the compiler will determine (at compile time) that a division with two <code>int</code> operands will produce an <code>int</code> result, so <code>int</code> is the type of this expression. Via type inference, <code>int</code> will then be used as the type of <code>v1</code>.</p><p>For <code>v2</code>, the compiler will determine (at compile time) that a division with a <code>double</code> operand and an <code>int</code> operand will produce a <code>double</code> result. Remember that arithmetic operators must have operands of matching types, so in this case, the <code>int</code> operand gets converted to a <code>double</code>, and a floating point division is performed. So <code>double</code> is the type of this expression.</p><p>The compiler can use the type of an expression to determine whether an expression is valid in a given context. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print(int x)</code><code>{</code><code>    std::cout &lt;&lt; x &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    print("foo"); // error: print() was expecting an int argument, we tried to pass in a string literal</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above program, the <code>print(int)</code> function is expecting an <code>int</code> parameter. However, the type of the expression we’re passing in (the string literal <code>"foo"</code>) does not match, and no conversion can be found. So a compile error results.</p><p>Note that the type of an expression must be determinable at compile time (otherwise type checking and type deduction wouldn’t work) -- however, the value of an expression may be determined at either compile time (if the expression is constexpr) or runtime (if the expression is not constexpr).</p><br><h3>The value category of an expression</h3><p>Now consider the following program:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int x{};</code><code></code><code>    x = 5; // valid: we can assign 5 to x</code><code>    5 = x; // error: can not assign value of x to literal value 5</code><code></code><code>    return 0;</code><code>}</code></pre><p>One of these assignment statements is valid (assigning value <code>5</code> to variable <code>x</code>) and one is not (what would it mean to assign the value of <code>x</code> to the literal value <code>5</code>?). So how does the compiler know which expressions can legally appear on either side of an assignment statement?</p><p>The answer lies in the second property of expressions: the <code>value category</code>. The <span class="cpp-definition">value category</span> of an expression (or subexpression) indicates whether an expression resolves to a value, a function, or an object of some kind.</p><p>Prior to C++11, there were only two possible value categories: <code>lvalue</code> and <code>rvalue</code>.</p><p>In C++11, three additional value categories (<code>glvalue</code>, <code>prvalue</code>, and <code>xvalue</code>) were added to support a new feature called <code>move semantics</code>.</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>In this lesson, we’ll stick to the pre-C++11 view of value categories, as this makes for a gentler introduction to value categories (and is all that we need for the moment). We’ll cover move semantics (and the additional three value categories) in a future chapter.</p></div><br><h3>Lvalue and rvalue expressions</h3><p>An <span class="cpp-definition">lvalue</span> (pronounced “ell-value”, short for “left value” or “locator value”, and sometimes written as “l-value”) is an expression that evaluates to an identifiable object or function (or bit-field).</p><p>The term “identity” is used by the C++ standard, but is not well-defined. An entity (such as an object or function) that has an identity can be differentiated from other similar entities (typically by comparing the addresses of the entity).</p><p>Entities with identities can be accessed via an identifier, reference, or pointer, and typically have a lifetime longer than a single expression or statement.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x { 5 };</code><code>    int y { x }; // x is an lvalue expression</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above program, the expression <code>x</code> is an lvalue expression as it evaluates to variable <code>x</code> (which has an identifier).</p><p>Since the introduction of constants into the language, lvalues come in two subtypes: a <span class="cpp-definition">modifiable lvalue</span> is an lvalue whose value can be modified. A <span class="cpp-definition">non-modifiable lvalue</span> is an lvalue whose value can’t be modified (because the lvalue is const or constexpr).</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{};</code><code>    const double d{};</code><code></code><code>    int y { x }; // x is a modifiable lvalue expression</code><code>    const double e { d }; // d is a non-modifiable lvalue expression</code><code></code><code>    return 0;</code><code>}</code></pre><p>An <span class="cpp-definition">rvalue</span> (pronounced “arr-value”, short for “right value”, and sometimes written as <code>r-value</code>) is an expression that is not an l-value. Commonly seen rvalues include literals (except C-style string literals, which are lvalues) and the return value of functions and operators. Rvalues aren’t identifiable (meaning they have to be used immediately), and only exist within the scope of the expression in which they are used.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int return5()</code><code>{</code><code>    return 5;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 }; // 5 is an rvalue expression</code><code>    const double d{ 1.2 }; // 1.2 is an rvalue expression</code><code></code><code>    int y { x }; // x is a modifiable lvalue expression</code><code>    const double e { d }; // d is a non-modifiable lvalue expression</code><code>    int z { return5() }; // return5() is an rvalue expression (since the result is returned by value)</code><code></code><code>    int w { x + 1 }; // x + 1 is an rvalue expression</code><code>    int q { static_cast<int>(d) }; // the result of static casting d to an int is an rvalue expression</int></code><code></code><code>    return 0;</code><code>}</code></pre><p>You may be wondering why <code>return5()</code>, <code>x + 1</code>, and <code>static_cast<int>(d)</int></code> are rvalues: the answer is because these expressions produce temporary values that are not identifiable objects.</p><p>Now we can answer the question about why <code>x = 5</code> is valid but <code>5 = x</code> is not: an assignment operation requires the left operand of the assignment to be a modifiable lvalue expression, and the right operand to be an rvalue expression. The latter assignment (<code>5 = x</code>) fails because the left operand expression <code>5</code> isn’t an lvalue.</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int x{};</code><code></code><code>    // Assignment requires the left operand to be a modifiable lvalue expression and the right operand to be an rvalue expression</code><code>    x = 5; // valid: x is a modifiable lvalue expression and 5 is an rvalue expression</code><code>    5 = x; // error: 5 is an rvalue expression and x is a modifiable lvalue expression</code><code></code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>A full list of lvalue and rvalue expressions can be found <a href="https://en.cppreference.com/w/cpp/language/value_category">here</a>. In C++11, rvalues are broken into two subtypes: prvalues and xvalues, so the rvalues we’re talking about here are the sum of both of those categories.</p></div><br><h3>L-value to r-value conversion</h3><p>We said above that the assignment operator expects the right operand to be an rvalue expression, so why does code like this work?</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int x{ 1 };</code><code>    int y{ 2 };</code><code></code><code>    x = y; // y is a modifiable lvalue, not an rvalue, but this is legal</code><code></code><code>    return 0;</code><code>}</code></pre><p>The answer is because lvalues will implicitly convert to rvalues, so an lvalue can be used wherever an rvalue is required.</p><p>Now consider this snippet:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int x { 2 };</code><code></code><code>    x = x + 1;</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this statement, the variable <code>x</code> is being used in two different contexts. On the left side of the assignment operator, <code>x</code> is an lvalue expression that evaluates to variable x. On the right side of the assignment operator, <code>x + 1</code> is an rvalue expression that evaluates to the value <code>3</code>.</p><p>Now that we’ve covered lvalues, we can get to our first compound type: the <code>lvalue reference</code>.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>As a rule of thumb to identify lvalue and rvalue expressions:</p><p>lvalues expressions are those that evaluate to variables or other identifiable objects that persist beyond the end of the expression.<br>rvalues expressions are those that evaluate to literals or the returned value of functions and operators that are discarded at the end of the expression.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">9.3 — Lvalue references</h1></header><div class="entry-content" itemprop="articleBody"><p>In C++, a <span class="cpp-definition">reference</span> is an alias for an existing object. Once a reference has been defined, any operation on the reference is applied to the object being referenced.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>A reference is essentially identical to the object being referenced.</p></div><p>This means we can use a reference to read or modify the object being referenced. Although references might seem silly, useless, or redundant at first, references are used everywhere in C++ (we’ll see examples of this in a few lessons).</p><p>You can also create references to functions, though this is done less often.</p><p>Modern C++ contains two types of references: <code>lvalue references</code>, and <code>rvalue references</code>. In this chapter, we’ll discuss lvalue references.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>Because we’ll be talking about <code>lvalues</code> and <code>rvalues</code> in this lesson, please review <a href="https://www.learncpp.com/cpp-tutorial/value-categories-lvalues-and-rvalues/">9.2 -- Value categories (lvalues and rvalues)</a> if you need a refresher on these terms before proceeding.</p><p>Rvalue references are covered in the chapter on <code>move semantics</code> (<a href="https://www.learncpp.com#ChapterM">chapter M</a>).</p></div><br><h3>Lvalue reference types</h3><p>An <span class="cpp-definition">lvalue reference</span> (commonly just called a <code>reference</code> since prior to C++11 there was only one type of reference) acts as an alias for an existing lvalue (such as a variable).</p><p>To declare an lvalue reference type, we use an ampersand (&amp;) in the type declaration:</p><pre class="language-cpp line-numbers"><code>int      // a normal int type</code><code>int&amp;     // an lvalue reference to an int object</code><code>double&amp;  // an lvalue reference to a double object</code></pre><br><h3>Lvalue reference variables</h3><p>One of the things we can do with an lvalue reference type is create an lvalue reference variable. An <span class="cpp-definition">lvalue reference variable</span> is a variable that acts as a reference to an lvalue (usually another variable).</p><p>To create an lvalue reference variable, we simply define a variable with an lvalue reference type:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x { 5 };    // x is a normal integer variable</code><code>    int&amp; ref { x }; // ref is an lvalue reference variable that can now be used as an alias for variable x</code><code></code><code>    std::cout &lt;&lt; x &lt;&lt; '\n';  // print the value of x (5)</code><code>    std::cout &lt;&lt; ref &lt;&lt; '\n'; // print the value of x via ref (5)</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, the type <code>int&amp;</code> defines <code>ref</code> as an lvalue reference to an int, which we then initialize with lvalue expression <code>x</code>. Thereafter, <code>ref</code> and <code>x</code> can be used synonymously. This program thus prints:</p><pre>5
5
</pre><p>From the compiler’s perspective, it doesn’t matter whether the ampersand is “attached” to the type name (<code>int&amp; ref</code>) or the variable’s name (<code>int &amp;ref</code>), and which you choose is a matter of style. Modern C++ programmers tend to prefer attaching the ampersand to the type, as it makes clearer that the reference is part of the type information, not the identifier.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>When defining a reference, place the ampersand next to the type (not the reference variable’s name).</p></div><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>For those of you already familiar with pointers, the ampersand in this context does not mean “address of”, it means “lvalue reference to”.</p></div><br><h3>Modifying values through an lvalue reference</h3><p>In the above example, we showed that we can use a reference to read the value of the object being referenced. We can also use a reference to modify the value of the object being referenced:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x { 5 }; // normal integer variable</code><code>    int&amp; ref { x }; // ref is now an alias for variable x</code><code></code><code>    std::cout &lt;&lt; x &lt;&lt; ref &lt;&lt; '\n'; // print 55</code><code></code><code>    x = 6; // x now has value 6</code><code></code><code>    std::cout &lt;&lt; x &lt;&lt; ref &lt;&lt; '\n'; // prints 66</code><code></code><code>    ref = 7; // the object being referenced (x) now has value 7</code><code></code><code>    std::cout &lt;&lt; x &lt;&lt; ref &lt;&lt; '\n'; // prints 77</code><code></code><code>    return 0;</code><code>}</code></pre><p>This code prints:</p><pre>55
66
77
</pre><p>In the above example, <code>ref</code> is an alias for <code>x</code>, so we are able to change the value of <code>x</code> through either <code>x</code> or <code>ref</code>.</p><br><h3>Initialization of lvalue references</h3><p>Much like constants, all references must be initialized.</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int&amp; invalidRef;   // error: references must be initialized</code><code></code><code>    int x { 5 };</code><code>    int&amp; ref { x }; // okay: reference to int is bound to int variable</code><code></code><code>    return 0;</code><code>}</code></pre><p>When a reference is initialized with an object (or function), we say it is <span class="cpp-definition">bound</span> to that object (or function). The process by which such a reference is bound is called <span class="cpp-definition">reference binding</span>. The object (or function) being referenced is sometimes called the <span class="cpp-definition">referent</span>.</p><p>Lvalue references must be bound to a <em>modifiable</em> lvalue.</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int x { 5 };</code><code>    int&amp; ref { x }; // valid: lvalue reference bound to a modifiable lvalue</code><code></code><code>    const int y { 5 };</code><code>    int&amp; invalidRef { y };  // invalid: can't bind to a non-modifiable lvalue </code><code>    int&amp; invalidRef2 { 0 }; // invalid: can't bind to an r-value</code><code></code><code>    return 0;</code><code>}</code></pre><p>Lvalue references can’t be bound to non-modifiable lvalues or rvalues (otherwise you’d be able to change those values through the reference, which would be a violation of their const-ness). For this reason, lvalue references are occasionally called <span class="cpp-definition">lvalue references to non-const</span> (sometimes shortened to <span class="cpp-definition">non-const reference</span>).</p><p>In most cases, the type of the reference must match the type of the referent (there are some exceptions to this rule that we’ll discuss when we get into inheritance):</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int x { 5 };</code><code>    int&amp; ref { x }; // okay: reference to int is bound to int variable</code><code></code><code>    double y { 6.0 };</code><code>    int&amp; invalidRef { y }; // invalid; reference to int cannot bind to double variable</code><code>    double&amp; invalidRef2 { x }; // invalid: reference to double cannot bind to int variable</code><code></code><code>    return 0;</code><code>}</code></pre><p>Lvalue references to <code>void</code> are disallowed (what would be the point?).</p><br><h3>References can’t be reseated (changed to refer to another object)</h3><p>Once initialized, a reference in C++ cannot be <span class="cpp-definition">reseated</span>, meaning it cannot be changed to reference another object.</p><p>New C++ programmers often try to reseat a reference by using assignment to provide the reference with another variable to reference. This will compile and run -- but not function as expected. Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x { 5 };</code><code>    int y { 6 };</code><code></code><code>    int&amp; ref { x }; // ref is now an alias for x</code><code>    </code><code>    ref = y; // assigns 6 (the value of y) to x (the object being referenced by ref)</code><code>    // The above line does NOT change ref into a reference to variable y!</code><code></code><code>    std::cout &lt;&lt; x &lt;&lt; '\n'; // user is expecting this to print 5</code><code></code><code>    return 0;</code><code>}</code></pre><p>Perhaps surprisingly, this prints:</p><pre>6
</pre><p>When a reference is evaluated in an expression, it resolves to the object it’s referencing. So <code>ref = y</code> doesn’t change <code>ref</code> to now reference <code>y</code>. Rather, because <code>ref</code> is an alias for <code>x</code>, the expression evaluates as if it was written <code>x = y</code> -- and since <code>y</code> evaluates to value <code>6</code>, <code>x</code> is assigned the value <code>6</code>.</p><br><h3>Lvalue reference scope and duration</h3><p>Reference variables follow the same scoping and duration rules that normal variables do:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x { 5 }; // normal integer</code><code>    int&amp; ref { x }; // reference to variable value</code><code></code><code>     return 0;</code><code>} // x and ref die here</code></pre><br><h3>References and referents have independent lifetimes</h3><p>With one exception (that we’ll cover next lesson), the lifetime of a reference and the lifetime of its referent are independent. In other words, both of the following are true:</p><ul><li>A reference can be destroyed before the object it is referencing.</li><li>The object being referenced can be destroyed before the reference.</li></ul><p>When a reference is destroyed before the referent, the referent is not impacted. The following program demonstrates this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x { 5 };</code><code></code><code>    {</code><code>        int&amp; ref { x };   // ref is a reference to x</code><code>        std::cout &lt;&lt; ref &lt;&lt; '\n'; // prints value of ref (5)</code><code>    } // ref is destroyed here -- x is unaware of this</code><code></code><code>    std::cout &lt;&lt; x &lt;&lt; '\n'; // prints value of x (5)</code><code></code><code>    return 0;</code><code>} // x destroyed here</code></pre><p>The above prints:</p><pre>5
5
</pre><p>When <code>ref</code> dies, variable <code>x</code> carries on as normal, blissfully unaware that a reference to it has been destroyed.</p><br><h3>Dangling references</h3><p>When an object being referenced is destroyed before a reference to it, the reference is left referencing an object that no longer exists. Such a reference is called a <span class="cpp-definition">dangling reference</span>. Accessing a dangling reference leads to undefined behavior.</p><p>Dangling references are fairly easy to avoid, but we’ll show a case where this can happen in practice in lesson <a href="https://www.learncpp.com/cpp-tutorial/return-by-reference-and-return-by-address/">9.11 -- Return by reference and return by address</a>.</p><br><h3>References aren’t objects</h3><p>Perhaps surprisingly, references are not objects in C++. A reference is not required to exist or occupy storage. If possible, the compiler will optimize references away by replacing all occurrences of a reference with the referent. However, this isn’t always possible, and in such cases, references may require storage.</p><p>This also means that the term “reference variable” is a bit of a misnomer, as variables are objects with a name, and references aren’t objects.</p><p>Because references aren’t objects, they can’t be used anywhere an object is required (e.g. you can’t have a reference to a reference, since an lvalue reference must reference an identifiable object). In cases where you need a reference that is an object or a reference that can be reseated, <code>std::reference_wrapper</code> (which we cover in lesson <a href="https://www.learncpp.com/cpp-tutorial/aggregation/">16.3 -- Aggregation</a>) provides a solution.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>Consider the following variables:</p><pre class="language-cpp line-numbers"><code>int var{};</code><code>int&amp; ref1{ var };  // an lvalue reference bound to var</code><code>int&amp; ref2{ ref1 }; // an lvalue reference bound to var</code></pre><p>Because <code>ref2</code> (a reference) is initialized with <code>ref1</code> (a reference), you might be tempted to conclude that <code>ref2</code> is a reference to a reference. It is not. Because <code>ref1</code> is a reference to <code>var</code>, when used in an expression (such as an initializer), <code>ref1</code> evaluates to <code>var</code>. So <code>ref2</code> is just a normal lvalue reference (as indicated by its type <code>int&amp;</code>), bound to <code>var</code>.</p><p>A reference to a reference (to an <code>int</code>) would have syntax <code>int&amp;&amp;</code> -- but since C++ doesn’t support references to references, this syntax was repurposed in C++11 to indicate an rvalue reference (which we cover in lesson <a href="https://www.learncpp.com/cpp-tutorial/rvalue-references/">M.2 -- R-value references</a>).</p></div><br><h3>Quiz time</h3><p class="cpp-quiz-question" style="clear:both">Question #1</p><p>Determine what values the following program prints by yourself (do not compile the program).</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 1 };</code><code>    int&amp; ref{ x };</code><code></code><code>    std::cout &lt;&lt; x &lt;&lt; ref &lt;&lt; '\n';</code><code></code><code>    int y{ 2 };</code><code>    ref = y;</code><code>    y = 3;</code><code></code><code>    std::cout &lt;&lt; x &lt;&lt; ref &lt;&lt; '\n';</code><code></code><code>    x = 4;</code><code></code><code>    std::cout &lt;&lt; x &lt;&lt; ref &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>11<br>22<br>44</p><p>Because <code>ref</code> is bound to <code>x</code>, <code>x</code> and <code>ref</code> are synonymous, so they will always print the same value. The line <code>ref = y</code> assigns the value of <code>y</code> (2) to <code>ref</code> -- it does not change <code>ref</code> to reference <code>y</code>. The subsequent line <code>y = 3</code> only changes <code>y</code>.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">9.4 — Lvalue references to const</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson (<a href="https://www.learncpp.com/cpp-tutorial/lvalue-references/">9.3 -- Lvalue references</a>), we discussed how an lvalue reference can only bind to a modifiable lvalue. This means the following is illegal:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    const int x { 5 }; // x is a non-modifiable (const) lvalue</code><code>    int&amp; ref { x }; // error: ref can not bind to non-modifiable lvalue</code><code></code><code>    return 0;</code><code>}</code></pre><p>This is disallowed because it would allow us to modify a const variable (<code>x</code>) through the non-const reference (<code>ref</code>).</p><p>But what if we want to have a const variable we want to create a reference to? A normal lvalue reference (to a non-const value) won’t do.</p><br><h3>Lvalue reference to const</h3><p>By using the <code>const</code> keyword when declaring an lvalue reference, we tell an lvalue reference to treat the object it is referencing as const. Such a reference is called an <span class="cpp-definition">lvalue reference to a const value</span> (sometimes called a <span class="cpp-definition">reference to const</span> or a <span class="cpp-definition">const reference</span>).</p><p>Lvalue references to const can bind to non-modifiable lvalues:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    const int x { 5 };    // x is a non-modifiable lvalue</code><code>    const int&amp; ref { x }; // okay: ref is a an lvalue reference to a const value</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because lvalue references to const treat the object they are referencing as const, they can be used to access but not modify the value being referenced:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    const int x { 5 };    // x is a non-modifiable lvalue</code><code>    const int&amp; ref { x }; // okay: ref is a an lvalue reference to a const value</code><code></code><code>    std::cout &lt;&lt; ref &lt;&lt; '\n'; // okay: we can access the const object</code><code>    ref = 6;                  // error: we can not modify a const object</code><code>    </code><code>    return 0;</code><code>}</code></pre><br><h3>Initializing an lvalue reference to const with a modifiable lvalue</h3><p>Lvalue references to const can also bind to modifiable lvalues. In such a case, the object being referenced is treated as const when accessed through the reference (even though the underlying object is non-const):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x { 5 };          // x is a modifiable lvalue</code><code>    const int&amp; ref { x }; // okay: we can bind a const reference to a modifiable lvalue</code><code></code><code>    std::cout &lt;&lt; ref &lt;&lt; '\n'; // okay: we can access the object through our const reference</code><code>    ref = 7;                 // error: we can not modify an object through a const reference</code><code></code><code>    x = 6;                // okay: x is a modifiable lvalue, we can still modify it through the original identifier</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above program, we bind const reference <code>ref</code> to modifiable lvalue <code>x</code>. We can then use <code>ref</code> to access <code>x</code>, but because <code>ref</code> is const, we can not modify the value of <code>x</code> through <code>ref</code>. However, we still can modify the value of <code>x</code> directly (using the identifier <code>x</code>).</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Favor <code>lvalue references to const</code> over <code>lvalue references to non-const</code> unless you need to modify the object being referenced.</p></div><br><h3>Initializing an lvalue reference to const with an rvalue</h3><p>Perhaps surprisingly, lvalues references to const can also bind to rvalues:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    const int&amp; ref { 5 }; // okay: 5 is an rvalue</code><code></code><code>    std::cout &lt;&lt; ref &lt;&lt; '\n'; // prints 5</code><code></code><code>    return 0;</code><code>}</code></pre><p>When this happens, a temporary object is created and initialized with the rvalue, and the reference to const is bound to that temporary object.</p><p>A <span class="cpp-definition">temporary object</span> (also sometimes called an <span class="cpp-definition">anonymous object</span>) is an object that is created for temporary use (and then destroyed) within a single expression. Temporary objects have no scope at all (this makes sense, since scope is a property of an identifier, and temporary objects have no identifier). This means a temporary object can only be used directly at the point where it is created, since there is no way to refer to it beyond that point.</p><br><h3>Const references bound to temporary objects extend the lifetime of the temporary object</h3><p>Temporary objects are normally destroyed at the end of the expression in which they are created.</p><p>However, consider what would happen in the above example if the temporary object created to hold rvalue <code>5</code> was destroyed at the end of the expression that initializes <code>ref</code>. Reference <code>ref</code> would be left dangling (referencing an object that had been destroyed), and we’d get undefined behavior when we tried to access <code>ref</code>.</p><p>To avoid dangling references in such cases, C++ has a special rule: When a const lvalue reference is bound to a temporary object, the lifetime of the temporary object is extended to match the lifetime of the reference.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    const int&amp; ref { 5 }; // The temporary object holding value 5 has its lifetime extended to match ref</code><code></code><code>    std::cout &lt;&lt; ref &lt;&lt; '\n'; // Therefore, we can safely use it here</code><code></code><code>    return 0;</code><code>} // Both ref and the temporary object die here</code></pre><p>In the above example, when <code>ref</code> is initialized with rvalue <code>5</code>, a temporary object is created and <code>ref</code> is bound to that temporary object. The lifetime of the temporary object matches the lifetime of <code>ref</code>. Thus, we can safely print the value of <code>ref</code> in the next statement. Then both <code>ref</code> and the temporary object go out of scope and are destroyed at the end of the block.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Lvalue references can only bind to modifiable lvalues.</p><p>Lvalue references to const can bind to modifiable lvalues, non-modifiable lvalues, and rvalues. This makes them a much more flexible type of reference.</p></div><p>So why does C++ allow a const reference to bind to an rvalue anyway? We’ll answer that question in the next lesson!</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">9.5 — Pass by lvalue reference</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lessons, we introduced lvalue references (<a href="https://www.learncpp.com/cpp-tutorial/lvalue-references/">9.3 -- Lvalue references</a>) and lvalue references to const (<a href="https://www.learncpp.com/cpp-tutorial/lvalue-references-to-const/">9.4 -- Lvalue references to const</a>). In isolation, these may not have seemed very useful -- why create an alias to a variable when you can just use the variable itself?</p><p>In this lesson, we’ll finally provide some insight into what makes references useful. And then starting later in this chapter, you’ll see references used regularly.</p><p>First, some context. Back in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-function-parameters-and-arguments/">2.4 -- Introduction to function parameters and arguments</a> we discussed <code>pass by value</code>, where an argument passed to a function is copied into the function’s parameter:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printValue(int y)</code><code>{</code><code>    std::cout &lt;&lt; y &lt;&lt; '\n';</code><code>} // y is destroyed here</code><code></code><code>int main()</code><code>{</code><code>    int x { 2 };</code><code></code><code>    printValue(x); // x is passed by value (copied) into parameter y (inexpensive)</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above program, when <code>printValue(x)</code> is called, the value of <code>x</code> (<code>2</code>) is <em>copied</em> into parameter <code>y</code>. Then, at the end of the function, object <code>y</code> is destroyed.</p><p>This means that when we called the function, we made a copy of our argument’s value, only to use it briefly and then destroy it! Fortunately, because fundamental types are cheap to copy, this isn’t a problem.</p><br><h3>Some objects are expensive to copy</h3><p>Most of the types provided by the standard library (such as <code>std::string</code>) are <code>class types</code>. Class types are usually expensive to copy. Whenever possible, we want to avoid making unnecessary copies of objects that are expensive to copy, especially when we will destroy those copies almost immediately.</p><p>Consider the following program illustrating this point:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>void printValue(std::string y)</code><code>{</code><code>    std::cout &lt;&lt; y &lt;&lt; '\n';</code><code>} // y is destroyed here</code><code></code><code>int main()</code><code>{</code><code>    std::string x { "Hello, world!" }; // x is a std::string</code><code></code><code>    printValue(x); // x is passed by value (copied) into parameter y (expensive)</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints</p><pre>Hello, world!
</pre><p>While this program behaves like we expect, it’s also inefficient. Identically to the prior example, when <code>printValue()</code> is called, argument <code>x</code> is copied into <code>printValue()</code> parameter <code>y</code>. However, in this example, the argument is a <code>std::string</code> instead of an <code>int</code>, and <code>std::string</code> is a class type that is expensive to copy. And this expensive copy is made every time <code>printValue()</code> is called!</p><p>We can do better.</p><br><h3>Pass by reference</h3><p>One way to avoid making an expensive copy of an argument when calling a function is to use <code>pass by reference</code> instead of <code>pass by value</code>. When using <span class="cpp-definition">pass by reference</span>, we declare a function parameter as a reference type (or const reference type) rather than as a normal type. When the function is called, each reference parameter is bound to the appropriate argument. Because the reference acts as an alias for the argument, no copy of the argument is made.</p><p>Here’s the same example as above, using pass by reference instead of pass by value:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>void printValue(std::string&amp; y) // type changed to std::string&amp;</code><code>{</code><code>    std::cout &lt;&lt; y &lt;&lt; '\n';</code><code>} // y is destroyed here</code><code></code><code>int main()</code><code>{</code><code>    std::string x { "Hello, world!" };</code><code></code><code>    printValue(x); // x is now passed by reference into reference parameter y (inexpensive)</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program is identical to the prior one, except the type of parameter <code>y</code> has been changed from <code>std::string</code> to <code>std::string&amp;</code> (an lvalue reference). Now, when <code>printValue(x)</code> is called, lvalue reference parameter <code>y</code> is bound to argument <code>x</code>. Binding a reference is always inexpensive, and no copy of <code>x</code> needs to be made. Because a reference acts as an alias for the object being referenced, when <code>printValue()</code> uses reference <code>y</code>, it’s accessing the actual argument <code>x</code> (rather than a copy of <code>x</code>).</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Pass by reference allows us to pass arguments to a function without making copies of those arguments each time the function is called.</p></div><br><h3>Pass by reference allows us to change the value of an argument</h3><p>When an object is passed by value, the function parameter receives a copy of the argument. This means that any changes to the value of the parameter are made to the copy of the argument, not the argument itself:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void addOne(int y) // y is a copy of x</code><code>{</code><code>    ++y; // this modifies the copy of x, not the actual object x</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x { 5 };</code><code></code><code>    std::cout &lt;&lt; "value = " &lt;&lt; x &lt;&lt; '\n';</code><code></code><code>    addOne(x);</code><code></code><code>    std::cout &lt;&lt; "value = " &lt;&lt; x &lt;&lt; '\n'; // x has not been modified</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above program, because value parameter <code>y</code> is a copy of <code>x</code>, when we increment <code>y</code>, this only affects <code>y</code>. This program outputs:</p><pre>value = 5
value = 5
</pre><p>However, since a reference acts identically to the object being referenced, when using pass by reference, any changes made to the reference parameter <em>will</em> affect the argument:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void addOne(int&amp; y) // y is bound to the actual object x</code><code>{</code><code>    ++y; // this modifies the actual object x</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x { 5 };</code><code></code><code>    std::cout &lt;&lt; "value = " &lt;&lt; x &lt;&lt; '\n';</code><code></code><code>    addOne(x);</code><code></code><code>    std::cout &lt;&lt; "value = " &lt;&lt; x &lt;&lt; '\n'; // x has been modified</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program outputs:</p><pre>value = 5
value = 6
</pre><p>In the above example, <code>x</code> initially has value <code>5</code>. When <code>addOne(x)</code> is called, reference parameter <code>y</code> is bound to argument <code>x</code>. When the <code>addOne()</code> function increments reference <code>y</code>, it’s actually incrementing argument <code>x</code> from <code>5</code> to <code>6</code> (not a copy of <code>x</code>). This changed value persists even after <code>addOne()</code> has finished executing.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Passing values by reference to non-const allows us to write functions that modify the value of arguments passed in.</p></div><p>The ability for functions to modify the value of arguments passed in can be useful. Imagine you’ve written a function that determines whether a monster has successfully attacked the player. If so, the monster should do some amount of damage to the player’s health. If you pass your player object by reference, the function can directly modify the health of the actual player object that was passed in. If you pass the player object by value, you could only modify the health of a copy of the player object, which isn’t as useful.</p><br><h3>Pass by reference to non-const can only accept modifiable lvalue arguments</h3><p>Because a reference to a non-const value can only bind to a modifiable lvalue (essentially a non-const variable), this means that pass by reference only works with arguments that are modifiable lvalues. In practical terms, this significantly limits the usefulness of pass by reference to non-const, as it means we can not pass const variables or literals. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>void printValue(int&amp; y) // y only accepts modifiable lvalues</code><code>{</code><code>    std::cout &lt;&lt; y &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x { 5 };</code><code>    printValue(x); // ok: x is a modifiable lvalue</code><code></code><code>    const int z { 5 };</code><code>    printValue(z); // error: z is a non-modifiable lvalue</code><code></code><code>    printValue(5); // error: 5 is an rvalue</code><code></code><code>    return 0;</code><code>}</code></pre><p>Fortunately, there’s an easy way around this.</p><br><h3>Pass by const reference</h3><p>Unlike a reference to non-const (which can only bind to modifiable lvalues), a reference to const can bind to modifiable lvalues, non-modifiable lvalues, and rvalues. Therefore, if we make our reference parameter const, then it will be able to bind to any type of argument:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>void printValue(const int&amp; y) // y is now a const reference</code><code>{</code><code>    std::cout &lt;&lt; y &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x { 5 };</code><code>    printValue(x); // ok: x is a modifiable lvalue</code><code></code><code>    const int z { 5 };</code><code>    printValue(z); // ok: z is a non-modifiable lvalue</code><code></code><code>    printValue(5); // ok: 5 is a literal rvalue</code><code></code><code>    return 0;</code><code>}</code></pre><p>Passing by const reference offers the same primary benefit as pass by reference (avoiding making a copy of the argument), while also guaranteeing that the function can <em>not</em> change the value being referenced.</p><p>For example, the following is disallowed, because <code>ref</code> is const:</p><pre class="language-cpp line-numbers"><code>void addOne(const int&amp; ref)</code><code>{</code><code>    ++ref; // not allowed: ref is const</code><code>}</code></pre><p>In most cases, we don’t want our functions modifying the value of arguments.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Favor passing by const reference over passing by non-const reference unless you have a specific reason to do otherwise (e.g. the function needs to change the value of an argument).</p></div><p>Now we can understand the motivation for allowing const lvalue references to bind to rvalues: without that capability, there would be no way to pass literals (or other rvalues) to functions that used pass by reference!</p><br><h3>Mixing pass by value and pass by reference</h3><p>A function with multiple parameters can determine whether each parameter is passed by value or passed by reference individually.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>void foo(int a, int&amp; b, const std::string&amp; c)</code><code>{</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x { 5 };</code><code>    const std::string s { "Hello, world!" };</code><code></code><code>    foo(5, x, s);</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, the first argument is passed by value, the second by reference, and the third by const reference.</p><br><h3>When to pass by reference</h3><p>Because class types can be expensive to copy (sometimes significantly so), class types are usually passed by const reference instead of by value to avoid making an expensive copy of the argument. Fundamental types are cheap to copy, so they are typically passed by value.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Pass fundamental types by value, and class (or struct) types by const reference.</p></div><br><h3>The cost of pass by value vs pass by reference (advanced)</h3><p>Not all class types need to be passed by reference. And you may be wondering why we don’t just pass everything by reference. In this section (which is optional reading), we discuss the cost of pass by value vs pass by reference, and refine our best practice as to when we should use each.</p><p>There are two key points that will help us understand when we should pass by value vs pass by reference:</p><p>First, the cost of copying an object is generally proportional to two things:</p><ul><li>The size of the object. Objects that use more memory take more time to copy.</li><li>Any additional setup costs. Some class types do additional setup when they are instantiated (e.g. such as opening a file or database, or allocating a certain amount of dynamic memory to hold an object of a variable size). These setup costs must be paid each time an object is copied.</li></ul><p>On the other hand, binding a reference to an object is always fast (about the same speed as copying a fundamental type).</p><p>Second, accessing an object through a reference is slightly more expensive than accessing an object through a normal variable identifier. With a variable identifier, the compiler can just go to the memory address assigned to that variable and access the value. With a reference, there usually is an extra step: the compiler must first determine which object is being referenced, and only then can it go to that memory address for that object and access the value. The compiler can also sometimes optimize code using objects passed by value more highly than code using objects passed by reference. This means code generated for objects passed by reference is typically slower than the code generated for objects passed by value.</p><p>We can now answer the question of why we don’t pass everything by reference:</p><ul><li>For objects that are cheap to copy, the cost of copying is similar to the cost of binding, so we favor pass by value so the code generated will be faster.</li><li>For objects that are expensive to copy, the cost of the copy dominates, so we favor pass by (const) reference to avoid making a copy.</li></ul><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Prefer pass by value for objects that are cheap to copy, and pass by const reference for objects that are expensive to copy. If you’re not sure whether an object is cheap or expensive to copy, favor pass by const reference.</p></div><p>The last question then is, how do we define “cheap to copy”? There is no absolute answer here, as this varies by compiler, use case, and architecture. However, we can formulate a good rule of thumb: An object is cheap to copy if it uses 2 or fewer “words” of memory (where a “word” is approximated by the size of a memory address) and it has no setup costs.</p><p>The following program defines a macro that can be used to determine if a type (or object) uses 2 or fewer memory addresses worth of memory:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// Evaluates to true if the type (or object) uses 2 or fewer memory addresses worth of memory</code><code>#define isSmall(T) (sizeof(T) &lt;= 2 * sizeof(void*))</code><code></code><code>struct S</code><code>{</code><code>    double a, b, c;</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; std::boolalpha; // print true or false rather than 1 or 0</code><code>    std::cout &lt;&lt; isSmall(int) &lt;&lt; '\n'; // true</code><code>    std::cout &lt;&lt; isSmall(double) &lt;&lt; '\n'; // true</code><code>    std::cout &lt;&lt; isSmall(S) &lt;&lt; '\n'; // false</code><code></code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>We use a preprocessor macro here so that we can substitute in a type (normal functions disallow this).</p></div><p>However, it can be hard to know whether a class type object has setup costs or not. It’s best to assume that most standard library classes have setup costs, unless you know otherwise that they don’t.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>An object of type T is cheap to copy if <code>sizeof(T) &lt;= 2 * sizeof(void*)</code> and has no additional setup costs.</p><p>Common types that are cheap to copy include all of the fundamental types, enumerated types, and std::string_view.<br>Common types that are expensive to copy include std::array, std::string, std::vector, and std::ostream.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">9.6 — Introduction to pointers</h1></header><div class="entry-content" itemprop="articleBody"><p>Pointers are one of C++’s historical boogeymen, and a place where many aspiring C++ learners have gotten stuck. However, as you’ll see shortly, pointers are nothing to be scared of.</p><p>In fact, pointers behave a lot like lvalue references. But before we explain that further, let’s do some setup.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>If you’re rusty or not familiar with lvalue references, now would be a good time to review them. We cover lvalue references in lessons <a href="https://www.learncpp.com/cpp-tutorial/lvalue-references/">9.3 -- Lvalue references</a>, <a href="https://www.learncpp.com/cpp-tutorial/lvalue-references-to-const/">9.4 -- Lvalue references to const</a>, and <a href="https://www.learncpp.com/cpp-tutorial/pass-by-lvalue-reference/">9.5 -- Pass by lvalue reference</a>.</p></div><p>Consider a normal variable, like this one:</p><pre class="language-cpp line-numbers"><code>char x {}; // chars use 1 byte of memory</code></pre><p>Simplifying a bit, when the code generated for this definition is executed, a piece of memory from RAM will be assigned to this object. For the sake of example, let’s say that the variable <code>x</code> is assigned memory address <code>140</code>. Whenever we use variable <code>x</code> in an expression or statement, the program will go to memory address <code>140</code> to access the value stored there.</p><p>The nice thing about variables is that we don’t need to worry about what specific memory addresses are assigned, or how many bytes are required to store the object’s value. We just refer to the variable by its given identifier, and the compiler translates this name into the appropriately assigned memory address. The compiler takes care of all the addressing.</p><p>This is also true with references:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    char x {}; // assume this is assigned memory address 140</code><code>    char&amp; ref { x }; // ref is an lvalue reference to x (when used with a type, &amp; means lvalue reference)</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because <code>ref</code> acts as an alias for <code>x</code>, whenever we use <code>ref</code>, the program will go to memory address <code>140</code> to access the value. Again the compiler takes care of the addressing, so that we don’t have to think about it.</p><br><h3>The address-of operator (&amp;)</h3><p>Although the memory addresses used by variables aren’t exposed to us by default, we do have access to this information. The <span class="cpp-definition">address-of operator</span> (&amp;) returns the memory address of its operand. This is pretty straightforward:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    std::cout &lt;&lt; x &lt;&lt; '\n';  // print the value of variable x</code><code>    std::cout &lt;&lt; &amp;x &lt;&lt; '\n'; // print the memory address of variable x</code><code></code><code>    return 0;</code><code>}</code></pre><p>On the author’s machine, the above program printed:</p><pre>5
0027FEA0
</pre><p>In the above example, we use the address-of operator (&amp;) to retrieve the address assigned to variable <code>x</code> and print that address to the console. Memory addresses are typically printed as hexadecimal values (we covered hex in lesson <a href="https://www.learncpp.com/cpp-tutorial/literals/">4.15 -- Literals</a>), often without the 0x prefix.</p><p>For objects that use more than one byte of memory, address-of will return the memory address of the first byte used by the object.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>The &amp; symbol tends to cause confusion because it has different meanings depending on context:</p><ul><li>When following a type name, &amp; denotes an lvalue reference: <code>int&amp; ref</code>.</li><li>When used in a unary context in an expression, &amp; is the address-of operator: <code>std::cout &lt;&lt; &amp;x</code>.</li><li>When used in a binary context in an expression, &amp; is the Bitwise AND operator: <code>std::cout &lt;&lt; x &amp; y</code>.</li></ul></div><br><h3>The dereference operator (*)</h3><p>Getting the address of a variable isn’t very useful by itself.</p><p>The most useful thing we can do with an address is access the value stored at that address. The <span class="cpp-definition">dereference operator</span> (*) (also occasionally called the <span class="cpp-definition">indirection operator</span>) returns the value at a given memory address as an lvalue:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    std::cout &lt;&lt; x &lt;&lt; '\n';  // print the value of variable x</code><code>    std::cout &lt;&lt; &amp;x &lt;&lt; '\n'; // print the memory address of variable x</code><code></code><code>    std::cout &lt;&lt; *(&amp;x) &lt;&lt; '\n'; // print the value at the memory address of variable x (parentheses not required, but make it easier to read)</code><code></code><code>    return 0;</code><code>}</code></pre><p>On the author’s machine, the above program printed:</p><pre>5
0027FEA0
5
</pre><p>This program is pretty simple. First we declare a variable <code>x</code> and print its value. Then we print the address of variable <code>x</code>. Finally, we use the dereference operator to get the value at the memory address of variable <code>x</code> (which is just the value of <code>x</code>), which we print to the console.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Given a memory address, we can use the dereference operator (*) to get the value at that address (as an lvalue).</p><p>The address-of operator (&amp;) and dereference operator (*) work as opposites: address-of gets the address of an object, and dereference gets the object at an address.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>Although the dereference operator looks just like the multiplication operator, you can distinguish them because the dereference operator is unary, whereas the multiplication operator is binary.</p></div><p>Getting the memory address of a variable and then immediately dereferencing that address to get a value isn’t that useful either (after all, we can just use the variable to access the value).</p><p>But now that we have the address-of operator (&amp;) and dereference operator (*) added to our toolkits, we’re ready to talk about pointers.</p><br><h3>Pointers</h3><p>A <span class="cpp-definition">pointer</span> is an object that holds a <em>memory address</em> (typically of another variable) as its value. This allows us to store the address of some other object to use later.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>In modern C++, the pointers we are talking about here are sometimes called “raw pointers” or “dumb pointers”, to help differentiate them from “smart pointers” that were introduced into the language more recently. We cover smart pointers in <a href="https://www.learncpp.com#ChapterM">chapter M</a>.</p></div><p>Much like reference types are declared using an ampersand (&amp;) character, pointer types are declared using an asterisk (*):</p><pre class="language-cpp line-numbers"><code>int;  // a normal int</code><code>int&amp;; // an lvalue reference to an int value</code><code></code><code>int*; // a pointer to an int value (holds the address of an integer value)</code></pre><p>To create a pointer variable, we simply define a variable with a pointer type:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int x { 5 };    // normal variable</code><code>    int&amp; ref { x }; // a reference to an integer (bound to x)</code><code></code><code>    int* ptr;       // a pointer to an integer</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note that this asterisk is part of the declaration syntax for pointers, not a use of the dereference operator.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>When declaring a pointer type, place the asterisk next to the type name.</p></div><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Although you generally should not declare multiple variables on a single line, if you do, the asterisk has to be included with each variable.</p><pre class="language-cpp line-numbers"><code>int* ptr1, ptr2;   // incorrect: ptr1 is a pointer to an int, but ptr2 is just a plain int!</code><code>int* ptr3, * ptr4; // correct: ptr3 and p4 are both pointers to an int</code></pre><p>Although this is sometimes used as an argument to not place the asterisk with the type name (instead placing it next to the variable name), it’s a better argument for avoiding defining multiple variables in the same statement.</p></div><br><h3>Pointer initialization</h3><p>Like normal variables, pointers are <em>not</em> initialized by default. A pointer that has not been initialized is sometimes called a <span class="cpp-definition">wild pointer</span>. Wild pointers contain a garbage address, and dereferencing a wild pointer will result in undefined behavior. Because of this, you should always initialize your pointers to a known value.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Always initialize your pointers.</p></div><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code></code><code>    int* ptr;        // an uninitialized pointer (holds a garbage address)</code><code>    int* ptr2{};     // a null pointer (we'll discuss these in the next lesson)</code><code>    int* ptr3{ &amp;x }; // a pointer initialized with the address of variable x</code><code></code><code>    return 0;</code><code>}</code></pre><p>Since pointers hold addresses, when we initialize or assign a value to a pointer, that value has to be an address. Typically, pointers are used to hold the address of another variable (which we can get using the address-of operator (&amp;)).</p><p>Once we have a pointer holding the address of another object, we can then use the dereference operator (*) to access the value at that address. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    std::cout &lt;&lt; x &lt;&lt; '\n'; // print the value of variable x</code><code></code><code>    int* ptr{ &amp;x }; // ptr holds the address of x</code><code>    std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // use dereference operator to print the value at the address that ptr is holding (which is x's address)</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>5
5
</pre><p>Conceptually, you can think of the above snippet like this:<br><img src="https://www.learncpp.com/images/CppTutorial/Section6/6-Pointer.png" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Section6/6-Pointer.png"></p><p>This is where pointers get their name from -- <code>ptr</code> is holding the address of <code>x</code>, so we say that <code>ptr</code> is “pointing to” <code>x</code>.</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>A note on pointer nomenclature: “X pointer” (where X is some type) is a commonly used shorthand for “pointer to an X”. So when we say, “an integer pointer”, we really mean “a pointer to an integer”. This distinction will be valuable when we talk about const pointers.</p></div><p>Much like the type of a reference has to match the type of object being referred to, the type of the pointer has to match the type of the object being pointed to:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int i{ 5 };</code><code>    double d{ 7.0 };</code><code></code><code>    int* iPtr{ &amp;i };     // ok: a pointer to an int can point to an int object</code><code>    int* iPtr2 { &amp;d };   // not okay: a pointer to an int can't point to a double</code><code>    double* dPtr{ &amp;d };  // ok: a pointer to a double can point to a double object</code><code>    double* dPtr2{ &amp;i }; // not okay: a pointer to a double can't point to an int</code><code>}</code></pre><p>With one exception that we’ll discuss next lesson, initializing a pointer with a literal value is disallowed:</p><pre class="language-cpp line-numbers"><code>int* ptr{ 5 }; // not okay</code><code>int* ptr{ 0x0012FF7C }; // not okay, 0x0012FF7C is treated as an integer literal</code></pre><br><h3>Pointers and assignment</h3><p>We can use assignment with pointers in two different ways:</p><ol start="1"><li>To change what the pointer is pointing at (by assigning the pointer a new address)</li><li>To change the value being pointed at (by assigning the dereferenced pointer a new value)</li></ol><p>First, let’s look at a case where a pointer is changed to point at a different object:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    int* ptr{ &amp;x }; // ptr initialized to point at x</code><code></code><code>    std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // print the value at the address being pointed to (x's address)</code><code></code><code>    int y{ 6 };</code><code>    ptr = &amp;y; // // change ptr to point at y</code><code></code><code>    std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // print the value at the address being pointed to (y's address)</code><code></code><code>    return 0;</code><code>}</code></pre><p>The above prints:</p><pre>5
6
</pre><p>In the above example, we define pointer <code>ptr</code>, initialize it with the address of <code>x</code>, and dereference the pointer to print the value being pointed to (<code>5</code>). We then use the assignment operator to change the address that <code>ptr</code> is holding to the address of <code>y</code>. We then dereference the pointer again to print the value being pointed to (which is now <code>6</code>).</p><p>Now let’s look at how we can also use a pointer to change the value being pointed at:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    int* ptr{ &amp;x }; // initialize ptr with address of variable x</code><code></code><code>    std::cout &lt;&lt; x &lt;&lt; '\n';    // print x's value</code><code>    std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // print the value at the address that ptr is holding (x's address)</code><code></code><code>    *ptr = 6; // The object at the address held by ptr (x) assigned value 6 (note that ptr is dereferenced here)</code><code></code><code>    std::cout &lt;&lt; x &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // print the value at the address that ptr is holding (x's address)</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>5
5
6
6
</pre><p>In this example, we define pointer <code>ptr</code>, initialize it with the address of <code>x</code>, and then print the value of both <code>x</code> and <code>*ptr</code> (<code>5</code>). Because <code>*ptr</code> returns an lvalue, we can use this on the left hand side of an assignment statement, which we do to change the value being pointed at by <code>ptr</code> to <code>6</code>. We then print the value of both <code>x</code> and <code>*ptr</code> again to show that the value has been updated as expected.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>When we use a pointer without a dereference (<code>ptr</code>), we are accessing the address held by the pointer. Modifying this (<code>ptr = &amp;y</code>) changes what the pointer is pointing at.</p><p>When we dereference a pointer (<code>*ptr</code>), we are accessing the object being pointed at. Modifying this (<code>*ptr = 6;</code>) changes the value of the object being pointed at.</p></div><br><h3>Pointers behave much like lvalue references</h3><p>Pointers and lvalue references behave similarly. Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    int&amp; ref { x };  // get a reference to x</code><code>    int* ptr { &amp;x }; // get a pointer to x</code><code></code><code>    std::cout &lt;&lt; x;</code><code>    std::cout &lt;&lt; ref;  // use the reference to print x's value (5)</code><code>    std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // use the pointer to print x's value (5)</code><code></code><code>    ref = 6; // use the reference to change the value of x</code><code>    std::cout &lt;&lt; x;</code><code>    std::cout &lt;&lt; ref;  // use the reference to print x's value (6)</code><code>    std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // use the pointer to print x's value (6)</code><code></code><code>    *ptr = 7; // use the pointer to change the value of x</code><code>    std::cout &lt;&lt; x;</code><code>    std::cout &lt;&lt; ref;  // use the reference to print x's value (7)</code><code>    std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // use the pointer to print x's value (7)</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>555
666
777
</pre><p>In the above program, we create a normal variable <code>x</code> with value <code>5</code>, and then create an lvalue reference and a pointer to <code>x</code>. Next, we use the lvalue reference to change the value from <code>5</code> to <code>6</code>, and show that we can access that updated value via all three methods. Finally, we use the dereferenced pointer to change the value from <code>6</code> to <code>7</code>, and again show that we can access the updated value via all three methods.</p><p>Thus, both pointers and references provide a way to indirectly access another object. The primary difference is that with pointers, we need to explicitly get the address to point at, and we have to explicitly dereference the pointer to get the value. With references, the address-of and dereference happens implicitly.</p><p>There are some other differences between pointers and references worth mentioning:</p><ul><li>References must be initialized, pointers are not required to be initialized (but should be).</li><li>References are not objects, pointers are.</li><li>References can not be reseated (changed to reference something else), pointers can change what they are pointing at.</li><li>References must always be bound to an object, pointers can point to nothing (we’ll see an example of this in the next lesson).</li><li>References are “safe” (outside of dangling references), pointers are inherently dangerous (we’ll also discuss this in the next lesson).</li></ul><br><h3>The address-of operator returns a pointer</h3><p>It’s worth noting that the address-of operator (&amp;) doesn’t return the address of its operand as a literal. Instead, it returns a pointer containing the address of the operand, whose type is derived from the argument (e.g. taking the address of an <code>int</code> will return the address in an <code>int</code> pointer).</p><p>We can see this in the following example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <typeinfo></typeinfo></code><code></code><code>int main()</code><code>{</code><code>	int x{ 4 };</code><code>	std::cout &lt;&lt; typeid(&amp;x).name() &lt;&lt; '\n'; // print the type of &amp;x</code><code></code><code>	return 0;</code><code>}</code></pre><p>On Visual Studio, this printed:</p><pre>int *
</pre><p>With gcc, this prints “pi” (pointer to int) instead. Because the result of typeid().name() is compiler-dependent, your compiler may print something different, but it will have the same meaning.</p><br><h3>The size of pointers</h3><p>The size of a pointer is dependent upon the architecture the executable is compiled for -- a 32-bit executable uses 32-bit memory addresses -- consequently, a pointer on a 32-bit machine is 32 bits (4 bytes). With a 64-bit executable, a pointer would be 64 bits (8 bytes). Note that this is true regardless of the size of the object being pointed to:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main() // assume a 32-bit application</code><code>{</code><code>    char* chPtr{};        // chars are 1 byte</code><code>    int* iPtr{};          // ints are usually 4 bytes</code><code>    long double* ldPtr{}; // long doubles are usually 8 or 12 bytes</code><code></code><code>    std::cout &lt;&lt; sizeof(chPtr) &lt;&lt; '\n'; // prints 4</code><code>    std::cout &lt;&lt; sizeof(iPtr) &lt;&lt; '\n';  // prints 4</code><code>    std::cout &lt;&lt; sizeof(ldPtr) &lt;&lt; '\n'; // prints 4</code><code></code><code>    return 0;</code><code>}</code></pre><p>The size of the pointer is always the same. This is because a pointer is just a memory address, and the number of bits needed to access a memory address is constant.</p><br><h3>Dangling pointers</h3><p>Much like a dangling reference, a <span class="cpp-definition">dangling pointer</span> is a pointer that is holding the address of an object that is no longer valid (e.g. because it has been destroyed). Dereferencing a dangling pointer will lead to undefined results.</p><p>Here’s an example of creating a dangling pointer:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    int* ptr{ &amp;x };</code><code></code><code>    std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // valid</code><code></code><code>    {</code><code>        int y{ 6 };</code><code>        ptr = &amp;y;</code><code></code><code>        std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // valid</code><code>    } // y goes out of scope, and ptr is now dangling</code><code></code><code>    std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // undefined behavior from dereferencing a dangling pointer</code><code></code><code>    return 0;</code><code>}</code></pre><p>The above program will probably print:</p><pre>5
6
6
</pre><p>But it may not, as the object that <code>ptr</code> was pointing at went out of scope and was destroyed at the end of the inner block, leaving <code>ptr</code> dangling.</p><br><h3>Conclusion</h3><p>Pointers are variables that hold a memory address. They can be dereferenced using the dereference operator (*) to retrieve the value at the address they are holding. Dereferencing a wild or dangling (or null) pointer will result in undefined behavior and will probably crash your application.</p><p>Pointers are both more flexible than references and more dangerous. We’ll continue to explore this in the upcoming lessons.</p><br><h3>Quiz time</h3><p class="cpp-quiz-question" style="clear:both">Question #1</p><p>What values does this program print? Assume a short is 2 bytes, and a 32-bit machine.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	short value{ 7 }; // &amp;value = 0012FF60</code><code>	short otherValue{ 3 }; // &amp;otherValue = 0012FF54</code><code></code><code>	short* ptr{ &amp;value };</code><code></code><code>	std::cout &lt;&lt; &amp;value &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; value &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; ptr &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; *ptr &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; '\n';</code><code></code><code>	*ptr = 9;</code><code></code><code>	std::cout &lt;&lt; &amp;value &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; value &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; ptr &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; *ptr &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; '\n';</code><code></code><code>	ptr = &amp;otherValue;</code><code></code><code>	std::cout &lt;&lt; &amp;otherValue &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; otherValue &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; ptr &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; *ptr &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; '\n';</code><code></code><code>	std::cout &lt;&lt; sizeof(ptr) &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; sizeof(*ptr) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre>0012FF60
7
0012FF60
7

0012FF60
9
0012FF60
9

0012FF54
3
0012FF54
3

4
2
</pre><p>A short explanation about the 4 and the 2. A 32-bit machine means that pointers will be 32 bits in length, but sizeof() always prints the size in bytes. 32 bits is 4 bytes. Thus the <code>sizeof(ptr)</code> is 4. Because <code>ptr</code> is a pointer to a short, <code>*ptr</code> is a short. The size of a short in this example is 2 bytes. Thus the <code>sizeof(*ptr)</code> is 2.</p></div><p class="cpp-quiz-question cpp-topline" style="clear:both">Question #2</p><p>What’s wrong with this snippet of code?</p><pre class="language-cpp line-numbers"><code>int value{ 45 };</code><code>int* ptr{ &amp;value }; // declare a pointer and initialize with address of value</code><code>*ptr = &amp;value; // assign address of value to ptr</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>The last line of the above snippet doesn’t compile.</p><p>Let’s examine this program in more detail.</p><p>The first line contains a standard variable definition, along with an initialization value. Nothing special here.</p><p>In the second line, we’re defining a new pointer named <code>ptr</code>, and initializing it with the address of <code>value</code>. Remember that in this context, the asterisk is part of the pointer declaration syntax, not a dereference. So this line is fine.</p><p>On line three, the asterisk represents a dereference, which is used to get the value that a pointer is pointing to. So this line says, “retrieve the value that <code>ptr</code> is pointing to (an integer), and overwrite it with the address of <code>value</code> (an address). That doesn’t make any sense -- you can’t assign an address to an integer!</p><p>The third line should be:</p><pre class="language-cpp line-numbers"><code>ptr = &amp;value;</code></pre><p>This correctly assigns the address of variable value to the pointer.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">9.7 — Null pointers</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-pointers/">9.6 -- Introduction to pointers</a>), we covered the basics of pointers, which are objects that hold the address of another object. This address can be dereferenced using the dereference operator (*) to get the value at that address:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    std::cout &lt;&lt; x &lt;&lt; '\n'; // print the value of variable x</code><code></code><code>    int* ptr{ &amp;x }; // ptr holds the address of x</code><code>    std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // use dereference operator to print the value at the address that ptr is holding (which is x's address)</code><code></code><code>    return 0;</code><code>}</code></pre><p>The above example prints:</p><pre>5
5
</pre><p>In the prior lesson, we also noted that pointers do not need to point to anything. In this lesson, we’ll explore such pointers (and the various implications of pointing to nothing) further.</p><br><h3>Null pointers</h3><p>Besides a memory address, there is one additional value that a pointer can hold: a null value. A <span class="cpp-definition">null value</span> (often shortened to <span class="cpp-definition">null</span>) is a special value that means something has no value. When a pointer is holding a null value, it means the pointer is not pointing at anything. Such a pointer is called a <span class="cpp-definition">null pointer</span>.</p><p>The easiest way to create a null pointer is to use value initialization:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int* ptr {}; // ptr is now a null pointer, and is not holding an address</code><code> </code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Value initialize your pointers (to be null pointers) if you are not initializing them with the address of a valid object.</p></div><p>Because we can use assignment to change what a pointer is pointing at, a pointer that is initially set to null can later be changed to point at a valid object:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int* ptr {}; // ptr is a null pointer, and is not holding an address</code><code></code><code>    int x { 5 };</code><code>    ptr = &amp;x; // ptr now pointing at object x (no longer a null pointer)</code><code></code><code>    std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // print value of x through dereferenced ptr</code><code> </code><code>    return 0;</code><code>}</code></pre><br><h3>The nullptr keyword</h3><p>Much like the keywords <code>true</code> and <code>false</code> represent Boolean literal values, the <span class="cpp-definition">nullptr</span> keyword represents a null pointer literal. We can use <code>nullptr</code> to explicitly initialize or assign a pointer a null value.</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int* ptr { nullptr }; // can use nullptr to initialize a pointer to be a null pointer</code><code></code><code>    int value { 5 };</code><code>    int* ptr2 { &amp;value }; // ptr2 is a valid pointer</code><code>    ptr2 = nullptr; // Can assign nullptr to make the pointer a null pointer</code><code></code><code>    someFunction(nullptr); // we can also pass nullptr to a function that has a pointer parameter</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, we use assignment to set the value of <code>ptr2</code> to <code>nullptr</code>, making <code>ptr2</code> a null pointer.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use <code>nullptr</code> when you need a null pointer literal for initialization, assignment, or passing a null pointer to a function.</p></div><br><h3>Dereferencing a null pointer results in undefined behavior</h3><p>Much like dereferencing a dangling (or wild) pointer leads to undefined behavior, dereferencing a null pointer also leads to undefined behavior. In most cases, it will crash your application.</p><p>The following program illustrates this, and will probably crash or terminate your application abnormally when you run it (go ahead, try it, you won’t harm your machine):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int* ptr {}; // Create a null pointer</code><code>    std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // Dereference the null pointer</code><code></code><code>    return 0;</code><code>}</code></pre><p>Conceptually, this makes sense. Dereferencing a pointer means “go to the address the pointer is pointing at and access the value there”. A null pointer doesn’t have an address. So when you try to access the value at that address, what should it do?</p><p>Accidentally dereferencing null and dangling pointers is one of the most common mistakes C++ programmers make, and is probably the most common reason that C++ programs crash in practice.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Whenever you are using pointers, you’ll need to be extra careful that your code isn’t dereferencing null or dangling pointers, as this will cause undefined behavior (probably an application crash).</p></div><br><h3>Checking for null pointers</h3><p>Much like we can use a conditional to test Boolean values for <code>true</code> or <code>false</code>, we can use a conditional to test whether a pointer has value <code>nullptr</code> or not:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x { 5 };</code><code>    int* ptr { &amp;x };</code><code></code><code>    // pointers convert to Boolean false if they are null, and Boolean true if they are non-null</code><code>    if (ptr == nullptr) // explicit test for equivalence</code><code>        std::cout &lt;&lt; "ptr is null\n";</code><code>    else</code><code>        std::cout &lt;&lt; "ptr is non-null\n";</code><code></code><code>    int* nullPtr {};</code><code>    std::cout &lt;&lt; "nullPtr is " &lt;&lt; (nullPtr==nullptr ? "null\n" : "non-null\n"); // explicit test for equivalence</code><code></code><code>    return 0;</code><code>}</code></pre><p>The above program prints:</p><pre>ptr is non-null
nullPtr is null
</pre><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/boolean-values/">4.9 -- Boolean values</a>, we noted that integral values will implicitly convert into Boolean values: an integral value of <code>0</code> converts to Boolean value <code>false</code>, and any other integral value converts to Boolean value <code>true</code>.</p><p>Similarly, pointers will also implicitly convert to Boolean values: a null pointer converts to Boolean value <code>false</code>, and a non-null pointer converts to Boolean value <code>true</code>. This allows us to skip explicitly testing for <code>nullptr</code> and just use the implicit conversion to Boolean to test whether a pointer is a null pointer. The following program is equivalent to the prior one:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x { 5 };</code><code>    int* ptr { &amp;x };</code><code></code><code>    // pointers convert to Boolean false if they are null, and Boolean true if they are non-null</code><code>    if (ptr) // implicit conversion to Boolean</code><code>        std::cout &lt;&lt; "ptr is non-null\n";</code><code>    else</code><code>        std::cout &lt;&lt; "ptr is null\n";</code><code></code><code>    int* nullPtr {};</code><code>    std::cout &lt;&lt; "nullPtr is " &lt;&lt; (nullPtr ? "non-null\n" : "null\n"); // implicit conversion to Boolean</code><code></code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Conditionals can only be used to differentiate null pointers from non-null pointers. There is no convenient way to determine whether a non-null pointer is pointing to a valid object or dangling (pointing to an invalid object).</p></div><br><h3>Use nullptr to avoid dangling pointers</h3><p>Above, we mentioned that dereferencing a pointer that is either null or dangling will result in undefined behavior. Therefore, we need to ensure our code does not do either of these things.</p><p>We can easily avoid dereferencing a null pointer by using a conditional to ensure a pointer is non-null before trying to dereference it:</p><pre class="language-cpp line-numbers"><code>// Assume ptr is some pointer that may or may not be a null pointer</code><code>if (ptr) // if ptr is not a null pointer</code><code>    std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // okay to dereference</code><code>else</code><code>    // do something else that doesn't involve dereferencing ptr (print an error message, do nothing at all, etc...)</code></pre><p>But what about dangling pointers? Because there is no way to detect whether a pointer is dangling, we need to avoid having any dangling pointers in our program in the first place. We do that by ensuring that any pointer that is not pointing at a valid object is set to <code>nullptr</code>.</p><p>That way, before dereferencing a pointer, we only need to test whether it is null -- if it is non-null, we assume the pointer is not dangling.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>A pointer should either hold the address of a valid object, or be set to nullptr. That way we only need to test pointers for null, and can assume any non-null pointer is valid.</p></div><p>Unfortunately, avoiding dangling pointers isn’t always easy: when an object is destroyed, any pointers to that object will be left dangling. Such pointers are <em>not</em> nulled automatically! It is the programmer’s responsibility to ensure that all pointers to an object that has just been destroyed are properly set to <code>nullptr</code>.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>When an object is destroyed, any pointers to the destroyed object will be left dangling (they will not be automatically set to <code>nullptr</code>). It is your responsibility to detect these cases and ensure those pointers are subsequently set to <code>nullptr</code>.</p></div><br><h3>Legacy null pointer literals: 0 and NULL</h3><p>In older code, you may see two other literal values used instead of <code>nullptr</code>.</p><p>The first is the literal <code>0</code>. In the context of a pointer, the literal <code>0</code> is specially defined to mean a null value, and is the only time you can assign an integral literal to a pointer.</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    float* ptr { 0 };  // ptr is now a null pointer (for example only, don't do this)</code><code></code><code>    float* ptr2; // ptr2 is uninitialized</code><code>    ptr2 = 0; // ptr2 is now a null pointer (for example only, don't do this)</code><code></code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>On modern architectures, the address <code>0</code> is typically used to represent a null pointer. However, this value is not guaranteed by the C++ standard, and some architectures use other values. The literal <code>0</code>, when used in the context of a null pointer, will be translated into whatever address the architecture uses to represent a null pointer.</p></div><p>Additionally, there is a preprocessor macro named <code>NULL</code> (defined in the &lt;cstddef&gt; header). This macro is inherited from C, where it is commonly used to indicate a null pointer.</p><pre class="language-cpp line-numbers"><code>#include <cstddef> // for NULL</cstddef></code><code></code><code>int main()</code><code>{</code><code>    double* ptr { NULL }; // ptr is a null pointer</code><code></code><code>    double* ptr2; // ptr2 is uninitialized</code><code>    ptr2 = NULL; // ptr2 is now a null pointer</code><code>}</code></pre><p>Both <code>0</code> and <code>NULL</code> should be avoided in modern C++ (use <code>nullptr</code> instead). We discuss why in lesson <a href="https://www.learncpp.com/cpp-tutorial/pass-by-address-part-2/">9.10 -- Pass by address (part 2)</a>.</p><br><h3>Favor references over pointers whenever possible</h3><p>Pointers and references both give us the ability to access some other object indirectly.</p><p>Pointers have the additional abilities of being able to change what they are pointing at, and to be pointed at null. However, these pointer abilities are also inherently dangerous: A null pointer runs the risk of being dereferenced, and the ability to change what a pointer is pointing at can make creating dangling pointers easier:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int* ptr { };</code><code>    </code><code>    {</code><code>        int x{ 5 };</code><code>        ptr = &amp;x; // set the pointer to an object that will be destroyed (not possible with a reference)</code><code>    } // ptr is now dangling</code><code></code><code>    return 0;</code><code>}</code></pre><p>Since references can’t be bound to null, we don’t have to worry about null references. And because references must be bound to a valid object upon creation and then can not be reseated, dangling references are harder to create.</p><p>Because they are safer, references should be favored over pointers, unless the additional capabilities provided by pointers are required.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Favor references over pointers unless the additional capabilities provided by pointers are needed.</p></div><br><h3>Quiz time</h3><p class="cpp-quiz-question" style="clear:both">Question #1</p><p>1a) Can we determine whether a pointer is a null pointer or not? If so, how?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>Yes, we can use a conditional (if statement or conditional operator) on the pointer. A pointer will convert to Boolean <code>false</code> if it is a null pointer, and <code>true</code> otherwise.</p></div><p>1b) Can we determine whether a non-null pointer is valid or dangling? If so, how?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>There is no easy way to determine this.</p></div><p class="cpp-quiz-question cpp-topline" style="clear:both">Question #2</p><p>For each subitem, answer “yes”, “no”, or “possibly” to whether the action described will result in undefined behavior (immediately). If the answer is “possibly”, clarify when.</p><p>2a) Assigning a new address to a pointer</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>No</p></div><p>2b) Assigning nullptr to a pointer</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><p>No</p></div><p>2c) Dereferencing a pointer to a valid object</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><p>No</p></div><p>2d) Dereferencing a dangling pointer</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><p>Yes</p></div><p>2e) Dereferencing a null pointer</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none"><p>Yes</p></div><p>2f) Dereferencing a non-null pointer</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_7'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_7" style="display:none"><p>Possibly, if the pointer is dangling</p></div><p class="cpp-quiz-question cpp-topline" style="clear:both">Question #3</p><p>Why should we set pointers that aren’t pointing to a valid object to ‘nullptr’?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_8'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_8" style="display:none"><p>We can not determine whether a non-null pointer is valid or dangling, and accessing a dangling pointer will result in undefined behavior. Therefore, we need to ensure that we do not have any dangling pointers in our program.</p><p>If we ensure all pointers are either pointing to valid objects or set to <code>nullptr</code>, then we can use a conditional to test for null to ensure we don’t dereference a null pointer, and assume all non-null pointers are pointing to valid objects.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">9.8 — Pointers and const</h1></header><div class="entry-content" itemprop="articleBody"><p>Consider the following code snippet:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int x { 5 };</code><code>    int* ptr { &amp;x }; // ptr is a normal (non-const) pointer</code><code></code><code>    int y { 6 };</code><code>    ptr = &amp;y; // we can point at another value</code><code></code><code>    *ptr = 7; // we can change the value at the address being held</code><code></code><code>    return 0;</code><code>}</code></pre><p>With normal (non-const) pointers, we can change both what the pointer is pointing at (by assigning the pointer a new address to hold) or change the value at the address being held (by assigning a new value to the dereferenced pointer).</p><p>However, what happens if the value we want to point at is const?</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    const int x { 5 }; // x is now const</code><code>    int* ptr { &amp;x };   // compile error: cannot convert from const int* to int*</code><code></code><code>    return 0;</code><code>}</code></pre><p>The above snippet won’t compile -- we can’t set a normal pointer to point at a const variable. This makes sense: a const variable is one whose value cannot be changed. Allowing the programmer to set a non-const pointer to a const value would allow the programmer to dereference the pointer and change the value. That would violate the const-ness of the variable.</p><br><h3>Pointer to const value</h3><p>A <span class="cpp-definition">pointer to a const value</span> (sometimes called a <code>pointer to const</code> for short) is a (non-const) pointer that points to a constant value.</p><p>To declare a pointer to a const value, use the <code>const</code> keyword before the pointer’s data type:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    const int x{ 5 };</code><code>    const int* ptr { &amp;x }; // okay: ptr is pointing to a "const int"</code><code></code><code>    *ptr = 6; // not allowed: we can't change a const value</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, <code>ptr</code> points to a <code>const int</code>. Because the data type being pointed to is const, the value being pointed to can’t be changed.</p><p>However, because a pointer to const is not const itself (it just points to a const value), we can change what the pointer is pointing at by assigning the pointer a new address:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    const int x{ 5 };</code><code>    const int* ptr { &amp;x }; // ptr points to const int x</code><code></code><code>    const int y{ 6 };</code><code>    ptr = &amp;y; // okay: ptr now points at const int y</code><code></code><code>    return 0;</code><code>}</code></pre><p>Just like a reference to const, a pointer to const can point to non-const variables too. A pointer to const treats the value being pointed to as constant, regardless of whether the object at that address was initially defined as const or not:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int x{ 5 }; // non-const</code><code>    const int* ptr { &amp;x }; // ptr points to a "const int"</code><code></code><code>    *ptr = 6;  // not allowed: ptr points to a "const int" so we can't change the value through ptr</code><code>    x = 6; // allowed: the value is still non-const when accessed through non-const identifier x</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>Const pointers</h3><p>We can also make a pointer itself constant. A <span class="cpp-definition">const pointer</span> is a pointer whose address can not be changed after initialization.</p><p>To declare a const pointer, use the <code>const</code> keyword after the asterisk in the pointer declaration:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    int* const ptr { &amp;x }; // const after the asterisk means this is a const pointer</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above case, <code>ptr</code> is a const pointer to a (non-const) int value.</p><p>Just like a normal const variable, a const pointer must be initialized upon definition, and this value can’t be changed via assignment:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    int y{ 6 };</code><code></code><code>    int* const ptr { &amp;x }; // okay: the const pointer is initialized to the address of x</code><code>    ptr = &amp;y; // error: once initialized, a const pointer can not be changed.</code><code></code><code>    return 0;</code><code>}</code></pre><p>However, because the <em>value</em> being pointed to is non-const, it is possible to change the value being pointed to via dereferencing the const pointer:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    int* const ptr { &amp;x }; // ptr will always point to x</code><code></code><code>    *ptr = 6; // okay: the value being pointed to is non-const</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>Const pointer to a const value</h3><p>Finally, it is possible to declare a <span class="cpp-definition">const pointer to a const value</span> by using the <code>const</code> keyword both before the type and after the asterisk:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int value { 5 };</code><code>    const int* const ptr { &amp;value }; // a const pointer to a const value</code><code></code><code>    return 0;</code><code>}</code></pre><p>A const pointer to a const value can not have its address changed, nor can the value it is pointing to be changed through the pointer. It can only be dereferenced to get the value it is pointing at.</p><br><h3>Pointer and const recap</h3><p>To summarize, you only need to remember 4 rules, and they are pretty logical:</p><ul><li>A non-const pointer can be assigned another address to change what it is pointing at</li><li>A const pointer always points to the same address, and this address can not be changed.</li></ul><p></p><ul><li>A pointer to a non-const value can change the value it is pointing to. These can not point to a const value.</li><li>A pointer to a const value treats the value as const when accessed through the pointer, and thus can not change the value it is pointing to. These can be pointed to const or non-const l-values (but not r-values, which don’t have an address)</li></ul><p>Keeping the declaration syntax straight can be a bit challenging:</p><ul><li>The pointer’s type defines the type of the object being pointed at. So a <code>const</code> in the type means the pointer is pointing at a const value.</li><li>A <code>const</code> after the asterisk means the pointer itself is const and it can not be assigned a new address.</li></ul><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int value { 5 };</code><code></code><code>    int* ptr0 { &amp;value };             // ptr0 points to an "int" and is not const itself, so this is a normal pointer.</code><code>    const int* ptr1 { &amp;value };       // ptr1 points to a "const int", but is not const itself, so this is a pointer to a const value.</code><code>    int* const ptr2 { &amp;value };       // ptr2 points to an "int", but is const itself, so this is a const pointer (to a non-const value).</code><code>    const int* const ptr3 { &amp;value }; // ptr3 points to an "const int", and it is const itself, so this is a const pointer to a const value.</code><code></code><code>    return 0;</code><code>}</code></pre></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">9.9 — Pass by address</h1></header><div class="entry-content" itemprop="articleBody"><p>In prior lessons, we’ve covered two different ways to pass an argument to a function: pass by value (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-function-parameters-and-arguments/">2.4 -- Introduction to function parameters and arguments</a>) and pass by reference (<a href="https://www.learncpp.com/cpp-tutorial/pass-by-lvalue-reference/">9.5 -- Pass by lvalue reference</a>).</p><p>Here’s a sample program that shows a <code>std::string</code> object being passed by value and by reference:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>void printByValue(std::string val) // The function parameter is a copy of str</code><code>{</code><code>    std::cout &lt;&lt; val &lt;&lt; '\n'; // print the value via the copy</code><code>}</code><code></code><code>void printByReference(const std::string&amp; ref) // The function parameter is a reference that binds to str</code><code>{</code><code>    std::cout &lt;&lt; ref &lt;&lt; '\n'; // print the value via the reference</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::string str{ "Hello, world!" };</code><code>    </code><code>    printByValue(str); // pass str by value, makes a copy of str</code><code>    printByReference(str); // pass str by reference, does not make a copy of str</code><code></code><code>    return 0;</code><code>}</code></pre><p>When we pass argument <code>str</code> by value, the function parameter <code>val</code> receives a copy of the argument. Because the parameter is a copy of the argument, any changes to the <code>val</code> are made to the copy, not the original argument.</p><p>When we pass argument <code>str</code> by reference, the reference parameter <code>ref</code> is bound to the actual argument. This avoids making a copy of the argument. Because our reference parameter is const, we are not allowed to change <code>ref</code>. But if <code>ref</code> were non-const, any changes we made to <code>ref</code> would change <code>str</code>.</p><p>In both cases, the caller is providing the actual object (<code>str</code>) to be passed as an argument to the function call.</p><br><h3>Pass by address</h3><p>C++ provides a third way to pass values to a function, called pass by address. With <span class="cpp-definition">pass by address</span>, instead of providing an object as an argument, the caller provides an object’s <em>address</em> (via a pointer). This pointer (holding the address of the object) is copied into a pointer parameter of the called function (which now also holds the address of the object). The function can then dereference that pointer to access the object whose address was passed.</p><p>Here’s a version of the above program that adds a pass by address variant:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>void printByValue(std::string val) // The function parameter is a copy of str</code><code>{</code><code>    std::cout &lt;&lt; val &lt;&lt; '\n'; // print the value via the copy</code><code>}</code><code></code><code>void printByReference(const std::string&amp; ref) // The function parameter is a reference that binds to str</code><code>{</code><code>    std::cout &lt;&lt; ref &lt;&lt; '\n'; // print the value via the reference</code><code>}</code><code></code><code>void printByAddress(const std::string* ptr) // The function parameter is a pointer that holds the address of str</code><code>{</code><code>    std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // print the value via the dereferenced pointer</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::string str{ "Hello, world!" };</code><code>    </code><code>    printByValue(str); // pass str by value, makes a copy of str</code><code>    printByReference(str); // pass str by reference, does not make a copy of str</code><code>    printByAddress(&amp;str); // pass str by address, does not make a copy of str</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note how similar all three of these versions are. Let’s explore the pass by address version in more detail.</p><p>First, because we want our <code>printByAddress()</code> function to use pass by address, we’ve made our function parameter a pointer named <code>ptr</code>. Since <code>printByAddress()</code> will use <code>ptr</code> in a read-only manner, <code>ptr</code> is a pointer to a const value.</p><pre class="language-cpp line-numbers"><code>void printByAddress(const std::string* ptr)</code><code>{</code><code>    std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // print the value via the dereferenced pointer</code><code>}</code></pre><p>Inside the <code>printByAddress()</code> function, we dereference <code>ptr</code> parameter to access the value of the object being pointed to.</p><p>Second, when the function is called, we can’t just pass in the <code>str</code> object -- we need to pass in the address of <code>str</code>. The easiest way to do that is to use the address-of operator (&amp;) to get a pointer holding the address of <code>str</code>:</p><pre class="language-cpp line-numbers"><code>printByAddress(&amp;str); // use address-of operator (&amp;) to get pointer holding address of str</code></pre><p>When this call is executed, <code>&amp;str</code> will create a pointer holding the address of <code>str</code>. This address is then copied into function parameter <code>ptr</code> as part of the function call. Because <code>ptr</code> now holds the address of <code>str</code>, when the function dereferences <code>ptr</code>, it will get the value of <code>str</code>, which the function prints to the console.</p><p>That’s it.</p><p>Although we use the address-of operator in the above example to get the address of <code>str</code>, if we already had a pointer variable holding the address of <code>str</code>, we could use that instead:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    std::string str{ "Hello, world!" };</code><code>    </code><code>    printByValue(str); // pass str by value, makes a copy of str</code><code>    printByReference(str); // pass str by reference, does not make a copy of str</code><code>    printByAddress(&amp;str); // pass str by address, does not make a copy of str</code><code></code><code>    std::string* ptr { &amp;str }; // define a pointer variable holding the address of str</code><code>    printByAddress(ptr); // pass str by address, does not make a copy of str    </code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>Pass by address does not make a copy of the object being pointed to</h3><p>Consider the following statements:</p><pre class="language-cpp line-numbers"><code>std::string str{ "Hello, world!" };</code><code>printByAddress(&amp;str); // use address-of operator (&amp;) to get pointer holding address of str</code></pre><p>As we noted in <a href="https://www.learncpp.com/cpp-tutorial/pass-by-lvalue-reference/">9.5 -- Pass by lvalue reference</a>, copying a <code>std::string</code> is expensive, so that’s something we want to avoid. When we pass a <code>std::string</code> by address, we’re not copying the actual <code>std::string</code> object -- we’re just copying the pointer (holding the address of the object) from the caller to the called function. Since an address is typically only 4 or 8 bytes, a pointer is only 4 or 8 bytes, so copying a pointer is always fast.</p><p>Thus, just like pass by reference, pass by address is fast, and avoids making a copy of the argument object.</p><br><h3>Pass by address allows the function to modify the argument’s value</h3><p>When we pass an object by address, the function receives the address of the passed object, which it can access via dereferencing. Because this is the address of the actual argument object being passed (not a copy of the object), if the function parameter is a pointer to non-const, the function can modify the argument via the pointer parameter:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void changeValue(int* ptr) // note: ptr is a pointer to non-const in this example</code><code>{</code><code>    *ptr = 6; // change the value to 6</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code></code><code>    std::cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; '\n';</code><code></code><code>    changeValue(&amp;x); // we're passing the address of x to the function</code><code></code><code>    std::cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>x = 5
x = 6
</pre><p>As you can see, the argument is modified and this modification persists even after <code>changeValue()</code> has finished running.</p><p>If a function is not supposed to modify the object being passed in, the function parameter can be made a pointer to const:</p><pre class="language-cpp line-numbers"><code>void changeValue(const int* ptr) // note: ptr is now a pointer to a const</code><code>{</code><code>    *ptr = 6; // error: can not change const value</code><code>}</code></pre><br><h3>Null checking</h3><p>Now consider this fairly innocent looking program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print(int* ptr)</code><code>{</code><code>	std::cout &lt;&lt; *ptr;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int x{ 5 };</code><code>	print(&amp;x);</code><code></code><code>	int* myptr {};</code><code>	print(myptr);</code><code></code><code>	return 0;</code><code>}</code></pre><p>When this program is run, it will print the value <code>5</code> and then most likely crash.</p><p>In the call to <code>print(myptr)</code>, <code>myptr</code> is a null pointer, so function parameter <code>ptr</code> will also be a null pointer. When this null pointer is dereferenced in the body of the function, undefined behavior results.</p><p>When passing a parameter by address, care should be taken to ensure the pointer is not a null pointer before you dereference the value. One way to do that is to use a conditional statement:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print(int* ptr)</code><code>{</code><code>    if (ptr) // if ptr is not a null pointer</code><code>    {</code><code>        std::cout &lt;&lt; *ptr;</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int x{ 5 };</code><code>	</code><code>	print(&amp;x);</code><code>	print(nullptr);</code><code></code><code>	return 0;</code><code>}</code></pre><p>In the above program, we’re testing <code>ptr</code> to ensure it is not null before we dereference it. While this is fine for such a simple function, in more complicated functions this can result in redundant logic (testing if ptr is not null multiple times) or nesting of the primary logic of the function (if contained in a block).</p><p>In most cases, it is more effective to do the opposite: test whether the function parameter is null as a precondition (<a href="https://www.learncpp.com/cpp-tutorial/assert-and-static_assert/">7.17 -- Assert and static_assert</a>) and handle the negative case immediately:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void print(int* ptr)</code><code>{</code><code>    if (!ptr) // if ptr is a null pointer, early return back to the caller</code><code>        return;</code><code></code><code>    // if we reached this point, we can assume ptr is valid</code><code>    // so no more testing or nesting required</code><code></code><code>    std::cout &lt;&lt; *ptr;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int x{ 5 };</code><code>	</code><code>	print(&amp;x);</code><code>	print(nullptr);</code><code></code><code>	return 0;</code><code>}</code></pre><p>If a null pointer should never be passed to the function, an <code>assert</code> (which we covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/assert-and-static_assert/">7.17 -- Assert and static_assert</a>) can be used instead (or also) (as asserts are intended to document things that should never happen):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cassert></cassert></code><code></code><code>void print(const int* ptr) // now a pointer to a const int</code><code>{</code><code>	assert(ptr); // fail the program in debug mode if a null pointer is passed (since this should never happen)</code><code></code><code>	// (optionally) handle this as an error case in production mode so we don't crash if it does happen</code><code>	if (!ptr)</code><code>		return;</code><code></code><code>	std::cout &lt;&lt; *ptr;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int x{ 5 };</code><code>	</code><code>	print(&amp;x);</code><code>	print(nullptr);</code><code></code><code>	return 0;</code><code>}</code></pre><br><h3>Prefer pass by (const) reference</h3><p>Note that function <code>print()</code> in the example above doesn’t handle null values very well -- it effectively just aborts the function. Given this, why allow a user to pass in a null value at all? Pass by reference has the same benefits as pass by address without the risk of inadvertently dereferencing a null pointer.</p><p>Pass by const reference has a few other advantages over pass by address.</p><p>First, because an object being passed by address must have an address, only lvalues can be passed by address (as rvalues don’t have addresses). Pass by const reference is more flexible, as it can accept lvalues and rvalues:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>void printByValue(int val) // The function parameter is a copy of the argument</code><code>{</code><code>    std::cout &lt;&lt; val &lt;&lt; '\n'; // print the value via the copy</code><code>}</code><code></code><code>void printByReference(const int&amp; ref) // The function parameter is a reference that binds to the argument</code><code>{</code><code>    std::cout &lt;&lt; ref &lt;&lt; '\n'; // print the value via the reference</code><code>}</code><code></code><code>void printByAddress(const int* ptr) // The function parameter is a pointer that holds the address of the argument</code><code>{</code><code>    std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // print the value via the dereferenced pointer</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printByValue(5);     // valid (but makes a copy)</code><code>    printByReference(5); // valid (because the parameter is a const reference)</code><code>    printByAddress(&amp;5);  // error: can't take address of r-value</code><code></code><code>    return 0;</code><code>}</code></pre><p>Second, the syntax for pass by reference is natural, as we can just pass in literals or objects. With pass by address, our code ends up littered with ampersands (&amp;) and asterisks (*).</p><p>In modern C++, most things that can be done with pass by address are better accomplished through other methods. Follow this common maxim: “Pass by reference when you can, pass by address when you must”.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Prefer pass by reference to pass by address unless you have a specific reason to use pass by address.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">9.10 — Pass by address (part 2)</h1></header><div class="entry-content" itemprop="articleBody"><p>This lesson is a continuation of <a href="https://www.learncpp.com/cpp-tutorial/pass-by-address/">9.9 -- Pass by address</a>.</p><br><h3>Pass by address for “optional” arguments</h3><p>One of the more common uses for pass by address is to allow a function to accept an “optional” argument. This is easier to illustrate by example than to describe:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>void greet(std::string* name=nullptr)</code><code>{</code><code>    std::cout &lt;&lt; "Hello ";</code><code>    std::cout &lt;&lt; (name ? *name : "guest") &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    greet(); // we don't know who the user is yet</code><code></code><code>    std::string joe{ "Joe" };</code><code>    greet(&amp;joe); // we know the user is joe</code><code></code><code>    return 0;</code><code>}</code></pre><p>This example prints:</p><pre>Hello guest
Hello Joe
</pre><p>In this program, the <code>greet()</code> function has one parameter that is passed by address and defaulted to <code>nullptr</code>. Inside <code>main()</code>, we call this function twice. The first call, we don’t know who the user is, so we call <code>greet()</code> without an argument. The <code>name</code> parameter defaults to <code>nullptr</code>, and the greet function substitutes in the name “guest”. For the second call, we now have a valid user, so we call <code>greet(&amp;joe)</code>. The <code>name</code> parameter receives the address of <code>joe</code>, and can use it to print the name “Joe”.</p><p>However, in many cases, function overloading is a better alternative to achieve the same result:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>void greet(std::string_view name)</code><code>{</code><code>    std::cout &lt;&lt; "Hello " &lt;&lt; name &lt;&lt; '\n';</code><code>}</code><code></code><code>void greet()</code><code>{</code><code>    greet("guest");</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    greet(); // we don't know who the user is yet</code><code></code><code>    std::string joe{ "Joe" };</code><code>    greet(joe); // we know the user is joe</code><code></code><code>    return 0;</code><code>}</code></pre><p>This has a number of advantages: we no longer have to worry about null dereferences, and we could pass in a string literal if we wanted.</p><br><h3>Changing what a pointer parameter points at</h3><p>When we pass an address to a function, that address is copied from the argument into the pointer parameter (which is fine, because copying an address is fast). Now consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// [[maybe_unused]] gets rid of compiler warnings about ptr2 being set but not used</code><code>void nullify([[maybe_unused]] int* ptr2) </code><code>{</code><code>    ptr2 = nullptr; // Make the function parameter a null pointer</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    int* ptr{ &amp;x }; // ptr points to x</code><code></code><code>    std::cout &lt;&lt; "ptr is " &lt;&lt; (ptr ? "non-null\n" : "null\n");</code><code></code><code>    nullify(ptr);</code><code></code><code>    std::cout &lt;&lt; "ptr is " &lt;&lt; (ptr ? "non-null\n" : "null\n");</code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>ptr is non-null
ptr is non-null
</pre><p>As you can see, changing the address held by the pointer parameter had no impact on the address held by the argument (<code>ptr</code> still points at <code>x</code>). When function <code>nullify()</code> is called, <code>ptr2</code> receives a copy of the address passed in (in this case, the address held by <code>ptr</code>, which is the address of <code>x</code>). When the function changes what <code>ptr2</code> points at, this only affects the copy held by <code>ptr2</code>.</p><p>So what if we want to allow a function to change what a pointer argument points to?</p><br><h3>Pass by address… by reference?</h3><p>Yup, it’s a thing. Just like we can pass a normal variable by reference, we can also pass pointers by reference. Here’s the same program as above with <code>ptr2</code> changed to be a reference to an address:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void nullify(int*&amp; refptr) // refptr is now a reference to a pointer</code><code>{</code><code>    refptr = nullptr; // Make the function parameter a null pointer</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x{ 5 };</code><code>    int* ptr{ &amp;x }; // ptr points to x</code><code></code><code>    std::cout &lt;&lt; "ptr is " &lt;&lt; (ptr ? "non-null\n" : "null\n");</code><code></code><code>    nullify(ptr);</code><code></code><code>    std::cout &lt;&lt; "ptr is " &lt;&lt; (ptr ? "non-null\n" : "null\n");</code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>ptr is non-null
ptr is null
</pre><p>Because <code>refptr</code> is now a reference to a pointer, when <code>ptr</code> is passed as an argument, <code>refptr</code> is bound to <code>ptr</code>. This means any changes to <code>refptr</code> are made to <code>ptr</code>.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>Because references to pointers are fairly uncommon, it can be easy to mix up the syntax (is it <code>int*&amp;</code> or <code>int&amp;*</code>?). The good news is that if you do it backwards, the compiler will error because you can’t have a pointer to a reference (because pointers must hold the address of an object, and references aren’t objects). Then you can switch it around.</p></div><br><h3>Why using 0 or NULL is no longer preferred (optional)</h3><p>In this subsection, we’ll explain why using <code>0</code> or <code>NULL</code> is no longer preferred.</p><p>The literal <code>0</code> can be interpreted as either an integer literal, or as a null pointer literal. In certain cases, it can be ambiguous which one we intend -- and in some of those cases, the compiler may assume we mean one when we mean the other -- with unintended consequences to the behavior of our program.</p><p>The definition of preprocessor macro <code>NULL</code> is not defined by the language standard. It can be defined as <code>0</code>, <code>0L</code>, <code>((void*)0)</code>, or something else entirely.</p><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-function-overloading/">8.9 -- Introduction to function overloading</a>, we discussed that functions can be overloaded (multiple functions can have the same name, so long as they can be differentiated by the number or type of parameters). The compiler can figure out which overloaded function you desire by the arguments passed in as part of the function call.</p><p>When using <code>0</code> or <code>NULL</code>, this can cause problems:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cstddef> // for NULL</cstddef></code><code></code><code>void print(int x) // this function accepts an integer</code><code>{</code><code>	std::cout &lt;&lt; "print(int): " &lt;&lt; x &lt;&lt; '\n';</code><code>}</code><code></code><code>void print(int* ptr) // this function accepts an integer pointer</code><code>{</code><code>	std::cout &lt;&lt; "print(int*): " &lt;&lt; (ptr ? "non-null\n" : "null\n");</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int x{ 5 };</code><code>	int* ptr{ &amp;x };</code><code></code><code>	print(ptr);  // always calls print(int*) because ptr has type int* (good)</code><code>	print(0);    // always calls print(int) because 0 is an integer literal (hopefully this is what we expected)</code><code></code><code>	print(NULL); // this statement could do any of the following:</code><code>	// call print(int) (Visual Studio does this)</code><code>	// call print(int*)</code><code>	// result in an ambiguous function call compilation error (gcc and Clang do this)</code><code></code><code>	print(nullptr); // always calls print(int*)</code><code></code><code>	return 0;</code><code>}</code></pre><p>On the author’s machine (using Visual Studio), this prints:</p><pre>print(int*): non-null
print(int): 0
print(int): 0
print(int*): null
</pre><p>When passing integer value <code>0</code> as a parameter, the compiler will prefer <code>print(int)</code> over <code>print(int*)</code>. This can lead to unexpected results when we intended <code>print(int*)</code> to be called with a null pointer argument.</p><p>In the case where <code>NULL</code> is defined as value <code>0</code>, <code>print(NULL)</code> will also call <code>print(int)</code>, not <code>print(int*)</code> like you might expect for a null pointer literal. In cases where <code>NULL</code> is not defined as <code>0</code>, other behavior might result, like a call to <code>print(int*)</code> or a compilation error.</p><p>Using <code>nullptr</code> removes this ambiguity (it will always call <code>print(int*)</code>), since <code>nullptr</code> will only match a pointer type.</p><br><h3>std::nullptr_t (optional)</h3><p>Since <code>nullptr</code> can be differentiated from integer values in function overloads, it must have a different type. So what type is <code>nullptr</code>? The answer is that <code>nullptr</code> has type <code>std::nullptr_t</code> (defined in header &lt;cstddef&gt;). <code>std::nullptr_t</code> can only hold one value: <code>nullptr</code>! While this may seem kind of silly, it’s useful in one situation. If we want to write a function that accepts only a <code>nullptr</code> literal argument, we can make the parameter a <code>std::nullptr_t</code>.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cstddef> // for std::nullptr_t</cstddef></code><code></code><code>void print(std::nullptr_t)</code><code>{</code><code>    std::cout &lt;&lt; "in print(std::nullptr_t)\n";</code><code>}</code><code></code><code>void print(int*)</code><code>{</code><code>    std::cout &lt;&lt; "in print(int*)\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    print(nullptr); // calls print(std::nullptr_t)</code><code></code><code>    int x { 5 };</code><code>    int* ptr { &amp;x };</code><code></code><code>    print(ptr); // calls print(int*)</code><code></code><code>    ptr = nullptr;</code><code>    print(ptr); // calls print(int*) (since ptr has type int*)</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, the function call <code>print(nullptr)</code> resolves to the function <code>print(std::nullptr_t)</code> over <code>print(int*)</code> because it doesn’t require a conversion.</p><p>The one case that might be a little confusing is when we call <code>print(ptr)</code> when <code>ptr</code> is holding the value <code>nullptr</code>. Remember that function overloading matches on types, not values, and <code>ptr</code> has type <code>int*</code>. Therefore, <code>print(int*)</code> will be matched. <code>print(std::nullptr_t)</code> isn’t even in consideration in this case, as pointer types will not implicitly convert to a <code>std::nullptr_t</code>.</p><p>You probably won’t ever need to use this, but it’s good to know, just in case.</p><br><h3>There is only pass by value</h3><p>Now that you understand the basic differences between passing by reference, address, and value, let’s get reductionist for a moment. :)</p><p>While the compiler can often optimize references away entirely, there are cases where this is not possible and a reference is actually needed. References are normally implemented by the compiler using pointers. This means that behind the scenes, pass by reference is essentially just a pass by address (with access to the reference doing an implicit dereference).</p><p>And in the previous lesson, we mentioned that pass by address just copies an address from the caller to the called function -- which is just passing an address by value.</p><p>Therefore, we can conclude that C++ really passes everything by value! The properties of pass by address (and reference) come solely from the fact that we can dereference the passed address to change the argument, which we can not do with a normal value parameter!</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">9.11 — Return by reference and return by address</h1></header><div class="entry-content" itemprop="articleBody"><p>In previous lessons, we discussed that when passing an argument by value, a copy of the argument is made into the function parameter. For fundamental types (which are cheap to copy), this is fine. But copying is typically expensive for class types (such as <code>std::string</code>). We can avoid making an expensive copy by utilizing passing by (const) reference (or pass by address) instead.</p><p>We encounter a similar situation when returning by value: a copy of the return value is passed back to the caller. If the return type of the function is a class type, this can be expensive.</p><pre class="language-cpp line-numbers"><code>std::string returnByValue(); // returns a copy of a std::string (expensive)</code></pre><br><h3>Return by reference</h3><p>In cases where we’re passing a class type back to the caller, we may (or may not) want to return by reference instead. <span class="cpp-definition">Return by reference</span> returns a reference that is bound to the object being returned, which avoids making a copy of the return value. To return by reference, we simply define the return value of the function to be a reference type:</p><pre class="language-cpp line-numbers"><code>std::string&amp;       returnByReference(); // returns a reference to an existing std::string (cheap)</code><code>const std::string&amp; returnByReferenceToConst(); // returns a const reference to an existing std::string (cheap)</code></pre><p>Here is an academic program to demonstrate the mechanics of return by reference:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>const std::string&amp; getProgramName() // returns a const reference</code><code>{</code><code>    static const std::string s_programName { "Calculator" }; // has static duration, destroyed at end of program</code><code></code><code>    return s_programName;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "This program is named " &lt;&lt; getProgramName();</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>This program is named Calculator
</pre><p>Because <code>getProgramName()</code> returns a const reference, when the line <code>return s_programName</code> is executed, <code>getProgramName()</code> will return a const reference to <code>s_programName</code> (thus avoiding making a copy). That const reference can then be used by the caller to access the value of <code>s_programName</code>, which is printed.</p><br><h3>The object being returned by reference must exist after the function returns</h3><p>Using return by reference has one major caveat: the programmer <em>must</em> be sure that the object being referenced outlives the function returning the reference. Otherwise, the reference being returned will be left dangling (referencing an object that has been destroyed), and use of that reference will result in undefined behavior.</p><p>In the program above, because <code>s_programName</code> has static duration, <code>s_programName</code> will exist until the end of the program. When <code>main()</code> accesses the returned reference, it is actually accessing <code>s_programName</code>, which is fine, because <code>s_programName</code> won’t be destroyed until later.</p><p>Now let’s modify the above program to show what happens in the case where our function returns a dangling reference:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>const std::string&amp; getProgramName()</code><code>{</code><code>    const std::string programName { "Calculator" }; // now a local variable, destroyed when function ends</code><code></code><code>    return programName;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "This program is named " &lt;&lt; getProgramName();</code><code></code><code>    return 0;</code><code>}</code></pre><p>The result of this program is undefined. When <code>getProgramName()</code> returns, a reference bound to local variable <code>programName</code> is returned. Then, because <code>programName</code> is a local variable with automatic duration, <code>programName</code> is destroyed at the end of the function. That means the returned reference is now dangling, and use of <code>programName</code> in the <code>main()</code> function results in undefined behavior.</p><p>Modern compilers will produce a warning or error if you try to return a local variable by reference (so the above program may not even compile), but compilers sometimes have trouble detecting more complicated cases.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Objects returned by reference must live beyond the scope of the function returning the reference, or a dangling reference will result. Never return a local variable by reference.</p></div><br><h3>Don’t return non-const local static variables by reference</h3><p>In the original example above, we returned a const local static variable by reference to illustrate the mechanics of return by reference in a simple way. However, returning non-const static variables by reference is fairly non-idiomatic, and should generally be avoided. Here’s a simplified example that illustrates one such problem that can occur:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>const int&amp; getNextId()</code><code>{</code><code>    static int s_x{ 0 }; // note: variable is non-const</code><code>    ++s_x; // generate the next id</code><code>    return s_x; // and return a reference to it</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    const int&amp; id1 { getNextId() }; // id1 is a reference</code><code>    const int&amp; id2 { getNextId() }; // id2 is a reference</code><code></code><code>    std::cout &lt;&lt; id1 &lt;&lt; id2 &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>22
</pre><p>This happens because <code>id1</code> and <code>id2</code> are referencing the same object (the static variable <code>s_x</code>), so when anything (e.g. <code>getNextId()</code>) modifies that value, all references are now accessing the modified value. Another issue that commonly occurs with programs that return a static local by const reference is that there is no standardized way to reset <code>s_x</code> back to the default state. Such programs must either use a non-idiomatic solution (e.g. a reset parameter), or can only be reset by quitting and restarting the program.</p><p>While the above example is a bit silly, there are permutations of the above that programmers sometimes try for optimization purposes, and then their programs don’t work as expected.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Avoid returning references to non-const local static variables.</p></div><p>Returning a const reference to a <em>const</em> local static variable is sometimes done if the local variable being returned by reference is expensive to create (so we don’t have to recreate the variable every function call). But this is rare.</p><p>Returning a const reference to a <em>const</em> global variable is also sometimes done as a way to encapsulate access to a global variable. We discuss this in lesson <a href="https://www.learncpp.com/cpp-tutorial/why-non-const-global-variables-are-evil/">6.8 -- Why (non-const) global variables are evil</a>. When used intentionally and carefully, this is also okay.</p><br><h3>Assigning/initializing a normal variable with a returned reference makes a copy</h3><p>If a function returns a reference, and that reference is used to initialize or assign to a non-reference variable, the return value will be copied (as if it had been returned by value).</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>const int&amp; getNextId()</code><code>{</code><code>    static int s_x{ 0 };</code><code>    ++s_x;</code><code>    return s_x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    const int id1 { getNextId() }; // id1 is a normal variable now and receives a copy of the value returned by reference from getNextId()</code><code>    const int id2 { getNextId() }; // id2 is a normal variable now and receives a copy of the value returned by reference from getNextId()</code><code></code><code>    std::cout &lt;&lt; id1 &lt;&lt; id2 &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, <code>getNextId()</code> is returning a reference, but <code>id1</code> and <code>id2</code> are non-reference variables. In such a case, the value of the returned reference is copied into the normal variable. Thus, this program prints:</p><pre>12
</pre><p>Of course, this also defeats the purpose of returning a value by reference.</p><p>Also note that if a program returns a dangling reference, the reference is left dangling before the copy is made, which will lead to undefined behavior:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>const std::string&amp; getProgramName() // will return a const reference</code><code>{</code><code>    const std::string programName{ "Calculator" };</code><code></code><code>    return programName;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::string name { getProgramName() }; // makes a copy of a dangling reference</code><code>    std::cout &lt;&lt; "This program is named " &lt;&lt; name &lt;&lt; '\n'; // undefined behavior</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>It’s okay to return reference parameters by reference</h3><p>There are quite a few cases where returning objects by reference makes sense, and we’ll encounter many of those in future lessons. However, there is one useful example that we can show now.</p><p>If a parameter is passed into a function by reference, it’s safe to return that parameter by reference. This makes sense: in order to pass an argument to a function, the argument must exist in the scope of the caller. When the called function returns, that object must still exist in the scope of the caller.</p><p>Here is a simple example of such a function:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>// Takes two std::string objects, returns the one that comes first alphabetically</code><code>const std::string&amp; firstAlphabetical(const std::string&amp; a, const std::string&amp; b)</code><code>{</code><code>	return (a &lt; b) ? a : b; // We can use operator&lt; on std::string to determine which comes first alphabetically</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::string hello { "Hello" };</code><code>	std::string world { "World" };</code><code></code><code>	std::cout &lt;&lt; firstAlphabetical(hello, world) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>Hello
</pre><p>In the above function, the caller passes in two std::string objects by const reference, and whichever of these strings comes first alphabetically is passed back by const reference. If we had used pass by value and return by value, we would have made up to 3 copies of std::string (one for each parameter, one for the return value). By using pass by reference/return by reference, we can avoid those copies.</p><br><h3>The caller can modify values through the reference</h3><p>When an argument is passed to a function by non-const reference, the function can use the reference to modify the value of the argument.</p><p>Similarly, when a non-const reference is returned from a function, the caller can use the reference to modify the value being returned.</p><p>Here’s an illustrative example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// takes two integers by non-const reference, and returns the greater by reference</code><code>int&amp; max(int&amp; x, int&amp; y)</code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int a{ 5 };</code><code>    int b{ 6 };</code><code></code><code>    max(a, b) = 7; // sets the greater of a or b to 7</code><code></code><code>    std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; '\n';</code><code>        </code><code>    return 0;</code><code>}</code></pre><p>In the above program, <code>max(a, b)</code> calls the <code>max()</code> function with <code>a</code> and <code>b</code> as arguments. Reference parameter <code>x</code> binds to argument <code>a</code>, and reference parameter <code>y</code> binds to argument <code>b</code>. The function then determines which of <code>x</code> (<code>5</code>) and <code>y</code> (<code>6</code>) is greater. In this case, that’s <code>y</code>, so the function returns <code>y</code> (which is still bound to <code>b</code>) back to the caller. The caller then assigns the value <code>7</code> to this returned reference.</p><p>Therefore, the expression <code>max(a, b) = 7</code> effectively resolves to <code>b = 7</code>.</p><p>This prints:</p><pre>57
</pre><br><h3>Return by address</h3><p><span class="cpp-definition">Return by address</span> works almost identically to return by reference, except a pointer to an object is returned instead of a reference to an object. Return by address has the same primary caveat as return by reference -- the object being returned by address must outlive the scope of the function returning the address, otherwise the caller will receive a dangling pointer.</p><p>The major advantage of return by address over return by reference is that we can have the function return <code>nullptr</code> if there is no valid object to return. For example, let’s say we have a list of students that we want to search. If we find the student we are looking for in the list, we can return a pointer to the object representing the matching student. If we don’t find any students matching, we can return <code>nullptr</code> to indicate a matching student object was not found.</p><p>The major disadvantage of return by address is that the caller has to remember to do a <code>nullptr</code> check before dereferencing the return value, otherwise a null pointer dereference may occur and undefined behavior will result. Because of this danger, return by reference should be preferred over return by address unless the ability to return “no object” is needed.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Prefer return by reference over return by address unless the ability to return “no object” (using <code>nullptr</code>) is important.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">9.12 — Type deduction with pointers, references, and const</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/type-deduction-for-objects-using-the-auto-keyword/">8.7 -- Type deduction for objects using the auto keyword</a>, we discussed how the <code>auto</code> keyword can be used to have the compiler deduce the type of a variable from the initializer:</p><pre class="language-cpp line-numbers"><code>int getVal(); // some function that returns an int by value</code><code></code><code>int main()</code><code>{</code><code>    auto val { getVal() }; // val deduced as type int</code><code></code><code>    return 0;</code><code>}</code></pre><p>We also noted that by default, type deduction will drop <code>const</code> qualifiers:</p><pre class="language-cpp line-numbers"><code>const double foo()</code><code>{</code><code>    return 5.6;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    const double cd{ 7.8 };</code><code></code><code>    auto x{ cd };    // double (const dropped)</code><code>    auto y{ foo() }; // double (const dropped)</code><code></code><code>    return 0;</code><code>}</code></pre><p>Const can be reapplied by adding the <code>const</code> qualifier in the definition:</p><pre class="language-cpp line-numbers"><code>const double foo()</code><code>{</code><code>    return 5.6;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    const double cd{ 7.8 };</code><code></code><code>    const auto x{ cd };    // const double (const reapplied)</code><code>    const auto y{ foo() }; // const double (const reapplied)</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>Type deduction drops references</h3><p>In addition to dropping const qualifiers, type deduction will also drop references:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>std::string&amp; getRef(); // some function that returns a reference</code><code></code><code>int main()</code><code>{</code><code>    auto ref { getRef() }; // type deduced as std::string (not std::string&amp;)</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, variable <code>ref</code> is using type deduction. Although function <code>getRef()</code> returns a <code>std::string&amp;</code>, the reference qualifier is dropped, so the type of <code>ref</code> is deduced as <code>std::string</code>.</p><p>Just like with the dropped <code>const</code> qualifier, if you want the deduced type to be a reference, you can reapply the reference at the point of definition:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>std::string&amp; getRef(); // some function that returns a reference to const</code><code></code><code>int main()</code><code>{</code><code>    auto ref1 { getRef() };  // std::string (reference dropped)</code><code>    auto&amp; ref2 { getRef() }; // std::string&amp; (reference reapplied)</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>Top-level const and low-level const</h3><p>A <span class="cpp-definition">top-level const</span> is a const qualifier that applies to an object itself. For example:</p><pre class="language-cpp line-numbers"><code>const int x;    // this const applies to x, so it is top-level</code><code>int* const ptr; // this const applies to ptr, so it is top-level</code></pre><p>In contrast, a <span class="cpp-definition">low-level const</span> is a const qualifier that applies to the object being referenced or pointed to:</p><pre class="language-cpp line-numbers"><code>const int&amp; ref; // this const applies to the object being referenced, so it is low-level</code><code>const int* ptr; // this const applies to the object being pointed to, so it is low-level</code></pre><p>A reference to a const value is always a low-level const. A pointer can have a top-level, low-level, or both kinds of const:</p><pre class="language-cpp line-numbers"><code>const int* const ptr; // the left const is low-level, the right const is top-level</code></pre><p>When we say that type deduction drops const qualifiers, it only drops top-level consts. Low-level consts are not dropped. We’ll see examples of this in just a moment.</p><br><h3>Type deduction and const references</h3><p>If the initializer is a reference to const, the reference is dropped first (and then reapplied if applicable), and then any top-level const is dropped from the result.</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>const std::string&amp; getRef(); // some function that returns a reference to const</code><code></code><code>int main()</code><code>{</code><code>    auto ref1{ getRef() }; // std::string (reference dropped, then top-level const dropped from result)</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, since <code>getRef()</code> returns a <code>const std::string&amp;</code>, the reference is dropped first, leaving us with a <code>const std::string</code>. This const is now a top-level const, so it is also dropped, leaving the deduced type as <code>std::string</code>.</p><p>We can reapply either or both of these:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>const std::string&amp; getRef(); // some function that returns a const reference</code><code></code><code>int main()</code><code>{</code><code>    auto ref1{ getRef() };        // std::string (top-level const and reference dropped)</code><code>    const auto ref2{ getRef() };  // const std::string (const reapplied, reference dropped)</code><code></code><code>    auto&amp; ref3{ getRef() };       // const std::string&amp; (reference reapplied, low-level const not dropped)</code><code>    const auto&amp; ref4{ getRef() }; // const std::string&amp; (reference and const reapplied)</code><code></code><code>    return 0;</code><code>}</code></pre><p>We covered the case for <code>ref1</code> in the prior example. For <code>ref2</code>, this is similar to the <code>ref1</code> case, except we’re reapplying the <code>const</code> qualifier, so the deduced type is <code>const std::string</code>.</p><p>Things get more interesting with <code>ref3</code>. Normally the reference would be dropped, but since we’ve reapplied the reference, it is not dropped. That means the type is still <code>const std::string&amp;</code>. And since this const is a low-level const, it is not dropped. Thus the deduced type is <code>const std::string&amp;</code>.</p><p>The <code>ref4</code> case works similarly to <code>ref3</code>, except we’ve reapplied the <code>const</code> qualifier as well. Since the type is already deduced as a reference to const, us reapplying <code>const</code> here is redundant. That said, using <code>const</code> here makes it explicitly clear that our result will be const (whereas in the <code>ref3</code> case, the constness of the result is implicit and not obvious).</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>If you want a const reference, reapply the <code>const</code> qualifier even when it’s not strictly necessary, as it makes your intent clear and helps prevent mistakes.</p></div><br><h3>Type deduction and pointers</h3><p>Unlike references, type deduction does not drop pointers:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>std::string* getPtr(); // some function that returns a pointer</code><code></code><code>int main()</code><code>{</code><code>    auto ptr1{ getPtr() }; // std::string*</code><code></code><code>    return 0;</code><code>}</code></pre><p>We can also use an asterisk in conjunction with pointer type deduction:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>std::string* getPtr(); // some function that returns a pointer</code><code></code><code>int main()</code><code>{</code><code>    auto ptr1{ getPtr() };  // std::string*</code><code>    auto* ptr2{ getPtr() }; // std::string*</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>The difference between auto and auto* (optional reading)</h3><p>When we use <code>auto</code> with a pointer type initializer, the type deduced for <code>auto</code> includes the pointer. So for <code>ptr1</code> above, the type substituted for <code>auto</code> is <code>std::string*</code>.</p><p>When we use <code>auto*</code> with a pointer type initializer, the type deduced for auto does <em>not</em> include the pointer -- the pointer is reapplied afterward after the type is deduced. So for <code>ptr2</code> above, the type substituted for <code>auto</code> is <code>std::string</code>, and then the pointer is reapplied.</p><p>In most cases, the practical effect is the same (<code>ptr1</code> and <code>ptr2</code> both deduce to <code>std::string*</code> in the above example).</p><p>However, there are a couple of difference between <code>auto</code> and <code>auto*</code> in practice. First, <code>auto*</code> must resolve to a pointer initializer, otherwise a compile error will result:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>std::string* getPtr(); // some function that returns a pointer</code><code></code><code>int main()</code><code>{</code><code>    auto ptr3{ *getPtr() };      // std::string (because we dereferenced getPtr())</code><code>    auto* ptr4{ *getPtr() };     // does not compile (initializer not a pointer)</code><code></code><code>    return 0;</code><code>}</code></pre><p>This makes sense: in the <code>ptr4</code> case, <code>auto</code> deduces to <code>std::string</code>, then the pointer is reapplied. Thus <code>ptr4</code> has type <code>std::string*</code>, and we can’t initialize a <code>std::string*</code> with an initializer that is not a pointer.</p><p>Second, there are differences in how <code>auto</code> and <code>auto*</code> behave when we introduce <code>const</code> into the equation. We’ll cover this below.</p><br><h3>Type deduction and const pointers (optional reading)</h3><p>Since pointers aren’t dropped, we don’t have to worry about that. But with pointers, we have both the const pointer and the pointer to const cases to think about, and we also have <code>auto</code> vs <code>auto*</code>. Just like with references, only top-level const is dropped during pointer type deduction.</p><p>Let’s start with a simple case:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>std::string* getPtr(); // some function that returns a pointer</code><code></code><code>int main()</code><code>{</code><code>    const auto ptr1{ getPtr() };  // std::string* const</code><code>    auto const ptr2 { getPtr() }; // std::string* const</code><code></code><code>    const auto* ptr3{ getPtr() }; // const std::string*</code><code>    auto* const ptr4{ getPtr() }; // std::string* const</code><code></code><code>    return 0;</code><code>}</code></pre><p>When we use either <code>auto const</code> or <code>const auto</code>, we’re saying, “make whatever the deduced type is const”. So in the case of <code>ptr1</code> and <code>ptr2</code>, the deduced type is <code>std::string*</code>, and then const is applied, making the final type <code>std::string* const</code>. This is similar to how <code>const int</code> and <code>int const</code> mean the same thing.</p><p>However, when we use <code>auto*</code>, the order of the const qualifier matters. A <code>const</code> on the left means “make the deduced pointer type a pointer to const”, whereas a <code>const</code> on the right means “make the deduced pointer type a const pointer”. Thus <code>ptr3</code> ends up as a pointer to const, and <code>ptr4</code> ends up as a const pointer.</p><p>Now let’s look at an example where the initializer is a const pointer to const.</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>const std::string* const getConstPtr(); // some function that returns a const pointer to a const value</code><code></code><code>int main()</code><code>{</code><code>    auto ptr1{ getConstPtr() };  // const std::string*</code><code>    auto* ptr2{ getConstPtr() }; // const std::string*</code><code></code><code>    auto const ptr3{ getConstPtr() };  // const std::string* const</code><code>    const auto ptr4{ getConstPtr() };  // const std::string* const</code><code></code><code>    auto* const ptr5{ getConstPtr() }; // const std::string* const</code><code>    const auto* ptr6{ getConstPtr() }; // const std::string*</code><code></code><code>    const auto const ptr7{ getConstPtr() };  // error: const qualifer can not be applied twice</code><code>    const auto* const ptr8{ getConstPtr() }; // const std::string* const</code><code></code><code>    return 0;</code><code>}</code></pre><p>The <code>ptr1</code> and <code>ptr2</code> cases are straightforward. The top-level const (the const on the pointer itself) is dropped. The low-level const on the object being pointed to is not dropped. So in both cases, the final type is <code>const std::string*</code>.</p><p>The <code>ptr3</code> and <code>ptr4</code> cases are also straightforward. The top-level const is dropped, but we’re reapplying it. The low-level const on the object being pointed to is not dropped. So in both cases, the final type is <code>const std::string* const</code>.</p><p>The <code>ptr5</code> and <code>ptr6</code> cases are analogous to the cases we showed in the prior example. In both cases, the top-level const is dropped. For <code>ptr5</code>, the <code>auto* const</code> reapplies the top-level const, so the final type is <code>const std::string* const</code>. For <code>ptr6</code>, the <code>const auto*</code> applies const to the type being pointed to (which in this case was already const), so the final type is <code>const std::string*</code>.</p><p>In the <code>ptr7</code> case, we’re applying the const qualifier twice, which is disallowed, and will cause a compile error.</p><p>And finally, in the <code>ptr8</code> case, we’re applying const on both sides of the pointer (which is allowed since <code>auto*</code> must be a pointer type), so the resulting types is <code>const std::string* const</code>.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>If you want a const pointer, reapply the <code>const</code> qualifier even when it’s not strictly necessary, as it makes your intent clear and helps prevent mistakes.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">9.x — Chapter 9 summary and quiz</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Quick review</h3><p><span class="cpp-definition">Compound data types</span> (also called <span class="cpp-definition">composite data type</span>) are data types that can be constructed from fundamental data types (or other compound data types).</p><p>The <span class="cpp-definition">value category</span> of an expression indicates whether an expression resolves to a value, a function, or an object of some kind.</p><p>An <span class="cpp-definition">lvalue</span> is an expression that evaluates to a function or an object that has an identity. An object or function with an <span class="cpp-definition">identity</span> has an identifier or an identifiable memory address. Lvalues come in two subtypes: <span class="cpp-definition">modifiable lvalues</span> are lvalues that can be modified, and <span class="cpp-definition">non-modifiable lvalues</span> are lvalues whose values can’t be modified (typically because they are const or constexpr).</p><p>An <span class="cpp-definition">rvalue</span> is an expression that is not an l-value. This includes literals (except string literals) and the return values of functions or operators (when returned by value).</p><p>A <span class="cpp-definition">reference</span> is an alias for an existing object. Once a reference has been defined, any operation on the reference is applied to the object being referenced. C++ contains two types of references: lvalue references and rvalue references. An <span class="cpp-definition">lvalue reference</span> (commonly just called a <span class="cpp-definition">reference</span>) acts as an alias for an existing lvalue (such as a variable). An <span class="cpp-definition">lvalue reference variable</span> is a variable that acts as a reference to an lvalue (usually another variable).</p><p>When a reference is initialized with an object (or function), we say it is <span class="cpp-definition">bound</span> to that object (or function). The object (or function) being referenced is sometimes called the <span class="cpp-definition">referent</span>.</p><p>Lvalue references can’t be bound to non-modifiable lvalues or rvalues (otherwise you’d be able to change those values through the reference, which would be a violation of their const-ness). For this reason, lvalue references are occasionally called <span class="cpp-definition">lvalue references to non-const</span> (sometimes shortened to <span class="cpp-definition">non-const reference</span>).</p><p>Once initialized, a reference in C++ cannot be <span class="cpp-definition">reseated</span>, meaning it can not be changed to reference another object.</p><p>When an object being referenced is destroyed before a reference to it, the reference is left referencing an object that no longer exists. Such a reference is called a <span class="cpp-definition">dangling reference</span>. Accessing a dangling reference leads to undefined behavior.</p><p>By using the <code>const</code> keyword when declaring an lvalue reference, we tell an lvalue reference to treat the object it is referencing as const. Such a reference is called an <span class="cpp-definition">lvalue reference to a const value</span> (sometimes called a <span class="cpp-definition">reference to const</span> or a <span class="cpp-definition">const reference</span>). Const references can bind to modifiable lvalues, non-modifiable lvalues, and rvalues.</p><p>A <span class="cpp-definition">temporary object</span> (also sometimes called an <span class="cpp-definition">unnamed object</span> or <span class="cpp-definition">anonymous object</span>) is an object that is created for temporary use (and then destroyed) within a single expression.</p><p>When using <span class="cpp-definition">pass by reference</span>, we declare a function parameter as a reference (or const reference) rather than as a normal variable. When the function is called, each reference parameter is bound to the appropriate argument. Because the reference acts as an alias for the argument, no copy of the argument is made.</p><p>The <span class="cpp-definition">address-of operator</span> (&amp;) returns the memory address of its operand. The <span class="cpp-definition">dereference operator</span> (*) returns the value at a given memory address as an lvalue.</p><p>A <span class="cpp-definition">pointer</span> is an object that holds a <em>memory address</em> (typically of another variable) as its value. This allows us to store the address of some other object to use later. Like normal variables, pointers are not initialized by default. A pointer that has not been initialized is sometimes called a <span class="cpp-definition">wild pointer</span>. A <span class="cpp-definition">dangling pointer</span> is a pointer that is holding the address of an object that is no longer valid (e.g. because it has been destroyed).</p><p>Besides a memory address, there is one additional value that a pointer can hold: a null value. A <span class="cpp-definition">null value</span> (often shortened to <span class="cpp-definition">null</span>) is a special value that means something has no value. When a pointer is holding a null value, it means the pointer is not pointing at anything. Such a pointer is called a <span class="cpp-definition">null pointer</span>. The <span class="cpp-definition">nullptr</span> keyword represents a null pointer literal. We can use <code>nullptr</code> to explicitly initialize or assign a pointer a null value.</p><p>A pointer should either hold the address of a valid object, or be set to <code>nullptr</code>. That way we only need to test pointers for null, and can assume any non-null pointer is valid.</p><p>A <span class="cpp-definition">pointer to a const value</span> (sometimes called a <span class="cpp-definition">pointer to const</span> for short) is a (non-const) pointer that points to a constant value.</p><p>A <span class="cpp-definition">const pointer</span> is a pointer whose address can not be changed after initialization.</p><p>A <span class="cpp-definition">const pointer to a const value</span> can not have its address changed, nor can the value it is pointing to be changed through the pointer.</p><p>With <span class="cpp-definition">pass by address</span>, instead of providing an object as an argument, the caller provides an object’s address (via a pointer). This pointer (holding the address of the object) is copied into a pointer parameter of the called function (which now also holds the address of the object). The function can then dereference that pointer to access the object whose address was passed.</p><p><span class="cpp-definition">Return by reference</span> returns a reference that is bound to the object being returned, which avoids making a copy of the return value. Using return by reference has one major caveat: the programmer must be sure that the object being referenced outlives the function returning the reference. Otherwise, the reference being returned will be left dangling (referencing an object that has been destroyed), and use of that reference will result in undefined behavior. If a parameter is passed into a function by reference, it’s safe to return that parameter by reference.</p><p>If a function returns a reference, and that reference is used to initialize or assign to a non-reference variable, the return value will be copied (as if it had been returned by value).</p><p>Type deduction for variables (via the <code>auto</code> keyword) will drop any reference or top-level const qualifiers from the deduced type. These can be reapplied as part of the variable declaration if desired.</p><p><span class="cpp-definition">Return by address</span> works almost identically to return by reference, except a pointer to an object is returned instead of a reference to an object.</p><p></p><br><h3>Quiz time</h3><p class="cpp-quiz-question" style="clear:both">Question #1</p><p>For each of the following expressions on the right side of operator &lt;&lt;, indicate whether the expression is an lvalue or rvalue:</p><p>a)</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; 5;</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none">Literals are rvalues, so <code>5</code> is an rvalue</div><p>b)</p><pre class="language-cpp line-numbers"><code>int x { 5 };</code><code>std::cout &lt;&lt; x;</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none">The expression <code>x</code> identifies variable <code>x</code>, so this expression is an lvalue.</div><p>c)</p><pre class="language-cpp line-numbers"><code>int x { 5 };</code><code>std::cout &lt;&lt; x + 1;</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none">The expression <code>x + 1</code> calculates a temporary value, so this expression is an rvalue.</div><p>d)</p><pre class="language-cpp line-numbers"><code>int foo() { return 5; }</code><code>std::cout &lt;&lt; foo();</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none">The return value of a function (when returned by value) is an rvalue.</div><p>e)</p><pre class="language-cpp line-numbers"><code>int&amp; max(int &amp;x, int &amp;y) { return x &gt; y ? x : y; }</code><code>int x { 5 };</code><code>int y { 6 };</code><code>std::cout &lt;&lt; max(x, y);</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none">max() returns an lvalue reference, which is an lvalue</div><p class="cpp-quiz-question cpp-topline" style="clear:both">Question #2</p><p>What is the output of this program?</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	int x{ 5 };</code><code>	int y{ 6 };</code><code></code><code>	int&amp; ref{ x };</code><code>	++ref;</code><code>	ref = y;</code><code>	++ref;</code><code></code><code>	std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y;</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><pre>7 6
</pre><p>Remember, references cannot be reseated, so <code>ref = y</code> does not make <code>ref</code> a reference to <code>y</code>. It assigns the value of <code>y</code> to the object <code>ref</code> is referring to (which is <code>x</code>).</p></div><p class="cpp-quiz-question cpp-topline" style="clear:both">Question #3</p><p>Name two reasons why we prefer to pass arguments by const reference instead of by non-const reference whenever possible.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none"><ol start="1"><li>A non-const reference parameter can be used to modify the value of the argument. If we do not need this ability, it’s better to pass by const reference so that we don’t accidentally modify the argument.</li><li>A non-const reference parameter can only accept a modifiable lvalue as an argument. A const reference-parameter can accept a modifiable lvalue, a non-modifiable lvalue, or an rvalue as an argument.</li></ol></div><p class="cpp-quiz-question cpp-topline" style="clear:both">Question #4</p><p>What is the difference between a const pointer and a pointer-to-const?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_7'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_7" style="display:none"><p>A const pointer is a pointer whose address can not be changed (it cannot be re-pointed at some other object).<br>A pointer-to-const is a pointer that is pointing at a const object, and thus the value of that object can’t be changed through the pointer.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">10.1 — Introduction to program-defined (user-defined) types</h1></header><div class="entry-content" itemprop="articleBody"><p>Because fundamental types are defined as part of the core C++ language, they are available for immediate use. For example, if we want to define a variable with a type of <code>int</code> or <code>double</code>, we can just do so:</p><pre class="language-cpp line-numbers"><code>int x; // define variable of fundamental type 'int'</code><code>double d; // define variable of fundamental type 'double'</code></pre><p>This is also true for the compound types that are simple extensions of fundamental types (including functions, pointers, references, and arrays):</p><pre class="language-cpp line-numbers"><code>void fcn(int) {}; // define a function of type void()(int)</code><code>int* ptr; // define variable of compound type 'pointer to int'</code><code>int&amp; ref; // define variable of compound type 'reference to int'</code><code>int arr[5]; // define an array of 5 integers of type int[5] (we'll cover this in a future chapter)</code></pre><p>This works because the C++ language already knows what the type names (and symbols) for these types mean -- we do not need to provide or import any definitions.</p><p>However, consider the case of a type alias (introduced in lesson <a href="https://www.learncpp.com/cpp-tutorial/typedefs-and-type-aliases/">8.6 -- Typedefs and type aliases</a>), which allows us to define a new name for an existing type. Because a type alias introduces a new identifier into the program, a type alias must be defined before it can be used:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>using length = int; // define a type alias with identifier 'length'</code><code></code><code>int main()</code><code>{</code><code>    length x { 5 }; // we can use 'length' here since we defined it above</code><code>    std::cout &lt;&lt; x;</code><code></code><code>    return 0;</code><code>}</code></pre><p>If we were to omit the definition of <code>length</code>, the compiler wouldn’t know what a <code>length</code> is, and would complain when we try to define a variable using that type. The definition for <code>length</code> doesn’t create an object -- it just tells the compiler what a <code>length</code> is so it can be used later.</p><br><h3>What are user-defined / program-defined types?</h3><p>Back in the introduction to the previous chapter (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-compound-data-types/">9.1 -- Introduction to compound data types</a>), we introduced the challenge of wanting to store a fraction, which has a numerator and denominator that are conceptually linked together. In that lesson, we discussed some of the challenges with using two separate integers to store a fraction’s numerator and denominator independently.</p><p>If C++ had a built-in fraction type, that would have been perfect -- but it doesn’t. And there are hundreds of other potentially useful types that C++ doesn’t include because it’s just not possible to anticipate everything that someone might need (let alone implement and test those things).</p><p>Instead, C++ solves for such problems in a different way: by allowing us to create entirely new, custom types for use in our programs! Such types are often called <span class="cpp-definition">user-defined types</span> (though we think the term <span class="cpp-definition">program-defined types</span> is better -- we’ll discuss the difference later in this lesson). C++ has two categories of compound types that allow for this: the enumerated types (including unscoped and scoped enumerations), and the class types (including structs, classes, and unions).</p><br><h3>Defining program-defined types</h3><p>Just like type aliases, program-defined types must also be defined before they can be used. The definition for a program-defined type is called a <span class="cpp-definition">type definition</span>.</p><p>Although we haven’t covered what a struct is yet, here’s an example showing the definition of custom Fraction type and an instantiation of an object using that type:</p><pre class="language-cpp line-numbers"><code>// Define a program-defined type named Fraction so the compiler understands what a Fraction is</code><code>// (we'll explain what a struct is and how to use them later in this chapter)</code><code>// This only defines what a Fraction type looks like, it doesn't create one</code><code>struct Fraction</code><code>{</code><code>	int numerator {};</code><code>	int denominator {};</code><code>};</code><code></code><code>// Now we can make use of our Fraction type</code><code>int main()</code><code>{</code><code>	Fraction f{ 3, 4 }; // this actually instantiates a Fraction object named f</code><code></code><code>	return 0;</code><code>}</code></pre><p>In this example, we’re using the <code>struct</code> keyword to define a new program-defined type named <code>Fraction</code> (in the global scope, so it can be used anywhere in the rest of the file). This doesn’t allocate any memory -- it just tells the compiler what a <code>Fraction</code> looks like, so we can allocate objects of a <code>Fraction</code> type later. Then, inside <code>main()</code>, we instantiate (and initialize) a variable of type <code>Fraction</code> named <code>f</code>.</p><p>Program-defined type definitions always end in a semicolon. Failure to include the semicolon at the end of a type definition is a common programmer error, and one that can be hard to debug because the compiler will usually error on the line <em>after</em> the type definition. For example, if you remove the semicolon from the end of the <code>Fraction</code> definition (line 8) of the example above, the compiler will probably complain about the definition of <code>main()</code> (line 11).</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Don’t forget to end your type definitions with a semicolon, otherwise the compiler will typically error on the next line of code.</p></div><p>We’ll show more examples of defining and using program-defined types in the next lesson (<a href="https://www.learncpp.com/cpp-tutorial/unscoped-enumerations/">10.2 -- Unscoped enumerations</a>), and we cover structs starting in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-structs-members-and-member-selection/">10.5 -- Introduction to structs, members, and member selection</a>.</p><br><h3>Naming program-defined types</h3><p>By convention, program-defined types are named starting with a capital letter and don’t use a suffix (e.g. <code>Fraction</code>, not <code>fraction</code>, <code>fraction_t</code>, or <code>Fraction_t</code>).</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Name your program-defined types starting with a capital letter and do not use a suffix.</p></div><p>New programmers sometimes find variable definitions such as the following confusing because of the similarity between the type name and variable name:</p><pre class="language-cpp line-numbers"><code>Fraction fraction {}; // Instantiates a variable named fraction of type Fraction</code></pre><p>But this is no different than any other variable definition: the type (<code>Fraction</code>) comes first (and because Fraction is capitalized, we know it’s a program-defined type), then the variable name (<code>fraction</code>), and then an optional initializer. Because C++ is case-sensitive, there is no naming conflict here!</p><br><h3>Using program-defined types throughout a multi-file program</h3><p>Every code file that uses a program-defined type needs to see the full type definition before it is used. A forward declaration is not sufficient. This is required so that the compiler knows how much memory to allocate for objects of that type.</p><p>To propagate type definitions into the code files that need them, program-defined types are typically defined in header files, and then #included into any code file that requires that type definition. These header files are typically given the same name as the program-defined type (e.g. a program-defined type named Fraction would be defined in Fraction.h)</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>A program-defined type used in only one code file should be defined in that code file as close to the first point of use as possible.</p><p>A program-defined type used in multiple code files should be defined in a header file with the same name as the program-defined type and then #included into each code file as needed.</p></div><p>Here’s an example of what our Fraction type would look like if we moved it to a header file (named Fraction.h) so that it could be included into multiple code files:</p><p>Fraction.h:</p><pre class="language-cpp line-numbers"><code>#ifndef FRACTION_H</code><code>#define FRACTION_H</code><code></code><code>// Define a new type named Fraction</code><code>// This only defines what a Fraction looks like, it doesn't create one</code><code>// Note that this is a full definition, not a forward declaration</code><code>struct Fraction</code><code>{</code><code>	int numerator {};</code><code>	int denominator {};</code><code>};</code><code></code><code>#endif</code></pre><p>Fraction.cpp:</p><pre class="language-cpp line-numbers"><code>#include "Fraction.h" // include our Fraction definition in this code file</code><code></code><code>// Now we can make use of our Fraction type</code><code>int main()</code><code>{</code><code>	Fraction f{ 3, 4 }; // this actually creates a Fraction object named f</code><code></code><code>	return 0;</code><code>}</code></pre><br><h3>Type definitions are partially exempt from the one-definition rule</h3><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/forward-declarations/">2.7 -- Forward declarations and definitions</a>, we discussed how the one-definition rule requires that each function and global variable only have one definition per program. To use a given function or global variable in a file that does not contain the definition, we need a forward declaration (which we typically propagate via a header file). This works because declarations are enough to satisfy the compiler when it comes to functions and non-constexpr variables, and the linker can then connect everything up.</p><p>However, using forward declarations in a similar manner doesn’t work for types, because the compiler typically needs to see the full definition to use a given type. We must be able to propagate the full type definition to each code file that needs it.</p><p>To allow for this, types are partially exempt from the one-definition rule: a given type is allowed to be defined in multiple code files.</p><p>You’ve already exercised this capability (likely without realizing it): if your program has two code files that both <code>#include <iostream></iostream></code>, you’re importing all of the input/output type definitions into both files.</p><p>There are two caveats that are worth knowing about. First, you can still only have one type definition per code file (this usually isn’t a problem since header guards will prevent this). Second, all of the type definitions for a given type must be identical, otherwise undefined behavior will result.</p><br><h3>Nomenclature: user-defined types vs program-defined types</h3><p>The term “user-defined type” sometimes comes up in casual conversation, as well as being mentioned (but not defined) in the C++ language standard. In casual conversation, the term tends to mean “a type that you defined yourself” (such as the Fraction type example above). Sometimes this also includes type aliases.</p><p>However, as used in the C++ language standard, a user-defined type is intended to be any type not defined as part of the core C++ language (in other words, a non-fundamental type). Therefore, types defined in the C++ standard library (such as <code>std::string</code>) are technically considered to be user-defined types, as are any types that you’ve defined yourself.</p><p>To provide additional differentiation, the C++20 language standard helpfully defines the term “program-defined type” to mean only types that you’ve defined yourself. We’ll prefer this term when talking about such types, as it is less ambiguous.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Type</th><th>Meaning</th><th>Examples</th></tr><tr><td>Fundamental</td><td>A type built into the core C++ language</td><td>int, std::nullptr_t</td></tr><tr><td>User-defined</td><td>A non-fundamental type<br>(in casual use, typically used to mean program-defined types)</td><td>std::string, Fraction</td></tr><tr><td>Program-defined</td><td>a class type or enumeration type defined yourself</td><td>Fraction</td></tr></tbody></table></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">10.2 — Unscoped enumerations</h1></header><div class="entry-content" itemprop="articleBody"><p>C++ contains many useful fundamental and compound data types (which we introduced in lessons <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-fundamental-data-types/">4.1 -- Introduction to fundamental data types</a> and <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-compound-data-types/">9.1 -- Introduction to compound data types</a>). But these types aren’t always sufficient for the kinds of things we want to do.</p><p>For example, let’s say you’re writing a program that needs to keep track of whether an apple is red, yellow, or green, or what color a shirt is (from a preset list of colors). If only fundamental types were available, how might you do this?</p><p>You might store the color as an integer value, using some kind of implicit mapping (0 = red , 1 = green, 2 = blue):</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int appleColor{ 0 }; // my apple is red</code><code>    int shirtColor{ 1 }; // my shirt is green</code><code></code><code>    return 0;</code><code>}</code></pre><p>But this isn’t at all intuitive, and we’ve already discussed why magic numbers are bad (<a href="https://www.learncpp.com/cpp-tutorial/const-variables-and-symbolic-constants/">4.13 -- Const variables and symbolic constants</a>). We can get rid of the magic numbers by using symbolic constants:</p><pre class="language-cpp line-numbers"><code>constexpr int red{ 0 };</code><code>constexpr int green{ 1 };</code><code>constexpr int blue{ 2 };</code><code></code><code>int main()</code><code>{</code><code>    int appleColor{ red };</code><code>    int shirtColor{ green };</code><code></code><code>    return 0;</code><code>}</code></pre><p>While this is a bit better for reading, the programmer is still left to deduce that <code>appleColor</code> and <code>shirtColor</code> (which are of type <code>int</code>) are meant to hold one of the values defined in the set of color symbolic constants (which are likely defined elsewhere, probably in a separate file).</p><p>We can make this program a little more clear by using a type alias:</p><pre class="language-cpp line-numbers"><code>using Color = int; // define a type alias named Color</code><code></code><code>// The following color values should be used for a Color</code><code>constexpr Color red{ 0 };</code><code>constexpr Color green{ 1 };</code><code>constexpr Color blue{ 2 };</code><code></code><code>int main()</code><code>{</code><code>    Color appleColor{ red };</code><code>    Color shirtColor{ green };</code><code></code><code>    return 0;</code><code>}</code></pre><p>We’re getting closer. Someone reading this code still has to understand that these color symbolic constants are meant to be used with variables of type <code>Color</code>, but at least the type has a unique name now so someone searching for <code>Color</code> would be able to find the set of associated symbolic constants.</p><p>However, because <code>Color</code> is just an alias for an <code>int</code>, we still have the problem that nothing enforces proper usage of these color symbolic constants. We can still do something like this:</p><pre class="language-cpp line-numbers"><code>Color eyeColor{ 8 }; // syntactically valid, semantically meaningless</code></pre><p>Also, if we debug any of these variables in our debugger, we’ll only see the integer value of the color (e.g. <code>0</code>), not the symbolic meaning (<code>red</code>), which can make it harder to tell if our program is correct.</p><p>Fortunately, we can do even better.</p><br><h3>Enumerations</h3><p>An <span class="cpp-definition">enumeration</span> (also called an <span class="cpp-definition">enumerated type</span> or an <span class="cpp-definition">enum</span>) is a compound data type where every possible value is defined as a symbolic constant (called an <span class="cpp-definition">enumerator</span>).</p><p>Because enumerations are program-defined types <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-program-defined-user-defined-types/">10.1 -- Introduction to program-defined (user-defined) types</a>, each enumeration needs to be defined before we can use it to create objects using that enumerated type.</p><p>C++ supports two kinds of enumerations: unscoped enumerations (which we’ll cover now) and scoped enumerations (which we’ll cover later in this chapter).</p><br><h3>Unscoped enumerations</h3><p>Unscoped enumerations are defined via the <code>enum</code> keyword.</p><p>Enumerated types are best taught by example, so let’s define an unscoped enumeration that can hold some color values. We’ll explain how it all works below.</p><pre class="language-cpp line-numbers"><code>// Define a new unscoped enumeration named Color</code><code>enum Color</code><code>{</code><code>    // Here are the enumerators</code><code>    // These symbolic constants define all the possible values this type can hold</code><code>    // Each enumerator is separated by a comma, not a semicolon</code><code>    red,</code><code>    green,</code><code>    blue, // trailing comma optional but recommended</code><code>}; // the enum definition must end with a semicolon</code><code></code><code>int main()</code><code>{</code><code>    // Define a few variables of enumerated type Color</code><code>    Color apple { red };   // my apple is red</code><code>    Color shirt { green }; // my shirt is green</code><code>    Color cup { blue };    // my cup is blue</code><code></code><code>    Color socks { white }; // error: white is not an enumerator of Color</code><code>    Color hat { 2 };       // error: 2 is not an enumerator of Color</code><code></code><code>    return 0;</code><code>}</code></pre><p>We start our example by using the <code>enum</code> keyword to tell the compiler that we are defining an unscoped enumeration, which we’ve named <code>Color</code>.</p><p>Inside a pair of curly braces, we define the enumerators for the <code>Color</code> type: <code>red</code>, <code>green</code>, and <code>blue</code>. These enumerators specify the set of possible values that objects of type <code>Color</code> will be able to hold. Each enumerator must be separated by a comma (not a semicolon) -- a trailing comma after the last enumerator is optional but recommended for consistency.</p><p>The type definition for <code>Color</code> ends with a semicolon. We’ve now fully defined what enumerated type <code>Color</code> is!</p><p>Inside <code>main()</code>, we instantiate three variables of type <code>Color</code>: <code>apple</code> is initialized with the color <code>red</code>, <code>shirt</code> is initialized with the color <code>green</code>, and <code>cup</code> is initialized with the color <code>blue</code>. Memory is allocated for each of these objects. Note that the initializer for an enumerated type must be one of the defined enumerators for that type. The variables <code>socks</code> and <code>hat</code> cause compile errors because the initializers <code>white</code> and <code>2</code> are not enumerators of <code>Color</code>.</p><div class="cpp-note cpp-lightgraybackground"><h4>A reminder</h4><p>To quickly recap on nomenclature:</p><ul><li>An <em>enumeration</em> or <em>enumerated type</em> is the program-defined type itself (e.g. <code>Color</code>)</li><li>An <em>enumerator</em> is a symbolic constant that is a possible value for a given enumeration (e.g. <code>red</code>)</li></ul></div><br><h3>Naming enumerations and enumerators</h3><p>By convention, the names of enumerated types start with a capital letter (as do all program-defined types).</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Enumerations don’t have to be named, but unnamed enumerations should be avoided in modern C++.</p></div><p>Enumerators must be given names. Unfortunately, there is no common naming convention for enumerator names. Common choices include starting with lower case (e.g. red), starting with caps (Red), all caps (RED), all caps with a prefix (COLOR_RED), or prefixed with a “k” and intercapped (kColorRed).</p><p>Modern C++ guidelines typically recommend avoiding the all caps naming conventions, as all caps is typically used for preprocessor macros and may conflict. We recommend also avoiding the conventions starting with a capital letter, as names beginning with a capital letter are typically reserved for program-defined types.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Name your enumerated types starting with a capital letter. Name your enumerators starting with a lower case letter.</p></div><br><h3>Enumerated types are distinct types</h3><p>Each enumerated type you create is considered to be a <span class="cpp-definition">distinct type</span>, meaning the compiler can distinguish it from other types (unlike typedefs or type aliases, which are considered non-distinct from the types they are aliasing).</p><p>Because enumerated types are distinct, enumerators defined as part of one enumerated type can’t be used with objects of another enumerated type:</p><pre class="language-cpp line-numbers"><code>enum Pet</code><code>{</code><code>    cat,</code><code>    dog,</code><code>    pig,</code><code>    whale,</code><code>};</code><code></code><code>enum Color</code><code>{</code><code>    black,</code><code>    red,</code><code>    blue,</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Pet myPet { black }; // compile error: black is not an enumerator of Pet</code><code>    Color shirt { pig }; // compile error: pig is not an enumerator of Color</code><code></code><code>    return 0;</code><code>}</code></pre><p>You probably didn’t want a pig shirt anyway.</p><br><h3>Putting enumerations to use</h3><p>Because enumerators are descriptive, they are useful for enhancing code documentation and readability. Enumerated types are best used when you have a smallish set of related constants, and objects only need to hold one of those values at a time.</p><p>Commonly defined enumerations include days of the week, the cardinal directions, and the suits in a deck of cards:</p><pre class="language-cpp line-numbers"><code>enum DaysOfWeek</code><code>{</code><code>    sunday,</code><code>    monday,</code><code>    tuesday,</code><code>    wednesday,</code><code>    thursday,</code><code>    friday,</code><code>    saturday,</code><code>};</code><code></code><code>enum CardinalDirections</code><code>{</code><code>    north,</code><code>    east,</code><code>    south,</code><code>    west,</code><code>};</code><code></code><code>enum CardSuits</code><code>{</code><code>    clubs,</code><code>    diamonds,</code><code>    hearts,</code><code>    spades,</code><code>};</code></pre><p>Sometimes functions will return a status code to the caller to indicate whether the function executed successfully or encountered an error. Traditionally, small negative numbers were used to represent different possible error codes. For example:</p><pre class="language-cpp line-numbers"><code>int readFileContents()</code><code>{</code><code>    if (!openFile())</code><code>        return -1;</code><code>    if (!readFile())</code><code>        return -2;</code><code>    if (!parseFile())</code><code>        return -3;</code><code></code><code>    return 0; // success</code><code>}</code></pre><p>However, using magic numbers like this isn’t very descriptive. A better method would be to use an enumerated type:</p><pre class="language-cpp line-numbers"><code>enum FileReadResult</code><code>{</code><code>    readResultSuccess,</code><code>    readResultErrorFileOpen,</code><code>    readResultErrorFileRead,</code><code>    readResultErrorFileParse,</code><code>};</code><code></code><code>FileReadResult readFileContents()</code><code>{</code><code>    if (!openFile())</code><code>        return readResultErrorFileOpen;</code><code>    if (!readFile())</code><code>        return readResultErrorFileRead;</code><code>    if (!parseFile())</code><code>        return readResultErrorFileParse;</code><code></code><code>    return readResultSuccess;</code><code>}</code></pre><p>Then the caller can test the function’s return value against the appropriate enumerator, which is easier to understand than testing the return result for a specific integer value.</p><pre class="language-cpp line-numbers"><code>if (readFileContents() == readResultSuccess)</code><code>{</code><code>    // do something</code><code>}</code><code>else</code><code>{</code><code>    // print error message</code><code>}</code></pre><p>Enumerated types can also be put to good use in games, to identify different types of items, or monsters, or terrain types. Basically, anything that is a small set of related objects.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>enum ItemType</code><code>{</code><code>	sword,</code><code>	torch,</code><code>	potion,</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	ItemType holding{ torch };</code><code></code><code>	return 0;</code><code>}</code></pre><p>Enumerated types can also make for useful function parameters when the user needs to make a choice between two or more options:</p><pre class="language-cpp line-numbers"><code>enum SortOrder</code><code>{</code><code>    alphabetical,</code><code>    alphabeticalReverse,</code><code>    numerical,</code><code>};</code><code></code><code>void sortData(SortOrder order)</code><code>{</code><code>    if (order == alphabetical)</code><code>        // sort data in forwards alphabetical order</code><code>    else if (order == alphabeticalReverse)</code><code>        // sort data in backwards alphabetical order</code><code>    else if (order == numerical)</code><code>        // sort data numerically</code><code>}</code></pre><p>Many languages use enumerations to define Booleans -- after all, a Boolean is essentially just an enumeration with 2 enumerators: <code>false</code> and <code>true</code>! However, in C++, <code>true</code> and <code>false</code> are defined as keywords instead of enumerators.</p><br><h3>The scope of unscoped enumerations</h3><p>Unscoped enumerations are named such because they put their enumerator names into the same scope as the enumeration definition itself (as opposed to creating a new scope region like a namespace does).</p><p>For example, given this program:</p><pre class="language-cpp line-numbers"><code>enum Color // this enum is defined in the global namespace</code><code>{</code><code>    red, // so red is put into the global namespace</code><code>    green,</code><code>    blue, </code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Color apple { red }; // my apple is red</code><code></code><code>    return 0;</code><code>}</code></pre><p>The <code>Color</code> enumeration is defined in the global scope. Therefore, all the enumeration names (<code>red</code>, <code>green</code>, and <code>blue</code>) also go into the global scope. This pollutes the global scope and significantly raises the chance of naming collisions.</p><p>One consequence of this is that an enumerator name can’t be used in multiple enumerations within the same scope:</p><pre class="language-cpp line-numbers"><code>enum Color</code><code>{</code><code>    red,</code><code>    green,</code><code>    blue, // blue is put into the global namespace</code><code>};</code><code></code><code>enum Feeling</code><code>{</code><code>    happy,</code><code>    tired,</code><code>    blue, // error: naming collision with the above blue</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Color apple { red }; // my apple is red</code><code>    Feeling me { happy }; // I'm happy right now (even though my program doesn't compile)</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, both unscoped enumerations (<code>Color</code> and <code>Feeling</code>) put enumerators with the same name <code>blue</code> into the global scope. This leads to a naming collision and subsequent compile error.</p><p>Unscoped enumerations also provide a named scope region for their enumerators (much like a namespace acts as a named scope region for the names declared within). This means we can access the enumerators of an unscoped enumeration as follows:</p><pre class="language-cpp line-numbers"><code>enum Color</code><code>{</code><code>    red,</code><code>    green,</code><code>    blue, // blue is put into the global namespace</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Color apple { red }; // okay, accessing enumerator from global namespace</code><code>    Color raspberry { Color::red }; // also okay, accessing enumerator from scope of Color</code><code></code><code>    return 0;</code><code>}</code></pre><p>Most often, unscoped enumerators are accessed without using the scope resolution operator.</p><br><h3>Avoiding enumerator naming collisions</h3><p>There are quite a few common ways to prevent unscoped enumerator naming collisions. One option is to prefix each enumerator with the name of the enumeration itself:</p><pre class="language-cpp line-numbers"><code>enum Color</code><code>{</code><code>    color_red,</code><code>    color_blue,</code><code>    color_green,</code><code>};</code><code></code><code>enum Feeling</code><code>{</code><code>    feeling_happy,</code><code>    feeling_tired,</code><code>    feeling_blue, // no longer has a naming collision with color_blue</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Color paint { color_blue };</code><code>    Feeling me { feeling_blue };</code><code></code><code>    return 0;</code><code>}</code></pre><p>This still pollutes the namespace but reduces the chance for naming collisions by making the names longer and more unique.</p><p>A better option is to put the enumerated type inside something that provides a separate scope region, such as a namespace:</p><pre class="language-cpp line-numbers"><code>namespace color</code><code>{</code><code>    // The names Color, red, blue, and green are defined inside namespace color</code><code>    enum Color</code><code>    {</code><code>        red,</code><code>        green,</code><code>        blue,</code><code>    };</code><code>}</code><code></code><code>namespace feeling</code><code>{</code><code>    enum Feeling</code><code>    {</code><code>        happy,</code><code>        tired,</code><code>        blue, // feeling::blue doesn't collide with color::blue</code><code>    };</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    color::Color paint { color::blue };</code><code>    feeling::Feeling me { feeling::blue };</code><code></code><code>    return 0;</code><code>}</code></pre><p>This means we now have to prefix our enumeration and enumerator names with the name of the scoped region.</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>Classes also provide a scope region, and it’s common to put enumerated types related to a class inside the scope region of the class. We discuss this in lesson <a href="https://www.learncpp.com/cpp-tutorial/nested-types-in-classes/">13.17 -- Nested types in classes</a>.</p></div><p>A related option is to use a scoped enumeration (which defines its own scope region). We’ll discuss scoped enumerations shortly (<a href="https://www.learncpp.com/cpp-tutorial/scoped-enumerations-enum-classes/">10.4 -- Scoped enumerations (enum classes)</a>).</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Prefer putting your enumerations inside a named scope region (such as a namespace or class) so the enumerators don’t pollute the global namespace.</p></div><br><h3>Comparing against enumerators</h3><p>We can use the equality operators (<code>operator==</code> and <code>operator!=</code>) to test whether an enumeration has the value of a particular enumerator or not.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>enum Color</code><code>{</code><code>    red,</code><code>    green,</code><code>    blue,</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Color shirt{ blue };</code><code></code><code>    if (shirt == blue) // if the shirt is blue</code><code>        std::cout &lt;&lt; "Your shirt is blue!";</code><code>    else</code><code>        std::cout &lt;&lt; "Your shirt is not blue!";</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, we use an if-statement to test whether <code>shirt</code> is equal to the enumerator <code>blue</code>. This gives us a way to conditionalize our program’s behavior based on what enumerator our enumeration is holding.</p><p>We’ll make more use of this in the next lesson.</p><br><h3>Quiz time</h3><p class="cpp-quiz-question" style="clear:both">Question #1</p><p>Define an enumerated type named MonsterType to choose between the following monster races: orcs, goblins, trolls, ogres, and skeletons.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>enum MonsterType</code><code>{</code><code>    orc,</code><code>    goblin,</code><code>    troll,</code><code>    ogre,</code><code>    skeleton,</code><code>};</code></pre></div><p class="cpp-quiz-question cpp-topline" style="clear:both">Question #2</p><p>Put the MonsterType enumeration inside a namespace. Then, create a main() function and instantiate a troll. The program should compile.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>namespace monster</code><code>{</code><code>    enum MonsterType</code><code>    {</code><code>        orc,</code><code>        goblin,</code><code>        troll,</code><code>        ogre,</code><code>        skeleton,</code><code>    };</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    monster::MonsterType monster{ monster::troll };</code><code></code><code>    return 0;</code><code>}</code></pre></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">10.3 — Unscoped enumeration input and output</h1></header><div class="entry-content" itemprop="articleBody"><p>In the prior lesson (<a href="https://www.learncpp.com/cpp-tutorial/unscoped-enumerations/">10.2 -- Unscoped enumerations</a>), we mentioned that enumerators are symbolic constants. What we didn’t tell you then is that enumerators are <em>integral</em> symbolic constants. As a result, enumerated types actually hold an integral value.</p><p>This is similar to the case with chars (<a href="https://www.learncpp.com/cpp-tutorial/chars/">4.11 -- Chars</a>). Consider:</p><pre class="language-cpp line-numbers"><code>char ch { 'A' };</code></pre><p>A char is really just a 1-byte integral value, and the character <code>'A'</code> gets converted to an integral value (in this case, <code>65</code>) and stored.</p><p>When we define an enumerator, each enumerator is automatically assigned an integer value based on its position in the enumerator list. By default, the first enumerator is assigned the integral value <code>0</code>, and each subsequent enumerator has a value one greater than the previous enumerator:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>enum Color</code><code>{</code><code>    black, // assigned 0</code><code>    red, // assigned 1</code><code>    blue, // assigned 2</code><code>    green, // assigned 3</code><code>    white, // assigned 4</code><code>    cyan, // assigned 5</code><code>    yellow, // assigned 6</code><code>    magenta, // assigned 7</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Color shirt{ blue }; // This actually stores the integral value 2</code><code></code><code>    return 0;</code><code>}</code></pre><p>It is possible to explicitly define the value of enumerators. These integral values can be positive or negative, and can share the same value as other enumerators. Any non-defined enumerators are given a value one greater than the previous enumerator.</p><pre class="language-cpp line-numbers"><code>enum Animal</code><code>{</code><code>    cat = -3,</code><code>    dog,         // assigned -2</code><code>    pig,         // assigned -1</code><code>    horse = 5,</code><code>    giraffe = 5, // shares same value as horse</code><code>    chicken,      // assigned 6 </code><code>};</code></pre><p>Note in this case, <code>horse</code> and <code>giraffe</code> have been given the same value. When this happens, the enumerators become non-distinct -- essentially, <code>horse</code> and <code>giraffe</code> are interchangeable. Although C++ allows it, assigning the same value to two enumerators in the same enumeration should generally be avoided.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Avoid assigning explicit values to your enumerators unless you have a compelling reason to do so.</p></div><br><h3>Unscoped enumerations will implicitly convert to integral values</h3><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>enum Color</code><code>{</code><code>    black, // assigned 0</code><code>    red, // assigned 1</code><code>    blue, // assigned 2</code><code>    green, // assigned 3</code><code>    white, // assigned 4</code><code>    cyan, // assigned 5</code><code>    yellow, // assigned 6</code><code>    magenta, // assigned 7</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Color shirt{ blue };</code><code></code><code>    std::cout &lt;&lt; "Your shirt is " &lt;&lt; shirt; // what does this do?</code><code></code><code>    return 0;</code><code>}</code></pre><p>Since enumerated types hold integral values, as you might expect, this prints:</p><pre>Your shirt is 2
</pre><p>When an enumerated type is used in a function call or with an operator, the compiler will first try to find a function or operator that matches the enumerated type. For example, when the compiler tries to compile <code>std::cout &lt;&lt; shirt</code>, the compiler will first look to see if <code>operator&lt;&lt;</code> knows how to print an object of type <code>Color</code> (because <code>shirt</code> is of type <code>Color</code>) to <code>std::cout</code>. It doesn’t.</p><p>If the compiler can’t find a match, the compiler will then implicitly convert an unscoped enumeration or enumerator to its corresponding integer value. Because <code>std::cout</code> does know how to print an integral value, the value in <code>shirt</code> gets converted to an integer and printed as integer value <code>2</code>.</p><br><h3>Printing enumerator names</h3><p>Most of the time, printing an enumeration as an integral value (such as <code>2</code>) isn’t what we want. Instead, we typically will want to print the name of whatever the enumerator represents (<code>blue</code>). But to do that, we need some way to convert the integral value of the enumeration (<code>2</code>) into a string matching the enumerator name (<code>"blue"</code>).</p><p>As of C++20, C++ doesn’t come with any easy way to do this, so we’ll have to find a solution ourselves. Fortunately, that’s not very difficult. The typical way to do this is to write a function that takes an enumerated type as a parameter and then outputs the corresponding string (or returns the string to the caller).</p><p>The typical way to do this is to test our enumeration against every possible enumerator:</p><pre class="language-cpp line-numbers"><code>// Using if-else for this is inefficient</code><code>void printColor(Color color)</code><code>{</code><code>    if (color == black) std::cout &lt;&lt; "black";</code><code>    else if (color == red) std::cout &lt;&lt; "red";</code><code>    else if (color == blue) std::cout &lt;&lt; "blue";</code><code>    else std::cout &lt;&lt; "???";</code><code>}</code></pre><p>However, using a series of if-else statements for this is inefficient, as it requires multiple comparisons before a match is found. A more efficient way to do the same thing is to use a switch statement. In the following example, we will also return our <code>Color</code> as a <code>std::string</code>, to give the caller more flexibility to do whatever they want with the name (including print it):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>enum Color</code><code>{</code><code>    black,</code><code>    red,</code><code>    blue,</code><code>};</code><code></code><code></code><code>// We'll show a better version of this for C++17 below</code><code>std::string getColor(Color color)</code><code>{</code><code>    switch (color)</code><code>    {</code><code>    case black: return "black";</code><code>    case red:   return "red";</code><code>    case blue:  return "blue";</code><code>    default:    return "???";</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Color shirt { blue };</code><code></code><code>    std::cout &lt;&lt; "Your shirt is " &lt;&lt; getColor(shirt) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>Your shirt is blue
</pre><p>This likely performs better than the if-else chain (switch statements tend to be more efficient than if-else chains), and it’s easier to read too. However, this version is still inefficient, because we need to create and return a <code>std::string</code> (which is expensive) every time the function is called.</p><p>In C++17, a more efficient option is to replace <code>std::string</code> with <code>std::string_view</code>. <code>std::string_view</code> allows us to return string literals in a way that is much less expensive to copy.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view> // C++17</string_view></code><code></code><code>enum Color</code><code>{</code><code>    black,</code><code>    red,</code><code>    blue,</code><code>};</code><code></code><code>constexpr std::string_view getColor(Color color) // C++17</code><code>{</code><code>    switch (color)</code><code>    {</code><code>    case black: return "black";</code><code>    case red:   return "red";</code><code>    case blue:  return "blue";</code><code>    default:    return "???";</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Color shirt{ blue };</code><code></code><code>    std::cout &lt;&lt; "Your shirt is " &lt;&lt; getColor(shirt) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>Constexpr return types are covered in in lesson <a href="https://www.learncpp.com/cpp-tutorial/constexpr-and-consteval-functions/">6.14 -- Constexpr and consteval functions</a>.</p></div><br><h3>Teaching operator&lt;&lt; how to print an enumerator</h3><p>Although the above example functions well, we still have to remember the name of the function we created to get the enumerator name. While this usually isn’t too burdensome, it can become more problematic if you have lots of enumerations. Using operator overloading (a capability similar to function overloading), we can actually teach <code>operator&lt;&lt;</code> how to print the value of a program-defined enumeration! We haven’t explained how this works yet, so consider it a bit of magic for now:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>enum Color</code><code>{</code><code>	black,</code><code>	red,</code><code>	blue,</code><code>};</code><code></code><code>// Teach operator&lt;&lt; how to print a Color</code><code>// Consider this magic for now since we haven't explained any of the concepts it uses yet</code><code>// std::ostream is the type of std::cout</code><code>// The return type and parameter type are references (to prevent copies from being made)!</code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, Color color)</code><code>{</code><code>	switch (color)</code><code>	{</code><code>	case black: out &lt;&lt; "black";  break;</code><code>	case red:   out &lt;&lt; "red";    break;</code><code>	case blue:  out &lt;&lt; "blue";   break;</code><code>	default:    out &lt;&lt; "???";    break;</code><code>	}</code><code>	</code><code>	return out;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Color shirt{ blue };</code><code>	std::cout &lt;&lt; "Your shirt is " &lt;&lt; shirt; // it works!</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>Your shirt is blue
</pre><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>For the curious, here’s what the above code is actually doing. When we try to print <code>shirt</code> using <code>std::cout</code> and <code>operator&lt;&lt;</code>, the compiler will see that we’ve overloaded <code>operator&lt;&lt;</code> to work with objects of type <code>Color</code>. This overloaded <code>operator&lt;&lt;</code> function is then called with <code>std::cout</code> as the <code>out</code> parameter, and our <code>shirt</code> as parameter <code>color</code>. Since <code>out</code> is a reference to <code>std::cout</code>, a statement such as <code>out &lt;&lt; "blue"</code> is really just printing <code>"blue"</code> to <code>std::cout</code>.</p></div><p>We cover overloading the I/O operators in lesson <a href="https://www.learncpp.com/cpp-tutorial/overloading-the-io-operators/">14.4 -- Overloading the I/O operators</a>. For now, you can copy this code and replace <code>Color</code> with your own enumerated type.</p><br><h3>Enumeration size and base </h3><p>Enumerated types are considered part of the integer family of types, and it’s up to the compiler to determine how much memory to allocate for an enum variable. The C++ standard says the enum size needs to be large enough to represent all of the enumerator values. Most often, it will make enum variables the same size as a standard <code>int</code>.</p><p>However, it is possible to specify a different underlying type. For example, if you are working in some bandwidth-sensitive context (e.g. sending data over a network) you may want to specify a smaller type:</p><pre class="language-cpp line-numbers"><code>// Use an 8-bit unsigned integer as the enum base</code><code>enum Color : std::uint8_t</code><code>{</code><code>    black,</code><code>    red,</code><code>    blue,</code><code>};</code></pre><p>Since enumerators aren’t usually used for arithmetic or comparisons with integers, it’s generally safe to use an unsigned integer if desired.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Specify the base type of an enumeration only when necessary.</p></div><br><h3>Integer to unscoped enumerator conversion</h3><p>While the compiler will implicitly convert unscoped enumerators to an integer, it will <em>not</em> implicitly convert an integer to an unscoped enumerator. The following will produce a compiler error:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>enum Pet</code><code>{</code><code>    cat, // assigned 0</code><code>    dog, // assigned 1</code><code>    pig, // assigned 2</code><code>    whale, // assigned 3</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Pet pet { 2 }; // compile error: integer value 2 won't implicitly convert to a Pet</code><code>    pet = 3;       // compile error: integer value 3 won't implicitly convert to a Pet</code><code></code><code>    return 0;</code><code>}</code></pre><p>There are two ways to work around this.</p><p>First, you can force the compiler to convert an integer to an unscoped enumerator using <code>static_cast</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>enum Pet</code><code>{</code><code>    cat, // assigned 0</code><code>    dog, // assigned 1</code><code>    pig, // assigned 2</code><code>    whale, // assigned 3</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Pet pet { static_cast<pet>(2) }; // convert integer 2 to a Pet</pet></code><code>    pet = static_cast<pet>(3);       // our pig evolved into a whale!</pet></code><code></code><code>    return 0;</code><code>}</code></pre><p>We’ll see an example in a moment where this can be useful.</p><p>Second, in C++17, if an unscoped enumeration has a specified base, then the compiler will allow you to initialize (but not assign) an unscoped enumeration using an integral value:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>enum Pet: int // we've specified a base</code><code>{</code><code>    cat, // assigned 0</code><code>    dog, // assigned 1</code><code>    pig, // assigned 2</code><code>    whale, // assigned 3</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Pet pet { 2 }; // ok: can initialize with integer</code><code>    pet = 3;       // compile error: can not assign with integer</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>Unscoped enumerator input</h3><p>Because <code>Pet</code> is a program-defined type, the language doesn’t know how to input a Pet using <code>std::cin</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>enum Pet</code><code>{</code><code>    cat, // assigned 0</code><code>    dog, // assigned 1</code><code>    pig, // assigned 2</code><code>    whale, // assigned 3</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Pet pet { pig };</code><code>    std::cin &gt;&gt; pet; // compile error, std::cin doesn't know how to input a Pet</code><code></code><code>    return 0;</code><code>}</code></pre><p>To work around this, we can read in an integer, and use <code>static_cast</code> to convert the integer to an enumerator of the appropriate enumerated type:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>enum Pet</code><code>{</code><code>    cat, // assigned 0</code><code>    dog, // assigned 1</code><code>    pig, // assigned 2</code><code>    whale, // assigned 3</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a pet (0=cat, 1=dog, 2=pig, 3=whale): ";</code><code></code><code>    int input{};</code><code>    std::cin &gt;&gt; input; // input an integer</code><code></code><code>    Pet pet{ static_cast<pet>(input) }; // static_cast our integer to a Pet</pet></code><code></code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>Similar to how we were able to teach <code>operator&lt;&lt;</code> to output an enum type above, we can also teach <code>operator&gt;&gt;</code> how to input an enum type:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>enum Pet</code><code>{</code><code>    cat, // assigned 0</code><code>    dog, // assigned 1</code><code>    pig, // assigned 2</code><code>    whale, // assigned 3</code><code>};</code><code></code><code>// Consider this magic for now</code><code>// We pass pet by reference so we can have the function modify its value</code><code>std::istream&amp; operator&gt;&gt; (std::istream&amp; in, Pet &amp;pet)</code><code>{</code><code>    int input{};</code><code>    in &gt;&gt; input; // input an integer</code><code></code><code>    pet = static_cast<pet>(input);</pet></code><code>    return in;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a pet (0=cat, 1=dog, 2=pig, 3=whale): ";</code><code></code><code>    Pet pet{};</code><code>    std::cin &gt;&gt; pet; // input our pet using std::cin</code><code></code><code>    std::cout &lt;&lt; pet &lt;&lt; '\n'; // prove that it worked</code><code></code><code>    return 0;</code><code>}</code></pre><p>Again, consider this a bit of magic for now (since we haven’t explained the concepts behind it yet), but you might find it handy.</p></div><br><h3>Quiz time</h3><p class="cpp-quiz-question" style="clear:both">Question #1</p><p>True or false. Enumerators can be:</p><ul><li>Given an integer value</li></ul><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>True</p></div><ul><li>Given no explicit value</li></ul><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>True. Enumerators not explicitly assigned a value will be implicitly assigned the integer value of the previous enumerator + 1. If there is no previous enumerator, the enumerator will assume value 0.</p></div><ul><li>Given a floating point value</li></ul><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>False</p></div><ul><li>Given a negative value</li></ul><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><p>True</p></div><ul><li>Given a non-unique value</li></ul><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><p>True</p></div><ul><li>Initialized with the value of prior enumerators (e.g. magenta = red)</li></ul><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><p>True. Since enumerators evaluate to integers, and integers can be assigned to enumerators, enumerators can be initialized with other enumerators (though there is typically little reason to do so!).</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">10.4 — Scoped enumerations (enum classes)</h1></header><div class="entry-content" itemprop="articleBody"><p>Although unscoped enumerations are distinct types in C++, they are not type safe, and in some cases will allow you to do things that don’t make sense. Consider the following case:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    enum Color</code><code>    {</code><code>        red,</code><code>        blue,</code><code>    };</code><code></code><code>    enum Fruit</code><code>    {</code><code>        banana,</code><code>        apple,</code><code>    };</code><code>	</code><code>    Color color { red };</code><code>    Fruit fruit { banana };</code><code></code><code>    if (color == fruit) // The compiler will compare color and fruit as integers</code><code>        std::cout &lt;&lt; "color and fruit are equal\n"; // and find they are equal!</code><code>    else</code><code>        std::cout &lt;&lt; "color and fruit are not equal\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>color and fruit are equal
</pre><p>When <code>color</code> and <code>fruit</code> are compared, the compiler will look to see if it knows how to compare a <code>Color</code> and a <code>Fruit</code>. It doesn’t. Next, it will try converting <code>Color</code> and/or <code>Fruit</code> to integers to see if it can find a match. Eventually the compiler will determine that if it converts both to integers, it can do the comparison. Since <code>color</code> and <code>fruit</code> are both set to enumerators that convert to integer value <code>0</code>, <code>color</code> will equal <code>fruit</code>.</p><p>This doesn’t make sense semantically since <code>color</code> and <code>fruit</code> are from different enumerations and are not intended to be comparable. With standard enumerators, there’s no easy way to prevent this.</p><p>Because of such challenges, as well as the namespace pollution problem (unscoped enumerations defined in the global scope put their enumerators in the global namespace), the C++ designers determined that a cleaner solution for enumerations would be of use.</p><br><h3>Scoped enumerations</h3><p>That solution is the <span class="cpp-definition">scoped enumeration</span> (often called an <span class="cpp-definition">enum class</span> in C++ for reasons that will become obvious shortly).</p><p>Scoped enumerations work similarly to unscoped enumerations (<a href="https://www.learncpp.com/cpp-tutorial/unscoped-enumerations/">10.2 -- Unscoped enumerations</a>), but have two primary differences: They are strongly typed (they won’t implicitly convert to integers) and strongly scoped (the enumerators are <em>only</em> placed into the scope region of the enumeration).</p><p>To make a scoped enumeration, we use the keywords <code>enum class</code>. The rest of the scoped enumeration definition is the same as an unscoped enumeration definition. Here’s an example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>int main()</code><code>{</code><code>    enum class Color // "enum class" defines this as a scoped enumeration rather than an unscoped enumeration</code><code>    {</code><code>        red, // red is considered part of Color's scope region</code><code>        blue,</code><code>    };</code><code></code><code>    enum class Fruit</code><code>    {</code><code>        banana, // banana is considered part of Fruit's scope region</code><code>        apple,</code><code>    };</code><code></code><code>    Color color { Color::red }; // note: red is not directly accessible, we have to use Color::red</code><code>    Fruit fruit { Fruit::banana }; // note: banana is not directly accessible, we have to use Fruit::banana</code><code>	</code><code>    if (color == fruit) // compile error: the compiler doesn't know how to compare different types Color and Fruit</code><code>        std::cout &lt;&lt; "color and fruit are equal\n";</code><code>    else</code><code>        std::cout &lt;&lt; "color and fruit are not equal\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program produces a compile error on line 19, since the scoped enumeration won’t convert to any type that can be compared with another type.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>The <code>class</code> keyword (along with the <code>static</code> keyword), is one of the most overloaded keywords in the C++ language, and can have different meanings depending on context. Although scoped enumerations use the <code>class</code> keyword, they aren’t considered to be a “class type” (which is reserved for structs, classes, and unions).</p></div><br><h3>Scoped enumerations define their own scope regions</h3><p>Unlike unscoped enumerations, which place their enumerators in the same scope as the enumeration itself, scoped enumerations place their enumerators <em>only</em> in the scope region of the enumeration. In other words, scoped enumerations act like a namespace for their enumerators. This built-in namespacing helps reduce global namespace pollution and the potential for name conflicts when scoped enumerations are used in the global scope.</p><p>To access a scoped enumerator, we do so just as if it was in a namespace having the same name as the scoped enumeration:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    enum class Color // "enum class" defines this as a scoped enum rather than an unscoped enum</code><code>    {</code><code>        red, // red is considered part of Color's scope region</code><code>        blue,</code><code>    };</code><code></code><code>    std::cout &lt;&lt; red &lt;&lt; '\n';        // compile error: red not defined in this scope region</code><code>    std::cout &lt;&lt; Color::red &lt;&lt; '\n'; // compile error: std::cout doesn't know how to print this (will not implicitly convert to int)</code><code></code><code>    Color color { Color::blue }; // okay</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because scoped enumerations offer their own implicit namespacing for enumerators, there’s no need to put scoped enumerations inside another scope region (such as a namespace), unless there’s some other compelling reason to do so, as it would be redundant.</p><br><h3>Scoped enumerations don’t implicitly convert to integers</h3><p>Unlike non-scoped enumerators, scoped enumerators won’t implicitly convert to integers. In most cases, this is a good thing because it rarely makes sense to do so, and it helps prevent semantic errors, such as comparing enumerators from different enumerations, or expressions such as <code>red + 5</code>.</p><p>Note that you can still compare enumerators from within the same scoped enumeration (since they are of the same type):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>int main()</code><code>{</code><code>    enum class Color</code><code>    {</code><code>        red,</code><code>        blue,</code><code>    };</code><code></code><code>    Color shirt { Color::red };</code><code></code><code>    if (shirt == Color::red) // this Color to Color comparison is okay</code><code>        std::cout &lt;&lt; "The shirt is red!\n";</code><code>    else if (shirt == Color::blue)</code><code>        std::cout &lt;&lt; "The shirt is blue!\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>There are occasionally cases where it is useful to be able to treat a scoped enumerator as an integer. In these cases, you can explicitly convert a scoped enumeration to an integer by using a <code>static_cast</code> to int:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>int main()</code><code>{</code><code>    enum class Color</code><code>    {</code><code>        red,</code><code>        blue,</code><code>    };</code><code></code><code>    Color color { Color::blue };</code><code></code><code>    std::cout &lt;&lt; color &lt;&lt; '\n'; // won't work, because there's no implicit conversion to int</code><code>    std::cout &lt;&lt; static_cast<int>(color) &lt;&lt; '\n'; // will print 1</int></code><code></code><code>    return 0;</code><code>}</code></pre><p>Conversely, you can also <code>static_cast</code> an integer to a scoped enumerator, which can be useful when doing input from users:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>enum class Pet</code><code>{</code><code>    cat, // assigned 0</code><code>    dog, // assigned 1</code><code>    pig, // assigned 2</code><code>    whale, // assigned 3</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a pet (0=cat, 1=dog, 2=pig, 3=whale): ";</code><code></code><code>    int input{};</code><code>    std::cin &gt;&gt; input; // input an integer</code><code></code><code>    Pet pet{ static_cast<pet>(input) }; // static_cast our integer to a Pet</pet></code><code></code><code>    return 0;</code><code>}</code></pre><p>As of C++17, you can initialize a scoped enumeration using an integral value without the static_cast (and unlike an unscoped enumeration, you don’t need to specify a base).</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Favor scoped enumerations over unscoped enumerations unless there’s a compelling reason to do otherwise.</p></div><p>Despite the benefits that scoped enumerations offer, unscoped enumerations are still commonly used in C++ because there are situations where we desire the implicit conversion to int (doing lots of static_casting get annoying) and we don’t need the extra namespacing.</p><br><h3>Easing the conversion of scoped enumerators to integers (advanced) </h3><p>Scoped enumerations are great, but the lack of implicit conversion to integers can sometimes be a pain point. If we need to convert a scoped enumeration to integers often (e.g. cases where we want to use scoped enumerators as array indices), having to use static_cast every time we want a conversion can clutter our code significantly.</p><p>If you find yourself in the situation where it would be useful to make conversion of scoped enumerators to integers easier, a useful hack is to overload the unary <code>operator+</code> to perform this conversion. We haven’t explained how this works yet, so consider it magic for now:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>enum class Animals</code><code>{</code><code>    chicken, // 0</code><code>    dog, // 1</code><code>    cat, // 2</code><code>    elephant, // 3</code><code>    duck, // 4</code><code>    snake, // 5</code><code></code><code>    maxAnimals,</code><code>};</code><code></code><code>// Overload the unary + operator to convert Animals to the underlying type</code><code>// adapted from https://stackoverflow.com/a/42198760, thanks to Pixelchemist for the idea</code><code>constexpr auto operator+(Animals a) noexcept</code><code>{</code><code>    return static_cast<std::underlying_type_t<animals>&gt;(a);</std::underlying_type_t<animals></code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; +Animals::elephant &lt;&lt; '\n'; // convert Animals::elephant to an integer using unary operator+</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>3
</pre><p>This method prevents unintended implicit conversions to an integral type, but provides a convenient way to explicitly request such conversions as needed.</p><br><h3>using enum statements C++20</h3><p>Introduced in C++20, a <code>using enum</code> statement imports all of the enumerators from an enum into the current scope. When used with an enum class type, this allows us to access the enum class enumerators without having to prefix each with the name of the enum class.</p><p>This can be useful in cases where we would otherwise have many identical, repeated prefixes, such as within a switch statement:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>enum class Color</code><code>{</code><code>    black,</code><code>    red,</code><code>    blue,</code><code>};</code><code></code><code>constexpr std::string_view getColor(Color color)</code><code>{</code><code>    using enum Color; // bring all Color enumerators into current scope (C++20)</code><code>    // We can now access the enumerators of Color without using a Color:: prefix</code><code></code><code>    switch (color)</code><code>    {</code><code>    case black: return "black"; // note: black instead of Color::black</code><code>    case red:   return "red";</code><code>    case blue:  return "blue";</code><code>    default:    return "???";</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Color shirt{ Color::blue };</code><code></code><code>    std::cout &lt;&lt; "Your shirt is " &lt;&lt; getColor(shirt) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, <code>Color</code> is an enum class, so we normally would access the enumerators using a fully qualified name (e.g. <code>Color::blue</code>). However, within function <code>getColor()</code>, we’ve added the statement <code>using enum Color;</code>, which allows us to access those enumerators without the <code>Color::</code> prefix.</p><p>This saves us from having multiple, redundant, obvious prefixes inside the switch statement.</p><br><h3>Quiz time</h3><p class="cpp-quiz-question" style="clear:both">Question #1</p><p>Define an enum class named Animal that contains the following animals: pig, chicken, goat, cat, dog, duck. Write a function named getAnimalName() that takes an Animal parameter and uses a switch statement to return the name for that animal as a std::string_view (or std::string if you’re using C++14). Write another function named printNumberOfLegs() that uses a switch statement to print the number of legs each animal walks on. Make sure both functions have a default case that prints an error message. Call printNumberOfLegs() from main() with a cat and a chicken. Your output should look like this:</p><pre>A cat has 4 legs.
A chicken has 2 legs.
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view> // C++17</string_view></code><code>//#include <string> // for C++14</string></code><code></code><code>enum class Animal</code><code>{</code><code>    pig,</code><code>    chicken,</code><code>    goat,</code><code>    cat,</code><code>    dog,</code><code>    duck,</code><code>};</code><code></code><code>constexpr std::string_view getAnimalName(Animal animal) // C++17</code><code>// const std::string getAnimalName(Animal animal) // C++14</code><code>{</code><code>    switch (animal)</code><code>    {</code><code>        case Animal::chicken:</code><code>            return "chicken";</code><code>        case Animal::duck:</code><code>            return "duck";</code><code>        case Animal::pig:</code><code>            return "pig";</code><code>        case Animal::goat:</code><code>            return "goat";</code><code>        case Animal::cat:</code><code>            return "cat";</code><code>        case Animal::dog:</code><code>            return "dog";</code><code></code><code>        default:</code><code>            return "???";</code><code>    }</code><code>}</code><code></code><code>void printNumberOfLegs(Animal animal)</code><code>{</code><code>    std::cout &lt;&lt; "A " &lt;&lt; getAnimalName(animal) &lt;&lt; " has ";</code><code></code><code>    switch (animal)</code><code>    {</code><code>        case Animal::chicken:</code><code>        case Animal::duck:</code><code>            std::cout &lt;&lt; 2;</code><code>            break;</code><code></code><code>        case Animal::pig:</code><code>        case Animal::goat:</code><code>        case Animal::cat:</code><code>        case Animal::dog:</code><code>            std::cout &lt;&lt; 4;</code><code>            break;</code><code></code><code>        default:</code><code>            std::cout &lt;&lt; "???";</code><code>            break;</code><code>    }</code><code></code><code>    std::cout &lt;&lt; " legs.\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printNumberOfLegs(Animal::cat);</code><code>    printNumberOfLegs(Animal::chicken);</code><code></code><code>    return 0;</code><code>}</code></pre></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">10.5 — Introduction to structs, members, and member selection</h1></header><div class="entry-content" itemprop="articleBody"><p>There are many instances in programming where we need more than one variable in order to represent something of interest. As we discussed in the introduction to the previous chapter (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-compound-data-types/">9.1 -- Introduction to compound data types</a>), a fraction has a numerator and denominator that are linked together into a single mathematical object.</p><p>Alternatively, lets say we want to write a program where we need to store information about the employees in a company. We might be interested in keeping track of attributes such as the employee’s name, title, age, employee id, manager id, wage, birthday, hire date, etc…</p><p>If we were to use independent variables to track all of this information, that might look something like this:</p><pre class="language-cpp line-numbers"><code>std::string name;</code><code>std::string title;</code><code>int age;</code><code>int id;</code><code>int managerId;</code><code>double wage;</code><code>int birthdayYear;</code><code>int birthdayMonth;</code><code>int birthdayDay;</code><code>int hireYear;</code><code>int hireMonth;</code><code>int hireDay;</code></pre><p>However, there are a number of problems with this approach. First, it’s not immediately clear whether these variables are actually related or not (you’d have to read comments, or see how they are used in context). Second, there are now 12 variables to manage. If we wanted to pass this employee to a function, we’d have to pass 12 arguments (and in the correct order), which would make a mess of our function prototypes and function calls. And since a function can only return a single value, how would a function even return an employee?</p><p>And if we wanted more than one employee, we’d need to define 12 more variables for each additional employee (each of which would require a unique name)! This clearly doesn’t scale at all. What we really need is some way to organize all of these related pieces of data together, to make them easier to manage.</p><p>Fortunately, C++ comes with two compound types designed to solve such challenges: structs (which we’ll introduce now) and classes (which we’ll explore soon). A <span class="cpp-definition">struct</span> (short for <span class="cpp-definition">structure</span>) is a program-defined data type (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-program-defined-user-defined-types/">10.1 -- Introduction to program-defined (user-defined) types</a>) that allows us to bundle multiple variables together into a single type. As you’ll see shortly, this makes management of related sets of variables much simpler!</p><br><h3>Defining structs</h3><p>Because structs are a program-defined type, we first have to tell the compiler what our struct type looks like before we can begin using it. Here is an example of a struct definition for a simplified employee:</p><pre class="language-cpp line-numbers"><code>struct Employee</code><code>{</code><code>    int id {};</code><code>    int age {};</code><code>    double wage {};</code><code>};</code></pre><p>The <code>struct</code> keyword is used to tell the compiler that we’re defining a struct, which we’ve named <code>Employee</code> (since program-defined types are typically given names starting with a capital letter).</p><p>Then, inside a pair of curly braces, we define the variables that each Employee object will contain. In this example, each <code>Employee</code> we create will have 3 variables: an <code>int id</code>, an <code>int age</code>, and a <code>double wage</code>. The variables that are part of the struct are called <span class="cpp-definition">data members</span> (or <span class="cpp-definition">member variables</span>).</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>We’ll use the term <code>member</code> a lot in future lessons, so make sure you remember what it means.</p></div><p>Just like we use an empty set of curly braces to value initialize (<a href="https://www.learncpp.com/cpp-tutorial/variable-assignment-and-initialization/">1.4 -- Variable assignment and initialization</a>) normal variables, the empty curly braces here ensure that the variables inside our <code>Employee</code> are value initialized when an <code>Employee</code> is created. We’ll talk more about this when we cover default member initialization in a few lessons (<a href="https://www.learncpp.com/cpp-tutorial/default-member-initialization/">10.7 -- Default member initialization</a>).</p><p>Finally, we end the type definition with a semicolon.</p><p>As a reminder, <code>Employee</code> is just a type definition -- no objects are actually created at this point.</p><br><h3>Defining struct objects</h3><p>In order to use the <code>Employee</code> type, we simply define a variable of type <code>Employee</code>:</p><pre class="language-cpp line-numbers"><code>Employee joe; // Employee is the type, joe is the variable name</code></pre><p>This defines a variable of type <code>Employee</code> named <code>joe</code>. When <code>joe</code> is defined, an Employee object is created, and the 3 data members within are created in sequential order (and then value initialized).</p><p>Just like any other type, it is possible to define multiple variables of the same struct type:</p><pre class="language-cpp line-numbers"><code>Employee joe; // create an Employee struct for Joe</code><code>Employee frank; // create an Employee struct for Frank</code></pre><br><h3>Accessing members</h3><p>Consider the following example:</p><pre class="language-cpp line-numbers"><code>struct Employee</code><code>{</code><code>    int id {};</code><code>    int age {};</code><code>    double wage {};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Employee joe;</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, the name <code>joe</code> refers to the entire struct object (which contains the member variables). To access a specific member variable, we use the <span class="cpp-definition">member selection operator</span> (<code>operator.</code>) in between the struct variable name and the member name. For example, to access Joe’s age member, we’d use <code>joe.age</code>.</p><p>Struct member variables work just like normal variables, so it is possible to do normal operations on them, including assignment, arithmetic, comparison, etc…</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>struct Employee</code><code>{</code><code>    int id {};</code><code>    int age {};</code><code>    double wage {};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Employee joe;</code><code></code><code>    joe.age = 32;  // use member selection operator (.) to select the age member of variable joe</code><code></code><code>    std::cout &lt;&lt; joe.age &lt;&lt; '\n'; // print joe's age</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>32
</pre><p>One of the biggest advantages of structs is that we only need to create one new name per struct variable (the member names are fixed as part of the struct type definition). In the following example, we instantiate two <code>Employee</code> objects: <code>joe</code> and <code>frank</code>.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>struct Employee</code><code>{</code><code>    int id {};</code><code>    int age {};</code><code>    double wage {};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Employee joe;</code><code>    joe.id = 14;</code><code>    joe.age = 32;</code><code>    joe.wage = 60000.0;</code><code></code><code>    Employee frank;</code><code>    frank.id = 15;</code><code>    frank.age = 28;</code><code>    frank.wage = 45000.0;</code><code></code><code>    int totalAge { joe.age + frank.age };</code><code></code><code>    if (joe.wage &gt; frank.wage)</code><code>        std::cout &lt;&lt; "Joe makes more than Frank\n";</code><code>    else if (joe.wage &lt; frank.wage)</code><code>        std::cout &lt;&lt; "Joe makes less than Frank\n";</code><code>    else</code><code>        std::cout &lt;&lt; "Joe and Frank make the same amount\n";</code><code></code><code>    // Frank got a promotion</code><code>    frank.wage += 5000.0;</code><code></code><code>    // Today is Joe's birthday</code><code>    ++joe.age; // use pre-increment to increment Joe's age by 1</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, it is very easy to tell which member variables belong to Joe and which belong to Frank. This provides a much higher level of organization than individual variables would. Furthermore, because Joe’s and Frank’s members have the same names, this provides consistency when you have multiple variables of the same struct type.</p><p>We’ll continue our exploration of structs in the next lesson, including a look at how to initialize them.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">10.6 — Struct aggregate initialization</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-structs-members-and-member-selection/">10.5 -- Introduction to structs, members, and member selection</a>), we talked about how to define structs, instantiate struct objects, and access their members. In this lesson, we’ll discuss how structs are intialized.</p><br><h3>Data members are not initialized by default</h3><p>Much like normal variables, data members are not initialized by default. Consider the following struct:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>struct Employee</code><code>{</code><code>    int id; // note: no initializer here</code><code>    int age;</code><code>    double wage;</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Employee joe; // note: no initializer here either</code><code>    std::cout &lt;&lt; joe.id &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because we have not provided any initializers, when <code>joe</code> is instantiated, <code>joe.id</code>, <code>joe.age</code>, and <code>joe.wage</code> will all be uninitialized. We will then get undefined behavior when we try to print the value of <code>joe.id</code>.</p><p>However, before we show you how to initialize a struct, let’s take a short detour.</p><br><h3>What is an aggregate?</h3><p>In general programming, an <span class="cpp-definition">aggregate data type</span> (also called an <span class="cpp-definition">aggregate</span>) is any type that can contain multiple data members. Some types of aggregates allow members to have different types (e.g. structs), while others require that all members must be of a single type (e.g. arrays).</p><p>In C++, the definition of an aggregate is narrower and quite a bit more complicated.</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>To be an aggregate in C++, a type must meet the following criteria:</p><ul><li>Is a class type (a struct, class, or union), or an array type (a built-in array or <code>std::array</code>).</li><li>Has no private or protected non-static data members.</li><li>Has no user-declared or inherited constructors.</li><li>Has no base classes.</li><li>Has no virtual member functions.</li></ul></div><p>Putting the precise definition of a C++ aggregate aside, the important thing to understand at this point is that structs with only data members (which are the only kind of structs we’ll create in these lessons) are aggregates. Arrays (which we’ll cover next chapter) are also aggregates.</p><br><h3>Aggregate initialization of a struct</h3><p>Because a normal variable can only hold a single value, we only need to provide a single initializer:</p><pre class="language-cpp line-numbers"><code>int x { 5 };</code></pre><p>However, a struct can have multiple members:</p><pre class="language-cpp line-numbers"><code>struct Employee</code><code>{</code><code>    int id {};</code><code>    int age {};</code><code>    double wage {};</code><code>};</code></pre><p>When we define an object with a struct type, we need some way to initialize multiple members at initialization time:</p><pre class="language-cpp line-numbers"><code>Employee joe; // how do we initialize joe.id, joe.age, and joe.wage?</code></pre><p>Aggregates use a form of initialization called <span class="cpp-definition">aggregate initialization</span>, which allows us to directly initialize the members of aggregates. To do this, we provide an <span class="cpp-definition">initializer list</span> as an initializer, which is just a list of comma-separated initialization values.</p><p>Much like normal variables can be copy initialized, direct initialized, or list initialized, there are 3 forms of aggregate initialization:</p><pre class="language-cpp line-numbers"><code>struct Employee</code><code>{</code><code>    int id {};</code><code>    int age {};</code><code>    double wage {};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Employee frank = { 1, 32, 60000.0 }; // copy-list initialization using braced list</code><code>    Employee robert ( 3, 45, 62500.0 );  // direct initialization using parenthesized list (C++20)</code><code>    Employee joe { 2, 28, 45000.0 };     // list initialization using braced list (preferred)</code><code></code><code>    return 0;</code><code>}</code></pre><p>Each of these initialization forms does a <span class="cpp-definition">memberwise initialization</span>, which means each member in the struct is initialized in the order of declaration. Thus, <code>Employee joe { 2, 28, 45000.0 };</code> first initializes <code>joe.id</code> with value <code>2</code>, then <code>joe.age</code> with value <code>28</code>, and <code>joe.wage</code> with value <code>45000.0</code> last.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Prefer the (non-copy) braced list form when initializing aggregates.</p></div><br><h3>Missing initializers in an initializer list</h3><p>If an aggregate is initialized but the number of initialization values is fewer than the number of members, then all remaining members will be value-initialized.</p><pre class="language-cpp line-numbers"><code>struct Employee</code><code>{</code><code>    int id {};</code><code>    int age {};</code><code>    double wage {};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Employee joe { 2, 28 }; // joe.wage will be value-initialized to 0.0</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, <code>joe.id</code> will be initialized with value <code>2</code>, <code>joe.age</code> will be initialized with value <code>28</code>, and because <code>joe.wage</code> wasn’t given an explicit initializer, it will be value-initialized to <code>0.0</code>.</p><p>This means we can use an empty initialization list to value-initialize all members of the struct:</p><pre class="language-cpp line-numbers"><code>Employee joe {}; // value-initialize all members</code></pre><br><h3>Const structs</h3><p>Variables of a struct type can be const, and just like all const variables, they must be initialized.</p><pre class="language-cpp line-numbers"><code>struct Rectangle</code><code>{</code><code>    double length {};</code><code>    double width {};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    const Rectangle unit { 1.0, 1.0 };</code><code>    const Rectangle zero { }; // value-initialize all members</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>Designated initializers C++20</h3><p>When initializing a struct from a list of values, the initializers are applied to the members in order of declaration.</p><pre class="language-cpp line-numbers"><code>struct Foo</code><code>{</code><code>    int a {};</code><code>    int c {};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Foo f { 1, 3 }; // f.a = 1, f.c = 3</code><code>}</code></pre><p>Now consider what would happen if you were to add a new member to your struct that is not the last member:</p><pre class="language-cpp line-numbers"><code>struct Foo</code><code>{</code><code>    int a {};</code><code>    int b {}; // just added</code><code>    int c {};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Foo f { 1, 3 }; // now, f.a = 1, f.b = 3, f.c = 0</code><code>}</code></pre><p>Now all your initialization values have shifted, and worse, the compiler may not detect this as an error (after all, the syntax is still valid).</p><p>To help avoid this, C++20 adds a new way to initialize struct members called <span class="cpp-definition">designated initializers</span>. Designated initializers allow you to explicitly define which initialization values map to which members. The members must be initialized in the same order in which they are declared in the struct, otherwise an error will result. Members not designated an initializer will be value initialized.</p><pre class="language-cpp line-numbers"><code>struct Foo</code><code>{</code><code>    int a{ };</code><code>    int b{ };</code><code>    int c{ };</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Foo f1{ .a{ 1 }, .c{ 3 } }; // ok: f.a = 1, f.b = 0 (value initialized), f.c = 3</code><code>    Foo f2{ .b{ 2 }, .a{ 1 } }; // error: initialization order does not match order of declaration in struct</code><code></code><code>    return 0;</code><code>}</code></pre><p>Designated initializers are nice because they provide some level of self-documentation and help ensure you don’t inadvertently mix up the order of your initialization values. However, designated initializers also clutter up the initializer list significantly, so we won’t recommend their use as a best practice at this time.</p><p>Also, because there’s no enforcement that designated initializers are being used consistently everywhere an aggregate is initialized, it’s a good idea to avoid adding new members to the middle of an existing aggregate definition, to avoid the risk of initializer shifting.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>When adding a new member to an aggregate, it’s safest to add it to the bottom of the definition list so the initializers for other members don’t shift.</p></div><br><h3>Assignment with an initializer list</h3><p>As shown in the prior lesson, we can assign values to members of structs individually:</p><pre class="language-cpp line-numbers"><code>struct Employee</code><code>{</code><code>    int id {};</code><code>    int age {};</code><code>    double wage {};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Employee joe { 1, 32, 60000.0 };</code><code></code><code>    joe.age  = 33;      // Joe had a birthday</code><code>    joe.wage = 66000.0; // and got a raise</code><code></code><code>    return 0;</code><code>}</code></pre><p>This is fine for single members, but not great when we want to update many members. Similar to initializing a struct with an initializer list, you can also assign values to structs using an initializer list (which does memberwise assignment):</p><pre class="language-cpp line-numbers"><code>struct Employee</code><code>{</code><code>    int id {};</code><code>    int age {};</code><code>    double wage {};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Employee joe { 1, 32, 60000.0 };</code><code>    joe = { joe.id, 33, 66000.0 }; // Joe had a birthday and got a raise</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note that because we didn’t want to change <code>joe.id</code>, we needed to provide the current value for <code>joe.id</code> in our list as a placeholder, so that memberwise assignment could assign <code>joe.id</code> to <code>joe.id</code>. This is a bit ugly.</p><br><h3>Assignment with designated initializers C++20</h3><p>Designated initializers can also be used in a list assignment:</p><pre class="language-cpp line-numbers"><code>struct Employee</code><code>{</code><code>    int id {};</code><code>    int age {};</code><code>    double wage {};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Employee joe { 1, 32, 60000.0 };</code><code>    joe = { .id = joe.id, .age = 33, .wage = 66000.0 }; // Joe had a birthday and got a raise</code><code></code><code>    return 0;</code><code>}</code></pre><p>Any members that aren’t designated in such an assignment will be assigned the value that would be used for value initialization. If we hadn’t have specified a designated initializer for <code>joe.id</code>, <code>joe.id</code> would have been assigned the value 0.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">10.7 — Default member initialization</h1></header><div class="entry-content" itemprop="articleBody"><p>When we define a struct (or class) type, we can provide a default initialization value for each member as part of the type definition. This process is called <span class="cpp-definition">non-static member initialization</span>, and the initialization value is called a <span class="cpp-definition">default member initializer</span>.</p><p>Here’s an example:</p><pre class="language-cpp line-numbers"><code>struct Something</code><code>{</code><code>    int x;       // no initialization value (bad)</code><code>    int y {};    // value-initialized by default</code><code>    int z { 2 }; // explicit default value</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Something s1; // s1.x is uninitialized, s1.y is 0, and s1.z is 2</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above definition of <code>Something</code>, <code>x</code> has no default value, <code>y</code> is value-initialized by default, and <code>z</code> has the default value <code>2</code>. These default member initialization values will be used if the user doesn’t provide an explicit initialization value when instantiating an object of type <code>Something</code>.</p><p>Our <code>s1</code> object doesn’t have an initializer, so the members of <code>s1</code> are initialized to their default values. <code>s1.x</code> has no default initializer, so it remains uninitialized. <code>s1.y</code> is value initialized by default, so it gets value <code>0</code>. And <code>s1.z</code> is initialized with the value <code>2</code>.</p><p>Note that even though we haven’t provided an explicit initializer for <code>s1.z</code>, it is initialized to a non-zero value because of the default member initializer provided.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>Using default member initializers (or other mechanisms that we’ll cover later), structs and classes can self-initialize even when no explicit initializers are provided!</p></div><br><h3>Explicit initialization values take precedence over default values</h3><p>Explicit values in a list initializer always take precedence over default member initialization values.</p><pre class="language-cpp line-numbers"><code>struct Something</code><code>{</code><code>    int x;       // no default initialization value (bad)</code><code>    int y {};    // value-initialized by default</code><code>    int z { 2 }; // explicit default value</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Something s2 { 5, 6, 7 }; // use explicit initializers for s2.x, s2.y, and s2.z (no default values are used)</code><code>   </code><code>    return 0;</code><code>}</code></pre><p>In the above case, <code>s2</code> has explicit initialization values for every member, so the default member initialization values are not used at all. This means <code>s2.x</code>, <code>s2.y</code> and <code>s2.z</code> are initialized to the values <code>5</code>, <code>6</code>, and <code>7</code> respectively.</p><br><h3>Missing initializers in an initializer list when default values exist</h3><p>In the previous lesson (<a href="https://www.learncpp.com/cpp-tutorial/struct-aggregate-initialization/">10.6 -- Struct aggregate initialization</a>) we noted that if an aggregate is initialized but the number of initialization values is fewer than the number of members, then all remaining members will be value-initialized. However, if a default member initializer is provided for a given member, that default member initializer will be used instead.</p><pre class="language-cpp line-numbers"><code>struct Something</code><code>{</code><code>    int x;       // no default initialization value (bad)</code><code>    int y {};    // value-initialized by default</code><code>    int z { 2 }; // explicit default value</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Something s3 {}; // value initialize s3.x, use default values for s3.y and s3.z</code><code>   </code><code>    return 0;</code><code>}</code></pre><p>In the above case, <code>s3</code> is list initialized with an empty list, so all initializers are missing. This means that a default member initializer will be used if it exists, and value initialization will occur otherwise. Thus, <code>s3.x</code> (which has no default member initializer) is value initialized to <code>0</code>, <code>s3.y</code> is value initialized by default to <code>0</code>, and <code>s3.z</code> is defaulted to value <code>2</code>.</p><br><h3>Recapping the initialization possibilities</h3><p>If an aggregate is defined with an initialization list:</p><ul><li>If an explicit initialization value exists, that explicit value is used.</li><li>If an initializer is missing and a default member initializer exists, the default is used.</li><li>If an initializer is missing and no default member initializer exists, value initialization occurs.</li></ul><p>If an aggregate is defined with no initialization list:</p><ul><li>If a default member initializer exists, the default is used.</li><li>If no default member initializer exists, the member remains uninitialized.</li></ul><p>Members are always initialized in the order of declaration.</p><p>The following example recaps all possibilities:</p><pre class="language-cpp line-numbers"><code>struct Something</code><code>{</code><code>    int x;       // no default initialization value (bad)</code><code>    int y {};    // value-initialized by default</code><code>    int z { 2 }; // explicit default value</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Something s1;             // No initializer list: s1.x is uninitialized, s1.y and s1.z use defaults</code><code>    Something s2 { 5, 6, 7 }; // Explicit initializers: s2.x, s2.y, and s2.z use explicit values (no default values are used)</code><code>    Something s3 {};          // Missing initializers: s3.x is value initialized, s3.y and s3.z use defaults</code><code>   </code><code>    return 0;</code><code>}</code></pre><p>The case we want to watch out for is <code>s1.x</code>. Because <code>s1</code> has no initializer list and <code>x</code> has no default member initializer, <code>s1.x</code> remains uninitialized (which is bad, since we should always initialize our variables).</p><br><h3>Always provide default values for your members</h3><p>To avoid the possibility of uninitialized members, simply ensure that each member has a default value (either an explicit default value, or an empty pair of braces). That way, our members will be initialized with some value regardless of whether we provide an initializer list or not.</p><p>Consider the following struct, which has all members defaulted:</p><pre class="language-cpp line-numbers"><code>struct Fraction</code><code>{</code><code>	int numerator { }; // we should use { 0 } here, but for the sake of example we'll use value initialization instead</code><code>	int denominator { 1 };</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Fraction f1;          // f1.numerator value initialized to 0, f1.denominator defaulted to 1</code><code>	Fraction f2 {};       // f2.numerator value initialized to 0, f2.denominator defaulted to 1</code><code>	Fraction f3 { 6 };    // f3.numerator initialized to 6, f3.denominator defaulted to 1</code><code>	Fraction f4 { 5, 8 }; // f4.numerator initialized to 5, f4.denominator initialized to 8</code><code></code><code>	return 0;</code><code>}</code></pre><p>In all cases, our members are initialized with values.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Provide a default value for all members. This ensure that your members will be initialized even if the variable definition doesn’t include an initializer list.</p></div><br><h3>Default initialization vs value initialization for aggregates</h3><p>Revisiting two lines from the above example:</p><pre class="language-cpp line-numbers"><code>	Fraction f1;          // f1.numerator value initialized to 0, f1.denominator defaulted to 1</code><code>	Fraction f2 {};       // f2.numerator value initialized to 0, f2.denominator defaulted to 1</code></pre><p>You’ll note that <code>f1</code> is default initialized and <code>f2</code> is value initialized, yet the results are the same (<code>numerator</code> is initialized to <code>0</code> and <code>denominator</code> is initialized to <code>1</code>). So which should we prefer?</p><p>The value initialization case (<code>f2</code>) is safer, because it will ensure any members with no default values are value initialized (and although we should always provide default values for members, this protects against the case where one is missed).</p><p>Preferring value initialization has one more benefit -- it’s consistent with how we initialize objects of other types. Consistency helps prevent errors.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>If no explicit initializer values will be provided for an aggregate, prefer value initialization (with an empty braces initializer) to default initialization (with no braces).</p></div><p>That said, it’s not uncommon for programmers to use default initialization instead of value initialization for class types. This is partly for historic reasons (as value initialization wasn’t introduced until C++11), and partly because there is a similar case (for non-aggregates) where default initialization can be more efficient (we cover this case in <a href="https://www.learncpp.com/cpp-tutorial/constructors/">13.5 -- Constructors</a>).</p><p>Therefore, we won’t be militant about enforcing use of value initialization for structs and classes in these tutorials, but we do strongly recommend it.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">10.8 — Struct passing and miscellany</h1></header><div class="entry-content" itemprop="articleBody"><p>Consider an employee represented by 3 loose variables:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int id { 1 };</code><code>    int age { 24 };</code><code>    double wage { 52400.0 };</code><code></code><code>    return 0;</code><code>}</code></pre><p>If we want to pass this employee to a function, we have to pass three variables:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printEmployee(int id, int age, double wage)</code><code>{</code><code>    std::cout &lt;&lt; "ID:   " &lt;&lt; id &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "Age:  " &lt;&lt; age &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "Wage: " &lt;&lt; wage &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int id { 1 };</code><code>    int age { 24 };</code><code>    double wage { 52400.0 };</code><code></code><code>    printEmployee(id, age, wage);</code><code></code><code>    return 0;</code><code>}</code></pre><p>While passing 3 variables isn’t that bad, consider a struct with 10 or 12 members. Passing each variable independently would be time consuming and error prone. Additionally, if we ever add a new attribute to our employee (e.g. name), we now have to modify all the functions declarations, definitions, and function calls to accept the new parameter and argument!</p><br><h3>Passing structs (by reference)</h3><p>A big advantage of using structs over individual variables is that we can pass the entire struct to a function that needs to work with the members. Structs are generally passed by (const) reference to avoid making copies.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>struct Employee</code><code>{</code><code>    int id {};</code><code>    int age {};</code><code>    double wage {};</code><code>};</code><code></code><code>void printEmployee(const Employee&amp; employee) // note pass by reference here</code><code>{</code><code>    std::cout &lt;&lt; "ID:   " &lt;&lt; employee.id &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "Age:  " &lt;&lt; employee.age &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "Wage: " &lt;&lt; employee.wage &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Employee joe { 14, 32, 24.15 };</code><code>    Employee frank { 15, 28, 18.27 };</code><code></code><code>    // Print Joe's information</code><code>    printEmployee(joe);</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    // Print Frank's information</code><code>    printEmployee(frank);</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, we pass an entire <code>Employee</code> to <code>printEmployee()</code> (twice, once for <code>joe</code> and once for <code>frank</code>).</p><p>The above program outputs:</p><pre>ID:   14
Age:  32
Wage: 24.15

ID:   15
Age:  28
Wage: 18.27
</pre><p>Because we are passing the entire struct object (rather than individual members), we only need one parameter no matter how many members the struct object has. And, in the future, if we ever decide to add new members to our <code>Employee</code> struct, we will not have to change the function declaration or function call! The new member will automatically be included.</p><br><h3>Returning structs</h3><p>Consider the case where we have a function that needs to return a point in 3-dimensional Cartesian space. Such a point has 3 attributes: an x-coordinate, a y-coordinate, and a z-coordinate. But functions can only return one value. So how do we return all 3 coordinates back the user?</p><p>One common way is to return a struct:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>struct Point3d</code><code>{</code><code>    double x { 0.0 };</code><code>    double y { 0.0 };</code><code>    double z { 0.0 };</code><code>};</code><code></code><code>Point3d getZeroPoint()</code><code>{</code><code>    // We can create a variable and return the variable (we'll improve this below)</code><code>    Point3d temp { 0.0, 0.0, 0.0 };</code><code>    return temp;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Point3d zero{ getZeroPoint() };</code><code></code><code>    if (zero.x == 0.0 &amp;&amp; zero.y == 0.0 &amp;&amp; zero.z == 0.0)</code><code>        std::cout &lt;&lt; "The point is zero\n";</code><code>    else</code><code>        std::cout &lt;&lt; "The point is not zero\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>The point is zero
</pre><p>Structs are usually returned by value, so as not to return a dangling reference.</p><br><h3>Returning unnamed structs</h3><p>In the <code>getZeroPoint()</code> function above, we create a new named object (<code>temp</code>) just so we could return it:</p><pre class="language-cpp line-numbers"><code>Point3d getZeroPoint()</code><code>{</code><code>    // We can create a variable and return the variable (we'll improve this below)</code><code>    Point3d temp { 0.0, 0.0, 0.0 };</code><code>    return temp;</code><code>}</code></pre><p>The name of the object (<code>temp</code>) doesn’t really provide any documentation value here.</p><p>We can make our function slightly better by returning a temporary (unnamed) object instead:</p><pre class="language-cpp line-numbers"><code>Point3d getZeroPoint()</code><code>{</code><code>    return Point3d { 0.0, 0.0, 0.0 }; // return an unnamed Point3d</code><code>}</code></pre><p>In this case, a temporary Point3d is constructed, copied back to the caller, and then destroyed at the end of the expression. Note how much cleaner this is (one line vs two, and no need to understand whether <code>temp</code> is used more than once).</p><p>In the case where the function has an explicit return type (e.g. <code>Point3d</code>) instead of using type deduction (an <code>auto</code> return type), we can even omit the type in the return statement:</p><pre class="language-cpp line-numbers"><code>Point3d getZeroPoint()</code><code>{</code><code>    // We already specified the type at the function declaration</code><code>    // so we don't need to do so here again</code><code>    return { 0.0, 0.0, 0.0 }; // return an unnamed Point3d</code><code>}</code></pre><p>Also note that since in this case we’re returning all zero values, we can use empty braces to return a value-initialized Point3d:</p><pre class="language-cpp line-numbers"><code>Point3d getZeroPoint()</code><code>{</code><code>    // We can use empty curly braces to value-initialize all members</code><code>    return {};</code><code>}</code></pre><br><h3>Structs with program-defined members</h3><p>In C++, structs (and classes) can have members that are other program-defined types. There are two ways to do this.</p><p>First, we can define one program-defined type (in the global scope) and then use it as a member of another program-defined type:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>struct Employee</code><code>{</code><code>    int id {};</code><code>    int age {};</code><code>    double wage {};</code><code>};</code><code></code><code>struct Company</code><code>{</code><code>    int numberOfEmployees {};</code><code>    Employee CEO {}; // Employee is a struct within the Company struct</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Company myCompany{ 7, { 1, 32, 55000.0 } }; // Nested initialization list to initialize Employee</code><code>    std::cout &lt;&lt; myCompany.CEO.wage; // print the CEO's wage</code><code>}</code></pre><p>In the above case, we’ve defined an <code>Employee</code> struct, and then used that as a member in a <code>Company</code> struct. When we initialize our <code>Company</code>, we can also initialize our <code>Employee</code> by using a nested initialization list. And if we want to know what the CEO’s salary was, we simply use the member selection operator twice: <code>myCompany.CEO.wage;</code></p><p>Second, types can also be nested inside other types, so if an Employee only existed as part of a Company, the Employee type could be nested inside the Company struct:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>struct Company</code><code>{</code><code>    struct Employee // accessed via Company::Employee</code><code>    {</code><code>        int id{};</code><code>        int age{};</code><code>        double wage{};</code><code>    };</code><code></code><code>    int numberOfEmployees{};</code><code>    Employee CEO{}; // Employee is a struct within the Company struct</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Company myCompany{ 7, { 1, 32, 55000.0 } }; // Nested initialization list to initialize Employee</code><code>    std::cout &lt;&lt; myCompany.CEO.wage; // print the CEO's wage</code><code>}</code></pre><p>This is more often done with classes, so we’ll talk more about this in a future lesson (<a href="https://www.learncpp.com/cpp-tutorial/nested-types-in-classes/">13.17 -- Nested types in classes</a>).</p><br><h3>Struct size and data structure alignment</h3><p>Typically, the size of a struct is the sum of the size of all its members, but not always!</p><p>Consider the following struct:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>struct Foo</code><code>{</code><code>    short a {};</code><code>    int b {};</code><code>    double c {};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "The size of Foo is " &lt;&lt; sizeof(Foo) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>On many platforms, a short is 2 bytes, an int is 4 bytes, and a double is 8 bytes, so we’d expect <code>sizeof(Foo)</code> to be 2 + 4 + 8 = 14 bytes. However, on the author’s machine, this prints:</p><pre>The size of Foo is 16
</pre><p>It turns out, we can only say that the size of a struct will be <em>at least</em> as large as the size of all the variables it contains. But it could be larger! For performance reasons, the compiler will sometimes add gaps into structures (this is called <span class="cpp-definition">padding</span>).</p><p>In the <code>Foo</code> struct above, the compiler is invisibly adding 2 bytes of padding after member <code>a</code>, making the size of the structure 16 bytes instead of 14.</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>The reason compilers may add padding is beyond the scope of this tutorial, but readers who want to learn more can read about <a href="https://en.wikipedia.org/wiki/Data_structure_alignment">data structure alignment</a> on Wikipedia. This is optional reading and not required to understand structures or C++!</p></div><p>This can actually have a pretty significant impact on the size of the struct, as the following program will demonstrate:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>struct Foo1</code><code>{</code><code>    short a{};</code><code>    short qq{}; // note: qq is defined here</code><code>    int b{};</code><code>    double c{};</code><code>};</code><code></code><code>struct Foo2</code><code>{</code><code>    short a{};</code><code>    int b{};</code><code>    double c{};</code><code>    short qq{}; // note: qq is defined here</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "The size of Foo1 is " &lt;&lt; sizeof(Foo1) &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "The size of Foo2 is " &lt;&lt; sizeof(Foo2) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note that <code>Foo1</code> and <code>Foo2</code> have the same members, the only difference being where in the declaration order member <code>qq</code> is declared. This program prints:</p><pre>The size of Foo1 is 16
The size of Foo2 is 24
</pre><br><h3>Structs are an important building block</h3><p>While structs are useful in and of themselves, classes (which are the heart of C++ and object oriented programming) build directly on top of the concepts we’ve introduced here. Having a good understanding of structs (especially data members, member selection, and default member initialization) will make your transition to classes that much easier.</p><br><h3>Quiz time</h3><p class="cpp-quiz-question" style="clear:both">Question #1</p><p>You are running a website, and you are trying to keep track of how much money you make per day from advertising. Declare an advertising struct that keeps track of how many ads you’ve shown to readers, what percentage of ads were clicked on by users, and how much you earned on average from each ad that was clicked. Read in values for each of these fields from the user. Pass the advertising struct to a function that prints each of the values, and then calculates how much you made for that day (multiply all 3 fields together).</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// First we need to define our Advertising struct</code><code>struct Advertising</code><code>{</code><code>    int adsShown {};</code><code>    double clickThroughRatePercentage {};</code><code>    double averageEarningsPerClick {};</code><code>};</code><code></code><code>Advertising getAdvertising()</code><code>{</code><code>    Advertising temp;</code><code>    std::cout &lt;&lt; "How many ads were shown today? ";</code><code>    std::cin &gt;&gt; temp.adsShown;</code><code>    std::cout &lt;&lt; "What percentage of ads were clicked on by users? ";</code><code>    std::cin &gt;&gt; temp.clickThroughRatePercentage;</code><code>    std::cout &lt;&lt; "What was the average earnings per click? ";</code><code>    std::cin &gt;&gt; temp.averageEarningsPerClick;</code><code>    return temp;</code><code>}</code><code></code><code>void printAdvertising(const Advertising&amp; ad)</code><code>{</code><code>    std::cout &lt;&lt; "Number of ads shown: " &lt;&lt; ad.adsShown &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "Click through rate: " &lt;&lt; ad.clickThroughRatePercentage &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "Average earnings per click: $" &lt;&lt; ad.averageEarningsPerClick &lt;&lt; '\n';</code><code></code><code>    // The following line is split up to reduce the length</code><code>    // We need to divide ad.clickThroughRatePercentage by 100 because it's a percent of 100, not a multiplier</code><code>    std::cout &lt;&lt; "Total Earnings: $" &lt;&lt;</code><code>        (ad.adsShown * ad.clickThroughRatePercentage / 100 * ad.averageEarningsPerClick) &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    // Declare an Advertising struct variable</code><code>    Advertising ad{ getAdvertising() };</code><code>    printAdvertising(ad);</code><code></code><code>    return 0;</code><code>}</code></pre></div><p class="cpp-quiz-question cpp-topline" style="clear:both">Question #2</p><p>Create a struct to hold a fraction. The struct should have an integer numerator and an integer denominator member.</p><p>Write a function to read in a Fraction from the user, and use it to read-in two fraction objects. Write another function to multiply two Fractions together and return the result as a Fraction (you don’t need to reduce the fraction). Write another function that prints a fraction.</p><p>Your program’s output should match the following:</p><pre>Enter a value for the numerator: 1
Enter a value for the denominator: 2

Enter a value for the numerator: 3
Enter a value for the denominator: 4

Your fractions multiplied together: 3/8
</pre><p>When multiplying two fractions together, the resulting numerator is the product of the two numerators, and the resulting denominator is the product of the two denominators.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>struct Fraction</code><code>{</code><code>    int numerator{ 0 };</code><code>    int denominator{ 1 };</code><code>};</code><code></code><code>Fraction getFraction()</code><code>{</code><code>    Fraction temp{};</code><code>    std::cout &lt;&lt; "Enter a value for numerator: ";</code><code>    std::cin &gt;&gt; temp.numerator;</code><code>    std::cout &lt;&lt; "Enter a value for denominator: ";</code><code>    std::cin &gt;&gt; temp.denominator;</code><code>    std::cout &lt;&lt; '\n';</code><code>    return temp;</code><code>}</code><code></code><code>Fraction multiply(const Fraction&amp; f1, const Fraction&amp; f2)</code><code>{</code><code>    return { f1.numerator * f2.numerator, f1.denominator * f2.denominator };</code><code>}</code><code></code><code>void printFraction(const Fraction&amp; f)</code><code>{</code><code>    std::cout &lt;&lt; f.numerator &lt;&lt; '/' &lt;&lt; f.denominator;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    // Allocate our first fraction</code><code>    Fraction f1{ getFraction() };</code><code>    Fraction f2{ getFraction() };</code><code></code><code>    std::cout &lt;&lt; "Your fractions multiplied together: ";</code><code></code><code>    printFraction(multiply(f1, f2));</code><code></code><code>    return 0;</code><code>}</code></pre></div><p class="cpp-quiz-question cpp-topline" style="clear:both">Question #3</p><p>In the solution to the prior quiz question, why does <code>getFraction()</code> return by value instead of by reference?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>Because our <code>temp</code> Fraction is a local variable, it will go out of scope at the end of the function. If we were to return <code>temp</code> as reference, we’d return a dangling reference back to the caller.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">10.9 — Member selection with pointers and references</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Member selection for structs and references to structs</h3><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-structs-members-and-member-selection/">10.5 -- Introduction to structs, members, and member selection</a>, we showed that you can use the member selection operator (.) to select a member from a struct object:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>struct Employee</code><code>{</code><code>    int id {};</code><code>    int age {};</code><code>    double wage {};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Employee joe { 1, 34, 65000.0 };</code><code></code><code>    // Use member selection operator (.) to select a member from struct object</code><code>    ++joe.age; // Joe had a birthday</code><code>    joe.wage = 68000.0; // Joe got a promotion</code><code>    </code><code>    return 0;</code><code>}</code></pre><p>Since references to an object act just like the object itself, we can also use the member selection operator (.) to select a member from a reference to a struct:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>struct Employee</code><code>{</code><code>    int id{};</code><code>    int age{};</code><code>    double wage{};</code><code>};</code><code></code><code>void printEmployee(const Employee&amp; e)</code><code>{</code><code>    // Use member selection opeartor (.) to select member from reference to struct</code><code>    std::cout &lt;&lt; "Id: " &lt;&lt; e.id &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "  Age: " &lt;&lt; e.age &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "  Wage: " &lt;&lt; e.wage &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Employee joe{ 1, 34, 65000.0 };</code><code></code><code>    ++joe.age;</code><code>    joe.wage = 68000.0;</code><code></code><code>    printEmployee(joe);</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>Member selection for pointers to structs</h3><p>However, use of the member selection operator (.) doesn’t work if you have a pointer to a struct:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>struct Employee</code><code>{</code><code>    int id{};</code><code>    int age{};</code><code>    double wage{};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Employee joe{ 1, 34, 65000.0 };</code><code></code><code>    ++joe.age;</code><code>    joe.wage = 68000.0;</code><code></code><code>    Employee* ptr{ &amp;joe };</code><code>    std::cout &lt;&lt; ptr.id &lt;&lt; '\n'; // Compile error: can't use operator. with pointers</code><code></code><code>    return 0;</code><code>}</code></pre><p>With normal variables or references, we can access objects directly. However, because pointers hold addresses, we first need to dereference the pointer to get the object before we can do anything with it. So one way to access a member from a pointer to a struct is as follows:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>struct Employee</code><code>{</code><code>    int id{};</code><code>    int age{};</code><code>    double wage{};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Employee joe{ 1, 34, 65000.0 };</code><code></code><code>    ++joe.age;</code><code>    joe.wage = 68000.0;</code><code></code><code>    Employee* ptr{ &amp;joe };</code><code>    std::cout &lt;&lt; (*ptr).id &lt;&lt; '\n'; // Not great but works: First dereference ptr, then use member selection</code><code></code><code>    return 0;</code><code>}</code></pre><p>However, this is a bit ugly, especially because we need to parenthesize the dereference operation so it will take precedence over the member selection operation.</p><p>To make for a cleaner syntax, C++ offers a <span class="cpp-definition">member selection from pointer operator (-&gt;)</span> (also sometimes called the <span class="cpp-definition">arrow operator</span>) that can be used to select members from a pointer to an object:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>struct Employee</code><code>{</code><code>    int id{};</code><code>    int age{};</code><code>    double wage{};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Employee joe{ 1, 34, 65000.0 };</code><code></code><code>    ++joe.age;</code><code>    joe.wage = 68000.0;</code><code></code><code>    Employee* ptr{ &amp;joe };</code><code>    std::cout &lt;&lt; ptr-&gt;id &lt;&lt; '\n'; // Better: use -&gt; to select member from pointer to object</code><code></code><code>    return 0;</code><code>}</code></pre><p>This member selection from pointer operator (-&gt;) works identically to the member selection operator (.) but does an implicit dereference of the pointer object before selecting the member. This arrow operator is not only easier to type, but is also much less prone to error because the indirection is implicitly done for you, so there are no precedence issues to worry about. Consequently, when doing member access through a pointer, always use the -&gt; operator instead of the . operator.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>When using a pointer to access the value of a member, use operator-&gt;; instead of operator. (the . operator)</p></div><br><h3>Mixing pointers and non-pointers to members</h3><p>The member selection operator is always applied to the currently selected variable. If you have a mix of pointers and normal member variables, you can see member selections where . and -&gt; are both used in sequence:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>struct Paw</code><code>{</code><code>    int claws{};</code><code>};</code><code> </code><code>struct Animal</code><code>{</code><code>    std::string name{};</code><code>    Paw paw{};</code><code>};</code><code> </code><code>int main()</code><code>{</code><code>    Animal puma{ "Puma", { 5 } };</code><code> </code><code>    Animal* ptr{ &amp;puma };</code><code> </code><code>    // ptr is a pointer, use -&gt;</code><code>    // paw is not a pointer, use .</code><code></code><code>    std::cout &lt;&lt; (ptr-&gt;paw).claws &lt;&lt; '\n';</code><code> </code><code>    return 0;</code><code>}</code></pre><p>Note that in the case of <code>(ptr-&gt;paw).claws</code>, parentheses aren’t necessary since both <code>operator-&gt;</code> and <code>operator.</code> evaluate in left to right order, but it does help readability slightly.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">10.10 — Class templates</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/function-templates/">8.13 -- Function templates</a>, we introduced the challenge of having to create a separate (overloaded) function for each different set of types we want to work with:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// function to calculate the greater of two int values</code><code>int max(int x, int y)</code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code><code></code><code>// almost identical function to calculate the greater of two double values</code><code>// the only difference is the type information</code><code>double max(double x, double y)</code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; max(5, 6);     // calls max(int, int)</code><code>    std::cout &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; max(1.2, 3.4); // calls max(double, double)</code><code></code><code>    return 0;</code><code>}</code></pre><p>The solution to this was to create a function template that the compiler can use to instantiate normal functions for whichever set of types we need:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// a single function template for max</code><code>template <typename t=""></typename></code><code>T max(T x, T y)</code><code>{</code><code>    return (x &gt; y) ? x : y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; max(5, 6);     // instantiates and calls max<int>(int, int)</int></code><code>    std::cout &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; max(1.2, 3.4); // instantiates and calls max<double>(double, double)</double></code><code></code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We cover how function template instantiation works in lesson <a href="https://www.learncpp.com/cpp-tutorial/function-template-instantiation/">8.14 -- Function template instantiation</a>.</p></div><br><h3>Aggregate types have similar challenges</h3><p>We run into similar challenges with aggregate types (both structs/classes/unions and arrays).</p><p>For example, let’s say we’re writing a program where we need to work with pairs of <code>int</code> values, and need to determine which of the two numbers is larger. We might write a program like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>struct Pair</code><code>{</code><code>    int first{};</code><code>    int second{};</code><code>};</code><code></code><code>constexpr int max(Pair p) // pass by value because Pair is small</code><code>{</code><code>    return (p.first &gt; p.second ? p.first : p.second);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Pair p1{ 5, 6 };</code><code>    std::cout &lt;&lt; max(p1) &lt;&lt; " is larger\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>Later, we discover that we also need pairs of <code>double</code> values. So we update our program to the following:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>struct Pair</code><code>{</code><code>    int first{};</code><code>    int second{};</code><code>};</code><code></code><code>struct Pair // compile error: erroneous redefinition of Pair</code><code>{</code><code>    double first{};</code><code>    double second{};</code><code>};</code><code></code><code>constexpr int max(Pair p)</code><code>{</code><code>    return (p.first &gt; p.second ? p.first : p.second);</code><code>}</code><code></code><code>constexpr double max(Pair p) // compile error: overloaded function differs only by return type</code><code>{</code><code>    return (p.first &gt; p.second ? p.first : p.second);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Pair p1{ 5, 6 };</code><code>    std::cout &lt;&lt; max(p1) &lt;&lt; " is larger\n";</code><code></code><code>    Pair p2{ 1.2, 3.4 };</code><code>    std::cout &lt;&lt; max(p2) &lt;&lt; " is larger\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>Unfortunately, this program won’t compile, and has a number of problems that need to be addressed.</p><p>First, unlike functions, type definitions can’t be overloaded. The compiler will treat double second definition of <code>Pair</code> as an erroneous redeclaration of the first definition of <code>Pair</code>. Second, although functions can be overloaded, our <code>max(Pair)</code> functions only differ by return type, and overloaded functions can’t be differentiated solely by return type. Third, there is a lot of redundancy here. Each <code>Pair</code> struct is identical (except for the data type) and same with our <code>max(Pair)</code> functions (except for the return type).</p><p>We could solve the first two issues by giving our <code>Pair</code> structs different names (e.g. <code>Pairint</code> and <code>Pairdouble</code>). But then we both have to remember our naming scheme, and essentially clone a bunch of code for each additional pair type we want, which doesn’t solve the redundancy problem.</p><p>Fortunately, we can do better.</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>Before proceeding, please review lessons <a href="https://www.learncpp.com/cpp-tutorial/function-templates/">8.13 -- Function templates</a> and <a href="https://www.learncpp.com/cpp-tutorial/function-template-instantiation/">8.14 -- Function template instantiation</a> if you’re hazy on how function templates, template types, or function template instantiation works.</p></div><br><h3>Class templates</h3><p>Much like a function template is a template definition for instantiating functions, a <span class="cpp-definition">class template</span> is a template definition for instantiating class types.</p><div class="cpp-note cpp-lightgraybackground"><h4>A reminder</h4><p>A “class type” is a struct, class, or union type. Although we’ll be demonstrating “class templates” on structs for simplicity, everything here applies equally well to classes.</p></div><p>As a reminder, here’s our <code>int</code> pair struct definition:</p><pre class="language-cpp line-numbers"><code>struct Pair</code><code>{</code><code>    int first{};</code><code>    int second{};</code><code>};</code></pre><p>Let’s rewrite our pair class as a class template:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>struct Pair</code><code>{</code><code>    T first{};</code><code>    T second{};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Pair<int> p1{ 5, 6 };        // instantiates Pair<int> and creates object p1</int></int></code><code>    std::cout &lt;&lt; p1.first &lt;&lt; ' ' &lt;&lt; p1.second &lt;&lt; '\n';</code><code></code><code>    Pair<double> p2{ 1.2, 3.4 }; // instantiates Pair<double> and creates object p2</double></double></code><code>    std::cout &lt;&lt; p2.first &lt;&lt; ' ' &lt;&lt; p2.second &lt;&lt; '\n';</code><code></code><code>    Pair<double> p3{ 7.8, 9.0 }; // creates object p3 using prior definition for Pair<double></double></double></code><code>    std::cout &lt;&lt; p3.first &lt;&lt; ' ' &lt;&lt; p3.second &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Just like with function templates, we start a class template definition with a template parameter declaration. We begin with the <code>template</code> keyword. Next, we specify all of the template types that our class template will use inside angled brackets (&lt;&gt;). For each template type that we need, we use the keyword <code>typename</code> (preferred) or <code>class</code> (not preferred), followed by the name of the template type (e.g. <code>T</code>). In this case, since both of our members will be the same type, we only need one template type.</p><p>Next, we define our struct like usual, except we can use our template type (<code>T</code>) wherever we want a templated type that will be replaced with a real type later. That’s it! We’re done with the class template definition.</p><p>Inside main, we can instantiate <code>Pair</code> objects using whatever types we desire. First, we instantiate an object of type <code>Pair<int></int></code>. Because a type definition for <code>Pair<int></int></code> doesn’t exist yet, the compiler uses the class template to instantiate a struct type definition named <code>Pair<int></int></code>, where all occurrences of template type <code>T</code> are replaced by type <code>int</code>.</p><p>Next, we instantiate an object of type <code>Pair<double></double></code>, which instantiates a struct type definition named <code>Pair<double></double></code> where <code>T</code> is replaced by <code>double</code>. For <code>p3</code>, <code>Pair<double></double></code> has already been instantiated, so the compiler will use the prior type definition.</p><p>Here’s the same example as above, showing what the compiler actually compiles after all template instantiations are done:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// A declaration for our Pair class template</code><code>// (we don't need the definition any more since it's not used)</code><code>template <typename t=""></typename></code><code>struct Pair;</code><code></code><code>// Explicitly define what Pair<int> looks like</int></code><code>template &lt;&gt; // tells the compiler this is a template type with no template parameters</code><code>struct Pair<int></int></code><code>{</code><code>    int first{};</code><code>    int second{};</code><code>};</code><code></code><code>// Explicitly define what Pair<double> looks like</double></code><code>template &lt;&gt; // tells the compiler this is a template type with no template parameters</code><code>struct Pair<double></double></code><code>{</code><code>    double first{};</code><code>    double second{};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Pair<int> p1{ 5, 6 };        // instantiates Pair<int> and creates object p1</int></int></code><code>    std::cout &lt;&lt; p1.first &lt;&lt; ' ' &lt;&lt; p1.second &lt;&lt; '\n';</code><code></code><code>    Pair<double> p2{ 1.2, 3.4 }; // instantiates Pair<double> and creates object p2</double></double></code><code>    std::cout &lt;&lt; p2.first &lt;&lt; ' ' &lt;&lt; p2.second &lt;&lt; '\n';</code><code></code><code>    Pair<double> p3{ 7.8, 9.0 }; // creates object p3 using prior definition for Pair<double></double></double></code><code>    std::cout &lt;&lt; p3.first &lt;&lt; ' ' &lt;&lt; p3.second &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>You can compile this example directly and see that it works as expected!</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>The above example makes use of a feature called template class specialization (covered in future lesson <a href="https://www.learncpp.com/cpp-tutorial/class-template-specialization/">19.4 -- Class template specialization</a>). Knowledge of how this feature works is not required at this point.</p></div><br><h3>Using our class template in a function</h3><p>Now let’s return to the challenge of making our <code>max()</code> function work with different types. Because the compiler treats <code>Pair<int></int></code> and <code>Pair<double></double></code> as separate types, we could use overloaded functions that are differentiated by parameter type:</p><pre class="language-cpp line-numbers"><code>constexpr int max(Pair<int> p)</int></code><code>{</code><code>    return (p.first &gt; p.second ? p.first : p.second);</code><code>}</code><code></code><code>constexpr double max(Pair<double> p) // okay: overloaded function differentiated by parameter type</double></code><code>{</code><code>    return (p.first &gt; p.second ? p.first : p.second);</code><code>}</code></pre><p>While this compiles, it doesn’t solve the redundancy problem. What we really want is a function that can take a pair of any type. In other words, we want a function that takes a parameter of type <code>Pair<t></t></code>, where T is a template type parameter. And that means we need a function template for this job!</p><p>Here’s a full example, with <code>max()</code> being implemented as a function template:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>struct Pair</code><code>{</code><code>    T first{};</code><code>    T second{};</code><code>};</code><code></code><code>template <typename t=""></typename></code><code>constexpr T max(Pair<t> p)</t></code><code>{</code><code>    return (p.first &gt; p.second ? p.first : p.second);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Pair<int> p1{ 5, 6 };</int></code><code>    std::cout &lt;&lt; max<int>(p1) &lt;&lt; " is larger\n"; // explicit call to max<int></int></int></code><code></code><code>    Pair<double> p2{ 1.2, 3.4 };</double></code><code>    std::cout &lt;&lt; max(p2) &lt;&lt; " is larger\n"; // call to max<double> using template argument deduction (prefer this)</double></code><code></code><code>    return 0;</code><code>}</code></pre><p>The <code>max()</code> function template is pretty straightforward. Because we want to pass in a <code>Pair<t></t></code>, we need the compiler to understand what <code>T</code> is. Therefore, we need to start our function with a template parameter declaration that defines template type T. We can then use <code>T</code> as both our return type, and as the template type for <code>Pair<t></t></code>.</p><p>When the <code>max()</code> function is called with a <code>Pair<int></int></code> argument, the compiler will instantiate the function <code>int max<int>(Pair<int>)</int></int></code> from the function template, where template type <code>T</code> is replaced with <code>int</code>. The following snippet shows what the compiler actually instantiates in such a case:</p><pre class="language-cpp line-numbers"><code>template &lt;&gt;</code><code>constexpr int max(Pair<int> p)</int></code><code>{</code><code>    return (p.first &gt; p.second ? p.first : p.second);</code><code>}</code></pre><p>As with all calls to a function template, we can either be explicit about the template type argument (e.g. <code>max<int>(p1)</int></code>) or we can be implicitly (e.g. <code>max(p2)</code>) and let the compiler use template argument deduction to determine what the template type argument should be.</p><br><h3>Class templates with template type and non-template type members</h3><p>Class templates can have some members using a template type and other members using a normal (non-template) type. For example:</p><pre class="language-cpp line-numbers"><code>template <typename t=""></typename></code><code>struct Foo</code><code>{</code><code>    T first{};    // first will have whatever type T is replaced with</code><code>    int second{}; // second will always have type int, regardless of what type T is</code><code>};</code></pre><p>This works exactly like you’d expect: <code>first</code> will be whatever the template type <code>T</code> is, and <code>second</code> will always be an <code>int</code>.</p><br><h3>Class templates with multiple template types</h3><p>Class templates can also have multiple template types. For example, if we wanted the two members of our <code>Pair</code> class to be able to have different types, we can define our <code>Pair</code> class template with two template types:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t,="" typename="" u=""></typename></code><code>struct Pair</code><code>{</code><code>    T first{};</code><code>    U second{};</code><code>};</code><code></code><code>template <typename t,="" typename="" u=""></typename></code><code>void print(Pair<t, u=""> p)</t,></code><code>{</code><code>    std::cout &lt;&lt; '[' &lt;&lt; p.first &lt;&lt; ", " &lt;&lt; p.second &lt;&lt; ']';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Pair<int, double=""> p1{ 1, 2.3 }; // a pair holding an int and a double</int,></code><code>    Pair<double, int=""> p2{ 4.5, 6 }; // a pair holding a double and an int</double,></code><code>    Pair<int, int=""> p3{ 7, 8 };      // a pair holding two ints</int,></code><code></code><code>    print(p2);</code><code></code><code>    return 0;</code><code>}</code></pre><p>To define multiple template types, in our template parameter declaration, we separate each of our desired template types with a comma. In the above example we define two different template types, one named <code>T</code>, and one named <code>U</code>. The actual template type arguments for <code>T</code> and <code>U</code> can be different (as in the case of <code>p1</code> and <code>p2</code> above) or the same (as in the case of <code>p3</code>).</p><br><h3>std::pair</h3><p>Because working with pairs of data is common, the C++ standard library contains a class template named <code>std::pair</code> (in the <code><utility></utility></code> header) that is defined identically to the <code>Pair</code> class template with multiple template types in the preceding section. In fact, we can swap out the <code>pair</code> struct we developed for <code>std::pair</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <utility></utility></code><code></code><code>template <typename t,="" typename="" u=""></typename></code><code>void print(std::pair<t, u=""> p)</t,></code><code>{</code><code>    std::cout &lt;&lt; '[' &lt;&lt; p.first &lt;&lt; ", " &lt;&lt; p.second &lt;&lt; ']';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::pair<int, double=""> p1{ 1, 2.3 }; // a pair holding an int and a double</int,></code><code>    std::pair<double, int=""> p2{ 4.5, 6 }; // a pair holding a double and an int</double,></code><code>    std::pair<int, int=""> p3{ 7, 8 };      // a pair holding two ints</int,></code><code></code><code>    print(p2);</code><code></code><code>    return 0;</code><code>}</code></pre><p>We developed our own <code>Pair</code> class in this lesson to show how things work, but in real code, you should favor <code>std::pair</code> over writing your own.</p><br><h3>Using class templates in multiple files</h3><p>Just like function templates, class templates are typically defined in header files so they can be included into any code file that needs them. Both template definitions and type definitions are exempt from the one-definition rule, so this won’t cause problems:</p><p>pair.h:</p><pre class="language-cpp line-numbers"><code>#ifndef PAIR_H</code><code>#define PAIR_H</code><code></code><code>template <typename t=""></typename></code><code>struct Pair</code><code>{</code><code>    T first{};</code><code>    T second{};</code><code>};</code><code></code><code>template <typename t=""></typename></code><code>constexpr T max(Pair<t> p)</t></code><code>{</code><code>    return (p.first &gt; p.second ? p.first : p.second);</code><code>}</code><code></code><code>#endif</code></pre><p>foo.cpp:</p><pre class="language-cpp line-numbers"><code>#include "pair.h"</code><code>#include <iostream></iostream></code><code></code><code>void foo()</code><code>{</code><code>    Pair<int> p1{ 1, 2 };</int></code><code>    std::cout &lt;&lt; max(p1) &lt;&lt; " is larger\n";</code><code>}</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include "pair.h"</code><code>#include <iostream></iostream></code><code></code><code>void foo(); // forward declaration for function foo()</code><code></code><code>int main()</code><code>{</code><code>    Pair<double> p2 { 3.4, 5.6 };</double></code><code>    std::cout &lt;&lt; max(p2) &lt;&lt; " is larger\n";</code><code></code><code>    foo();</code><code></code><code>    return 0;</code><code>}</code></pre></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">10.11 — Class template argument deduction (CTAD) and deduction guides</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Class template argument deduction (CTAD) C++17 </h3><p>Starting in C++17, when instantiating an object from a class template, the compiler can deduce the template types from the types of the object’s initializer (this is called <span class="cpp-definition">class template argument deduction</span> or <span class="cpp-definition">CTAD</span> for short). For example:</p><pre class="language-cpp line-numbers"><code>#include <utility> // for std::pair</utility></code><code></code><code>int main()</code><code>{</code><code>    std::pair<int, int=""> p1{ 1, 2 }; // explicitly specify class template std::pair<int, int=""> (C++11 onward)</int,></int,></code><code>    std::pair p2{ 1, 2 };           // CTAD used to deduce std::pair<int, int=""> from the initializers (C++17)</int,></code><code></code><code>    return 0;</code><code>}</code></pre><p>CTAD is only performed if no template argument list is present. Therefore, both of the following are errors:</p><pre class="language-cpp line-numbers"><code>#include <utility> // for std::pair</utility></code><code></code><code>int main()</code><code>{</code><code>    std::pair&lt;&gt; p1 { 1, 2 };    // error: too few template arguments, both arguments not deduced</code><code>    std::pair<int> p2 { 3, 4 }; // error: too few template arguments, second argument not deduced</int></code><code></code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>Many future lessons on this site make use of CTAD. If you’re compiling these examples using the C++14 standard, you’ll get an error about missing template arguments. You’ll need to explicitly add such arguments to the example to make it compile.</p></div><br><h3>Template argument deduction guides C++17 </h3><p>In most cases, CTAD works right out of the box. However, in certain cases, the compiler may need a little extra help understanding how to deduce the template arguments properly.</p><p>You may be surprised to find that the following program (which is almost identical to the example that uses <code>std::pair</code> above) doesn’t compile in C++17:</p><pre class="language-cpp line-numbers"><code>// define our own Pair type</code><code>template <typename t,="" typename="" u=""></typename></code><code>struct Pair</code><code>{</code><code>    T first{};</code><code>    U second{};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Pair<int, int=""> p1{ 1, 2 }; // ok: we're explicitly specifying the template arguments</int,></code><code>    Pair p2{ 1, 2 };           // compile error in C++17</code><code></code><code>    return 0;</code><code>}</code></pre><p>If you compile this in C++17, you’ll likely get some error about “class template argument deduction failed” or “cannot deduce template arguments” or “No viable constructor or deduction guide”. This is because in C++17, CTAD doesn’t know how to deduce the template arguments for aggregate class templates. To address this, we can provide the compiler with a <span class="cpp-definition">deduction guide</span>, which tells the compiler how to deduce the template arguments for a given class template.</p><p>Here’s the same program with a deduction guide:</p><pre class="language-cpp line-numbers"><code>template <typename t,="" typename="" u=""></typename></code><code>struct Pair</code><code>{</code><code>    T first{};</code><code>    U second{};</code><code>};</code><code></code><code>// Here's a deduction guide for our Pair</code><code>// Pair objects initialized with arguments of type T and U should deduce to Pair<t, u=""></t,></code><code>template <typename t,="" typename="" u=""></typename></code><code>Pair(T, U) -&gt; Pair<t, u="">;</t,></code><code>    </code><code>int main()</code><code>{</code><code>    Pair<int, int=""> p1{ 1, 2 }; // explicitly specify class template Pair<int, int=""> (C++11 onward)</int,></int,></code><code>    Pair p2{ 1, 2 };     // CTAD used to deduce Pair<int, int=""> from the initializers (C++17)</int,></code><code></code><code>    return 0;</code><code>}</code></pre><p>This example should compile under C++17.</p><p>The deduction guide for our <code>Pair</code> class is pretty simple, but let’s take a closer look at how it works.</p><pre class="language-cpp line-numbers"><code>// Here's a deduction guide for our Pair</code><code>// Pair objects initialized with arguments of type T and U should deduce to Pair<t, u=""></t,></code><code>template <typename t,="" typename="" u=""></typename></code><code>Pair(T, U) -&gt; Pair<t, u="">;</t,></code></pre><p>First, we use the same template type definition as in our <code>Pair</code> class. This makes sense, because if our deduction guide is going to tell the compiler how to deduce the types for a <code>Pair<t, u=""></t,></code>, we have to define what <code>T</code> and <code>U</code> are (template types). Second, on the right hand side of the arrow, we have the type that we’re helping the compiler to deduce. In this case, we want the compiler to be able to deduce template arguments for objects of type <code>Pair<t, u=""></t,></code>, so that’s exactly what we put here. Finally, on the left side of the arrow, we tell the compiler what kind of declaration to look for. In this case, we’re telling it to look for a declaration of some object named <code>Pair</code> with two arguments (one of type <code>T</code>, the other of type <code>U</code>). We could also write this as <code>Pair(T t, U u)</code> (where <code>t</code> and <code>u</code> are the names of the parameters, but since we don’t use <code>t</code> and <code>u</code>, we don’t need to give them names).</p><p>Putting it all together, we’re telling the compiler that if it sees a declaration of a <code>Pair</code> with two arguments (of types <code>T</code> and <code>U</code> respectively), it should deduce the type to be a <code>Pair<t, u=""></t,></code>.</p><p>So when the compiler sees the definition <code>Pair p2{ 1, 2 };</code> in our program, it will say, “oh, this is a declaration of a <code>Pair</code> and there are two arguments of type <code>int</code> and <code>int</code>, so using the deduction guide, I should deduce this to be a <code>Pair<int, int=""></int,></code>“.</p><p>Here’s a similar example for a Pair that takes a single template type:</p><pre class="language-cpp line-numbers"><code>template <typename t=""></typename></code><code>struct Pair</code><code>{</code><code>    T first{};</code><code>    T second{};</code><code>};</code><code></code><code>// Here's a deduction guide for our Pair</code><code>// pair objects initialized with arguments of type T and T should deduce to Pair<t></t></code><code>template <typename t=""></typename></code><code>Pair(T, T)-&gt;Pair<t>;</t></code><code></code><code>int main()</code><code>{</code><code>    Pair<int> p1{ 1, 2 }; // explicitly specify class template Pair<int> (C++11 onward)</int></int></code><code>    Pair p2{ 1, 2 };     // CTAD used to deduce Pair<int, int=""> from the initializers (C++17)</int,></code><code></code><code>    return 0;</code><code>}</code></pre><p>In this case, our deduction guide maps a <code>Pair(T, T)</code> (a <code>Pair</code> with two arguments of type <code>T</code>) to a <code>Pair<t></t></code>.</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>A few notes about deduction guides.</p><p>First, <code>std::pair</code> (and other standard library template types) come with pre-defined deduction guides. This is why our example above that uses <code>std::pair</code> compiles fine in C++17 without us having to provide deduction guides ourselves.</p><p>Second, C++20 added the ability for the compiler to automatically generate deduction guides for aggregate class types, so the version of <code>Pair</code> without the deduction guides should compile in C++20. This assumes your compiler supports feature P1816, which as of the time of writing, gcc and Visual Studio do, and Clang does not.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">10.x — Chapter 10 summary and quiz</h1></header><div class="entry-content" itemprop="articleBody"><p>Congrats! You made it through another one. The knowledge you gained regarding structs will be useful when we get to C++’s most important topic -- classes!</p><br><h3>Quick review</h3><p>A <span class="cpp-definition">program-defined type</span> (also called a <span class="cpp-definition">user-defined type</span>) is a custom type that we can create for use in our own programs. The enumerated types and class types (including structs, classes and unions) allow for creation of program-defined types. Program-defined types must be defined before they can be used. The definition of a program-defined type is called a <span class="cpp-definition">type definition</span>. Type definitions are exempt from the one-definition rule.</p><p>An <span class="cpp-definition">enumeration</span> (also called an <span class="cpp-definition">enumerated type</span> or an <span class="cpp-definition">enum</span>) is a compound data type where every possible value is defined as a symbolic constant (called an <span class="cpp-definition">enumerator</span>). Enumerators are <span class="cpp-definition">distinct types</span>, meaning the compiler can differentiate it from other types (unlike type aliases).</p><p><span class="cpp-definition">Unscoped enumerations</span> are named such because they put their enumerator names into the same scope as the enumeration definition itself (as opposed to creating a new scope region like a namespace does). Unscoped enumerations also provide a named scope region for their enumerators. Unscoped enumerations will implicitly convert to integral values.</p><p><span class="cpp-definition">Scoped enumerations</span> work similarly to unscoped enumerations but are strongly typed (they won’t implicitly convert to integers) and strongly scoped (the enumerators are only placed into the scope region of the enumeration).</p><p>A <span class="cpp-definition">struct</span> (short for <span class="cpp-definition">structure</span>) is a program-defined data type that allows us to bundle multiple variables together into a single type. The variables that are part of the struct (or class) are called <span class="cpp-definition">data members</span> (or <span class="cpp-definition">member variables</span>). To access a specific member variable, we use the <span class="cpp-definition">member selection operator</span> (<code>operator.</code>) in between the struct variable name and the member name (for normal structs and references to structs), or the <span class="cpp-definition">member selection from pointer operator</span> (<code>operator-&gt;</code>) (for pointers to structs).</p><p>In general programming, an <span class="cpp-definition">aggregate data type</span> (also called an <span class="cpp-definition">aggregate</span>) is any type that can contain multiple data members. In C++, arrays and structs with only data members are <span class="cpp-definition">aggregates</span>.</p><p>Aggregates use a form of initialization called <span class="cpp-definition">aggregate initialization</span>, which allows us to directly initialize the members of aggregates. To do this, we provide an <span class="cpp-definition">initializer list</span> as an initializer, which is just a list of comma-separated values. Aggregate initialization does a <span class="cpp-definition">memberwise initialization</span>, which means each member in the struct is initialized in the order of declaration.</p><p>In C++20, <span class="cpp-definition">Designated initializers</span> allow you to explicitly define which initialization values map to which members. The members must be initialized in the order in which they are declared in the struct, otherwise an error will result.</p><p>When we define a struct (or class) type, we can provide a default initialization value for each member as part of the type definition. This process is called <span class="cpp-definition">non-static member initialization</span>, and the initialization value is called a <span class="cpp-definition">default member initializer</span>.</p><p>For performance reasons, the compiler will sometimes add gaps into structures (this is called <span class="cpp-definition">padding</span>), so the size of a structure may be larger than the sum of the size of its members.</p><p>A <span class="cpp-definition">class template</span> is a template definition for instantiating class types (structs, classes, or unions). <span class="cpp-definition">Class template argument deduction (CTAD)</span> is a C++17 feature that allows the compiler to deduce the template type arguments from an initializer.</p><br><h3>Quiz time</h3><p>Yay!</p><p class="cpp-quiz-question" style="clear:both">Question #1</p><p>In designing a game, we decide we want to have monsters, because everyone likes fighting monsters. Declare a struct that represents your monster. The monster should have a type that can be one of the following: an ogre, a dragon, an orc, a giant spider, or a slime. Use an enum class for this.</p><p>Each individual monster should also have a name (use a <code>std::string</code> or <code>std::string_view</code>), as well as an amount of health that represents how much damage they can take before they die. Write a function named printMonster() that prints out all of the struct’s members. Instantiate an ogre and a slime, initialize them using an initializer list, and pass them to printMonster().</p><p>Your program should produce the following output:</p><pre>This Ogre is named Torg and has 145 health.
This Slime is named Blurp and has 23 health.
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view> // C++17</string_view></code><code></code><code>// Define our different monster types as an enum</code><code>enum class MonsterType</code><code>{</code><code>	ogre,</code><code>	dragon,</code><code>	orc,</code><code>	giant_spider,</code><code>	slime</code><code>};</code><code></code><code>// Our monster struct represents a single monster</code><code>struct Monster</code><code>{</code><code>	MonsterType type{};</code><code>	std::string name{};</code><code>	int health{};</code><code>};</code><code></code><code>// Return the name of the monster's type as a string</code><code>// Since this could be used elsewhere, it's better to make this its own function</code><code>constexpr std::string_view getMonsterTypeString(MonsterType type)</code><code>{</code><code>	switch (type)</code><code>	{</code><code>	case MonsterType::ogre:          return "Ogre";</code><code>	case MonsterType::dragon:        return "Dragon";</code><code>	case MonsterType::orc:           return "Orc";</code><code>	case MonsterType::giant_spider:  return "Giant Spider";</code><code>	case MonsterType::slime:         return "Slime";</code><code>	}</code><code></code><code>	return "Unknown";</code><code>}</code><code></code><code>// Print our monster's stats</code><code>void printMonster(const Monster&amp; monster)</code><code>{</code><code>	std::cout &lt;&lt; "This " &lt;&lt; getMonsterTypeString(monster.type) &lt;&lt;</code><code>		" is named " &lt;&lt; monster.name &lt;&lt;</code><code>		" and has " &lt;&lt; monster.health &lt;&lt; " health.\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Monster ogre{ MonsterType::ogre, "Torg", 145 };</code><code>	Monster slime{ MonsterType::slime, "Blurp", 23 };</code><code></code><code>	printMonster(ogre);</code><code>	printMonster(slime);</code><code></code><code>	return 0;</code><code>}</code></pre></div><p class="cpp-quiz-question cpp-topline" style="clear:both">Question #2</p><p>Specify whether objects of each of the given types should be passed by value, const address, or const reference. You can assume the function that takes these types as parameters doesn’t modify them.</p><p>a) <code>char</code></p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p><code>char</code> is a fundamental type, so it should be passed by value.</p></div><p>b) <code>std::string</code></p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p><code>std::string</code> has to create a copy of the string whenever it is copied. Pass it by const reference.</p></div><p>c) <code>unsigned long</code></p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><p><code>unsigned long</code> is a fundamental type, so it should be passed by value.</p></div><p>d) <code>bool</code></p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><p><code>bool</code> is a fundamental type, so it should be passed by value.</p></div><p>e) An enumerated type</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><p>Enumerated types hold integral values (usually int). Since integral values are passed by value, enumerated types should be passed by value.</p></div><p>f)</p><pre class="language-cpp line-numbers"><code>struct Position</code><code>{</code><code>  double x{};</code><code>  double y{};</code><code>  double z{};</code><code>};</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none"><p><code>Position</code> is a struct type and should be passed by const reference.</p></div><p>g)</p><pre class="language-cpp line-numbers"><code>struct Player</code><code>{</code><code>  int health{};</code><code>  // The Player struct is still under development.  More members will be added.</code><code>};</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_7'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_7" style="display:none"><p>Although <code>Player</code> only contains a single <code>int</code> in its current state, which would make it fast to pass by value, more members will be added in the future. We don’t want to update every use of <code>Player</code> when that happens, so we pass it by const reference.</p></div><p>h) an object whose address is held in an <code>int*</code></p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_8'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_8" style="display:none"><p><code>int*</code> is a pointer, so it should be passed by address.</p></div><p>i) <code>std::string_view</code></p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_9'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_9" style="display:none"><p><code>std::string_view</code> does not create a copy of the string being viewed, and it is cheap to copy. Pass by value.</p></div><p class="cpp-quiz-question cpp-topline" style="clear:both">Question #3</p><p>Create a class template named <code>Triad</code> that has 3 members of the same template type. The following program should compile:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	Triad t1{ 1, 2, 3 }; // note: uses CTAD to deduce template arguments</code><code>	print(t1);</code><code></code><code>	Triad t2{ 1.2, 3.4, 5.6 }; // note: uses CTAD to deduce template arguments</code><code>	print(t2);</code><code></code><code>	return 0;</code><code>}</code></pre><p>and produce the following result:</p><pre>[1, 2, 3][1.2, 3.4, 5.6]
</pre><p>If you are using C++17, you will need to provide a deduction guide for CTAD to work (see <a href="https://www.learncpp.com/cpp-tutorial/class-template-argument-deduction-ctad-and-deduction-guides/">10.11 -- Class template argument deduction (CTAD) and deduction guides</a> for information on that).</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_10'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_10" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>struct Triad</code><code>{</code><code>	T first;</code><code>	T second;</code><code>	T third;</code><code>};</code><code></code><code>// If using C++17, we need to provide a deduction guide (not required in C++20)</code><code>// A Triad with three arguments of the same type should deduce to a Triad<t></t></code><code>template <typename t=""></typename></code><code>Triad(T, T, T) -&gt; Triad<t>;</t></code><code></code><code>template <typename t=""></typename></code><code>void print(const Triad<t>&amp; t)</t></code><code>{</code><code>	std::cout &lt;&lt; '[' &lt;&lt; t.first &lt;&lt; ", " &lt;&lt; t.second &lt;&lt; ", " &lt;&lt; t.third &lt;&lt; ']';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Triad t1{ 1, 2, 3 };</code><code>	print(t1);</code><code></code><code>	Triad t2{ 1.2, 3.4, 5.6 };</code><code>	print(t2);</code><code></code><code>	return 0;</code><code>}</code></pre></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">10.y — Using a language reference</h1></header><div class="entry-content" itemprop="articleBody"><p>Depending on where you’re at in your journey with learning programming languages (and specifically, C++), LearnCpp.com might be the only resource you’re using to learn C++ or to look something up. LearnCpp.com is designed to explain concepts in a beginner-friendly fashion, but it simply can’t cover every aspect of the language. As you begin to explore outside the topics that these tutorials cover, you’ll inevitably run into questions that these tutorials don’t answer. In that case, you’ll need to leverage outside resources.</p><p>One such resource is <a href="https://stackoverflow.com">Stack Overflow</a>, where you can ask questions (or better, read the answer to the same question someone before you asked). But sometimes a better first stop is a reference guide. Unlike tutorials, which tend to focus on the most important topics and use informal/common language to make learning easier, reference guides describe C++ precisely using formal terminology. Because of this, reference material tends to be comprehensive, accurate, and… hard to understand.</p><p>In this lesson, we’ll show how to use <a href="https://cppreference.com">cppreference</a>, a popular standard reference that we refer to throughout the lessons, by researching 3 examples.</p><br><h3>Overview</h3><p>Cppreference greets you with an <a href="https://en.cppreference.com/w/cpp">overview</a> of the core language and libraries:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/overview-min.png?ezimgfmt=rs%3Adevice%2Frscb2-1" alt="cppreference overview" ezimgfmt="rs rscb2 src ng ngcb2" loading="eager" srcset="" sizes="" importance="high"></div><p>From here, you can get to everything cppreference has to offer, but it’s easier to use the search function, or a search engine. The overview is a great place to visit once you’ve finished the tutorials on LearnCpp.com, to delve deeper into the libraries, and to see what else the language has to offer that you might not be aware of.</p><p>The upper half of the table shows features currently in the language, while the bottom half shows technical specifications, which are features that may or may not be added to C++ in a future version, or have already been partially accepted into the language. This can be useful if you want to see what new capabilities are coming soon.</p><p>Starting with C++11, cppreference marks all features with the language standard version they’ve been added in. The standard version is the little green number you can see next to some of the links in the above image. Features without a version number have been available since C++98/03. The version numbers are not only in the overview, but everywhere on cppreference, letting you know exactly what you can or cannot use in a specific C++ version.</p><div class="cpp-note cpp-lightgraybackground"><h4>A reminder</h4><p>The C++ versions are C++98, C++03, C++11, C++14, C++17, C++20. C++23 is the informal name for the next planned iteration.</p></div><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>If you use a search engine and a technical specification has just been accepted into the standard, you might get linked to a technical specification rather than the official reference, which can differ.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>Cppreference is not only a reference for C++, but also for C. Since C++ shares some functions with C (which can differ), you may find yourself in the C reference after searching for something. The URL and the navigation bar at the top of cppreference always show you if you’re browsing the C or C++ reference.</p></div><br><h3>std::string::length</h3><p>We’ll start by researching a function that you know from a previous lesson, <code>std::string::length</code>, which returns the length of a string.</p><p>On the top right of cppreference, search for “string”. Doing so shows a long list of types and functions, of which only the top is relevant for now.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/string-search-ddg-min.png" alt="string search" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/string-search-ddg-min.png"></div><p>We could have searched for “string length” right away, but for the purpose of showing as much as possible in this lesson, we’re taking the long route. Clicking on “Strings library” takes us to a page talking about the various kinds of strings that C++ supports.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/strings-lib-min.png" alt="strings library page" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/strings-lib-min.png"></div><p>If we look under the “std::basic_string” section, we can see a list of typedefs, and within that list is std::string.</p><p>Clicking on “std::string” leads to the page for <a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::basic_string</code></a>. There is no page for <code>std::string</code>, because <code>std::string</code> is a <code>typedef</code> for <code>std::basic_string<char></char></code>, which again can be seen in the <code>typedef</code> list:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/typedef-min.png" alt="typedef" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/typedef-min.png"></div><p>The <code><char></char></code> means that each character of the string is of type <code>char</code>. You’ll note that C++ offers other strings that use different character types. These can be useful when using Unicode instead of ASCII.</p><p>Further down the same page, there’s a <a href="https://en.cppreference.com/w/cpp/string/basic_string#Member_functions">list of member functions</a> (the behaviors that a type has). If you want to know what you can do with a type, this list is very convenient. In this list, you’ll find a row for <code>length</code> (and <code>size</code>).</p><p>Following the link brings us to the detailed function description of <a href="https://en.cppreference.com/w/cpp/string/basic_string/size"><code>length</code> and <code>size</code></a>, which both do the same thing.</p><p>The top of each page starts with a short summary of the feature and syntax, overloads, or declarations:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/string-length-overloads-min.png" alt="string length overloads" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/string-length-overloads-min.png"></div><p>The title of the page shows the name of the class and function with all template parameters. We can ignore this part. Below the title, we see all of the different function overloads (different versions of the function that share the same name) and which language standard they apply to.</p><p>Below that, we can see the parameters that the function takes, and what the return value means.</p><p>Because <code>std::string::length</code> is a simple function, there’s not a lot of content on this page. Many pages show example uses of the feature they’re documenting, as does this one:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/string-length-example-min.png" alt="string length example" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/string-length-example-min.png"></div><p>Until you’re done learning C++, there will be features in the examples that you haven’t seen before. If there are enough examples, you’re probably able to understand a sufficient amount of it to get an idea of how the function is used and what it does. If the example is too complicated, you can search for an example somewhere else or read the reference of the parts you don’t understand (you can click on functions and types in the examples to see what they do).</p><p>Now we know what <code>std::string::length</code> does, but we knew that before. Let’s have a look at something new!</p><br><h3>std::cin.ignore</h3><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/stdcin-and-handling-invalid-input/">7.16 -- std::cin and handling invalid input</a>, we talked about <code>std::cin.ignore</code>, which is used to ignore everything up to a line break. One of the parameters of this function is some long and verbose value. What was that again? Can’t you just use a big number? What does this argument do anyway? Let’s figure it out!</p><p>Typing “std::cin.ignore” into the cppreference search yields the following results:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/ignore-ddg-min.png" alt="Search engine results" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/ignore-ddg-min.png"></div><ul><li><code>std::cin, std::wcin</code> - We want <code>.ignore</code>, not plain <code>std::cin</code>.</li><li><code>std::basic_istream<chart,traits>::ignore</chart,traits></code> - Eew, what is this? Let’s skip for now.</li><li><code>std::ignore</code> - No, that’s not it.</li><li><code>std::basic_istream</code> - That’s not it either.</li></ul><p>It’s not there, what now? Let’s go to <a href="https://en.cppreference.com/w/cpp/io/cin"><code>std::cin</code></a> and work our way from there. There’s nothing immediately obvious on that page. On the top, we can see the declaration of <code>std::cin</code> and <code>std::wcin</code>, and it tells us which header we need to include to use <code>std::cin</code>:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/cintop-min.png" alt="Declaration" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/cintop-min.png"></div><p>We can see that <code>std::cin</code> is an object of type <code>std::istream</code>. Let’s follow the link to <a href="https://en.cppreference.com/w/cpp/io/basic_istream"><code>std::istream</code></a>:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/basic_istream-min.png" alt="basic_istream" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/basic_istream-min.png"></div><p>Hold up! We’ve seen <code>std::basic_istream</code> before when we searched for “std::cin.ignore” in our search engine. It turns out that <code>istream</code> is a typedef for <code>basic_istream</code>, so maybe our search wasn’t so wrong after all.</p><p>Scrolling down on that page, we’re greeted with familiar functions:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/members-min.png" alt="Member functions" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/members-min.png"></div><p>We’ve used many of these functions already: <code>operator&gt;&gt;</code>, <code>get</code>, <code>getline</code>, <code>ignore</code>. Scroll around on that page to get an idea of what else there is in <code>std::cin</code>. Then click <a href="https://en.cppreference.com/w/cpp/io/basic_istream/ignore"><code>ignore</code></a>, since that’s what we’re interested in.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/ignore-top-min.png" alt="ignore" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/ignore-top-min.png"></div><p>On the top of the page there’s the function signature and a description of what the function and its two parameters do. The <code>=</code> signs after the parameters indicate a <span class="cpp-definition">default argument</span> (we cover this in lesson <a href="https://www.learncpp.com/cpp-tutorial/default-arguments/">8.12 -- Default arguments</a>). If we don’t provide an argument for a parameter that has a default value, the default value is used.</p><p>The first bullet point answers all of our questions. We can see that <code>std::numeric_limits<std::streamsize>::max()</std::streamsize></code> has special meaning to <code>std::cin.ignore</code>, in that it disables the character count check. This means <code>std::cin.ignore</code> will continue ignoring characters until it finds the delimiter, or until it runs out of characters to look at.</p><p>Many times, you don’t need to read the entire description of a function if you already know it but forgot what the parameters or return value mean. In such situations, reading the parameter or return value description suffices.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/parameters-return-min.png" alt="Parameters and return value" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/parameters-return-min.png"></div><p>The parameter description is brief. It doesn’t contain the special handling of <code>std::numeric_limits<std::streamsize>::max()</std::streamsize></code> or the other stop conditions, but serves as a good reminder.</p><br><h3>A language grammar example</h3><p>Alongside the standard library, cppreference also documents the language grammar. Here’s a valid program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getUserInput()</code><code>{</code><code>  int i{};</code><code>  std::cin &gt;&gt; i;</code><code>  return i;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  std::cout &lt;&lt; "How many bananas did you eat today? \n";</code><code></code><code>  if (int iBananasEaten{ getUserInput() }; iBananasEaten &lt;= 2)</code><code>  {</code><code>    std::cout &lt;&lt; "Yummy\n";</code><code>  }</code><code>  else</code><code>  {</code><code>    std::cout &lt;&lt; iBananasEaten &lt;&lt; " is a lot!\n";</code><code>  }</code><code></code><code>  return 0;  </code><code>}</code></pre><p>Why is there a variable definition inside the condition of the <code>if-statement</code>? Let’s use cppreference to figure out what it does by searching for “cppreference if statement” in our favorite search engine. Doing so leads us to <a href="https://en.cppreference.com/w/cpp/language/if">if statements</a>. At the top, there’s a syntax reference.</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/syntax-min.png" alt="" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/syntax-min.png"></div><p>On the right, we can again see the version for which this syntax is relevant. Look at the version of the <code>if-statement</code> that is relevant since C++17. If you remove all of the optional parts, you get an <code>if-statement</code> that you already know. Before the <code>condition</code>, there’s an optional <code>init-statement</code>, that looks like what’s happening in the code above.</p><pre>if ( init-statement condition ) statement-true
if ( init-statement condition ) statement-true else statement-false
</pre><p>Below the syntax reference, there’s an explanation of each part of the syntax, including the <code>init-statement</code>. It says that the <code>init-statement</code> is typically a declaration of a variable with an initializer.</p><p>Following the syntax is an explanation of <code>if-statements</code> and simple examples:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/explanation-min.png" alt="Explanation on examples" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/explanation-min.png"></div><p>We already know how <code>if-statements</code> work, and the examples don’t include an <code>init-statement</code>, so we scroll down a little to find a section dedicated to <code>if-statements</code> with initializers:</p><div class="cpp-image-wrapper"><img src="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/if-init-min.png" alt="If Statements with Initializer" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/blog/wp-content/uploads/images/CppTutorial/cppreference/if-init-min.png"></div><p>First, it is shown how the <code>init-statement</code> can be written without actually using an <code>init-statement</code>. Now we know what the code in question is doing. It’s a normal variable declaration, just merged into the <code>if-statement</code>.</p><p>The sentence after that is interesting, because it lets us know that the names from the <code>init-statement</code> are available in <em>both</em> statements (<code>statement-true</code> and <code>statement-false</code>). This may be surprising, since you might otherwise assume the variable is only available in the <code>statement-true</code>.</p><p>The <code>init-statement</code> examples use features and types that we haven’t covered yet. You don’t have to understand everything you see to understand how the <code>init-statement</code> works. Let’s skip everything that’s too confusing until we find something we can work with:</p><pre class="language-cpp line-numbers"><code>// Iterators, we don't know them. Skip.</code><code>if (auto it = m.find(10); it != m.end()) { return it-&gt;second.size(); }</code><code></code><code>// [10], what's that? Skip.</code><code>if (char buf[10]; std::fgets(buf, 10, stdin)) { m[0] += buf; }</code><code></code><code>// std::lock_guard, we don't know that, but it's some type. We know what types are!</code><code>if (std::lock_guard lock(mx); shared_flag) { unsafe_ping(); shared_flag = false; }</code><code></code><code>// This is easy, that's an int!</code><code>if (int s; int count = ReadBytesWithSignal(&amp;s)) { publish(count); raise(s); }</code><code></code><code>// Whew, no thanks!</code><code>if (auto keywords = {"if", "for", "while"};</code><code>    std::any_of(keywords.begin(), keywords.end(),</code><code>                [&amp;s](const char* kw) { return s == kw; })) {</code><code>  std::cerr &lt;&lt; "Token must not be a keyword\n";</code><code>}</code></pre><p>The easiest example seems to be the one with an <code>int</code>. Then we look after the semicolon and there’s another definition, odd… Let’s go back to the <code>std::lock_guard</code> example.</p><pre class="language-cpp line-numbers"><code>if (std::lock_guard lock(mx); shared_flag)</code><code>{</code><code>  unsafe_ping();</code><code>  shared_flag = false;</code><code>}</code></pre><p>From this, it’s relatively easy to see how an <code>init-statement</code> works. Define some variable (<code>lock</code>), then a semicolon, then the condition. That’s exactly what happened in our example.</p><br><h3>A warning about the accuracy of cppreference</h3><p>Cppreference is not an official documentation source -- rather, it is a wiki. With wikis, anyone can add and modify content -- the content is sourced from the community. Although this means that it’s easy for someone to add wrong information, that misinformation is typically quickly caught and removed, making cppreference a reliable source.</p><p>The only official source for C++ is <a href="https://isocpp.org/std/the-standard">the standard</a> (Free drafts on <a href="https://github.com/cplusplus/draft/tree/master/papers">github</a>), which is a formal document and not easily usable as a reference.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>What does the following program print? Don’t run it, use a reference to figure out what <code>erase</code> does.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>  std::string str{ "The rice is cooking" };</code><code></code><code>  str.erase(4, 11);</code><code></code><code>  std::cout &lt;&lt; str &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>When you find <code>erase</code> on cppreference, you can ignore the function signatures (2) and (3).</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>Indexes in C++ start at 0. The character at index 0 in the string “House” is ‘H’, at 1 it’s ‘o’, and so on.</p></div><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre>The king
</pre><p>Here’s how you’d get there by using the search function on cppreference (you might have skipped the first step by using a search engine):</p><p><a href="https://en.cppreference.com/mwiki/index.php?title=Special%3ASearch&amp;search=string&amp;button=">Searching for string</a> and clicking “std::string” leads us to <a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::basic_string</code></a>.</p><p>Scrolling to the “Member functions” list, we find <a href="https://en.cppreference.com/w/cpp/string/basic_string/erase">erase</a>. As hinted in the tip above, the first <span class="cpp-definition">function overload</span> is used. It takes 2 <code>size_type</code> (Unsigned integer type) arguments. In our example, 4 and 11. According to the description of (1), it removes “<code>min(count, size() - index)</code> characters starting at <code>index</code>“. Plugging in our arguments, it removes <code>min(11, 19 - 4) = 11</code> characters starting at index 4.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>In the following code, modify <code>str</code> so that its value is “I saw a blue car yesterday” without repeating the string. For example, don’t do this:</p><pre class="language-cpp line-numbers"><code>str = "I saw a blue car yesterday.";</code></pre><p>You only need to call one function to <em>replace</em> “red” with “blue”.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>  std::string str{ "I saw a red car yesterday." };  </code><code></code><code>  // ...</code><code></code><code>  std::cout &lt;&lt; str &lt;&lt; '\n'; // I saw a blue car yesterday.</code><code></code><code>  return 0;</code><code>}</code></pre><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">Hint: <a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::basic_string</code></a></div><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_1'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_1" style="display:none;margin-bottom:1em">Hint: <a href="https://en.cppreference.com/w/cpp/string/basic_string#Member_functions">Member functions of <code>std::basic_string</code></a></div><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_2'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_2" style="display:none;margin-bottom:1em">Hint: <a href="https://en.cppreference.com/w/cpp/string/basic_string#Operations">Operations on <code>std::basic_string</code></a></div><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_3'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_3" style="display:none;margin-bottom:1em">Hint: <a href="https://en.cppreference.com/w/cpp/string/basic_string/replace"><code>std::basic_string::replace</code></a></div><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>  std::string str{ "I saw a red car yesterday." };  </code><code></code><code>  str.replace(8, 3, "blue");</code><code></code><code>  std::cout &lt;&lt; str &lt;&lt; '\n'; // I saw a blue car yesterday</code><code></code><code>  return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.1 — Arrays (Part I)</h1></header><div class="entry-content" itemprop="articleBody"><p>Note: This chapter is a bit harder than the previous ones. If you feel a little discouraged, stick with it. The best stuff is yet to come!</p><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-structs-members-and-member-selection/">10.5 -- Introduction to structs, members, and member selection</a>, you learned that you can use a struct to aggregate many different data types into one identifier. This is great for the case where we want to model a single object that has many different properties. However, this is not so great for the case where we want to track many related instances of something.</p><p>Fortunately, structs are not the only aggregate data type in C++. An <strong>array</strong> is an aggregate data type that lets us access many variables of the same type through a single identifier.</p><p>Consider the case where you want to record the test scores for 30 students in a class. Without arrays, you would have to allocate 30 almost-identical variables!</p><pre class="language-cpp line-numbers"><code>// allocate 30 integer variables (each with a different name)</code><code>int testScoreStudent1{};</code><code>int testScoreStudent2{};</code><code>int testScoreStudent3{};</code><code>// ...</code><code>int testScoreStudent30{};</code></pre><p>Arrays give us a much easier way to do this. The following array definition is essentially equivalent:</p><pre class="language-cpp line-numbers"><code>int testScore[30]{}; // allocate 30 integer variables in a fixed array</code></pre><p>In an array variable declaration, we use square brackets ([]) to tell the compiler both that this is an array variable (instead of a normal variable), as well as how many variables to allocate (called the <strong>array length</strong>).</p><p>In the above example, we declare a fixed array named testScore, with a length of 30. A <strong>fixed array</strong> (also called a <strong>fixed length array</strong> or <strong>fixed size array</strong>) is an array where the length is known at compile time. When testScore is instantiated, 30 integers will be allocated.</p><p><strong>Array elements and subscripting</strong></p><p>Each of the variables in an array is called an <strong>element</strong>. Elements do not have their own unique names. Instead, to access individual elements of an array, we use the array name, along with the <strong>subscript operator ([])</strong>, and a parameter called a <strong>subscript</strong> (or <strong>index</strong>) that tells the compiler which element we want. This process is called <strong>subscripting</strong> or <strong>indexing</strong> the array.</p><p>In the example above, the first element in our array is testScore[0]. The second is testScore[1]. The tenth is testScore[9]. The last element in our testScore array is testScore[29]. This is great because we no longer need to keep track of a bunch of different (but related) names -- we can just vary the subscript to access different elements.</p><p><em>Important: Unlike everyday life, where we typically count starting from 1, in C++, arrays always count starting from 0!</em></p><p>For an array of length N, the array elements are numbered 0 through N-1. This is called the array’s <strong>range</strong>.</p><p><strong>An example array program</strong></p><p>Here’s a sample program that puts together the definition and indexing of an array:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int prime[5]{}; // hold the first 5 prime numbers</code><code>    prime[0] = 2; // The first element has index 0</code><code>    prime[1] = 3;</code><code>    prime[2] = 5;</code><code>    prime[3] = 7;</code><code>    prime[4] = 11; // The last element has index 4 (array length-1)</code><code></code><code>    std::cout &lt;&lt; "The lowest prime number is: " &lt;&lt; prime[0] &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "The sum of the first 5 primes is: " &lt;&lt; prime[0] + prime[1] + prime[2] + prime[3] + prime[4] &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>The lowest prime number is: 2
The sum of the first 5 primes is: 28
</pre><p><strong>Array data types</strong></p><p>Arrays can be made from any data type. Consider the following example, where we declare an array of doubles:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    double batteryLifeInHours[3]{}; // allocate 3 doubles</code><code>    batteryLifeInHours[0] = 2.0;</code><code>    batteryLifeInHours[1] = 3.0;</code><code>    batteryLifeInHours[2] = 4.3;</code><code></code><code>    std::cout &lt;&lt; "The average battery life is " &lt;&lt; (batteryLifeInHours[0] + batteryLifeInHours[1] + batteryLifeInHours[2]) / 3.0 &lt;&lt; " hour(s)\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program produces the result:</p><pre>The average battery life is 3.1 hour(s)
</pre><p>Arrays can also be made from structs. Consider the following example:</p><pre class="language-cpp line-numbers"><code>struct Rectangle</code><code>{</code><code>    int length{};</code><code>    int width{};</code><code>};</code><code>Rectangle rects[5]{}; // declare an array of 5 Rectangle</code></pre><p>To access a struct member of an array element, first pick which array element you want, and then use the member selection operator to select the struct member you want:</p><pre class="language-cpp line-numbers"><code>rects[0].length = 24;</code></pre><p>Arrays can even be made from arrays, a topic that we’ll cover in a future lesson.</p><p><strong>Array subscripts</strong></p><p>In C++, array subscripts must always be an integral type. This includes char, short, int, long, long long, etc… and strangely enough, bool (where false gives an index of 0 and true gives an index of 1). An array subscript can be a literal value, a variable (constant or non-constant), or an expression that evaluates to an integral type.</p><p>Here are some examples:</p><pre class="language-cpp line-numbers"><code>int array[5]{}; // declare an array of length 5</code><code></code><code>// using a literal (constant) index:</code><code>array[1] = 7; // ok</code><code></code><code>// using an enum (constant) index</code><code>enum Animals</code><code>{</code><code>    animal_cat = 2</code><code>};</code><code>array[animal_cat] = 4; // ok</code><code></code><code>// using a variable (non-constant) index:</code><code>int index{ 3 };</code><code>array[index] = 7; // ok</code><code></code><code>// using an expression that evaluates to an integer index:</code><code>array[1+2] = 7; // ok</code></pre><p><strong>Fixed array declarations</strong></p><p>When declaring a fixed array, the length of the array (between the square brackets) must be a compile-time constant. This is because the length of a fixed array must be known at compile time. Here are some different ways to declare fixed arrays:</p><pre class="language-cpp line-numbers"><code>// using a literal constant</code><code>int numberOfLessonsPerDay[7]{}; // Ok</code><code></code><code>// using a constexpr symbolic constant</code><code>constexpr int daysPerWeek{ 7 };</code><code>int numberOfLessonsPerDay[daysPerWeek]{}; // Ok</code><code></code><code>// using an enumerator</code><code>enum DaysOfWeek</code><code>{</code><code>    monday,</code><code>    tuesday,</code><code>    wednesday,</code><code>    thursday,</code><code>    friday,</code><code>    saturday,</code><code>    sunday,</code><code>    </code><code>    maxDaysOfWeek</code><code>};</code><code>int numberOfLessonsPerDay[maxDaysOfWeek]{}; // Ok</code><code></code><code>// using a macro</code><code>#define DAYS_PER_WEEK 7</code><code>int numberOfLessonsPerDay[DAYS_PER_WEEK]{}; // Works, but don't do this (use a constexpr symbolic constant instead)</code></pre><p>Note that non-const variables or runtime constants cannot be used:</p><pre class="language-cpp line-numbers"><code>// using a non-const variable</code><code>int daysPerWeek{};</code><code>std::cin &gt;&gt; daysPerWeek;</code><code>int numberOfLessonsPerDay[daysPerWeek]{}; // Not ok -- daysPerWeek is not a compile-time constant!</code><code></code><code>// using a runtime const variable</code><code>int temp{ 5 };</code><code>const int daysPerWeek{ temp }; // the value of daysPerWeek isn't known until runtime, so this is a runtime constant, not a compile-time constant!</code><code>int numberOfLessonsPerDay[daysPerWeek]{}; // Not ok</code></pre><p>Note that in the last two cases, an error should result because the length is not a compile-time constant. Some compilers may allow these kinds of arrays (for C99 compatibility reasons), but they are invalid in C++, and should not be used in C++ programs. If your compiler allows these arrays, you probably forgot to disable compiler extensions (Lesson <a href="https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-compiler-extensions/">0.10 -- Configuring your compiler: Compiler extensions</a>).</p><p><strong>A note on dynamic arrays</strong></p><p>Because fixed arrays have memory allocated at compile time, that introduces two limitations:</p><ul><li>Fixed arrays cannot have a length based on either user input or some other value calculated at runtime.</li><li>Fixed arrays have a fixed length that can not be changed.</li></ul><p>In many cases, these limitations are problematic. Fortunately, C++ supports a second kind of array known as a <strong>dynamic array</strong>. The length of a dynamic array can be set at runtime, and their length can be changed. However, dynamic arrays are a little more complicated to instantiate, so we’ll cover them later in the chapter.</p><p><strong>Summary</strong></p><p>Fixed arrays provide an easy way to allocate and use multiple variables of the same type so long as the length of the array is known at compile time.</p><p>We’ll look at more topics around fixed arrays in the next lesson.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.2 — Arrays (Part II)</h1></header><div class="entry-content" itemprop="articleBody"><p>This lesson continues the discussion of arrays that began in lesson <a href="https://www.learncpp.com/cpp-tutorial/arrays-part-i/">11.1 -- Arrays (Part I)</a>.</p><p><strong>Initializing fixed arrays</strong></p><p>Array elements are treated just like normal variables, and as such, they are not initialized when created.</p><p>One way to “initialize” an array is to do it element by element:</p><pre class="language-cpp line-numbers"><code>int prime[5]; // hold the first 5 prime numbers</code><code>prime[0] = 2;</code><code>prime[1] = 3;</code><code>prime[2] = 5;</code><code>prime[3] = 7;</code><code>prime[4] = 11;</code></pre><p>However, this is a pain, especially as the array gets larger. Furthermore, it’s not initialization, but assignment. Assignments don’t work if the array is <code>const</code>.</p><p>Fortunately, C++ provides a more convenient way to initialize entire arrays via use of an <strong>initializer list</strong>. The following example initializes the array with the same values as the one above:</p><pre class="language-cpp line-numbers"><code>int prime[5]{ 2, 3, 5, 7, 11 }; // use initializer list to initialize the fixed array</code></pre><p>If there are more initializers in the list than the array can hold, the compiler will generate an error.</p><p>However, if there are less initializers in the list than the array can hold, the remaining elements are initialized to 0 (or whatever value 0 converts to for a non-integral fundamental type -- e.g. 0.0 for double). This is called <strong>zero initialization</strong>.</p><p>The following example shows this in action:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int array[5]{ 7, 4, 5 }; // only initialize first 3 elements</code><code></code><code>    std::cout &lt;&lt; array[0] &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; array[1] &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; array[2] &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; array[3] &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; array[4] &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>7
4
5
0
0
</pre><p>Consequently, to initialize all the elements of an array to 0, you can do this:</p><pre class="language-cpp line-numbers"><code>int array[5]{};          // Initialize all elements to 0</code><code>double array[5] {};      // Initialize all elements to 0.0</code><code>std::string array[5] {}; // Initialize all elements to an empty string</code></pre><p>If the initializer list is omitted, the elements are uninitialized, unless they are a class-type that self-initializes.</p><pre class="language-cpp line-numbers"><code>int array[5];         // uninitialized (since int doesn't self-initialize)</code><code>double array[5];      // uninitialized (since double doesn't self-initialize)</code><code>std::string array[5]; // Initialize all elements to an empty string</code></pre><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Explicitly initialize your arrays (even when the element type is self-initializing).</p></div><p><strong>Omitted length</strong></p><p>If you are initializing a fixed array of elements using an initializer list, the compiler can figure out the length of the array for you, and you can omit explicitly declaring the length of the array.</p><p>The following two lines are equivalent:</p><pre class="language-cpp line-numbers"><code>int array[5]{ 0, 1, 2, 3, 4 }; // explicitly define the length of the array</code><code>int array[]{ 0, 1, 2, 3, 4 }; // let the initializer list set length of the array</code></pre><p>This not only saves typing, it also means you don’t have to update the array length if you add or remove elements later.</p><p><strong>Arrays and enums</strong></p><p>One of the big documentation problems with arrays is that integer indices do not provide any information to the programmer about the meaning of the index. Consider a class of 5 students:</p><pre class="language-cpp line-numbers"><code>constexpr int numberOfStudents{5};</code><code>int testScores[numberOfStudents]{};</code><code>testScores[2] = 76;</code></pre><p>Who is represented by testScores[2]? It’s not clear.</p><p>This can be solved by setting up an enumeration where one enumerator maps to each of the possible array indices:</p><pre class="language-cpp line-numbers"><code>enum StudentNames</code><code>{</code><code>    kenny, // 0</code><code>    kyle, // 1</code><code>    stan, // 2</code><code>    butters, // 3</code><code>    cartman, // 4</code><code>    max_students // 5</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    int testScores[max_students]{}; // allocate 5 integers</code><code>    testScores[stan] = 76;</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this way, it’s much clearer what each of the array elements represents. Note that an extra enumerator named max_students has been added. This enumerator is used during the array declaration to ensure the array has the proper length (as the array length should be one greater than the largest index). This is useful both for documentation purposes, and because the array will automatically be resized if another enumerator is added:</p><pre class="language-cpp line-numbers"><code>enum StudentNames</code><code>{</code><code>    kenny, // 0</code><code>    kyle, // 1</code><code>    stan, // 2</code><code>    butters, // 3</code><code>    cartman, // 4</code><code>    wendy, // 5</code><code>    max_students // 6</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    int testScores[max_students]{}; // allocate 6 integers</code><code>    testScores[stan] = 76; // still works</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note that this “trick” only works if you do not change the enumerator values manually!</p><p><strong>Arrays and enum classes</strong></p><p>Enum classes don’t have an implicit conversion to integer, so if you try the following:</p><pre class="language-cpp line-numbers"><code>enum class StudentNames</code><code>{</code><code>    kenny, // 0</code><code>    kyle, // 1</code><code>    stan, // 2</code><code>    butters, // 3</code><code>    cartman, // 4</code><code>    wendy, // 5</code><code>    max_students // 6</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    int testScores[StudentNames::max_students]{}; // allocate 6 integers</code><code>    testScores[StudentNames::stan] = 76;</code><code></code><code>    return 0;</code><code>}</code></pre><p>You’ll get a compiler error. This can be addressed by using a static_cast to convert the enumerator to an integer:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int testScores[static_cast<int>(StudentNames::max_students)]{}; // allocate 6 integers</int></code><code>    testScores[static_cast<int>(StudentNames::stan)] = 76;</int></code><code></code><code>    return 0;</code><code>}</code></pre><p>However, doing this is somewhat of a pain, so it might be better to use a standard enum inside of a namespace:</p><pre class="language-cpp line-numbers"><code>namespace StudentNames</code><code>{</code><code>    enum StudentNames</code><code>    {</code><code>        kenny, // 0</code><code>        kyle, // 1</code><code>        stan, // 2</code><code>        butters, // 3</code><code>        cartman, // 4</code><code>        wendy, // 5</code><code>        max_students // 6</code><code>    };</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int testScores[StudentNames::max_students]{}; // allocate 6 integers</code><code>    testScores[StudentNames::stan] = 76;</code><code></code><code>    return 0;</code><code>}</code></pre><p><strong>Passing arrays to functions</strong></p><p>Although passing an array to a function at first glance looks just like passing a normal variable, underneath the hood, C++ treats arrays differently.</p><p>When a normal variable is passed by value, C++ copies the value of the argument into the function parameter. Because the parameter is a copy, changing the value of the parameter does not change the value of the original argument.</p><p>However, because copying large arrays can be very expensive, C++ does <em>not</em> copy an array when an array is passed into a function. Instead, the <em>actual</em> array is passed. This has the side effect of allowing functions to directly change the value of array elements!</p><p>The following example illustrates this concept:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void passValue(int value) // value is a copy of the argument</code><code>{</code><code>    value = 99; // so changing it here won't change the value of the argument</code><code>}</code><code></code><code>void passArray(int prime[5]) // prime is the actual array</code><code>{</code><code>    prime[0] = 11; // so changing it here will change the original argument!</code><code>    prime[1] = 7;</code><code>    prime[2] = 5;</code><code>    prime[3] = 3;</code><code>    prime[4] = 2;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int value{ 1 };</code><code>    std::cout &lt;&lt; "before passValue: " &lt;&lt; value &lt;&lt; '\n';</code><code>    passValue(value);</code><code>    std::cout &lt;&lt; "after passValue: " &lt;&lt; value &lt;&lt; '\n';</code><code></code><code>    int prime[5]{ 2, 3, 5, 7, 11 };</code><code>    std::cout &lt;&lt; "before passArray: " &lt;&lt; prime[0] &lt;&lt; " " &lt;&lt; prime[1] &lt;&lt; " " &lt;&lt; prime[2] &lt;&lt; " " &lt;&lt; prime[3] &lt;&lt; " " &lt;&lt; prime[4] &lt;&lt; '\n';</code><code>    passArray(prime);</code><code>    std::cout &lt;&lt; "after passArray: " &lt;&lt; prime[0] &lt;&lt; " " &lt;&lt; prime[1] &lt;&lt; " " &lt;&lt; prime[2] &lt;&lt; " " &lt;&lt; prime[3] &lt;&lt; " " &lt;&lt; prime[4] &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><pre>before passValue: 1
after passValue: 1
before passArray: 2 3 5 7 11
after passArray: 11 7 5 3 2
</pre><p>In the above example, value is not changed in main() because the parameter value in function passValue() was a copy of variable value in function main(), not the actual variable. However, because the parameter array in function passArray() is the actual array, passArray() is able to directly change the value of the elements!</p><p>Why this happens is related to the way arrays are implemented in C++, a topic we’ll revisit in lesson <a href="https://www.learncpp.com/cpp-tutorial/pointers-and-arrays/">11.8 -- Pointers and arrays</a>. For now, you can consider this as a quirk of the language.</p><p>As a side note, if you want to ensure a function does not modify the array elements passed into it, you can make the array const:</p><pre class="language-cpp line-numbers"><code>// even though prime is the actual array, within this function it should be treated as a constant</code><code>void passArray(const int prime[5])</code><code>{</code><code>    // so each of these lines will cause a compile error!</code><code>    prime[0] = 11;</code><code>    prime[1] = 7;</code><code>    prime[2] = 5;</code><code>    prime[3] = 3;</code><code>    prime[4] = 2;</code><code>}</code></pre><p><strong>Determining the length of an array</strong></p><p>The std::size() function from the &lt;iterator&gt; header can be used to determine the length of arrays.</p><p>Here’s an example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator> // for std::size</iterator></code><code></code><code>int main()</code><code>{</code><code>    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };</code><code>    std::cout &lt;&lt; "The array has: " &lt;&lt; std::size(array) &lt;&lt; " elements\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>The array has: 8 elements
</pre><p>Note that due to the way C++ passes arrays to functions, this will <em>not</em> work for arrays that have been passed to functions!</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator></iterator></code><code></code><code>void printSize(int array[])</code><code>{</code><code>    std::cout &lt;&lt; std::size(array) &lt;&lt; '\n'; // Error</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };</code><code>    std::cout &lt;&lt; std::size(array) &lt;&lt; '\n'; // will print the size of the array</code><code>    printSize(array);</code><code></code><code>    return 0;</code><code>}</code></pre><p>std::size() will work with other kinds of objects (such as std::array and std::vector), and it will cause a compiler error if you try to use it on a fixed array that has been passed to a function! Note that std::size returns an unsigned value. If you need a signed value, you can either cast the result or, since C++20, use std::ssize() (stands for signed size).</p><p>std::size() was added in C++17. If you’re still using an old compiler, you have to use the sizeof operator instead. sizeof isn’t as easy to use as std::size() and there are a few things you have to watch out for. If you’re using a C++17-capable compiler, you can skip to section “Indexing an array out of range”.</p><p>The sizeof operator can be used on arrays, and it will return the total size of the array (array length multiplied by element size).</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };</code><code>    std::cout &lt;&lt; sizeof(array) &lt;&lt; '\n'; // will print the size of the array multiplied by the size of an int</code><code>    std::cout &lt;&lt; sizeof(int) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>On a machine with 4 byte integers and 8 byte pointers, this printed:</p><pre>32
4
</pre><p>(You may get a different result if the size of your types are different).</p><p>One neat trick: we can determine the length of a fixed array by dividing the size of the entire array by the size of an array element:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };</code><code>    std::cout &lt;&lt; "The array has: " &lt;&lt; sizeof(array) / sizeof(array[0]) &lt;&lt; " elements\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This printed</p><pre>The array has: 8 elements
</pre><p>How does this work? First, note that the size of the entire array is equal to the array’s length multiplied by the size of an element. Put more compactly: array size = array length * element size.</p><p>Using algebra, we can rearrange this equation: array length = array size / element size. sizeof(array) is the array size, and sizeof(array[0]) is the element size, so our equation becomes array length = sizeof(array) / sizeof(array[0]). We typically use array element 0 for the array element, since it’s the only element guaranteed to exist no matter what the array length is.</p><p>Note that this will only work if the array is a fixed-length array, and you’re doing this trick in the same function that array is declared in (we’ll talk more about why this restriction exists in a future lesson in this chapter).</p><p>When sizeof is used on an array that has been passed to a function, it doesn’t error out like std::size() does. Instead, it returns the size of a pointer.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printSize(int array[])</code><code>{</code><code>    std::cout &lt;&lt; sizeof(array) / sizeof(array[0]) &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };</code><code>    std::cout &lt;&lt; sizeof(array) / sizeof(array[0]) &lt;&lt; '\n';</code><code>    printSize(array);</code><code></code><code>    return 0;</code><code>}</code></pre><p>Again assuming 8 byte pointers and 4 byte integers, this prints</p><pre>8
2
</pre><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>A properly configured compiler should print a warning if you try to use sizeof() on an array that was passed to a function.</p></div><p>The calculation in main() was correct, but the sizeof() in printSize() returned 8 (the size of a pointer), and 8 divided by 4 is 2.</p><p>For this reason, be careful about using sizeof() on arrays!</p><p>Note: In common usage, the terms “array size” and “array length” are both most often used to refer to the array’s length (the size of the array isn’t useful in most cases, outside of the trick we’ve shown you above).</p><p><strong>Indexing an array out of range</strong></p><p>Remember that an array of length N has array elements 0 through N-1. So what happens if you try to access an array with a subscript outside of that range?</p><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int prime[5]{}; // hold the first 5 prime numbers</code><code>    prime[5] = 13;</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this program, our array is of length 5, but we’re trying to write a prime number into the 6th element (index 5).</p><p>C++ does <em>not</em> do any checking to make sure that your indices are valid for the length of your array. So in the above example, the value of 13 will be inserted into memory where the 6th element would have been had it existed. When this happens, you will get undefined behavior -- for example, this could overwrite the value of another variable, or cause your program to crash.</p><p>Although it happens less often, C++ will also let you use a negative index, with similarly undesirable results.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Rule</h4><p>When using arrays, ensure that your indices are valid for the range of your array!</p></div><p><strong>Quiz</strong></p><ol start="1"><li>Declare an array to hold the high temperature (to the nearest tenth of a degree) for each day of a year (assume 365 days in a year). Initialize the array with a value of 0.0 for each day.</li><li>Set up an enum with the names of the following animals: chicken, dog, cat, elephant, duck, and snake. Put the enum in a namespace. Define an array with an element for each of these animals, and use an initializer list to initialize each element to hold the number of legs that animal has.</li></ol><p>Write a main function that prints the number of legs an elephant has, using the enumerator.</p><p><strong>Quiz answers</strong></p><ol start="1"><li><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></li></ol><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>double temperature[365] { };</code></pre></div><ol start="2"><li><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></li></ol><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>namespace animals</code><code>{</code><code>    enum Animals // The name of this enum could be omitted since it isn't used anywhere</code><code>    {</code><code>        chicken,</code><code>        dog,</code><code>        cat,</code><code>        elephant,</code><code>        duck,</code><code>        snake,</code><code>        max_animals</code><code>    };</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int legs[animals::max_animals]{ 2, 4, 4, 4, 2, 0 };</code><code></code><code>    std::cout &lt;&lt; "An elephant has " &lt;&lt; legs[animals::elephant] &lt;&lt; " legs.\n";</code><code></code><code>    return 0;</code><code>}</code></pre></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.3 — Arrays and loops</h1></header><div class="entry-content" itemprop="articleBody"><p>Consider the case where we want to find the average test score of a class of students. Using individual variables:</p><pre class="language-cpp line-numbers"><code>int numStudents{ 5 };</code><code>int score0{ 84 };</code><code>int score1{ 92 };</code><code>int score2{ 76 };</code><code>int score3{ 81 };</code><code>int score4{ 56 };</code><code></code><code>int totalScore{ score0 + score1 + score2 + score3 + score4 };</code><code>auto averageScore{ static_cast<double>(totalScore) / numStudents };</double></code></pre><p>That’s a lot of variables and a lot of typing -- and this is just 5 students! Imagine how much work we’d have to do for 30 students, or 150.</p><p>Plus, if a new student is added, a new variable has to be declared, initialized, and added to the totalScore calculation. Any time you have to modify old code, you run the risk of introducing errors.</p><p>Using arrays offers a slightly better solution:</p><pre class="language-cpp line-numbers"><code>int scores[]{ 84, 92, 76, 81, 56 };</code><code>int numStudents{ static_cast<int>(std::size(scores)) }; // requires C++17 and <iterator> header</iterator></int></code><code>int totalScore{ scores[0] + scores[1] + scores[2] + scores[3] + scores[4] };</code><code>auto averageScore{ static_cast<double>(totalScore) / numStudents };</double></code></pre><p>This cuts down on the number of variables declared significantly, but totalScore still requires each array element be listed individually. And as above, changing the number of students means the totalScore formula needs to be manually adjusted.</p><p>If only there were a way to loop through our array and calculate totalScore directly.</p><br><h3>Loops and arrays</h3><p>In a previous lesson, you learned that the array subscript doesn’t need to be a constant value -- it can be a variable. This means we can use a loop variable as an array index to loop through all of the elements of our array and perform some calculation on them. This is such a common thing to do that wherever you find arrays, you will almost certainly find loops! When a loop is used to access each array element in turn, this is often called <strong>iterating</strong> through the array.</p><p>Here’s our example above using a <em>for loop</em>:</p><pre class="language-cpp line-numbers"><code>constexpr int scores[]{ 84, 92, 76, 81, 56 };</code><code>constexpr int numStudents{ static_cast<int>(std::size(scores)) };</int></code><code>// const int numStudents{ sizeof(scores) / sizeof(scores[0]) }; // use this instead if not C++17 capable</code><code>int totalScore{ 0 };</code><code></code><code>// use a loop to calculate totalScore</code><code>for (int student{ 0 }; student &lt; numStudents; ++student)</code><code>    totalScore += scores[student];</code><code></code><code>auto averageScore{ static_cast<double>(totalScore) / numStudents };</double></code></pre><p>This solution is ideal in terms of both readability and maintenance. Because the loop does all of our array element accesses, the formulas adjust automatically to account for the number of elements in the array. This means the calculations do not have to be manually altered to account for new students, and we do not have to manually add the name of new array elements!</p><p>Here’s an example of using a loop to search an array in order to determine the best score in the class:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator> // for std::size</iterator></code><code></code><code>int main()</code><code>{</code><code>    // scores are 0 (worst) to 100 (best)</code><code>    constexpr int scores[]{ 84, 92, 76, 81, 56 };</code><code>    constexpr int numStudents{ static_cast<int>(std::size(scores)) };</int></code><code></code><code>    int maxScore{ 0 }; // keep track of our largest score</code><code>    for (int student{ 0 }; student &lt; numStudents; ++student)</code><code>    {</code><code>        if (scores[student] &gt; maxScore)</code><code>        {</code><code>            maxScore = scores[student];</code><code>        }</code><code>    }</code><code></code><code>    std::cout &lt;&lt; "The best score was " &lt;&lt; maxScore &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this example, we use a non-loop variable called maxScore to keep track of the highest score we’ve seen. maxScore is initialized to 0 to represent that we have not seen any scores yet. We then iterate through each element of the array, and if we find a score that is higher than any we’ve seen before, we set maxScore to that value. Thus, maxScore always represents the highest score out of all the elements we’ve searched so far. By the time we reach the end of the array, maxScore holds the highest score in the entire array.</p><br><h3>Mixing loops and arrays</h3><p>Loops are typically used with arrays to do one of three things:</p><ol start="1"><li>Calculate a value (e.g. average value, total value)</li><li>Search for a value (e.g. highest value, lowest value).</li><li>Reorganize the array (e.g. ascending order, descending order)</li></ol><p>When calculating a value, a variable is typically used to hold an intermediate result that is used to calculate the final value. In the above example where we are calculating an average score, totalScore holds the total score for all the elements examined so far.</p><p>When searching for a value, a variable is typically used to hold the best candidate value seen so far (or the array index of the best candidate). In the above example where we use a loop to find the best score, maxScore is used to hold the highest score encountered so far.</p><p>Sorting an array is a bit more tricky, as it typically involves nested loops. We will cover sorting an array in the next lesson.</p><br><h3>Arrays and off-by-one errors</h3><p>One of the trickiest parts of using loops with arrays is making sure the loop iterates the proper number of times. Off-by-one errors are easy to make, and trying to access an element that is larger than the length of the array can have dire consequences. Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator></iterator></code><code></code><code>int main()</code><code>{</code><code>  constexpr int scores[]{ 84, 92, 76, 81, 56 };</code><code>  constexpr int numStudents{ static_cast<int>(std::size(scores)) };</int></code><code></code><code>  int maxScore{ 0 }; // keep track of our largest score</code><code>  for (int student{ 0 }; student &lt;= numStudents; ++student)</code><code>  {</code><code>      if (scores[student] &gt; maxScore)</code><code>      {</code><code>          maxScore = scores[student];</code><code>      }</code><code>  }</code><code></code><code>  std::cout &lt;&lt; "The best score was " &lt;&lt; maxScore &lt;&lt; '\n';</code><code>  </code><code>  return 0;</code><code>}</code></pre><p>The problem with this program is that the condition in the for loop is wrong! The array declared has 5 elements, indexed from 0 to 4. However, this array loops from 0 to 5. Consequently, on the last iteration, the array will execute this:</p><pre class="language-cpp line-numbers"><code>if (scores[5] &gt; maxScore)</code><code>{</code><code>    maxScore = scores[5];</code><code>}</code></pre><p>But scores[5] is undefined! This can cause all sorts of issues, with the most likely being that scores[5] results in a garbage value. In this case, the probable result is that maxScore will be wrong.</p><p>However, imagine what would happen if we inadvertently assigned a value to array[5]! We might overwrite another variable (or part of it), or perhaps corrupt something -- these types of bugs can be very hard to track down!</p><p>Consequently, when using loops with arrays, always double-check your loop conditions to make sure you do not introduce off-by-one errors.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Print the following array to the screen using a loop:</p><pre class="language-cpp line-numbers"><code>constexpr int array[]{ 4, 6, 7, 3, 8, 2, 1, 9, 5 };</code></pre><p>Hint: You can use std::size (as of C++17) or the sizeof() trick (prior to C++17) to determine the array length.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator> // for std::size</iterator></code><code></code><code>int main()</code><code>{</code><code>    constexpr int array[]{ 4, 6, 7, 3, 8, 2, 1, 9, 5 };</code><code></code><code>    for (int index{ 0 }; index &lt; static_cast<int>(std::size(array)); ++index)</int></code><code>    {</code><code>        std::cout &lt;&lt; array[index] &lt;&lt; ' ';</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>Given the array in question 1:</p><p>Ask the user for a number between 1 and 9. If the user does not enter a number between 1 and 9, repeatedly ask for an integer value until they do. Once they have entered a number between 1 and 9, print the array. Then search the array for the value that the user entered and print the index of that element.</p><p>You can test std::cin for invalid input by using the following code:</p><pre class="language-cpp line-numbers"><code>// if the user entered something invalid</code><code>if (std::cin.fail())</code><code>{</code><code>    std::cin.clear(); // reset any error flags</code><code>    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // ignore any characters in the input buffer</std::streamsize></code><code>}</code></pre><p>Here is a sample run of this program:</p><pre>Enter a number between 1 and 9: d
Enter a number between 1 and 9: 6
4 6 7 3 8 2 1 9 5
The number 6 has index 1
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator> // for std::size</iterator></code><code>#include <limits></limits></code><code></code><code>int main()</code><code>{</code><code>    // First, read in valid input from user</code><code>    int number{};</code><code>    do</code><code>    {</code><code>        std::cout &lt;&lt; "Enter a number between 1 and 9: ";</code><code>        std::cin &gt;&gt; number;</code><code></code><code>        // if the user entered an invalid character</code><code>        if (std::cin.fail())</code><code>            std::cin.clear(); // reset any error flags</code><code></code><code>        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // ignore any extra characters in the input buffer (regardless of whether we had an error or not)</std::streamsize></code><code></code><code>    } while (number &lt; 1 || number &gt; 9);</code><code></code><code>    // Next, print the array</code><code>    constexpr int array[]{ 4, 6, 7, 3, 8, 2, 1, 9, 5 };</code><code></code><code>    for (int index{ 0 }; index &lt; static_cast<int>(std::size(array)); ++index)</int></code><code>    {</code><code>        std::cout &lt;&lt; array[index] &lt;&lt; ' ';</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    // Then, search the array to find the matching number and print the index</code><code>    for (int index{ 0 }; index &lt; static_cast<int>(std::size(array)); ++index)</int></code><code>    {</code><code>        if (array[index] == number)</code><code>        {</code><code>            std::cout &lt;&lt;  "The number " &lt;&lt; number &lt;&lt; " has index " &lt;&lt;  index &lt;&lt; '\n';</code><code>            break; // since each # in the array is unique, no need to search rest of array</code><code>        }</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>Modify the following program so that instead of having maxScore hold the largest score directly, a variable named maxIndex holds the index of the largest score. The program should still print the largest score.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator> // for std::size</iterator></code><code></code><code>int main()</code><code>{</code><code>    constexpr int scores[]{ 84, 92, 76, 81, 56 };</code><code></code><code>    int maxScore{ 0 }; // Assume our largest score is 0 to start</code><code></code><code>    // now look for a larger score in the full array</code><code>    for (int student{ 0 }; student &lt; static_cast<int>(std::size(scores)); ++student)</int></code><code>    {</code><code>        if (scores[student] &gt; maxScore)</code><code>        {</code><code>            maxScore = scores[student];</code><code>        }</code><code>    }</code><code></code><code>    std::cout &lt;&lt; "The best score was " &lt;&lt; maxScore &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator> // for std::size</iterator></code><code></code><code>int main()</code><code>{</code><code>    constexpr int scores[]{ 84, 92, 76, 81, 56 };</code><code></code><code>    int maxIndex{ 0 }; // Assume the element at index 0 is the largest</code><code></code><code>    // now look for a larger score in the rest of the array</code><code>    for (int student{ 1 }; student &lt; static_cast<int>(std::size(scores)); ++student)</int></code><code>    {</code><code>        if (scores[student] &gt; scores[maxIndex])</code><code>        {</code><code>            maxIndex = student;</code><code>        }</code><code>    }</code><code></code><code>    std::cout &lt;&lt; "The best score was " &lt;&lt; scores[maxIndex] &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.4 — Sorting an array using selection sort</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>A case for sorting</h3><p>Sorting an array is the process of arranging all of the elements in the array in a particular order. There are many different cases in which sorting an array can be useful. For example, your email program generally displays emails in order of time received, because more recent emails are typically considered more relevant. When you go to your contact list, the names are typically in alphabetical order, because it’s easier to find the name you are looking for that way. Both of these presentations involve sorting data before presentation.</p><p>Sorting an array can make searching an array more efficient, not only for humans, but also for computers. For example, consider the case where we want to know whether a name appears in a list of names. In order to see whether a name was on the list, we’d have to check every element in the array to see if the name appears. For an array with many elements, searching through them all can be expensive.</p><p>However, now assume our array of names is sorted alphabetically. In this case, we only need to search up to the point where we encounter a name that is alphabetically greater than the one we are looking for. At that point, if we haven’t found the name, we know it doesn’t exist in the rest of the array, because all of the names we haven’t looked at in the array are guaranteed to be alphabetically greater!</p><p>It turns out that there are even better algorithms to search sorted arrays. Using a simple algorithm, we can search a sorted array containing 1,000,000 elements using only 20 comparisons! The downside is, of course, that sorting an array is comparatively expensive, and it often isn’t worth sorting an array in order to make searching fast unless you’re going to be searching it many times.</p><p>In some cases, sorting an array can make searching unnecessary. Consider another example where we want to find the best test score. If the array is unsorted, we have to look through every element in the array to find the greatest test score. If the list is sorted, the best test score will be in the first or last position (depending on whether we sorted in ascending or descending order), so we don’t need to search at all!</p><br><h3>How sorting works</h3><p>Sorting is generally performed by repeatedly comparing pairs of array elements, and swapping them if they meet some predefined criteria. The order in which these elements are compared differs depending on which sorting algorithm is used. The criteria depends on how the list will be sorted (e.g. in ascending or descending order).</p><p>To swap two elements, we can use the std::swap() function from the C++ standard library, which is defined in the utility header.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <utility></utility></code><code></code><code>int main()</code><code>{</code><code>    int x{ 2 };</code><code>    int y{ 4 };</code><code>    std::cout &lt;&lt; "Before swap: x = " &lt;&lt; x &lt;&lt; ", y = " &lt;&lt; y &lt;&lt; '\n';</code><code>    std::swap(x, y); // swap the values of x and y</code><code>    std::cout &lt;&lt; "After swap:  x = " &lt;&lt; x &lt;&lt; ", y = " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>Before swap: x = 2, y = 4
After swap:  x = 4, y = 2
</pre><p>Note that after the swap, the values of x and y have been interchanged!</p><br><h3>Selection sort</h3><p>There are many ways to sort an array. Selection sort is probably the easiest sort to understand, which makes it a good candidate for teaching even though it is one of the slower sorts.</p><p>Selection sort performs the following steps to sort an array from smallest to largest:</p><ol start="1"><li>Starting at array index 0, search the entire array to find the smallest value</li><li>Swap the smallest value found in the array with the value at index 0</li><li>Repeat steps 1 &amp; 2 starting from the next index</li></ol><p>In other words, we’re going to find the smallest element in the array, and swap it into the first position. Then we’re going to find the next smallest element, and swap it into the second position. This process will be repeated until we run out of elements.</p><p>Here is an example of this algorithm working on 5 elements. Let’s start with a sample array:</p><p>{ 30, 50, 20, 10, 40 }</p><p>First, we find the smallest element, starting from index 0:</p><p>{ 30, 50, 20, <strong>10</strong>, 40 }</p><p>We then swap this with the element at index 0:</p><p>{ <strong>10</strong>, 50, 20, <strong>30</strong>, 40 }</p><p>Now that the first element is sorted, we can ignore it. Now, we find the smallest element, starting from index 1:</p><p>{ <em>10</em>, 50, <strong>20</strong>, 30, 40 }</p><p>And swap it with the element in index 1:</p><p>{ <em>10</em>, <strong>20</strong>, <strong>50</strong>, 30, 40 }</p><p>Now we can ignore the first two elements. Find the smallest element starting at index 2:</p><p>{ <em>10</em>, <em>20</em>, 50, <strong>30</strong>, 40 }</p><p>And swap it with the element in index 2:</p><p>{ <em>10</em>, <em>20</em>, <strong>30</strong>, <strong>50</strong>, 40 }</p><p>Find the smallest element starting at index 3:</p><p>{ <em>10</em>, <em>20</em>, <em>30</em>, 50, <strong>40</strong> }</p><p>And swap it with the element in index 3:</p><p>{ <em>10</em>, <em>20</em>, <em>30</em>, <strong>40</strong>, <strong>50</strong> }</p><p>Finally, find the smallest element starting at index 4:</p><p>{ <em>10</em>, <em>20</em>, <em>30</em>, <em>40</em>, <strong>50</strong> }</p><p>And swap it with the element in index 4 (which doesn’t do anything):</p><p>{ <em>10</em>, <em>20</em>, <em>30</em>, <em>40</em>, <strong>50</strong> }</p><p>Done!</p><p>{ 10, 20, 30, 40, 50 }</p><p>Note that the last comparison will always be with itself (which is redundant), so we can actually stop 1 element before the end of the array.</p><br><h3>Selection sort in C++</h3><p>Here’s how this algorithm is implemented in C++:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator></iterator></code><code>#include <utility></utility></code><code></code><code>int main()</code><code>{</code><code>	int array[]{ 30, 50, 20, 10, 40 };</code><code>	constexpr int length{ static_cast<int>(std::size(array)) };</int></code><code></code><code>	// Step through each element of the array</code><code>	// (except the last one, which will already be sorted by the time we get there)</code><code>	for (int startIndex{ 0 }; startIndex &lt; length - 1; ++startIndex)</code><code>	{</code><code>		// smallestIndex is the index of the smallest element we’ve encountered this iteration</code><code>		// Start by assuming the smallest element is the first element of this iteration</code><code>		int smallestIndex{ startIndex };</code><code></code><code>		// Then look for a smaller element in the rest of the array</code><code>		for (int currentIndex{ startIndex + 1 }; currentIndex &lt; length; ++currentIndex)</code><code>		{</code><code>			// If we've found an element that is smaller than our previously found smallest</code><code>			if (array[currentIndex] &lt; array[smallestIndex])</code><code>				// then keep track of it</code><code>				smallestIndex = currentIndex;</code><code>		}</code><code></code><code>		// smallestIndex is now the smallest element in the remaining array</code><code>                // swap our start element with our smallest element (this sorts it into the correct place)</code><code>		std::swap(array[startIndex], array[smallestIndex]);</code><code>	}</code><code></code><code>	// Now that the whole array is sorted, print our sorted array as proof it works</code><code>	for (int index{ 0 }; index &lt; length; ++index)</code><code>		std::cout &lt;&lt; array[index] &lt;&lt; ' ';</code><code></code><code>	std::cout &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>The most confusing part of this algorithm is the loop inside of another loop (called a <strong>nested loop</strong>). The outside loop (startIndex) iterates through each element one by one. For each iteration of the outer loop, the inner loop (currentIndex) is used to find the smallest element in the remaining array (starting from startIndex+1). smallestIndex keeps track of the index of the smallest element found by the inner loop. Then smallestIndex is swapped with startIndex. Finally, the outer loop (startIndex) advances one element, and the process is repeated.</p><p>Hint: If you’re having trouble figuring out how the above program works, it can be helpful to work through a sample case on a piece of paper. Write the starting (unsorted) array elements horizontally at the top of the paper. Draw arrows indicating which elements startIndex, currentIndex, and smallestIndex are indexing. Manually trace through the program and redraw the arrows as the indices change. For each iteration of the outer loop, start a new line showing the current state of the array.</p><p>Sorting names works using the same algorithm. Just change the array type from int to std::string, and initialize with the appropriate values.</p><br><h3>std::sort </h3><p>Because sorting arrays is so common, the C++ standard library includes a sorting function named <code>std::sort</code>. <code>std::sort</code> lives in the &lt;algorithm&gt; header, and can be invoked on an array like so:</p><pre class="language-cpp line-numbers"><code>#include <algorithm> // for std::sort</algorithm></code><code>#include <iostream></iostream></code><code>#include <iterator> // for std::size</iterator></code><code></code><code>int main()</code><code>{</code><code>	int array[]{ 30, 50, 20, 10, 40 };</code><code></code><code>	std::sort(std::begin(array), std::end(array));</code><code></code><code>	for (int i{ 0 }; i &lt; static_cast<int>(std::size(array)); ++i)</int></code><code>		std::cout &lt;&lt; array[i] &lt;&lt; ' ';</code><code></code><code>	std::cout &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>By default, std::sort sorts in ascending order using operator&lt; to compare pairs of elements and swapping them if necessary (much like our selection sort example does above).</p><p>We’ll talk more about <code>std::sort</code> in a future chapter.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Manually show how selection sort works on the following array: { 30, 60, 20, 50, 40, 10 }. Show the array after each swap that takes place.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>30 60 20 50 40 10<br><strong>10</strong> 60 20 50 40 <strong>30</strong><br>10 <strong>20</strong> <strong>60</strong> 50 40 30<br>10 20 <strong>30</strong> 50 40 <strong>60</strong><br>10 20 30 <strong>40</strong> <strong>50</strong> 60<br>10 20 30 40 <strong>50</strong> 60 (self-swap)<br>10 20 30 40 50 <strong>60</strong> (self-swap)</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>Rewrite the selection sort code above to sort in descending order (largest numbers first). Although this may seem complex, it is actually surprisingly simple.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>Simply change:</p><pre class="language-cpp line-numbers"><code>        if (array[currentIndex] &lt; array[smallestIndex])</code></pre><p>to:</p><pre class="language-cpp line-numbers"><code>        if (array[currentIndex] &gt; array[smallestIndex])</code></pre><p>smallestIndex should probably be renamed largestIndex as well.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator> // for std::size</iterator></code><code>#include <utility></utility></code><code></code><code>int main()</code><code>{</code><code>    int array[]{ 30, 50, 20, 10, 40 };</code><code>    constexpr int length{ static_cast<int>(std::size(array)) }; // C++17</int></code><code>//  constexpr int length{ sizeof(array) / sizeof(array[0]) }; // use instead if not C++17 capable</code><code></code><code>    // Step through each element of the array except the last</code><code>    for (int startIndex{ 0 }; startIndex &lt; length - 1; ++startIndex)</code><code>    {</code><code>        // largestIndex is the index of the largest element we've encountered so far.</code><code>        int largestIndex{ startIndex };</code><code></code><code>        // Search through every element starting at startIndex + 1</code><code>        for (int currentIndex{ startIndex + 1 }; currentIndex &lt; length; ++currentIndex)</code><code>        {</code><code>            // If the current element is larger than our previously found largest</code><code>            if (array[currentIndex] &gt; array[largestIndex])</code><code>                // This is the new largest number for this iteration</code><code>                largestIndex = currentIndex;</code><code>        }</code><code></code><code>        // Swap our start element with our largest element</code><code>        std::swap(array[startIndex], array[largestIndex]);</code><code>    }</code><code></code><code>    // Now print our sorted array as proof it works</code><code>    for (int index{ 0 }; index &lt; length; ++index)</code><code>        std::cout &lt;&lt; array[index] &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>This one is going to be difficult, so put your game face on.</p><p>Another simple sort is called “bubble sort”. Bubble sort works by comparing adjacent pairs of elements, and swapping them if the criteria is met, so that elements “bubble” to the end of the array. Although there are quite a few ways to optimize bubble sort, in this quiz we’ll stick with the unoptimized version here because it’s simplest.</p><p>Unoptimized bubble sort performs the following steps to sort an array from smallest to largest:<br>A) Compare array element 0 with array element 1. If element 0 is larger, swap it with element 1.<br>B) Now do the same for elements 1 and 2, and every subsequent pair of elements until you hit the end of the array. At this point, the last element in the array will be sorted.<br>C) Repeat the first two steps again until the array is sorted.</p><p>Write code that bubble sorts the following array according to the rules above:</p><pre class="language-cpp line-numbers"><code>int array[]{ 6, 3, 2, 9, 7, 1, 5, 4, 8 };</code></pre><p>Print the sorted array elements at the end of your program.</p><p>Hint: If we’re able to sort one element per iteration, that means we’ll need to iterate roughly as many times as there are numbers in our array to guarantee that the whole array is sorted.<br>Hint: When comparing pairs of elements, be careful of your array’s range.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator> // for std::size</iterator></code><code>#include <utility></utility></code><code></code><code>int main()</code><code>{</code><code>    int array[]{ 6, 3, 2, 9, 7, 1, 5, 4, 8 };</code><code>    constexpr int length{ static_cast<int>(std::size(array)) }; // C++17</int></code><code>//  constexpr int length{ sizeof(array) / sizeof(array[0]) }; // use instead if not C++17 capable</code><code></code><code>    // Step through each element of the array (except the last, which will already be sorted by the time we get to it)</code><code>    for (int iteration{ 0 }; iteration &lt; length-1; ++iteration)</code><code>    {</code><code>        // Search through all elements up to the end of the array - 1</code><code>        // The last element has no pair to compare against</code><code>        for (int currentIndex{ 0 }; currentIndex &lt; length - 1; ++currentIndex)</code><code>        {</code><code>            // If the current element is larger than the element after it, swap them</code><code>            if (array[currentIndex] &gt; array[currentIndex+1])</code><code>                std::swap(array[currentIndex], array[currentIndex + 1]);</code><code>        }</code><code>    }</code><code></code><code>    // Now print our sorted array as proof it works</code><code>    for (int index{ 0 }; index &lt; length; ++index)</code><code>        std::cout &lt;&lt; array[index] &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #4</p><p>Add two optimizations to the bubble sort algorithm you wrote in the previous quiz question:</p><ul><li>Notice how with each iteration of bubble sort, the biggest number remaining gets bubbled to the end of the array. After the first iteration, the last array element is sorted. After the second iteration, the second to last array element is sorted too. And so on… With each iteration, we don’t need to recheck elements that we know are already sorted. Change your loop to not re-check elements that are already sorted.</li><li>If we go through an entire iteration without doing a swap, then we know the array must already be sorted. Implement a check to determine whether any swaps were made this iteration, and if not, terminate the loop early. If the loop was terminated early, print on which iteration the sort ended early.</li></ul><p>Your output should match this:</p><pre>Early termination on iteration 6
1 2 3 4 5 6 7 8 9
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator> // for std::size</iterator></code><code>#include <utility></utility></code><code></code><code>int main()</code><code>{</code><code>    int array[]{ 6, 3, 2, 9, 7, 1, 5, 4, 8 };</code><code>    constexpr int length{ static_cast<int>(std::size(array)) }; // C++17</int></code><code>//  constexpr int length{ sizeof(array) / sizeof(array[0]) }; // use instead if not C++17 capable</code><code></code><code>    // Step through each element of the array except the last</code><code>    for (int iteration{ 0 }; iteration &lt; length-1; ++iteration)</code><code>    {</code><code>        // Account for the fact that the last element is already sorted with each subsequent iteration</code><code>        // so our array "ends" one element sooner</code><code>        int endOfArrayIndex{ length - iteration };</code><code></code><code>        bool swapped{ false }; // Keep track of whether any elements were swapped this iteration</code><code></code><code>        // Search through all elements up to the end of the array - 1</code><code>        // The last element has no pair to compare against</code><code>        for (int currentIndex{ 0 }; currentIndex &lt; endOfArrayIndex - 1; ++currentIndex)</code><code>        {</code><code>            // If the current element is larger than the element after it</code><code>            if (array[currentIndex] &gt; array[currentIndex + 1])</code><code>            {</code><code>                // Swap them</code><code>                std::swap(array[currentIndex], array[currentIndex + 1]);</code><code>                swapped = true;</code><code>            }</code><code>        }</code><code></code><code>        // If we haven't swapped any elements this iteration, we're done early</code><code>        if (!swapped)</code><code>        {</code><code>            // iteration is 0 based, but counting iterations is 1-based.  So add 1 here to adjust.</code><code>            std::cout &lt;&lt; "Early termination on iteration: " &lt;&lt; iteration+1 &lt;&lt; '\n';</code><code>            break;</code><code>        }</code><code>    }</code><code></code><code>    // Now print our sorted array as proof it works</code><code>    for (int index{ 0 }; index &lt; length; ++index)</code><code>        std::cout &lt;&lt; array[index] &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.5 — Multidimensional Arrays</h1></header><div class="entry-content" itemprop="articleBody"><p>The elements of an array can be of any data type, including arrays! An array of arrays is called a <strong>multidimensional array</strong>.</p><pre class="language-cpp line-numbers"><code>int array[3][5]; // a 3-element array of 5-element arrays</code></pre><p>Since we have 2 subscripts, this is a two-dimensional array.</p><p>In a two-dimensional array, it is convenient to think of the first (left) subscript as being the row, and the second (right) subscript as being the column. This is called <strong>row-major</strong> order. Conceptually, the above two-dimensional array is laid out as follows:</p><pre>[0][0]  [0][1]  [0][2]  [0][3]  [0][4] // row 0
[1][0]  [1][1]  [1][2]  [1][3]  [1][4] // row 1
[2][0]  [2][1]  [2][2]  [2][3]  [2][4] // row 2
</pre><p>To access the elements of a two-dimensional array, simply use two subscripts:</p><pre class="language-cpp line-numbers"><code>array[2][3] = 7;</code></pre><p><strong>Initializing two-dimensional arrays</strong></p><p>To initialize a two-dimensional array, it is easiest to use nested braces, with each set of numbers representing a row:</p><pre class="language-cpp line-numbers"><code>int array[3][5]</code><code>{</code><code>  { 1, 2, 3, 4, 5 }, // row 0</code><code>  { 6, 7, 8, 9, 10 }, // row 1</code><code>  { 11, 12, 13, 14, 15 } // row 2</code><code>};</code></pre><p>Although some compilers will let you omit the inner braces, we highly recommend you include them anyway, both for readability purposes and because of the way that C++ will replace missing initializers with 0.</p><pre class="language-cpp line-numbers"><code>int array[3][5]</code><code>{</code><code>  { 1, 2 }, // row 0 = 1, 2, 0, 0, 0</code><code>  { 6, 7, 8 }, // row 1 = 6, 7, 8, 0, 0</code><code>  { 11, 12, 13, 14 } // row 2 = 11, 12, 13, 14, 0</code><code>};</code></pre><p>Two-dimensional arrays with initializer lists can omit (only) the leftmost length specification:</p><pre class="language-cpp line-numbers"><code>int array[][5]</code><code>{</code><code>  { 1, 2, 3, 4, 5 },</code><code>  { 6, 7, 8, 9, 10 },</code><code>  { 11, 12, 13, 14, 15 }</code><code>};</code></pre><p>The compiler can do the math to figure out what the array length is. However, the following is not allowed:</p><pre class="language-cpp line-numbers"><code>int array[][] </code><code>{</code><code>  { 1, 2, 3, 4 },</code><code>  { 5, 6, 7, 8 }</code><code>};</code></pre><p>Just like normal arrays, multidimensional arrays can still be initialized to 0 as follows:</p><pre class="language-cpp line-numbers"><code>int array[3][5]{};</code></pre><p><strong>Accessing elements in a two-dimensional array</strong></p><p>Accessing all of the elements of a two-dimensional array requires two loops: one for the row, and one for the column. Since two-dimensional arrays are typically accessed row by row, the row index is typically used as the outer loop.</p><pre class="language-cpp line-numbers"><code>for (int row{ 0 }; row &lt; numRows; ++row) // step through the rows in the array</code><code>{</code><code>    for (int col{ 0 }; col &lt; numCols; ++col) // step through each element in the row</code><code>    {</code><code>        std::cout &lt;&lt; array[row][col];</code><code>    }</code><code>}</code></pre><p>In C++11, <em>for-each</em> loops can also be used with multidimensional arrays. We’ll cover for-each loops in detail later.</p><p><strong>Multidimensional arrays larger than two dimensions</strong></p><p>Multidimensional arrays may be larger than two dimensions. Here is a declaration of a three-dimensional array:</p><pre class="language-cpp line-numbers"><code>int array[5][4][3];</code></pre><p>Three-dimensional arrays are hard to initialize in any kind of intuitive way using initializer lists, so it’s typically better to initialize the array to 0 and explicitly assign values using nested loops.</p><p>Accessing the element of a three-dimensional array is analogous to the two-dimensional case:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; array[3][1][2];</code></pre><p><strong>A two-dimensional array example</strong></p><p>Let’s take a look at a practical example of a two-dimensional array:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    constexpr int numRows{ 10 };</code><code>    constexpr int numCols{ 10 };</code><code></code><code>    // Declare a 10x10 array</code><code>    int product[numRows][numCols]{};</code><code></code><code>    // Calculate a multiplication table</code><code>    for (int row{ 1 }; row &lt; numRows; ++row)</code><code>    {</code><code>        for (int col{ 1 }; col &lt; numCols; ++col)</code><code>        {</code><code>            product[row][col] = row * col;</code><code>        }</code><code>     }</code><code></code><code>    // Print the table</code><code>    for (int row{ 1 }; row &lt; numRows; ++row)</code><code>    {</code><code>        for (int col{ 1 }; col &lt; numCols; ++col)</code><code>        {</code><code>            std::cout &lt;&lt; product[row][col] &lt;&lt; '\t';</code><code>        }</code><code></code><code>        std::cout &lt;&lt; '\n';</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program calculates and prints a multiplication table for all values between 1 and 9 (inclusive). Note that when printing the table, the for loops start from 1 instead of 0. This is to omit printing the 0 column and 0 row, which would just be a bunch of 0s! Here is the output:</p><pre>1    2    3    4    5    6    7    8    9
2    4    6    8    10   12   14   16   18
3    6    9    12   15   18   21   24   27
4    8    12   16   20   24   28   32   36
5    10   15   20   25   30   35   40   45
6    12   18   24   30   36   42   48   54
7    14   21   28   35   42   49   56   63
8    16   24   32   40   48   56   64   72
9    18   27   36   45   54   63   72   81
</pre><p>Two dimensional arrays are commonly used in tile-based games, where each array element represents one tile. They’re also used in 3d computer graphics (as matrices) in order to rotate, scale, and reflect shapes.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.6 — C-style strings</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-stdstring/">4.17 -- Introduction to std::string</a>, we defined a string as a collection of sequential characters, such as “Hello, world!”. Strings are the primary way in which we work with text in C++, and std::string makes working with strings in C++ easy.</p><p>Modern C++ supports two different types of strings: std::string (as part of the standard library), and C-style strings (natively, as inherited from the C language). It turns out that std::string is implemented using C-style strings. In this lesson, we’ll take a closer look at C-style strings.</p><p><strong>C-style strings</strong></p><p>A <strong>C-style string</strong> is simply an array of characters that uses a null terminator. A <strong>null terminator</strong> is a special character (‘\0’, ascii code 0) used to indicate the end of the string. More generically, A C-style string is called a <strong>null-terminated string</strong>.</p><p>To define a C-style string, simply declare a char array and initialize it with a string literal:</p><pre class="language-cpp line-numbers"><code>char myString[]{ "string" };</code></pre><p>Although “string” only has 6 letters, C++ automatically adds a null terminator to the end of the string for us (we don’t need to include it ourselves). Consequently, myString is actually an array of length 7!</p><p>We can see the evidence of this in the following program, which prints out the length of the string, and then the ASCII values of all of the characters:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator> // for std::size</iterator></code><code></code><code>int main()</code><code>{</code><code>    char myString[]{ "string" };</code><code>    const int length{ static_cast<int>(std::size(myString)) };</int></code><code>//  const int length{ sizeof(myString) / sizeof(myString[0]) }; // use instead if not C++17 capable</code><code>    std::cout &lt;&lt; myString &lt;&lt; " has " &lt;&lt; length &lt;&lt; " characters.\n";</code><code></code><code>    for (int index{ 0 }; index &lt; length; ++index)</code><code>        std::cout &lt;&lt; static_cast<int>(myString[index]) &lt;&lt; ' ';</int></code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This produces the result:</p><pre>string has 7 characters.
115 116 114 105 110 103 0
</pre><p>That 0 is the ASCII code of the null terminator that has been appended to the end of the string.</p><p>When declaring strings in this manner, it is a good idea to use [] and let the compiler calculate the length of the array. That way if you change the string later, you won’t have to manually adjust the array length.</p><p>One important point to note is that C-style strings follow <em>all</em> the same rules as arrays. This means you can initialize the string upon creation, but you can not assign values to it using the assignment operator after that!</p><pre class="language-cpp line-numbers"><code>char myString[]{ "string" }; // ok</code><code>myString = "rope"; // not ok!</code></pre><p>Since C-style strings are arrays, you can use the [] operator to change individual characters in the string:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    char myString[]{ "string" };</code><code>    myString[1] = 'p';</code><code>    std::cout &lt;&lt; myString &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>spring
</pre><p>When printing a C-style string, std::cout prints characters until it encounters the null terminator. If you accidentally overwrite the null terminator in a string (e.g. by assigning something to myString[6]), you’ll not only get all the characters in the string, but std::cout will just keep printing everything in adjacent memory slots until it happens to hit a 0!</p><p>Note that it’s fine if the array is larger than the string it contains:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    char name[20]{ "Alex" }; // only use 5 characters (4 letters + null terminator)</code><code>    std::cout &lt;&lt; "My name is: " &lt;&lt; name &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this case, the string “Alex” will be printed, and std::cout will stop at the null terminator. The rest of the characters in the array are ignored.</p><p><strong>C-style strings and std::cin</strong></p><p>There are many cases where we don’t know in advance how long our string is going to be. For example, consider the problem of writing a program where we need to ask the user to enter their name. How long is their name? We don’t know until they enter it!</p><p>In this case, we can declare an array larger than we need:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    char name[255] {}; // declare array large enough to hold 254 characters + null terminator</code><code>    std::cout &lt;&lt; "Enter your name: ";</code><code>    std::cin &gt;&gt; name;</code><code>    std::cout &lt;&lt; "You entered: " &lt;&lt; name &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above program, we’ve allocated an array of 255 characters to name, guessing that the user will not enter this many characters. Although this is commonly seen in C/C++ programming, it is poor programming practice, because nothing is stopping the user from entering more than 254 characters (either unintentionally, or maliciously).</p><p>The recommended way of reading C-style strings using <code>std::cin</code> is as follows:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator> // for std::size</iterator></code><code></code><code>int main()</code><code>{</code><code>    char name[255] {}; // declare array large enough to hold 254 characters + null terminator</code><code>    std::cout &lt;&lt; "Enter your name: ";</code><code>    std::cin.getline(name, std::size(name));</code><code>    std::cout &lt;&lt; "You entered: " &lt;&lt; name &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This call to cin.getline() will read up to 254 characters into name (leaving room for the null terminator!). Any excess characters will be discarded. In this way, we guarantee that we will not overflow the array!</p><p><strong>Manipulating C-style strings</strong></p><p>C++ provides many functions to manipulate C-style strings as part of the &lt;cstring&gt; header. Here are a few of the most useful:</p><p>strcpy() allows you to copy a string to another string. More commonly, this is used to assign a value to a string:</p><pre class="language-cpp line-numbers"><code>#include <cstring></cstring></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    char source[]{ "Copy this!" };</code><code>    char dest[50];</code><code>    std::strcpy(dest, source);</code><code>    std::cout &lt;&lt; dest &lt;&lt; '\n'; // prints "Copy this!"</code><code></code><code>    return 0;</code><code>}</code></pre><p>However, strcpy() can easily cause array overflows if you’re not careful! In the following program, dest isn’t big enough to hold the entire string, so array overflow results.</p><pre class="language-cpp line-numbers"><code>#include <cstring></cstring></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    char source[]{ "Copy this!" };</code><code>    char dest[5]; // note that the length of dest is only 5 chars!</code><code>    std::strcpy(dest, source); // overflow!</code><code>    std::cout &lt;&lt; dest &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Many programmers recommend using strncpy() instead, which allows you to specify the size of the buffer, and ensures overflow doesn’t occur. Unfortunately, strncpy() doesn’t ensure strings are null terminated, which still leaves plenty of room for array overflow.</p><p>In C++11, strcpy_s() is preferred, which adds a new parameter to define the size of the destination. However, not all compilers support this function, and to use it, you have to define <strong>STDC_WANT_LIB_EXT1</strong> with integer value 1.</p><pre class="language-cpp line-numbers"><code>#define __STDC_WANT_LIB_EXT1__ 1</code><code>#include <cstring> // for strcpy_s</cstring></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    char source[]{ "Copy this!" };</code><code>    char dest[5]; // note that the length of dest is only 5 chars!</code><code>    strcpy_s(dest, 5, source); // A runtime error will occur in debug mode</code><code>    std::cout &lt;&lt; dest &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because not all compilers support strcpy_s(), strlcpy() is a popular alternative -- even though it’s non-standard, and thus not included in a lot of compilers. It also has its own set of issues. In short, there’s no universally recommended solution here if you need to copy a C-style string.</p><p>Another useful function is the strlen() function, which returns the length of the C-style string (without the null terminator).</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cstring></cstring></code><code>#include <iterator> // for std::size</iterator></code><code></code><code>int main()</code><code>{</code><code>    char name[20]{ "Alex" }; // only use 5 characters (4 letters + null terminator)</code><code>    std::cout &lt;&lt; "My name is: " &lt;&lt; name &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; name &lt;&lt; " has " &lt;&lt; std::strlen(name) &lt;&lt; " letters.\n";</code><code>    std::cout &lt;&lt; name &lt;&lt; " has " &lt;&lt; std::size(name) &lt;&lt; " characters in the array.\n"; // use sizeof(name) / sizeof(name[0]) if not C++17 capable</code><code></code><code>    return 0;</code><code>}</code></pre><p>The above example prints:</p><pre>My name is: Alex
Alex has 4 letters.
Alex has 20 characters in the array.
</pre><p>Note the difference between strlen() and std::size(). strlen() prints the number of characters before the null terminator, whereas std::size (or the sizeof() trick) returns the size of the entire array, regardless of what’s in it.</p><p>Other useful functions:<br>strcat() -- Appends one string to another (dangerous)<br>strncat() -- Appends one string to another (with buffer length check)<br>strcmp() -- Compare two strings (returns 0 if equal)<br>strncmp() -- Compare two strings up to a specific number of characters (returns 0 if equal)</p><p>Here’s an example program using some of the concepts in this lesson:</p><pre class="language-cpp line-numbers"><code>#include <cstring></cstring></code><code>#include <iostream></iostream></code><code>#include <iterator> // for std::size</iterator></code><code></code><code>int main()</code><code>{</code><code>    // Ask the user to enter a string</code><code>    char buffer[255] {};</code><code>    std::cout &lt;&lt; "Enter a string: ";</code><code>    std::cin.getline(buffer, std::size(buffer));</code><code></code><code>    int spacesFound{ 0 };</code><code>    int bufferLength{ static_cast<int>(std::strlen(buffer)) };</int></code><code>    // Loop through all of the characters the user entered</code><code>    for (int index{ 0 }; index &lt; bufferLength; ++index)</code><code>    {</code><code>        // If the current character is a space, count it</code><code>        if (buffer[index] == ' ')</code><code>            ++spacesFound;</code><code>    }</code><code></code><code>    std::cout &lt;&lt; "You typed " &lt;&lt; spacesFound &lt;&lt; " spaces!\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note that we put <code>strlen(buffer)</code> outside the loop so that the string length is only calculated once, not every time the loop condition is checked.</p><p><strong>Don’t use C-style strings</strong></p><p>It is important to know about C-style strings because they are used in a lot of code. However, now that we’ve explained how they work, we’re going to recommend that you avoid them altogether whenever possible! Unless you have a specific, compelling reason to use C-style strings, use std::string (defined in the &lt;string&gt; header) instead. std::string is easier, safer, and more flexible. In the rare case that you do need to work with fixed buffer sizes and C-style strings (e.g. for memory-limited devices), we’d recommend using a well-tested 3rd party string library designed for the purpose, or <code>std::string_view</code>, which is covered in the next lesson, instead.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Rule</h4><p>Use <code>std::string</code> or <code>std::string_view</code> (next lesson) instead of C-style strings.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.7 — std::string_view (part 2)</h1></header><div class="entry-content" itemprop="articleBody"><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>Some of the content of this lesson was moved into the introduction to std::string_view lesson (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-stdstring_view/">4.18 -- Introduction to std::string_view</a>). As a result, this lesson contains some duplicative content that has not been cleaned up yet. This will be addressed when this chapter is rewritten (soon).</p></div><p>In the previous lesson, we talked about C-style strings, and the dangers of using them. C-style strings are fast, but they’re not as easy to use and as safe as <code>std::string</code>.</p><p>But <code>std::string</code> (which we covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-stdstring/">4.17 -- Introduction to std::string</a>), has some of its own downsides, particularly when it comes to const strings.</p><p></p><p>Consider the following example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>  char text[]{ "hello" };</code><code>  std::string str{ text };</code><code>  std::string more{ str };</code><code></code><code>  std::cout &lt;&lt; text &lt;&lt; ' ' &lt;&lt; str &lt;&lt; ' ' &lt;&lt; more &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><p>As expected, this prints</p><pre>hello hello hello
</pre><p>Internally, <code>main</code> copies the string “hello” 3 times, resulting in 4 copies. First, there is the string literal “hello”, which is known at compile-time and stored in the binary. One copy is created when we create the <code>char[]</code>. The following two <code>std::string</code> objects create one copy of the string each.</p><p>So why does <code>std::string</code> make a copy of the string used to initialize it? A <code>std::string</code> provides some useful guarantees about the string data it manages:</p><ul><li>The string data will be valid for as long as the string object is alive, and cleaned up when the string object dies.</li><li>The string’s value can only be modified by the string object.</li><li>The string’s value can be modified without affecting other objects (for non-const strings).</li></ul><p>A <code>std::string</code> object has no control over what kind of string is used to initialize it (that is the caller’s responsibility) -- the caller could destroy or modify the initialization string immediately after the <code>std::string</code> object is initialized. Post-initialization, the string object can not rely on the initializer in any way, otherwise the above guarantees could be violated.</p><p>By making a copy of the initialization string (that only it has access to), the string object can ensure that the value and lifetime of the string data is independent from other objects (including the initialization string).</p><p>However, in some cases, we don’t need these benefits (particularly for const <code>std::string</code> objects, which can’t modify their value). Consider the case where we we know a <code>std::string</code> won’t outlive it’s initialization string, and that the initialization string won’t be modified. In such cases, we’re paying a high cost (making a copy of the initialization string) for benefits we don’t need (independence from the initialization string).</p><br><h3>Introducing std::string_view</h3><p>Consider a window in your house, looking at a car sitting on the street. You can look through the window and see the car, but you can’t touch or move the car. Your window just provides a view to the car, which is a completely separate object.</p><p>C++17 introduces another way of using strings, <code>std::string_view</code>, which lives in the &lt;string_view&gt; header.</p><p>Unlike <code>std::string</code>, which keeps its own copy of the string, <code>std::string_view</code> provides a <em>view</em> of a string that is defined elsewhere.</p><p>We can re-write the above code to use <code>std::string_view</code> by replacing every <code>std::string</code> and <code>C-style string</code> with <code>std::string_view</code>.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>int main()</code><code>{</code><code>  std::string_view text{ "hello" }; // view the text "hello", which is stored in the binary</code><code>  std::string_view str{ text }; // view of the same "hello"</code><code>  std::string_view more{ str }; // view of the same "hello"</code><code></code><code>  std::cout &lt;&lt; text &lt;&lt; ' ' &lt;&lt; str &lt;&lt; ' ' &lt;&lt; more &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><p>The output is the same, but no more copies of the string “hello” are created. The string “hello” is stored in the binary and is not allocated at run-time. <code>text</code> is only a view onto the string “hello”, so no copy has to be created. When we copy a <code>std::string_view</code>, the new <code>std::string_view</code> observes the same string as the copied-from <code>std::string_view</code> is observing. This means that neither <code>str</code> nor <code>more</code> create any copies of the string. They are views onto the existing string “hello”.</p><p><code>std::string_view</code> is not only fast, but has many of the functions that we know from <code>std::string</code>.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code> </code><code>int main()</code><code>{</code><code>  std::string_view str{ "Trains are fast!" };</code><code> </code><code>  std::cout &lt;&lt; str.length() &lt;&lt; '\n'; // 16</code><code>  std::cout &lt;&lt; str.substr(0, str.find(' ')) &lt;&lt; '\n'; // Trains</code><code>  std::cout &lt;&lt; (str == "Trains are fast!") &lt;&lt; '\n'; // 1</code><code> </code><code>  // Since C++20</code><code>  std::cout &lt;&lt; str.starts_with("Boats") &lt;&lt; '\n'; // 0</code><code>  std::cout &lt;&lt; str.ends_with("fast!") &lt;&lt; '\n'; // 1</code><code> </code><code>  std::cout &lt;&lt; str &lt;&lt; '\n'; // Trains are fast!</code><code> </code><code>  return 0;</code><code>}</code></pre><p>Because <code>std::string_view</code> doesn’t create a copy of the string, if we change the viewed string, the changes are reflected in the <code>std::string_view</code>.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>int main()</code><code>{</code><code>  char arr[]{ "Gold" };</code><code>  std::string_view str{ arr };</code><code></code><code>  std::cout &lt;&lt; str &lt;&lt; '\n'; // Gold</code><code></code><code>  // Change 'd' to 'f' in arr</code><code>  arr[3] = 'f';</code><code></code><code>  std::cout &lt;&lt; str &lt;&lt; '\n'; // Golf</code><code></code><code>  return 0;</code><code>}</code></pre><p>We modified <code>arr</code>, but <code>str</code> appears to be changing as well. That’s because <code>arr</code> and <code>str</code> share their string. When you use a <code>std::string_view</code>, it’s best to avoid modifications to the underlying string for the remainder of the <code>std::string_view</code>‘s life to prevent confusion and errors.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Prefer <code>std::string_view</code> over <code>std::string</code> and C-style strings when you only need read-only access to a string (unless you can’t guarantee the string being viewed will stay alive for the lifetime of the <code>std::string_view</code>, in which case you should prefer <code>std::string</code>).</p></div><br><h3>View modification functions</h3><p>Back to our window analogy, consider a window with curtains. We can close either the left or right curtain to reduce what we can see. We don’t change what’s outside, we just reduce the visible area.</p><p>Similarly, <code>std::string_view</code> contains functions that let us manipulate the <em>view</em> of the string. This allows us to change the view without modifying the viewed string.</p><p>The functions for this are <code>remove_prefix</code>, which removes characters from the left side of the view, and <code>remove_suffix</code>, which removes characters from the right side of the view.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>int main()</code><code>{</code><code>  std::string_view str{ "Peach" };</code><code></code><code>  std::cout &lt;&lt; str &lt;&lt; '\n';</code><code></code><code>  // Ignore the first character.</code><code>  str.remove_prefix(1);</code><code></code><code>  std::cout &lt;&lt; str &lt;&lt; '\n';</code><code></code><code>  // Ignore the last 2 characters.</code><code>  str.remove_suffix(2);</code><code></code><code>  std::cout &lt;&lt; str &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><p>This program produces the following output:</p><pre>Peach
each
ea
</pre><p>Unlike real curtains, a <code>std::string_view</code> cannot be opened back up. Once you shrink the area, the only way to re-widen it is to reset the view by reassigning the source string to it again.</p><br><h3>std::string_view works with non-null-terminated strings</h3><p>Unlike C-style strings and <code>std::string</code>, <code>std::string_view</code> doesn’t use null terminators to mark the end of the string. Rather, it knows where the string ends because it keeps track of its length.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator> // For std::size</iterator></code><code>#include <string_view></string_view></code><code></code><code>int main()</code><code>{</code><code>  // No null-terminator.</code><code>  char vowels[]{ 'a', 'e', 'i', 'o', 'u' };</code><code></code><code>  // vowels isn't null-terminated. We need to pass the length manually.</code><code>  // Because vowels is an array, we can use std::size to get its length.</code><code>  std::string_view str{ vowels, std::size(vowels) };</code><code></code><code>  std::cout &lt;&lt; str &lt;&lt; '\n'; // This is safe. std::cout knows how to print std::string_view.</code><code></code><code>  return 0;</code><code>}</code></pre><p>This program prints:</p><pre>aeiou
</pre><br><h3>Converting a std::string_view to a C-style string</h3><p>Some old functions (such as the old strlen function) still expect C-style strings. To convert a <code>std::string_view</code> to a C-style string, we can do so by first converting to a <code>std::string</code>:</p><pre class="language-cpp line-numbers"><code>#include <cstring></cstring></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>int main()</code><code>{</code><code>  std::string_view sv{ "balloon" };</code><code></code><code>  sv.remove_suffix(3);</code><code></code><code>  // Create a std::string from the std::string_view</code><code>  std::string str{ sv };</code><code></code><code>  // Get the null-terminated C-style string.</code><code>  auto szNullTerminated{ str.c_str() };</code><code></code><code>  // Pass the null-terminated string to the function that we want to use.</code><code>  std::cout &lt;&lt; str &lt;&lt; " has " &lt;&lt; std::strlen(szNullTerminated) &lt;&lt; " letter(s)\n";</code><code></code><code>  return 0;</code><code>}</code></pre><p>This prints:</p><pre>ball has 4 letter(s)
</pre><p>However, creating a <code>std::string</code> every time we want to pass a <code>std::string_view</code> as a C-style string is expensive, so this should be avoided if possible.</p><br><h3>Passing strings by const std::string&amp; or std::string_view?</h3><p>One question that often comes up: is it better to pass strings by <code>const std::string&amp;</code> or <code>std::string_view</code>?</p><p>If we want to write a function that takes a string parameter, making the parameter a <code>std::string_view</code> is the most flexible choice, because it can work efficiently with C-style string arguments (including string literals), <code>std::string</code> arguments (which will implicitly convert to <code>std::string_view</code>), and <code>std::string_view</code> arguments:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>void printSV(std::string_view sv)</code><code>{</code><code>    std::cout &lt;&lt; sv &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::string s{ "Hello, world" };</code><code>    std::string_view sv { s };</code><code></code><code>    printSV(s);              // ok: pass std::string</code><code>    printSV(sv);             // ok: pass std::string_view</code><code>    printSV("Hello, world"); // ok: pass C-style string literal</code><code>    </code><code>    return 0;</code><code>}</code></pre><p>Note that we pass <code>std::string_view</code> by value instead of by const reference. This is because <code>std::string_view</code> is typically fast to copy, and pass by value is optimal for cheap to copy types.</p><p>There is one case where making the parameter a <code>const std::string&amp;</code> is generally better: if your function needs to call some other function that takes a C-style string or <code>std::string</code> parameter, then <code>const std::string&amp;</code> may be a better choice, as <code>std::string_view</code> is not guaranteed to be null-terminated (something that C-style string functions expect) and does not efficiently convert back to a std::string.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Prefer passing strings using <code>std::string_view</code> (by value) instead of <code>const std::string&amp;</code>, unless your function calls other functions that require C-style strings or std::string parameters.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>Many examples in future lessons were written prior to the introduction of <code>std::string_view</code>, and still use <code>const std::string&amp;</code> for function parameters when <code>std::string_view</code> should be preferred. We’re working on cleaning these up.</p></div><br><h3>Ownership issues</h3><p>A <code>std::string_view</code>‘s lifetime is independent of that of the string it is viewing (meaning the string being viewed can be destroyed before the <code>std::string_view</code> object). If this happens, then accessing the <code>std::string_view</code> will cause undefined behavior.</p><p>The string that a <code>std::string_view</code> is viewing has to have been created somewhere else. It might be a string literal that lives as long as the program does, or a <code>std::string</code>, in which case the string lives until the <code>std::string</code> decides to destroy it or the <code>std::string</code> dies.</p><p><code>std::string_view</code> can’t create any strings on its own, because it’s just a view.</p><p>Here’s an example of a program that has an ownership issue:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>std::string_view askForName()</code><code>{</code><code>  std::cout &lt;&lt; "What's your name?\n";</code><code></code><code>  // Use a std::string, because std::cin needs to modify it.</code><code>  std::string name{};</code><code>  std::cin &gt;&gt; name;</code><code></code><code>  // We're switching to std::string_view for demonstrative purposes only.</code><code>  // If you already have a std::string, there's no reason to switch to</code><code>  // a std::string_view.</code><code>  std::string_view view{ name };</code><code></code><code>  std::cout &lt;&lt; "Hello " &lt;&lt; view &lt;&lt; '\n';</code><code></code><code>  return view;</code><code>} // name dies, and so does the string that name created.</code><code></code><code>int main()</code><code>{</code><code>  std::string_view view{ askForName() };</code><code></code><code>  // view is observing a string that already died.</code><code>  std::cout &lt;&lt; "Your name is " &lt;&lt; view &lt;&lt; '\n'; // Undefined behavior</code><code></code><code>  return 0;</code><code>}</code></pre><pre>What's your name?
nascardriver
Hello nascardriver
Your name is �<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="93c3d3">[email&nbsp;protected]</a>�<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4e1e0e">[email&nbsp;protected]</a>
</pre><p>In function <code>askForName()</code>, we create <code>name</code> and fill it with data from <code>std::cin</code>. Then we create <code>view</code>, which can view that string. At the end of the function, we return <code>view</code>, but the string it is viewing (<code>name</code>) is destroyed, so <code>view</code> is now pointing to deallocated memory. The function returns a dangling <code>std::string_view</code>.</p><p>Accessing the returned <code>std::string_view</code> in <code>main</code> causes undefined behavior, which on the author’s machine produced weird characters.</p><p>The same can happen when we create a <code>std::string_view</code> from a <code>std::string</code> and then modify the <code>std::string</code>. Modifying a <code>std::string</code> can cause its internal string to die and be replaced with a new one in a different place. The <code>std::string_view</code> will still look at where the old string was, but it’s not there anymore.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Make sure that the underlying string viewed with a <code>std::string_view</code> does not go out of scope and isn’t modified while using the std::string_view.</p></div><br><h3>Opening the window (kinda) via the data() function</h3><p>The string being viewed by a <code>std::string_view</code> can be accessed by using the <code>data()</code> function, which returns a C-style string. This provides fast access to the string being viewed (as a C-string). But it should also only be used if the <code>std::string_view</code>‘s view hasn’t been modified (e.g. by <code>remove_prefix</code> or <code>remove_suffix</code>) and the string being viewed is null-terminated.</p><p>In the following example, <code>std::strlen</code> doesn’t know what a <code>std::string_view</code> is, so we need to pass it <code>str.data()</code>:</p><pre class="language-cpp line-numbers"><code>#include <cstring> // For std::strlen</cstring></code><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>int main()</code><code>{</code><code>  std::string_view str{ "balloon" };</code><code></code><code>  std::cout &lt;&lt; str &lt;&lt; '\n';</code><code></code><code>  // We use std::strlen because it's simple, this could be any other function</code><code>  // that needs a null-terminated string.</code><code>  // It's okay to use data() because we haven't modified the view, and the</code><code>  // string is null-terminated.</code><code>  std::cout &lt;&lt; std::strlen(str.data()) &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><pre>balloon
7
</pre><p>When a <code>std::string_view</code> has been modified, <code>data()</code> doesn’t always do what we’d like it to. The following example demonstrates what happens when we access <code>data()</code> after modifying the view:</p><pre class="language-cpp line-numbers"><code>#include <cstring></cstring></code><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>int main()</code><code>{</code><code>  std::string_view str{ "balloon" };</code><code></code><code>  // Remove the "b"</code><code>  str.remove_prefix(1);</code><code>  // remove the "oon"</code><code>  str.remove_suffix(3);</code><code>  // Remember that the above doesn't modify the string, it only changes</code><code>  // the region that str is observing.</code><code></code><code>  std::cout &lt;&lt; str &lt;&lt; " has " &lt;&lt; std::strlen(str.data()) &lt;&lt; " letter(s)\n";</code><code>  std::cout &lt;&lt; "str.data() is " &lt;&lt; str.data() &lt;&lt; '\n';</code><code>  std::cout &lt;&lt; "str is " &lt;&lt; str &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><pre>all has 6 letter(s)
str.data() is alloon
str is all
</pre><p>Clearly this isn’t what we’d intended, and is a consequence of trying to access the data() of a <code>std::string_view</code> that has been modified. The length information about the string is lost when we access <code>data()</code>. <code>std::strlen</code> and <code>std::cout</code> keep reading characters from the underlying string until they find the null-terminator, which is at the end of “balloon”.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Only use <code>std::string_view::data()</code> if the <code>std::string_view</code>‘s view hasn’t been modified and the string being viewed is null-terminated. Using <code>std::string_view::data()</code> of a non-null-terminated string can cause undefined behavior.</p></div><br><h3>Incomplete implementation</h3><p>Being a relatively recent feature, <code>std::string_view</code> isn’t implemented as well as it could be.</p><pre class="language-cpp line-numbers"><code>std::string s{ "hello" };</code><code>std::string_view v{ "world" };</code><code></code><code>// Doesn't work</code><code>std::cout &lt;&lt; (s + v) &lt;&lt; '\n';</code><code>std::cout &lt;&lt; (v + s) &lt;&lt; '\n';</code><code></code><code>// Potentially unsafe, or not what we want, because we're treating</code><code>// the std::string_view as a C-style string.</code><code>std::cout &lt;&lt; (s + v.data()) &lt;&lt; '\n';</code><code>std::cout &lt;&lt; (v.data() + s) &lt;&lt; '\n';</code><code></code><code>// Ok, but ugly and wasteful because we have to construct a new std::string.</code><code>std::cout &lt;&lt; (s + std::string{ v }) &lt;&lt; '\n';</code><code>std::cout &lt;&lt; (std::string{ v } + s) &lt;&lt; '\n';</code><code>std::cout &lt;&lt; (s + static_cast<std::string>(v)) &lt;&lt; '\n';</std::string></code><code>std::cout &lt;&lt; (static_cast<std::string>(v) + s) &lt;&lt; '\n';</std::string></code></pre><p>There’s no reason why line 5 and 6 shouldn’t work. They will probably be supported in a future C++ version.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.8 — Pointers and arrays</h1></header><div class="entry-content" itemprop="articleBody"><p>Pointers and arrays are intrinsically related in C++.</p><p><strong>Array decay</strong></p><p>In a previous lesson, you learned how to define a fixed array:</p><pre class="language-cpp line-numbers"><code>int array[5]{ 9, 7, 5, 3, 1 }; // declare a fixed array of 5 integers</code></pre><p>To us, the above is an array of 5 integers, but to the compiler, array is a variable of type int[5]. We know what the values of array[0], array[1], array[2], array[3], and array[4] are (9, 7, 5, 3, and 1 respectively).</p><p>In all but two cases (which we’ll cover below), when a fixed array is used in an expression, the fixed array will <strong>decay</strong> (be implicitly converted) into a pointer that points to the first element of the array. You can see this in the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int array[5]{ 9, 7, 5, 3, 1 };</code><code></code><code>    // print address of the array's first element</code><code>    std::cout &lt;&lt; "Element 0 has address: " &lt;&lt; &amp;array[0] &lt;&lt; '\n';</code><code></code><code>    // print the value of the pointer the array decays to</code><code>    std::cout &lt;&lt; "The array decays to a pointer holding address: " &lt;&lt; array &lt;&lt; '\n';</code><code></code><code></code><code>    return 0;</code><code>}</code></pre><p>On the author’s machine, this printed:</p><pre>Element 0 has address: 0042FD5C
The array decays to a pointer holding address: 0042FD5C
</pre><p>It’s a common fallacy in C++ to believe an array and a pointer to the array are identical. They’re not. In the above case, array is of type “int[5]”, and its “value” is the array elements themselves. A pointer to the array would be of type “int*”, and its value would be the address of the first element of the array.</p><p>We’ll see where this makes a difference shortly.</p><p>All elements of the array can still be accessed through the pointer (we’ll see how this works in the next lesson), but information derived from the array’s type (such as how long the array is) can not be accessed from the pointer.</p><p>However, this also effectively allows us to treat fixed arrays and pointers identically in most cases.</p><p>For example, we can dereference the array to get the value of the first element:</p><pre class="language-cpp line-numbers"><code>int array[5]{ 9, 7, 5, 3, 1 };</code><code></code><code>// Deferencing an array returns the first element (element 0)</code><code>std::cout &lt;&lt; *array; // will print 9!</code><code></code><code>char name[]{ "Jason" }; // C-style string (also an array)</code><code>std::cout &lt;&lt; *name &lt;&lt; '\n'; // will print 'J'</code></pre><p>Note that we’re not <em>actually</em> dereferencing the array itself. The array (of type int[5]) gets implicitly converted into a pointer (of type int*), and we dereference the pointer to get the value at the memory address the pointer is holding (the value of the first element of the array).</p><p>We can also assign a pointer to point at the array:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int array[5]{ 9, 7, 5, 3, 1 };</code><code>    std::cout &lt;&lt; *array &lt;&lt; '\n'; // will print 9</code><code></code><code>    int* ptr{ array };</code><code>    std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // will print 9</code><code></code><code>    return 0;</code><code>}</code></pre><p>This works because the array decays into a pointer of type int*, and our pointer (also of type int*) has the same type.</p><p><strong>Differences between pointers and fixed arrays</strong></p><p>There are a few cases where the difference in typing between fixed arrays and pointers makes a difference. These help illustrate that a fixed array and a pointer are not the same.</p><p>The primary difference occurs when using the sizeof() operator. When used on a fixed array, sizeof returns the size of the entire array (array length * element size). When used on a pointer, sizeof returns the size of the pointer (in bytes). The following program illustrates this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int array[5]{ 9, 7, 5, 3, 1 };</code><code></code><code>    std::cout &lt;&lt; sizeof(array) &lt;&lt; '\n'; // will print sizeof(int) * array length</code><code></code><code>    int* ptr{ array };</code><code>    std::cout &lt;&lt; sizeof(ptr) &lt;&lt; '\n'; // will print the size of a pointer</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>20
4
</pre><p>A fixed array knows how long the array it is pointing to is. A pointer to the array does not.</p><p>The second difference occurs when using the address-of operator (&amp;). Taking the address of a pointer yields the memory address of the pointer variable. Taking the address of the array returns a pointer to the entire array. This pointer also points to the first element of the array, but the type information is different (in the above example, the type of <code>&amp;array</code> is <code>int(*)[5]</code>). It’s unlikely you’ll ever need to use this.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int array[5]{ 9, 7, 5, 3, 1 };</code><code>    std::cout &lt;&lt; array &lt;&lt; '\n';	 // type int[5], prints 009DF9D4</code><code>    std::cout &lt;&lt; &amp;array &lt;&lt; '\n'; // type int(*)[5], prints 009DF9D4</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    int* ptr{ array };</code><code>    std::cout &lt;&lt; ptr &lt;&lt; '\n';	 // type int*, prints 009DF9D4</code><code>    std::cout &lt;&lt; &amp;ptr &lt;&lt; '\n';	 // type int**, prints 009DF9C8</code><code></code><code>    return 0;</code><code>}</code><code>// h/t to reader PacMan for this example</code></pre><p><strong>Revisiting passing fixed arrays to functions</strong></p><p>Back in lesson <a href="https://www.learncpp.com/cpp-tutorial/arrays-part-ii/">11.2 -- Arrays (Part II)</a>, we mentioned that because copying large arrays can be very expensive, C++ does not copy an array when an array is passed into a function. When passing an array as an argument to a function, a fixed array decays into a pointer, and the pointer is passed to the function:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printSize(int* array)</code><code>{</code><code>    // array is treated as a pointer here</code><code>    std::cout &lt;&lt; sizeof(array) &lt;&lt; '\n'; // prints the size of a pointer, not the size of the array!</code><code>}</code><code> </code><code>int main()</code><code>{</code><code>    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };</code><code>    std::cout &lt;&lt; sizeof(array) &lt;&lt; '\n'; // will print sizeof(int) * array length</code><code></code><code>    printSize(array); // the array argument decays into a pointer here</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>32
4
</pre><p>Note that this happens even if the parameter is declared as a fixed array:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// C++ will implicitly convert parameter array[] to *array</code><code>void printSize(int array[])</code><code>{</code><code>    // array is treated as a pointer here, not a fixed array</code><code>    std::cout &lt;&lt; sizeof(array) &lt;&lt; '\n'; // prints the size of a pointer, not the size of the array!</code><code>}</code><code> </code><code>int main()</code><code>{</code><code>    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };</code><code>    std::cout &lt;&lt; sizeof(array) &lt;&lt; '\n'; // will print sizeof(int) * array length</code><code></code><code>    printSize(array); // the array argument decays into a pointer here</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>32
4
</pre><p>In the above example, C++ implicitly converts parameters using the array syntax ([]) to the pointer syntax (*). That means the following two function declarations are identical:</p><pre class="language-cpp line-numbers"><code>void printSize(int array[]);</code><code>void printSize(int* array);</code></pre><p>Some programmers prefer using the [] syntax because it makes it clear that the function is expecting an array, not just a pointer to a value. However, in most cases, because the pointer doesn’t know how large the array is, you’ll need to pass in the array size as a separate parameter anyway (strings being an exception because they’re null terminated).</p><p>We recommend using the pointer syntax, because it makes it clear that the parameter is being treated as a pointer, not a fixed array, and that certain operations, such as sizeof(), will operate as if the parameter is a pointer.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Favor the pointer syntax (*) over the array syntax ([]) for array function parameters.</p></div><p><strong>An intro to pass by address</strong></p><p>The fact that arrays decay into pointers when passed to a function explains the underlying reason why changing an array in a function changes the actual array argument passed in. Consider the following example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// parameter ptr contains a copy of the array's address</code><code>void changeArray(int* ptr)</code><code>{</code><code>    *ptr = 5; // so changing an array element changes the _actual_ array</code><code>}</code><code> </code><code>int main()</code><code>{</code><code>    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };</code><code>    std::cout &lt;&lt; "Element 0 has value: " &lt;&lt; array[0] &lt;&lt; '\n';</code><code></code><code>    changeArray(array);</code><code></code><code>    std::cout &lt;&lt; "Element 0 has value: " &lt;&lt; array[0] &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><pre>Element 0 has value: 1
Element 0 has value: 5
</pre><p>When changeArray() is called, array decays into a pointer, and the value of that pointer (the memory address of the first element of the array) is copied into the ptr parameter of function changeArray(). Although the value in ptr is a copy of the address of the array, ptr still points at the actual array (not a copy!). Consequently, when dereferencing ptr, the element accessed is the actual first element of the array!</p><p>Astute readers will note this phenomenon works with pointers to non-array values as well.</p><p><strong>Arrays in structs and classes don’t decay</strong></p><p>Finally, it is worth noting that arrays that are part of structs or classes do not decay when the whole struct or class is passed to a function. This yields a useful way to prevent decay if desired, and will be valuable later when we write classes that utilize arrays.</p><p>In the next lesson, we’ll take a look at pointer arithmetic, and talk about how array indexing actually works.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.9 — Pointer arithmetic and array indexing</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Pointer arithmetic</h3><p>The C++ language allows you to perform integer addition or subtraction operations on pointers. If <code>ptr</code> points to an integer, <code>ptr + 1</code> is the address of the next integer in memory after ptr. <code>ptr - 1</code> is the address of the previous integer before <code>ptr</code>.</p><p>Note that <code>ptr + 1</code> does not return the <em>memory address</em> after <code>ptr</code>, but the memory address of the <em>next object of the type</em> that <code>ptr</code> points to. If <code>ptr</code> points to an integer (assuming 4 bytes), <code>ptr + 3</code> means 3 integers (12 bytes) after <code>ptr</code>. If <code>ptr</code> points to a <code>char</code>, which is always 1 byte, <code>ptr + 3</code> means 3 chars (3 bytes) after ptr.</p><p>When calculating the result of a pointer arithmetic expression, the compiler always multiplies the integer operand by the size of the object being pointed to. This is called <strong>scaling</strong>.</p><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int value{ 7 };</code><code>    int* ptr{ &amp;value };</code><code></code><code>    std::cout &lt;&lt; ptr &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; ptr+1 &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; ptr+2 &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; ptr+3 &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>On the author’s machine, this output:</p><pre>0012FF7C
0012FF80
0012FF84
0012FF88
</pre><p>As you can see, each of these addresses differs by 4 (7C + 4 = 80 in hexadecimal). This is because an integer is 4 bytes on the author’s machine.</p><p>The same program using <code>short</code> instead of <code>int</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    short value{ 7 };</code><code>    short* ptr{ &amp;value };</code><code></code><code>    std::cout &lt;&lt; ptr &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; ptr+1 &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; ptr+2 &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; ptr+3 &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>On the author’s machine, this output:</p><pre>0012FF7C
0012FF7E
0012FF80
0012FF82
</pre><p>Because a short is 2 bytes, each address differs by 2.</p><p><strong>Arrays are laid out sequentially in memory</strong></p><p>By using the address-of operator (&amp;), we can determine that arrays are laid out sequentially in memory. That is, elements 0, 1, 2, … are all adjacent to each other, in order.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int array[]{ 9, 7, 5, 3, 1 };</code><code></code><code>    std::cout &lt;&lt; "Element 0 is at address: " &lt;&lt; &amp;array[0] &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "Element 1 is at address: " &lt;&lt; &amp;array[1] &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "Element 2 is at address: " &lt;&lt; &amp;array[2] &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "Element 3 is at address: " &lt;&lt; &amp;array[3] &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>On the author’s machine, this printed:</p><pre>Element 0 is at address: 0041FE9C
Element 1 is at address: 0041FEA0
Element 2 is at address: 0041FEA4
Element 3 is at address: 0041FEA8
</pre><p>Note that each of these memory addresses is 4 bytes apart, which is the size of an integer on the author’s machine.</p><br><h3>Pointer arithmetic, arrays, and the magic behind indexing</h3><p>In the section above, you learned that arrays are laid out in memory sequentially.</p><p>In the previous lesson, you learned that a fixed array can decay into a pointer that points to the first element (element 0) of the array.</p><p>Also in a section above, you learned that adding 1 to a pointer returns the memory address of the next object of that type in memory.</p><p>Therefore, we might conclude that adding 1 to an array should point to the second element (element 1) of the array. We can verify experimentally that this is true:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>     int array[]{ 9, 7, 5, 3, 1 };</code><code></code><code>     std::cout &lt;&lt; &amp;array[1] &lt;&lt; '\n'; // print memory address of array element 1</code><code>     std::cout &lt;&lt; array+1 &lt;&lt; '\n'; // print memory address of array pointer + 1 </code><code></code><code>     std::cout &lt;&lt; array[1] &lt;&lt; '\n'; // prints 7</code><code>     std::cout &lt;&lt; *(array+1) &lt;&lt; '\n'; // prints 7 (note the parenthesis required here)</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note that when performing indirection through the result of pointer arithmetic, parenthesis are necessary to ensure the operator precedence is correct, since operator * has higher precedence than operator +.</p><p>On the author’s machine, this printed:</p><pre>0017FB80
0017FB80
7
7
</pre><p>It turns out that when the compiler sees the subscript operator ([]), it actually translates that into a pointer addition and indirection! Generalizing, <code>array[n]</code> is the same as <code>*(array + n)</code>, where n is an integer. The subscript operator [] is there both to look nice and for ease of use (so you don’t have to remember the parenthesis).</p><br><h3>Using a pointer to iterate through an array</h3><p>We can use a pointer and pointer arithmetic to loop through an array. Although not commonly done this way (using subscripts is generally easier to read and less error prone), the following example goes to show it is possible:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator> // for std::size</iterator></code><code></code><code>bool isVowel(char ch)</code><code>{</code><code>    switch (ch)</code><code>    {</code><code>    case 'A':</code><code>    case 'a':</code><code>    case 'E':</code><code>    case 'e':</code><code>    case 'I':</code><code>    case 'i':</code><code>    case 'O':</code><code>    case 'o':</code><code>    case 'U':</code><code>    case 'u':</code><code>        return true;</code><code>    default:</code><code>        return false;</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    char name[]{ "Mollie" };</code><code>    int arrayLength{ static_cast<int>(std::size(name)) };</int></code><code>    int numVowels{ 0 };</code><code></code><code>    for (char* ptr{ name }; ptr != (name + arrayLength); ++ptr)</code><code>    {</code><code>        if (isVowel(*ptr))</code><code>        {</code><code>            ++numVowels;</code><code>        }</code><code>    }</code><code></code><code>    std::cout &lt;&lt; name &lt;&lt; " has " &lt;&lt; numVowels &lt;&lt; " vowels.\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>How does it work? This program uses a pointer to step through each of the elements in an array. Remember that arrays decay to pointers to the first element of the array. So by initializing <code>ptr</code> with <code>name</code>, <code>ptr</code> will point to the first element of the array. Indirection through <code>ptr</code> is performed for each element when we call <code>isVowel(*ptr)</code>, and if the element is a vowel, <code>numVowels</code> is incremented. Then the for loop uses the ++ operator to advance the pointer to the next character in the array. The for loop terminates when all characters have been examined.</p><p>The above program produces the result:</p><pre>Mollie has 3 vowels
</pre><p>Because counting elements is common, the algorithms library offers <code>std::count_if</code>, which counts elements that fulfill a condition. We can replace the <code>for</code>-loop with a call to <code>std::count_if</code>.</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <iostream></iostream></code><code>#include <iterator> // for std::begin and std::end</iterator></code><code></code><code>bool isVowel(char ch)</code><code>{</code><code>    switch (ch)</code><code>    {</code><code>    case 'A':</code><code>    case 'a':</code><code>    case 'E':</code><code>    case 'e':</code><code>    case 'I':</code><code>    case 'i':</code><code>    case 'O':</code><code>    case 'o':</code><code>    case 'U':</code><code>    case 'u':</code><code>        return true;</code><code>    default:</code><code>        return false;</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    char name[]{ "Mollie" };</code><code></code><code>    // walk through all the elements of name and count how many calls to isVowel return true</code><code>    auto numVowels{ std::count_if(std::begin(name), std::end(name), isVowel) };</code><code></code><code>    std::cout &lt;&lt; name &lt;&lt; " has " &lt;&lt; numVowels &lt;&lt; " vowels.\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p><code>std::begin</code> returns an iterator (pointer) to the first element, while <code>std::end</code> returns an iterator to the element that would be one after the last. The iterator returned by <code>std::end</code> is only used as a marker, accessing it causes undefined behavior, because it doesn’t point to a real element.</p><p><code>std::begin</code> and <code>std::end</code> only work on arrays with a known size. If the array decayed to a pointer, we can calculate begin and end manually.</p><pre class="language-cpp line-numbers"><code>// nameLength is the number of elements in the array.</code><code>std::count_if(name, name + nameLength, isVowel)</code><code></code><code>// Don't do this. Accessing invalid indexes causes undefined behavior.</code><code>// std::count_if(name, &amp;name[nameLength], isVowel)</code></pre><p>Note that we’re calculating <code>name + nameLength</code>, not <code>name + nameLength - 1</code>, because we don’t want the last element, but the pseudo-element one past the last.</p><p>Calculating begin and end of an array like this works for all algorithms that need a begin and end argument.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Why does the following code work?</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	int arr[]{ 1, 2, 3 };</code><code></code><code>	std::cout &lt;&lt; 2[arr] &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>The subscript operator (<code>[]</code>) is identical to an addition and an indirection, the operands can be swapped.</p><pre class="language-cpp line-numbers"><code>arr[2]</code><code>// same as</code><code>*(arr + 2)</code><code>// same as</code><code>*(2 + arr)</code><code>// same as</code><code>2[arr]</code></pre><p>It’s an interesting observation, but don’t use this syntax in real code. This only works for the built-in subscript operator. You’ll learn about types with custom operators where this doesn’t work later.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>Write a function named <code>findValue</code> that takes a pointer to the beginning and a pointer to the end (1 element past the last) of an array, as well as a value. The function should search for the given value and return a pointer to the first element with that value, or the end pointer if no element was found. The following program should run:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator></iterator></code><code></code><code>// ...</code><code></code><code>int main()</code><code>{</code><code>    int arr[]{ 2, 5, 4, 10, 8, 20, 16, 40 };</code><code></code><code>    // Search for the first element with value 20.</code><code>    int* found{ findValue(std::begin(arr), std::end(arr), 20) };</code><code></code><code>    // If an element with value 20 was found, print it.</code><code>    if (found != std::end(arr))</code><code>    {</code><code>        std::cout &lt;&lt; *found &lt;&lt; '\n';</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p><code>std::begin</code> and <code>std::end</code> return an <code>int*</code>. The call to <code>findValue</code> is equivalent to</p><pre class="language-cpp line-numbers"><code>int* found{ findValue(arr, arr + std::size(arr), 20) };</code></pre></div><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator></iterator></code><code></code><code>int* findValue(int* begin, int* end, int value)</code><code>{</code><code>    // We're using !=, rather than &lt;, because != is compatible with more types</code><code>    // than &lt;. This is common practice around iterators, which are covered later.</code><code>    // It has no advantage when used with pointers, but makes code consistent.</code><code>    for (int* p{ begin }; p != end; ++p)</code><code>    {</code><code>        if (*p == value)</code><code>        {</code><code>            return p;</code><code>        }</code><code>    }</code><code></code><code>    return end;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int arr[]{ 2, 5, 4, 10, 8, 20, 16, 40 };</code><code></code><code>    int* found{ findValue(std::begin(arr), std::end(arr), 20) };</code><code></code><code>    if (found != std::end(arr))</code><code>    {</code><code>        std::cout &lt;&lt; *found &lt;&lt; '\n';</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p><code>std::find</code> is a standard function that does the same thing as findValue(). It should be preferred over writing your own.</p><pre class="language-cpp line-numbers"><code>#include <algorithm> // std::find</algorithm></code><code>#include <iostream></iostream></code><code>#include <iterator></iterator></code><code></code><code>int main()</code><code>{</code><code>    int arr[]{ 2, 5, 4, 10, 8, 20, 16, 40 };</code><code></code><code>    // Note: std::find returns an iterator, we'll talk about iterators later.</code><code>    auto found{ std::find(std::begin(arr), std::end(arr), 20) };</code><code></code><code>    if (found != std::end(arr))</code><code>    {</code><code>        std::cout &lt;&lt; *found &lt;&lt; '\n';</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre></div></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.10 — C-style string symbolic constants</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>C-style string symbolic constants</strong></p><p>In a previous lesson, we discussed how you could create and initialize a C-style string, like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    char myName[]{ "Alex" }; // fixed array</code><code>    std::cout &lt;&lt; myName &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>C++ also supports a way to create C-style string symbolic constants using pointers:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    const char* myName{ "Alex" }; // pointer to symbolic constant</code><code>    std::cout &lt;&lt; myName &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>While these above two programs operate and produce the same results, C++ deals with the memory allocation for these slightly differently.</p><p>In the fixed array case, the program allocates memory for a fixed array of length 5, and initializes that memory with the string “Alex\0”. Because memory has been specifically allocated for the array, you’re free to alter the contents of the array. The array itself is treated as a normal local variable, so when the array goes out of scope, the memory used by the array is freed up for other uses.</p><p>In the symbolic constant case, how the compiler handles this is implementation defined. What <em>usually</em> happens is that the compiler places the string “Alex\0” into read-only memory somewhere, and then sets the pointer to point to it. Because this memory may be read-only, best practice is to make sure the string is const.</p><p>For optimization purposes, multiple string literals may be consolidated into a single value. For example:</p><pre class="language-cpp line-numbers"><code>const char* name1{ "Alex" };</code><code>const char* name2{ "Alex" };</code></pre><p>These are two different string literals with the same value. The compiler may opt to combine these into a single shared string literal, with both name1 and name2 pointed at the same address. Thus, if name1 was not const, making a change to name1 could also impact name2 (which might not be expected).</p><p>As a result of string literals being stored in a fixed location in memory, string literals have static duration rather than automatic duration (that is, they die at the end of the program, not the end of the block in which they are defined). That means that when we use string literals, we don’t have to worry about scoping issues. Thus, the following is okay:</p><pre class="language-cpp line-numbers"><code>const char* getName()</code><code>{</code><code>    return "Alex";</code><code>}</code></pre><p>In the above code, <code>getName()</code> will return a pointer to C-style string “Alex”. If this function were returning any other local variable by address, the variable would be destroyed at the end of <code>getName()</code>, and we’d return a dangling pointer back to the caller. However, because string literals have static duration, “Alex” will not be destroyed when <code>getName()</code> terminates, so the caller can still successfully access it.</p><p>C-style strings are used in a lot of old or low-level code, because they have a very small memory footprint. Modern code should favor the use <code>std::string</code> and <code>std::string_view</code>, as those provide safe and easy access to the string.</p><p></p><p><strong>std::cout and char pointers</strong></p><p>At this point, you may have noticed something interesting about the way <code>std::cout</code> handles pointers of different types.</p><p>Consider the following example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int nArray[5]{ 9, 7, 5, 3, 1 };</code><code>    char cArray[]{ "Hello!" };</code><code>    const char* name{ "Alex" };</code><code></code><code>    std::cout &lt;&lt; nArray &lt;&lt; '\n'; // nArray will decay to type int*</code><code>    std::cout &lt;&lt; cArray &lt;&lt; '\n'; // cArray will decay to type char*</code><code>    std::cout &lt;&lt; name &lt;&lt; '\n'; // name is already type char*</code><code></code><code>    return 0;</code><code>}</code></pre><p>On the author’s machine, this printed:</p><pre>003AF738
Hello!
Alex
</pre><p>Why did the int array print an address, but the character arrays printed strings?</p><p>The answer is that <code>std::cout</code> makes some assumptions about your intent. If you pass it a non-char pointer, it will simply print the contents of that pointer (the address that the pointer is holding). However, if you pass it an object of type <code>char*</code> or <code>const char*</code>, it will assume you’re intending to print a string. Consequently, instead of printing the pointer’s value, it will print the string being pointed to instead!</p><p>While this is great 99% of the time, it can lead to unexpected results. Consider the following case:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    char c{ 'Q' };</code><code>    std::cout &lt;&lt; &amp;c;</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this case, the programmer is intending to print the address of variable c. However, &amp;c has type char*, so std::cout tries to print this as a string! On the author’s machine, this printed:</p><pre>Q╠╠╠╠╜╡4;¿■A
</pre><p>Why did it do this? Well, it assumed &amp;c (which has type char*) was a string. So it printed the ‘Q’, and then kept going. Next in memory was a bunch of garbage. Eventually, it ran into some memory holding a 0 value, which it interpreted as a null terminator, so it stopped. What you see may be different depending on what’s in memory after variable c.</p><p>This case is somewhat unlikely to occur in real-life (as you’re not likely to actually want to print memory addresses), but it is illustrative of how things work under the hood, and how programs can inadvertently go off the rails.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.11 — Dynamic memory allocation with new and delete</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>The need for dynamic memory allocation</strong></p><p>C++ supports three basic types of memory allocation, of which you’ve already seen two.</p><ul><li><strong>Static memory allocation</strong> happens for static and global variables. Memory for these types of variables is allocated once when your program is run and persists throughout the life of your program.</li><li><strong>Automatic memory allocation</strong> happens for function parameters and local variables. Memory for these types of variables is allocated when the relevant block is entered, and freed when the block is exited, as many times as necessary.</li><li><strong>Dynamic memory allocation</strong> is the topic of this article.</li></ul><p>Both static and automatic allocation have two things in common:</p><ul><li>The size of the variable / array must be known at compile time.</li><li>Memory allocation and deallocation happens automatically (when the variable is instantiated / destroyed).</li></ul><p>Most of the time, this is just fine. However, you will come across situations where one or both of these constraints cause problems, usually when dealing with external (user or file) input.</p><p>For example, we may want to use a string to hold someone’s name, but we do not know how long their name is until they enter it. Or we may want to read in a number of records from disk, but we don’t know in advance how many records there are. Or we may be creating a game, with a variable number of monsters (that changes over time as some monsters die and new ones are spawned) trying to kill the player.</p><p>If we have to declare the size of everything at compile time, the best we can do is try to make a guess the maximum size of variables we’ll need and hope that’s enough:</p><pre class="language-cpp line-numbers"><code>char name[25]; // let's hope their name is less than 25 chars!</code><code>Record record[500]; // let's hope there are less than 500 records!</code><code>Monster monster[40]; // 40 monsters maximum</code><code>Polygon rendering[30000]; // this 3d rendering better not have more than 30,000 polygons!</code></pre><p>This is a poor solution for at least four reasons:</p><p>First, it leads to wasted memory if the variables aren’t actually used. For example, if we allocate 25 chars for every name, but names on average are only 12 chars long, we’re using over twice what we really need. Or consider the rendering array above: if a rendering only uses 10,000 polygons, we have 20,000 Polygons worth of memory not being used!</p><p>Second, how do we tell which bits of memory are actually used? For strings, it’s easy: a string that starts with a \0 is clearly not being used. But what about monster[24]? Is it alive or dead right now? That necessitates having some way to tell active from inactive items, which adds complexity and can use up additional memory.</p><p>Third, most normal variables (including fixed arrays) are allocated in a portion of memory called the <strong>stack</strong>. The amount of stack memory for a program is generally quite small -- Visual Studio defaults the stack size to 1MB. If you exceed this number, stack overflow will result, and the operating system will probably close down the program.</p><p>On Visual Studio, you can see this happen when running this program:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    int array[1000000]; // allocate 1 million integers (probably 4MB of memory)</code><code>}</code></pre><p>Being limited to just 1MB of memory would be problematic for many programs, especially those that deal with graphics.</p><p>Fourth, and most importantly, it can lead to artificial limitations and/or array overflows. What happens when the user tries to read in 600 records from disk, but we’ve only allocated memory for a maximum of 500 records? Either we have to give the user an error, only read the 500 records, or (in the worst case where we don’t handle this case at all) overflow the record array and watch something bad happen.</p><p>Fortunately, these problems are easily addressed via dynamic memory allocation. <strong>Dynamic memory allocation</strong> is a way for running programs to request memory from the operating system when needed. This memory does not come from the program’s limited stack memory -- instead, it is allocated from a much larger pool of memory managed by the operating system called the <strong>heap</strong>. On modern machines, the heap can be gigabytes in size.</p><p><strong>Dynamically allocating single variables</strong></p><p>To allocate a <em>single</em> variable dynamically, we use the scalar (non-array) form of the <strong>new</strong> operator:</p><pre class="language-cpp line-numbers"><code>new int; // dynamically allocate an integer (and discard the result)</code></pre><p>In the above case, we’re requesting an integer’s worth of memory from the operating system. The new operator creates the object using that memory, and then returns a pointer containing the <i>address</i> of the memory that has been allocated.</p><p>Most often, we’ll assign the return value to our own pointer variable so we can access the allocated memory later.</p><pre class="language-cpp line-numbers"><code>int* ptr{ new int }; // dynamically allocate an integer and assign the address to ptr so we can access it later</code></pre><p>We can then perform indirection through the pointer to access the memory:</p><pre class="language-cpp line-numbers"><code>*ptr = 7; // assign value of 7 to allocated memory</code></pre><p>If it wasn’t before, it should now be clear at least one case in which pointers are useful. Without a pointer to hold the address of the memory that was just allocated, we’d have no way to access the memory that was just allocated for us!</p><p><strong>How does dynamic memory allocation work?</strong></p><p>Your computer has memory (probably lots of it) that is available for applications to use. When you run an application, your operating system loads the application into some of that memory. This memory used by your application is divided into different areas, each of which serves a different purpose. One area contains your code. Another area is used for normal operations (keeping track of which functions were called, creating and destroying global and local variables, etc…). We’ll talk more about those later. However, much of the memory available just sits there, waiting to be handed out to programs that request it.</p><p>When you dynamically allocate memory, you’re asking the operating system to reserve some of that memory for your program’s use. If it can fulfill this request, it will return the address of that memory to your application. From that point forward, your application can use this memory as it wishes. When your application is done with the memory, it can return the memory back to the operating system to be given to another program.</p><p>Unlike static or automatic memory, the program itself is responsible for requesting and disposing of dynamically allocated memory.</p><p><strong>Initializing a dynamically allocated variable</strong></p><p>When you dynamically allocate a variable, you can also initialize it via direct initialization or uniform initialization:</p><pre class="language-cpp line-numbers"><code>int* ptr1{ new int (5) }; // use direct initialization</code><code>int* ptr2{ new int { 6 } }; // use uniform initialization</code></pre><p><strong>Deleting single variables</strong></p><p>When we are done with a dynamically allocated variable, we need to explicitly tell C++ to free the memory for reuse. For single variables, this is done via the scalar (non-array) form of the <strong>delete</strong> operator:</p><pre class="language-cpp line-numbers"><code>// assume ptr has previously been allocated with operator new</code><code>delete ptr; // return the memory pointed to by ptr to the operating system</code><code>ptr = nullptr; // set ptr to be a null pointer</code></pre><p><strong>What does it mean to delete memory?</strong></p><p>The delete operator does not <em>actually</em> delete anything. It simply returns the memory being pointed to back to the operating system. The operating system is then free to reassign that memory to another application (or to this application again later).</p><p>Although it looks like we’re deleting a <em>variable</em>, this is not the case! The pointer variable still has the same scope as before, and can be assigned a new value just like any other variable.</p><p>Note that deleting a pointer that is not pointing to dynamically allocated memory may cause bad things to happen.</p><p><strong>Dangling pointers</strong></p><p>C++ does not make any guarantees about what will happen to the contents of deallocated memory, or to the value of the pointer being deleted. In most cases, the memory returned to the operating system will contain the same values it had before it was returned, and the pointer will be left pointing to the now deallocated memory.</p><p>A pointer that is pointing to deallocated memory is called a <strong>dangling pointer</strong>. Indirection through- or deleting a dangling pointer will lead to undefined behavior. Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int* ptr{ new int }; // dynamically allocate an integer</code><code>    *ptr = 7; // put a value in that memory location</code><code></code><code>    delete ptr; // return the memory to the operating system.  ptr is now a dangling pointer.</code><code></code><code>    std::cout &lt;&lt; *ptr; // Indirection through a dangling pointer will cause undefined behavior</code><code>    delete ptr; // trying to deallocate the memory again will also lead to undefined behavior.</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above program, the value of 7 that was previously assigned to the allocated memory will probably still be there, but it’s possible that the value at that memory address could have changed. It’s also possible the memory could be allocated to another application (or for the operating system’s own usage), and trying to access that memory will cause the operating system to shut the program down.</p><p>Deallocating memory may create multiple dangling pointers. Consider the following example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int* ptr{ new int{} }; // dynamically allocate an integer</code><code>    int* otherPtr{ ptr }; // otherPtr is now pointed at that same memory location</code><code></code><code>    delete ptr; // return the memory to the operating system.  ptr and otherPtr are now dangling pointers.</code><code>    ptr = nullptr; // ptr is now a nullptr</code><code></code><code>    // however, otherPtr is still a dangling pointer!</code><code></code><code>    return 0;</code><code>}</code></pre><p>There are a few best practices that can help here.</p><p>First, try to avoid having multiple pointers point at the same piece of dynamic memory. If this is not possible, be clear about which pointer “owns” the memory (and is responsible for deleting it) and which pointers are just accessing it.</p><p>Second, when you delete a pointer, if that pointer is not going out of scope immediately afterward, set the pointer to nullptr. We’ll talk more about null pointers, and why they are useful in a bit.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Set deleted pointers to nullptr unless they are going out of scope immediately afterward.</p></div><p><strong>Operator new can fail</strong></p><p>When requesting memory from the operating system, in rare circumstances, the operating system may not have any memory to grant the request with.</p><p>By default, if new fails, a <em>bad_alloc</em> exception is thrown. If this exception isn’t properly handled (and it won’t be, since we haven’t covered exceptions or exception handling yet), the program will simply terminate (crash) with an unhandled exception error.</p><p>In many cases, having new throw an exception (or having your program crash) is undesirable, so there’s an alternate form of new that can be used instead to tell new to return a null pointer if memory can’t be allocated. This is done by adding the constant std::nothrow between the new keyword and the allocation type:</p><pre class="language-cpp line-numbers"><code>int* value { new (std::nothrow) int }; // value will be set to a null pointer if the integer allocation fails</code></pre><p>In the above example, if new fails to allocate memory, it will return a null pointer instead of the address of the allocated memory.</p><p>Note that if you then attempt indirection through this pointer, undefined behavior will result (most likely, your program will crash). Consequently, the best practice is to check all memory requests to ensure they actually succeeded before using the allocated memory.</p><pre class="language-cpp line-numbers"><code>int* value { new (std::nothrow) int{} }; // ask for an integer's worth of memory</code><code>if (!value) // handle case where new returned null</code><code>{</code><code>    // Do error handling here</code><code>    std::cerr &lt;&lt; "Could not allocate memory\n";</code><code>}</code></pre><p>Because asking new for memory only fails rarely (and almost never in a dev environment), it’s common to forget to do this check!</p><p><strong>Null pointers and dynamic memory allocation</strong></p><p>Null pointers (pointers set to nullptr) are particularly useful when dealing with dynamic memory allocation. In the context of dynamic memory allocation, a null pointer basically says “no memory has been allocated to this pointer”. This allows us to do things like conditionally allocate memory:</p><pre class="language-cpp line-numbers"><code>// If ptr isn't already allocated, allocate it</code><code>if (!ptr)</code><code>    ptr = new int;</code></pre><p>Deleting a null pointer has no effect. Thus, there is no need for the following:</p><pre class="language-cpp line-numbers"><code>if (ptr)</code><code>    delete ptr;</code></pre><p>Instead, you can just write:</p><pre class="language-cpp line-numbers"><code>delete ptr;</code></pre><p>If ptr is non-null, the dynamically allocated variable will be deleted. If it is null, nothing will happen.</p><p><strong>Memory leaks</strong></p><p>Dynamically allocated memory stays allocated until it is explicitly deallocated or until the program ends (and the operating system cleans it up, assuming your operating system does that). However, the pointers used to hold dynamically allocated memory addresses follow the normal scoping rules for local variables. This mismatch can create interesting problems.</p><p>Consider the following function:</p><pre class="language-cpp line-numbers"><code>void doSomething()</code><code>{</code><code>    int* ptr{ new int{} };</code><code>}</code></pre><p>This function allocates an integer dynamically, but never frees it using delete. Because pointers variables are just normal variables, when the function ends, ptr will go out of scope. And because ptr is the only variable holding the address of the dynamically allocated integer, when ptr is destroyed there are no more references to the dynamically allocated memory. This means the program has now “lost” the address of the dynamically allocated memory. As a result, this dynamically allocated integer can not be deleted.</p><p>This is called a <strong>memory leak</strong>. Memory leaks happen when your program loses the address of some bit of dynamically allocated memory before giving it back to the operating system. When this happens, your program can’t delete the dynamically allocated memory, because it no longer knows where it is. The operating system also can’t use this memory, because that memory is considered to be still in use by your program.</p><p>Memory leaks eat up free memory while the program is running, making less memory available not only to this program, but to other programs as well. Programs with severe memory leak problems can eat all the available memory, causing the entire machine to run slowly or even crash. Only after your program terminates is the operating system able to clean up and “reclaim” all leaked memory.</p><p>Although memory leaks can result from a pointer going out of scope, there are other ways that memory leaks can result. For example, a memory leak can occur if a pointer holding the address of the dynamically allocated memory is assigned another value:</p><pre class="language-cpp line-numbers"><code>int value = 5;</code><code>int* ptr{ new int{} }; // allocate memory</code><code>ptr = &amp;value; // old address lost, memory leak results</code></pre><p>This can be fixed by deleting the pointer before reassigning it:</p><pre class="language-cpp line-numbers"><code>int value{ 5 };</code><code>int* ptr{ new int{} }; // allocate memory</code><code>delete ptr; // return memory back to operating system</code><code>ptr = &amp;value; // reassign pointer to address of value</code></pre><p>Relatedly, it is also possible to get a memory leak via double-allocation:</p><pre class="language-cpp line-numbers"><code>int* ptr{ new int{} };</code><code>ptr = new int{}; // old address lost, memory leak results</code></pre><p>The address returned from the second allocation overwrites the address of the first allocation. Consequently, the first allocation becomes a memory leak!</p><p>Similarly, this can be avoided by ensuring you delete the pointer before reassigning.</p><p><strong>Conclusion</strong></p><p>Operators new and delete allow us to dynamically allocate single variables for our programs.</p><p>Dynamically allocated memory has dynamic duration and will stay allocated until you deallocate it or the program terminates.</p><p>Be careful not to perform indirection through dangling or null pointers.</p><p>In the next lesson, we’ll take a look at using new and delete to allocate and delete arrays.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.12 — Dynamically allocating arrays</h1></header><div class="entry-content" itemprop="articleBody"><p>In addition to dynamically allocating single values, we can also dynamically allocate arrays of variables. Unlike a fixed array, where the array size must be fixed at compile time, dynamically allocating an array allows us to choose an array length at runtime.</p><p>To allocate an array dynamically, we use the array form of new and delete (often called new[] and delete[]):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a positive integer: ";</code><code>    int length{};</code><code>    std::cin &gt;&gt; length;</code><code></code><code>    int* array{ new int[length]{} }; // use array new.  Note that length does not need to be constant!</code><code></code><code>    std::cout &lt;&lt; "I just allocated an array of integers of length " &lt;&lt; length &lt;&lt; '\n';</code><code></code><code>    array[0] = 5; // set element 0 to value 5</code><code></code><code>    delete[] array; // use array delete to deallocate array</code><code></code><code>    // we don't need to set array to nullptr/0 here because it's going out of scope immediately after this anyway</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because we are allocating an array, C++ knows that it should use the array version of new instead of the scalar version of new. Essentially, the new[] operator is called, even though the [] isn’t placed next to the new keyword.</p><p>The length of dynamically allocated arrays has to be a type that’s convertible to <code>std::size_t</code>. In practice, using an <code>int</code> length is fine, since <code>int</code> will convert to <code>std::size_t</code>.</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>Some might argue that because array new expects a length of type <code>size_t</code>, our lengths (e.g. such as <code>length</code> in the example above) should either be of type <code>size_t</code> or converted to a <code>size_t</code> via <code>static_cast</code>.</p><p>I find this argument uncompelling for a number of reasons. First, it contradicts the best practice to use signed integers over unsigned ones. Second, when creating dynamic arrays using an integral length, it’s convention to do something like this:</p><pre class="language-cpp line-numbers"><code>double* ptr { new double[5] };</code></pre><p><code>5</code> is an <code>int</code> literal, so we get an implicit conversion to <code>size_t</code>. Prior to C++23, there is no way to create a <code>size_t</code> literal without using <code>static_cast</code>! If the designers of C++ had intended us to strictly use <code>size_t</code> types here, they would have provided a way to create literals of type <code>size_t</code>.</p><p>The most common counterargument is that some pedantic compiler might flag this as a signed/unsigned conversion error (since we always treat warnings as errors). However, it’s worth noting that GCC does not flag this as a signed/unsigned conversion error even when such warnings (-Wconversion) are enabled.</p><p>While there is nothing wrong with using <code>size_t</code> as the length of a dynamically allocated array, in this tutorial series, we will not be pedantic about requiring it.</p></div><p>Note that because this memory is allocated from a different place than the memory used for fixed arrays, the size of the array can be quite large. You can run the program above and allocate an array of length 1,000,000 (or probably even 100,000,000) without issue. Try it! Because of this, programs that need to allocate a lot of memory in C++ typically do so dynamically.</p><br><h3>Dynamically deleting arrays</h3><p>When deleting a dynamically allocated array, we have to use the array version of delete, which is delete[].</p><p>This tells the CPU that it needs to clean up multiple variables instead of a single variable. One of the most common mistakes that new programmers make when dealing with dynamic memory allocation is to use delete instead of delete[] when deleting a dynamically allocated array. Using the scalar version of delete on an array will result in undefined behavior, such as data corruption, memory leaks, crashes, or other problems.</p><p>One often asked question of array delete[] is, “How does array delete know how much memory to delete?” The answer is that array new[] keeps track of how much memory was allocated to a variable, so that array delete[] can delete the proper amount. Unfortunately, this size/length isn’t accessible to the programmer.</p><br><h3>Dynamic arrays are almost identical to fixed arrays</h3><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/pointers-and-arrays/">11.8 -- Pointers and arrays</a>, you learned that a fixed array holds the memory address of the first array element. You also learned that a fixed array can decay into a pointer that points to the first element of the array. In this decayed form, the length of the fixed array is not available (and therefore neither is the size of the array via sizeof()), but otherwise there is little difference.</p><p>A dynamic array starts its life as a pointer that points to the first element of the array. Consequently, it has the same limitations in that it doesn’t know its length or size. A dynamic array functions identically to a decayed fixed array, with the exception that the programmer is responsible for deallocating the dynamic array via the delete[] keyword.</p><br><h3>Initializing dynamically allocated arrays</h3><p>If you want to initialize a dynamically allocated array to 0, the syntax is quite simple:</p><pre class="language-cpp line-numbers"><code>int* array{ new int[length]{} };</code></pre><p>Prior to C++11, there was no easy way to initialize a dynamic array to a non-zero value (initializer lists only worked for fixed arrays). This means you had to loop through the array and assign element values explicitly.</p><pre class="language-cpp line-numbers"><code>int* array = new int[5];</code><code>array[0] = 9;</code><code>array[1] = 7;</code><code>array[2] = 5;</code><code>array[3] = 3;</code><code>array[4] = 1;</code></pre><p>Super annoying!</p><p>However, starting with C++11, it’s now possible to initialize dynamic arrays using initializer lists!</p><pre class="language-cpp line-numbers"><code>int fixedArray[5] = { 9, 7, 5, 3, 1 }; // initialize a fixed array before C++11</code><code>int* array{ new int[5]{ 9, 7, 5, 3, 1 } }; // initialize a dynamic array since C++11</code><code>// To prevent writing the type twice, we can use auto. This is often done for types with long names.</code><code>auto* array{ new int[5]{ 9, 7, 5, 3, 1 } };</code></pre><p>Note that this syntax has no operator= between the array length and the initializer list.</p><p>For consistency, fixed arrays can also be initialized using uniform initialization:</p><pre class="language-cpp line-numbers"><code>int fixedArray[]{ 9, 7, 5, 3, 1 }; // initialize a fixed array in C++11</code><code>char fixedArray[]{ "Hello, world!" }; // initialize a fixed array in C++11</code></pre><p>Explicitly stating the size of the array is optional.</p><br><h3>Resizing arrays</h3><p>Dynamically allocating an array allows you to set the array length at the time of allocation. However, C++ does not provide a built-in way to resize an array that has already been allocated. It is possible to work around this limitation by dynamically allocating a new array, copying the elements over, and deleting the old array. However, this is error prone, especially when the element type is a class (which have special rules governing how they are created).</p><p>Consequently, we recommend avoiding doing this yourself.</p><p>Fortunately, if you need this capability, C++ provides a resizable array as part of the standard library called std::vector. We’ll introduce std::vector shortly.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Write a program that:</p><ul><li>Asks the user how many names they wish to enter.</li><li>Dynamically allocates a <code>std::string</code> array.</li><li>Asks the user to enter each name.</li><li>Calls <code>std::sort</code> to sort the names (See <a href="https://www.learncpp.com/cpp-tutorial/sorting-an-array-using-selection-sort/#stdsort">11.4 -- Sorting an array using selection sort</a> and <a href="https://www.learncpp.com/cpp-tutorial/pointer-arithmetic-and-array-indexing/">11.9 -- Pointer arithmetic and array indexing</a>)</li><li>Prints the sorted list of names.</li></ul><p><code>std::string</code> supports comparing strings via the comparison operators &lt; and &gt;. You don’t need to implement string comparison by hand.</p><p>Your output should match this:</p><pre>How many names would you like to enter? 5
Enter name #1: Jason
Enter name #2: Mark
Enter name #3: Alex
Enter name #4: Chris
Enter name #5: John

Here is your sorted list:
Name #1: Alex
Name #2: Chris
Name #3: Jason
Name #4: John
Name #5: Mark
</pre><div class="cpp-note cpp-lightgraybackground"><h4>A reminder</h4><p>You can use <code>std::getline()</code> to read in names that contain spaces (see lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-stdstring/">4.17 -- Introduction to std::string</a>).</p></div><div class="cpp-note cpp-lightgraybackground"><h4>A reminder</h4><p>To use <code>std::sort()</code> with a pointer to an array, calculate begin and end manually</p><pre class="language-cpp line-numbers"><code>std::sort(array, array + arrayLength);</code></pre></div><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <algorithm> // std::sort</algorithm></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int getNameCount()</code><code>{</code><code>    std::cout &lt;&lt; "How many names would you like to enter? ";</code><code>    int length{};</code><code>    std::cin &gt;&gt; length;</code><code></code><code>    return length;</code><code>}</code><code></code><code>// Asks user to enter all the names</code><code>void getNames(std::string* names, int length)</code><code>{</code><code>    for (int i{ 0 }; i &lt; length; ++i)</code><code>    {</code><code>        std::cout &lt;&lt; "Enter name #" &lt;&lt; i + 1 &lt;&lt; ": ";</code><code>        std::getline(std::cin &gt;&gt; std::ws, names[i]);</code><code>    }</code><code>}</code><code></code><code>// Prints the sorted names</code><code>void printNames(std::string* names, int length)</code><code>{</code><code>    std::cout &lt;&lt; "\nHere is your sorted list:\n";</code><code></code><code>    for (int i{ 0 }; i &lt; length; ++i)</code><code>        std::cout &lt;&lt; "Name #" &lt;&lt; i + 1 &lt;&lt; ": " &lt;&lt; names[i] &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int length{ getNameCount() };</code><code></code><code>    // Allocate an array to hold the names</code><code>    auto* names{ new std::string[length]{} };</code><code></code><code>    getNames(names, length);</code><code></code><code>    // Sort the array</code><code>    std::sort(names, names + length);</code><code></code><code>    printNames(names, length);</code><code></code><code>    // don't forget to use array delete</code><code>    delete[] names;</code><code>    // we don't need to set names to nullptr/0 here because it's going to go out</code><code>    // of scope immediately after this anyway.</code><code></code><code>    return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.13 — For-each loops</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/arrays-and-loops/">11.3 -- Arrays and loops</a>, we showed examples where we used a <em>for loop</em> to iterate through each element of an array.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator> // std::size</iterator></code><code></code><code>int main()</code><code>{</code><code>    constexpr int scores[]{ 84, 92, 76, 81, 56 };</code><code>    constexpr int numStudents{ std::size(scores) };</code><code></code><code>    int maxScore{ 0 }; // keep track of our largest score</code><code>    for (int student{ 0 }; student &lt; numStudents; ++student)</code><code>    {</code><code>        if (scores[student] &gt; maxScore)</code><code>        {</code><code>            maxScore = scores[student];</code><code>        }</code><code>    }</code><code> </code><code>    std::cout &lt;&lt; "The best score was " &lt;&lt; maxScore &lt;&lt; '\n';</code><code> </code><code>    return 0;</code><code>}</code></pre><p>While <em>for loops</em> provide a convenient and flexible way to iterate through an array, they are also easy to mess up and prone to off-by-one errors.</p><p>There’s a simpler and safer type of loop called a <strong>for-each</strong> loop (also called a <strong>range-based for-loop</strong>) for cases where we want to iterate through every element in an array (or other list-type structure).</p><br><h3>For-each loops</h3><p>The <em>for-each</em> statement has a syntax that looks like this:</p><pre>for (element_declaration : array)
   statement;
</pre><p>When this statement is encountered, the loop will iterate through each element in array, assigning the value of the current array element to the variable declared in element_declaration. For best results, element_declaration should have the same type as the array elements, otherwise type conversion will occur.</p><p>Let’s take a look at a simple example that uses a <em>for-each</em> loop to print all of the elements in an array named fibonacci:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    constexpr int fibonacci[]{ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 };</code><code>    for (int number : fibonacci) // iterate over array fibonacci</code><code>    {</code><code>       std::cout &lt;&lt; number &lt;&lt; ' '; // we access the array element for this iteration through variable number</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>0 1 1 2 3 5 8 13 21 34 55 89
</pre><p>Let’s take a closer look at how this works. First, the <em>for loop</em> executes, and variable number is set to the value of the first element, which has value 0. The program executes the statement, which prints 0. Then the <em>for loop</em> executes again, and number is set to the value of the second element, which has value 1. The statement executes again, which prints 1. The <em>for loop</em> continues to iterate through each of the numbers in turn, executing the statement for each one, until there are no elements left in the array to iterate over. At that point, the loop terminates, and the program continues execution (returning 0 to the operating system).</p><p>Note that variable number is not an array index. It’s assigned the value of the array element for the current loop iteration.</p><br><h3>For each loops and the auto keyword</h3><p>Because element_declaration should have the same type as the array elements, this is an ideal case in which to use the <code>auto</code> keyword, and let C++ deduce the type of the array elements for us.</p><p>Here’s the above example, using auto:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    constexpr int fibonacci[]{ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 };</code><code>    for (auto number : fibonacci) // type is auto, so number has its type deduced from the fibonacci array</code><code>    {</code><code>       std::cout &lt;&lt; number &lt;&lt; ' ';</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>For-each loops and references</h3><p>In the following for-each example, our element declarations are declared by value:</p><pre class="language-cpp line-numbers"><code>    std::string array[]{ "peter", "likes", "frozen", "yogurt" };</code><code>    for (auto element : array) // element will be a copy of the current array element</code><code>    {</code><code>        std::cout &lt;&lt; element &lt;&lt; ' ';</code><code>    }</code></pre><p>This means each array element iterated over will be copied into variable element. Copying array elements can be expensive, and most of the time we really just want to refer to the original element. Fortunately, we can use references for this:</p><pre class="language-cpp line-numbers"><code>    std::string array[]{ "peter", "likes", "frozen", "yogurt" };</code><code>    for (auto&amp; element: array) // The ampersand makes element a reference to the actual array element, preventing a copy from being made</code><code>    {</code><code>        std::cout &lt;&lt; element &lt;&lt; ' ';</code><code>    }</code></pre><p>In the above example, element will be a reference to the currently iterated array element, avoiding having to make a copy. Also any changes to element will affect the array being iterated over, something not possible if element is a normal variable.</p><p>And, of course, it’s a good idea to make your reference <code>const</code> if you’re intending to use it in a read-only fashion:</p><pre class="language-cpp line-numbers"><code>    std::string array[]{ "peter", "likes", "frozen", "yogurt" };</code><code>    for (const auto&amp; element: array) // element is a const reference to the currently iterated array element</code><code>    {</code><code>        std::cout &lt;&lt; element &lt;&lt; ' ';</code><code>    }</code></pre><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>In for-each loops element declarations, if your elements are non-fundamental types, use references or <code>const</code> references for performance reasons.</p></div><br><h3>Rewriting the max scores example using a for-each loop</h3><p>Here’s the example at the top of the lesson rewritten using a <em>for each</em> loop:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code> </code><code>int main()</code><code>{</code><code>    constexpr int scores[]{ 84, 92, 76, 81, 56 };</code><code>    int maxScore{ 0 }; // keep track of our largest score</code><code></code><code>    for (auto score : scores) // iterate over array scores, assigning each value in turn to variable score</code><code>    {</code><code>        if (score &gt; maxScore)</code><code>        {</code><code>            maxScore = score;</code><code>        }</code><code>    }</code><code> </code><code>    std::cout &lt;&lt; "The best score was " &lt;&lt; maxScore &lt;&lt; '\n';</code><code> </code><code>    return 0;</code><code>}</code></pre><p>Note that in this example, we no longer have to manually subscript the array or get its size. We can access the array element directly through variable score. The array has to have size information. An array that decayed to a pointer cannot be used in a for-each loop.</p><br><h3>For-each loops and non-arrays</h3><p><em>For-each</em> loops don’t only work with fixed arrays, they work with many kinds of list-like structures, such as vectors (e.g. <code>std::vector</code>), linked lists, trees, and maps. We haven’t covered any of these yet, so don’t worry if you don’t know what these are. Just remember that for each loops provide a flexible and generic way to iterate through more than just arrays.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <vector></vector></code><code></code><code>int main()</code><code>{</code><code>    std::vector fibonacci{ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 }; // note use of std::vector here rather than a fixed array</code><code>    // Before C++17</code><code>    // std::vector<int> fibonacci{ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 };</int></code><code></code><code>    for (auto number : fibonacci)</code><code>    {</code><code>        std::cout &lt;&lt; number &lt;&lt; ' ';</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>For-each doesn’t work with pointers to an array</h3><p>In order to iterate through the array, for-each needs to know how big the array is, which means knowing the array size. Because arrays that have decayed into a pointer do not know their size, for-each loops will not work with them!</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int sumArray(const int array[]) // array is a pointer</code><code>{</code><code>    int sum{ 0 };</code><code></code><code>    for (auto number : array) // compile error, the size of array isn't known</code><code>    {</code><code>        sum += number;</code><code>    }</code><code></code><code>    return sum;   </code><code>}</code><code></code><code>int main()</code><code>{</code><code>     constexpr int array[]{ 9, 7, 5, 3, 1 };</code><code></code><code>     std::cout &lt;&lt; sumArray(array) &lt;&lt; '\n'; // array decays into a pointer here</code><code></code><code>     return 0;</code><code>}</code></pre><p>Similarly, dynamic arrays won’t work with for-each loops for the same reason.</p><br><h3>Can I get the index of the current element?</h3><p><em>For-each</em> loops do <em>not</em> provide a direct way to get the array index of the current element. This is because many of the structures that <em>for-each</em> loops can be used with (such as linked lists) are not directly indexable!</p><p>Since C++20, range-based for-loops can be used with an <span class="cpp-definition">init-statement</span> just like the init-statement in normal for-loops. We can use the init-statement to create a manual index counter without polluting the function in which the for-loop is placed.</p><p>The init-statement is placed right before the loop variable:</p><pre>for (init-statement; element_declaration : array)
   statement;
</pre><p>In the following code, we have two arrays which are correlated by index. For example, the student with the name at <code>names[3]</code> has a score of <code>scores[3]</code>. Whenever a student with a new high score is found, we print their name and difference in points to the previous high score.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code> </code><code>int main()</code><code>{</code><code>    std::string names[]{ "Alex", "Betty", "Caroline", "Dave", "Emily" }; // Names of the students</code><code>    constexpr int scores[]{ 84, 92, 76, 81, 56 };</code><code>    int maxScore{ 0 };</code><code></code><code>    for (int i{ 0 }; auto score : scores) // i is the index of the current element</code><code>    {</code><code>        if (score &gt; maxScore)</code><code>        {</code><code>            std::cout &lt;&lt; names[i] &lt;&lt; " beat the previous best score of " &lt;&lt; maxScore &lt;&lt; " by " &lt;&lt; (score - maxScore) &lt;&lt; " points!\n";</code><code>            maxScore = score;</code><code>        }</code><code>        </code><code>        ++i;</code><code>    }</code><code> </code><code>    std::cout &lt;&lt; "The best score was " &lt;&lt; maxScore &lt;&lt; '\n';</code><code> </code><code>    return 0;</code><code>}</code></pre><p>Output</p><pre>Alex beat the previous best score of 0 by 84 points!
Betty beat the previous best score of 84 by 8 points!
The best score was 92
</pre><p>The <code>int i{ 0 };</code> is the init-statement, it only gets executed once when the loop starts. At the end of each iteration, we increment <code>i</code>, similar to a normal for-loop. However, if we were to use <code>continue</code> inside the loop, the <code>++i</code> would get skipped, leading to unexpected results. If you use <code>continue</code>, you need to make sure that <code>i</code> gets incremented before the <code>continue</code> is encountered.</p><p>Before C++20, the index variable <code>i</code> had to be declared outside of the loop, which could lead to name conflicts when we wanted to define another variable named <code>i</code> later in the function.</p><br><h3>Conclusion</h3><p><em>For-each</em> loops provide a superior syntax for iterating through an array when we need to access all of the array elements in forwards sequential order. It should be preferred over the standard for loop in the cases where it can be used. To prevent making copies of each element, the element declaration can be a reference.</p><br><h3>Quiz time</h3><p>This one should be easy.</p><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Declare a fixed array with the following names: Alex, Betty, Caroline, Dave, Emily, Fred, Greg, and Holly. Ask the user to enter a name. Use a <em>for each</em> loop to see if the name the user entered is in the array.</p><p>Sample output:</p><pre>Enter a name: Betty
Betty was found.
</pre><pre>Enter a name: Megatron
Megatron was not found.
</pre><p>Hint: Use <code>std::string_view</code> as your array type.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>int main()</code><code>{</code><code>    constexpr std::string_view names[]{ "Alex", "Betty", "Caroline", "Dave", "Emily", "Fred", "Greg", "Holly" };</code><code>	</code><code>    std::cout &lt;&lt; "Enter a name: ";</code><code>    std::string username{};</code><code>    std::cin &gt;&gt; username;</code><code></code><code>    bool found{ false };</code><code></code><code>    // We will be explicit about expecting `name` to be a std::string_view here</code><code>    // That way if `names` is ever changed to an expensive to copy type (like std::string)</code><code>    // We won't end up making expensive copies.</code><code>    for (std::string_view name : names)</code><code>    {</code><code>        if (name == username)</code><code>        {</code><code>            found = true;</code><code>            break;</code><code>        }</code><code>    }</code><code></code><code>    if (found)</code><code>        std::cout &lt;&lt; username &lt;&lt; " was found.\n";</code><code>    else</code><code>        std::cout &lt;&lt; username &lt;&lt; " was not found.\n";</code><code></code><code>    return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.14 — Void pointers</h1></header><div class="entry-content" itemprop="articleBody"><p>The <strong>void pointer</strong>, also known as the generic pointer, is a special type of pointer that can be pointed at objects of any data type! A void pointer is declared like a normal pointer, using the void keyword as the pointer’s type:</p><pre class="language-cpp line-numbers"><code>void* ptr; // ptr is a void pointer</code></pre><p>A void pointer can point to objects of any data type:</p><pre class="language-cpp line-numbers"><code>int nValue;</code><code>float fValue;</code><code></code><code>struct Something</code><code>{</code><code>    int n;</code><code>    float f;</code><code>};</code><code></code><code>Something sValue;</code><code></code><code>void* ptr;</code><code>ptr = &amp;nValue; // valid</code><code>ptr = &amp;fValue; // valid</code><code>ptr = &amp;sValue; // valid</code></pre><p>However, because the void pointer does not know what type of object it is pointing to, dereferencing a void pointer is illegal. Instead, the void pointer must first be cast to another pointer type before the dereference can be performed.</p><pre class="language-cpp line-numbers"><code>int value{ 5 };</code><code>void* voidPtr{ &amp;value };</code><code></code><code>// std::cout &lt;&lt; *voidPtr &lt;&lt; '\n'; // illegal: dereference of void pointer</code><code></code><code>int* intPtr{ static_cast<int*>(voidPtr) }; // however, if we cast our void pointer to an int pointer...</int*></code><code></code><code>std::cout &lt;&lt; *intPtr &lt;&lt; '\n'; // then we can dereference the result</code></pre><p>This prints:</p><pre>5
</pre><p>The next obvious question is: If a void pointer doesn’t know what it’s pointing to, how do we know what to cast it to? Ultimately, that is up to you to keep track of.</p><p>Here’s an example of a void pointer in use:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cassert></cassert></code><code></code><code>enum class Type</code><code>{</code><code>    tInt, // note: we can't use "int" here because it's a keyword, so we'll use "tInt" instead</code><code>    tFloat,</code><code>    tCString</code><code>};</code><code></code><code>void printValue(void* ptr, Type type)</code><code>{</code><code>    switch (type)</code><code>    {</code><code>    case Type::tInt:</code><code>        std::cout &lt;&lt; *static_cast<int*>(ptr) &lt;&lt; '\n'; // cast to int pointer and perform indirection</int*></code><code>        break;</code><code>    case Type::tFloat:</code><code>        std::cout &lt;&lt; *static_cast<float*>(ptr) &lt;&lt; '\n'; // cast to float pointer and perform indirection</float*></code><code>        break;</code><code>    case Type::tCString:</code><code>        std::cout &lt;&lt; static_cast<char*>(ptr) &lt;&lt; '\n'; // cast to char pointer (no indirection)</char*></code><code>        // std::cout will treat char* as a C-style string</code><code>        // if we were to perform indirection through the result, then we'd just print the single char that ptr is pointing to</code><code>        break;</code><code>    default:</code><code>        assert(false &amp;&amp; "type not found");</code><code>        break;</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int nValue{ 5 };</code><code>    float fValue{ 7.5f };</code><code>    char szValue[]{ "Mollie" };</code><code></code><code>    printValue(&amp;nValue, Type::tInt);</code><code>    printValue(&amp;fValue, Type::tFloat);</code><code>    printValue(szValue, Type::tCString);</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>5
7.5
Mollie
</pre><p><strong>Void pointer miscellany</strong></p><p>Void pointers can be set to a null value:</p><pre class="language-cpp line-numbers"><code>void* ptr{ nullptr }; // ptr is a void pointer that is currently a null pointer</code></pre><p>Although some compilers allow deleting a void pointer that points to dynamically allocated memory, doing so should be avoided, as it can result in undefined behavior.</p><p>It is not possible to do pointer arithmetic on a void pointer. This is because pointer arithmetic requires the pointer to know what size object it is pointing to, so it can increment or decrement the pointer appropriately.</p><p>Note that there is no such thing as a void reference. This is because a void reference would be of type void &amp;, and would not know what type of value it referenced.</p><p><strong>Conclusion</strong></p><p>In general, it is a good idea to avoid using void pointers unless absolutely necessary, as they effectively allow you to avoid type checking. This allows you to inadvertently do things that make no sense, and the compiler won’t complain about it. For example, the following would be valid:</p><pre class="language-cpp line-numbers"><code>    int nValue{ 5 };</code><code>    printValue(&amp;nValue, Type::tCString);</code></pre><p>But who knows what the result would actually be!</p><p>Although the above function seems like a neat way to make a single function handle multiple data types, C++ actually offers a much better way to do the same thing (via function overloading) that retains type checking to help prevent misuse. Many other places where void pointers would once be used to handle multiple data types are now better done using templates, which also offer strong type checking.</p><p>However, very occasionally, you may still find a reasonable use for the void pointer. Just make sure there isn’t a better (safer) way to do the same thing using other language mechanisms first!</p><p><strong>Quiz</strong></p><ol start="1"><li>What’s the difference between a void pointer and a null pointer?</li></ol><p><strong>Quiz answers</strong></p><ol start="1"><li><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></li></ol><div class="wpsolution" id="cpp_solution_id_0" style="display:none">A void pointer is a pointer that can point to any type of object, but does not know what type of object it points to. A void pointer must be explicitly cast into another type of pointer to perform indirection. A null pointer is a pointer that does not point to an address. A void pointer can be a null pointer.<p>Thus, a void pointer refers to the type of the pointer, whereas a null pointer refers to the value (address) of the pointer.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.15 — Pointers to pointers and dynamic multidimensional arrays</h1></header><div class="entry-content" itemprop="articleBody"><p>This lesson is optional, for advanced readers who want to learn more about C++. No future lessons build on this lesson.</p><p>A pointer to a pointer is exactly what you’d expect: a pointer that holds the address of another pointer.</p><p><strong>Pointers to pointers</strong></p><p>A normal pointer to an int is declared using a single asterisk:</p><pre class="language-cpp line-numbers"><code>int* ptr; // pointer to an int, one asterisk</code></pre><p>A pointer to a pointer to an int is declared using two asterisks</p><pre class="language-cpp line-numbers"><code>int** ptrptr; // pointer to a pointer to an int, two asterisks</code></pre><p>A pointer to a pointer works just like a normal pointer — you can perform indirection through it to retrieve the value pointed to. And because that value is itself a pointer, you can perform indirection through it again to get to the underlying value. These indirections can be done consecutively:</p><pre class="language-cpp line-numbers"><code>int value { 5 };</code><code></code><code>int* ptr { &amp;value };</code><code>std::cout &lt;&lt; *ptr &lt;&lt; '\n'; // Indirection through pointer to int to get int value</code><code></code><code>int** ptrptr { &amp;ptr };</code><code>std::cout &lt;&lt; **ptrptr &lt;&lt; '\n'; // first indirection to get pointer to int, second indirection to get int value</code></pre><p>The above program prints:</p><pre>5
5
</pre><p>Note that you can not set a pointer to a pointer directly to a value:</p><pre class="language-cpp line-numbers"><code>int value { 5 };</code><code>int** ptrptr { &amp;&amp;value }; // not valid</code></pre><p>This is because the address of operator (operator&amp;) requires an lvalue, but &amp;value is an rvalue.</p><p>However, a pointer to a pointer can be set to null:</p><pre class="language-cpp line-numbers"><code>int** ptrptr { nullptr };</code></pre><p><strong>Arrays of pointers</strong></p><p>Pointers to pointers have a few uses. The most common use is to dynamically allocate an array of pointers:</p><pre class="language-cpp line-numbers"><code>int** array { new int*[10] }; // allocate an array of 10 int pointers</code></pre><p>This works just like a standard dynamically allocated array, except the array elements are of type “pointer to integer” instead of integer.</p><p><strong>Two-dimensional dynamically allocated arrays</strong></p><p>Another common use for pointers to pointers is to facilitate dynamically allocated multidimensional arrays (see <a href="https://www.learncpp.com/cpp-tutorial/multidimensional-arrays/">11.5 -- Multidimensional Arrays</a> for a review of multidimensional arrays).</p><p>Unlike a two dimensional fixed array, which can easily be declared like this:</p><pre class="language-cpp line-numbers"><code>int array[10][5];</code></pre><p>Dynamically allocating a two-dimensional array is a little more challenging. You may be tempted to try something like this:</p><pre class="language-cpp line-numbers"><code>int** array { new int[10][5] }; // won’t work!</code></pre><p>But it won’t work.</p><p>There are two possible solutions here. If the rightmost array dimension is constexpr, you can do this:</p><pre class="language-cpp line-numbers"><code>int x { 7 }; // non-constant</code><code>int (*array)[5] { new int[x][5] }; // rightmost dimension must be constexpr</code></pre><p>The parenthesis are required here to ensure proper precedence. This is a good place to use automatic type deduction:</p><pre class="language-cpp line-numbers"><code>int x { 7 }; // non-constant</code><code>auto array { new int[x][5] }; // so much simpler!</code></pre><p>Unfortunately, this relatively simple solution doesn’t work if the rightmost array dimension isn’t a compile-time constant. In that case, we have to get a little more complicated. First, we allocate an array of pointers (as per above). Then we iterate through the array of pointers and allocate a dynamic array for each array element. Our dynamic two-dimensional array is a dynamic one-dimensional array of dynamic one-dimensional arrays!</p><pre class="language-cpp line-numbers"><code>int** array { new int*[10] }; // allocate an array of 10 int pointers — these are our rows</code><code>for (int count { 0 }; count &lt; 10; ++count)</code><code>    array[count] = new int[5]; // these are our columns</code></pre><p>We can then access our array like usual:</p><pre class="language-cpp line-numbers"><code>array[9][4] = 3; // This is the same as (array[9])[4] = 3;</code></pre><p>With this method, because each array column is dynamically allocated independently, it’s possible to make dynamically allocated two dimensional arrays that are not rectangular. For example, we can make a triangle-shaped array:</p><pre class="language-cpp line-numbers"><code>int** array { new int*[10] }; // allocate an array of 10 int pointers — these are our rows</code><code>for (int count { 0 }; count &lt; 10; ++count)</code><code>    array[count] = new int[count+1]; // these are our columns</code></pre><p>In the above example, note that array[0] is an array of length 1, array[1] is an array of length 2, etc…</p><p>Deallocating a dynamically allocated two-dimensional array using this method requires a loop as well:</p><pre class="language-cpp line-numbers"><code>for (int count { 0 }; count &lt; 10; ++count)</code><code>    delete[] array[count];</code><code>delete[] array; // this needs to be done last</code></pre><p>Note that we delete the array in the opposite order that we created it (elements first, then the array itself). If we delete array before the array columns, then we’d have to access deallocated memory to delete the array columns. And that would result in undefined behavior.</p><p>Because allocating and deallocating two-dimensional arrays is complex and easy to mess up, it’s often easier to “flatten” a two-dimensional array (of size x by y) into a one-dimensional array of size x * y:</p><pre class="language-cpp line-numbers"><code>// Instead of this:</code><code>int** array { new int*[10] }; // allocate an array of 10 int pointers — these are our rows</code><code>for (int count { 0 }; count &lt; 10; ++count)</code><code>    array[count] = new int[5]; // these are our columns</code><code></code><code>// Do this</code><code>int *array { new int[50] }; // a 10x5 array flattened into a single array</code></pre><p>Simple math can then be used to convert a row and column index for a rectangular two-dimensional array into a single index for a one-dimensional array:</p><pre class="language-cpp line-numbers"><code>int getSingleIndex(int row, int col, int numberOfColumnsInArray)</code><code>{</code><code>     return (row * numberOfColumnsInArray) + col;</code><code>}</code><code></code><code>// set array[9,4] to 3 using our flattened array</code><code>array[getSingleIndex(9, 4, 5)] = 3;</code></pre><p><strong>Passing a pointer by address</strong></p><p>Much like we can use a pointer parameter to change the actual value of the underlying argument passed in, we can pass a pointer to a pointer to a function and use that pointer to change the value of the pointer it points to (confused yet?).</p><p>However, if we want a function to be able to modify what a pointer argument points to, this is generally better done using a reference to a pointer instead. This is covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/pass-by-address-part-2/">9.10 -- Pass by address (part 2)</a>.</p><p><strong>Pointer to a pointer to a pointer to…</strong></p><p>It’s also possible to declare a pointer to a pointer to a pointer:</p><pre class="language-cpp line-numbers"><code>int*** ptrx3;</code></pre><p>This can be used to dynamically allocate a three-dimensional array. However, doing so would require a loop inside a loop, and is extremely complicated to get correct.</p><p>You can even declare a pointer to a pointer to a pointer to a pointer:</p><pre class="language-cpp line-numbers"><code>int**** ptrx4;</code></pre><p>Or higher, if you wish.</p><p>However, in reality these don’t see much use because it’s not often you need so much indirection.</p><p><strong>Conclusion</strong></p><p>We recommend avoiding using pointers to pointers unless no other options are available, because they’re complicated to use and potentially dangerous. It’s easy enough to perform indirection through a null or dangling pointer with normal pointers — it’s doubly easy with a pointer to a pointer since you have to do a double-indirection to get to the underlying value!</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.16 — An introduction to std::array</h1></header><div class="entry-content" itemprop="articleBody"><p>In previous lessons, we’ve talked at length about fixed and dynamic arrays. Although both are built right into the C++ language, they both have downsides: Fixed arrays decay into pointers, losing the array length information when they do, and dynamic arrays have messy deallocation issues and are challenging to resize without error.</p><p>To address these issues, the C++ standard library includes functionality that makes array management easier, <code>std::array</code> and <code>std::vector</code>. We’ll examine <code>std::array</code> in this lesson, and <code>std::vector</code> in the next.</p><br><h3>An introduction to std::array</h3><p><code>std::array</code> provides fixed array functionality that won’t decay when passed into a function. <code>std::array</code> is defined in the <code><array></array></code> header, inside the <code>std</code> namespace.</p><p>Declaring a <code>std::array</code> variable is easy:</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code></code><code>std::array<int, 3=""> myArray; // declare an integer array with length 3</int,></code></pre><p>Just like the native implementation of fixed arrays, the length of a <code>std::array</code> must be known at compile time.</p><p><code>std::array</code> can be initialized using initializer lists or list initialization:</p><pre class="language-cpp line-numbers"><code>std::array<int, 5=""> myArray = { 9, 7, 5, 3, 1 }; // initializer list</int,></code><code>std::array<int, 5=""> myArray2 { 9, 7, 5, 3, 1 }; // list initialization</int,></code></pre><p>Unlike built-in fixed arrays, with std::array you can not omit the array length when providing an initializer:</p><pre class="language-cpp line-numbers"><code>std::array<int,> myArray { 9, 7, 5, 3, 1 }; // illegal, array length must be provided</int,></code><code>std::array<int> myArray { 9, 7, 5, 3, 1 }; // illegal, array length must be provided</int></code></pre><p>However, since C++17, it is allowed to omit the type and size. They can only be omitted together, but not one or the other, and only if the array is explicitly initialized.</p><pre class="language-cpp line-numbers"><code>std::array myArray { 9, 7, 5, 3, 1 }; // The type is deduced to std::array<int, 5=""></int,></code><code>std::array myArray { 9.7, 7.31 }; // The type is deduced to std::array<double, 2=""></double,></code></pre><p>We favor this syntax rather than typing out the type and size at the declaration. If your compiler is not C++17 capable, you need to use the explicit syntax instead.</p><pre class="language-cpp line-numbers"><code>// std::array myArray { 9, 7, 5, 3, 1 }; // Since C++17</code><code>std::array<int, 5=""> myArray { 9, 7, 5, 3, 1 }; // Before C++17</int,></code><code></code><code>// std::array myArray { 9.7, 7.31 }; // Since C++17</code><code>std::array<double, 2=""> myArray { 9.7, 7.31 }; // Before C++17</double,></code></pre><p>Since C++20, it is possible to specify the element type but omit the array length. This makes creation of <code>std::array</code> a little more like creation of C-style arrays. To create an array with a specific type and deduced size, we use the <code>std::to_array</code> function:</p><pre class="language-cpp line-numbers"><code>auto myArray1 { std::to_array<int, 5="">({ 9, 7, 5, 3, 1 }) }; // Specify type and size</int,></code><code>auto myArray2 { std::to_array<int>({ 9, 7, 5, 3, 1 }) }; // Specify type only, deduce size</int></code><code>auto myArray3 { std::to_array({ 9, 7, 5, 3, 1 }) }; // Deduce type and size</code></pre><p>Unfortunately, <code>std::to_array</code> is more expensive than creating a <code>std::array</code> directly, because it actually copies all elements from a C-style array to a <code>std::array</code>. For this reason, <code>std::to_array</code> should be avoided when the array is created many times (e.g. in a loop).</p><p>You can also assign values to the array using an initializer list</p><pre class="language-cpp line-numbers"><code>std::array<int, 5=""> myArray;</int,></code><code>myArray = { 0, 1, 2, 3, 4 }; // okay</code><code>myArray = { 9, 8, 7 }; // okay, elements 3 and 4 are set to zero!</code><code>myArray = { 0, 1, 2, 3, 4, 5 }; // not allowed, too many elements in initializer list!</code></pre><p>Accessing <code>std::array</code> values using the subscript operator works just like you would expect:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; myArray[1] &lt;&lt; '\n';</code><code>myArray[2] = 6;</code></pre><p>Just like built-in fixed arrays, the subscript operator does not do any bounds-checking. If an invalid index is provided, bad things will probably happen.</p><p><code>std::array</code> supports a second form of array element access (the <code>at()</code> function) that does (runtime) bounds checking:</p><pre class="language-cpp line-numbers"><code>std::array myArray { 9, 7, 5, 3, 1 };</code><code>myArray.at(1) = 6; // array element 1 is valid, sets array element 1 to value 6</code><code>myArray.at(9) = 10; // array element 9 is invalid, will throw a runtime error</code></pre><p>In the above example, the call to <code>myArray.at(1)</code> checks to ensure the index 1 is valid, and because it is, it returns a reference to array element 1. We then assign the value of 6 to this. However, the call to <code>myArray.at(9)</code> fails (at runtime) because array element 9 is out of bounds for the array. Instead of returning a reference, the <code>at()</code> function throws an error that terminates the program (note: It’s actually throwing an exception of type <code>std::out_of_range</code> -- we cover exceptions in chapter 14). Because it does bounds checking, <code>at()</code> is slower (but safer) than <code>operator[]</code>.</p><p><code>std::array</code> will clean up after itself when it goes out of scope, so there’s no need to do any kind of manual cleanup.</p><br><h3>Size and sorting</h3><p>The <code>size()</code> function can be used to retrieve the length of the <code>std::array</code>:</p><pre class="language-cpp line-numbers"><code>std::array myArray { 9.0, 7.2, 5.4, 3.6, 1.8 };</code><code>std::cout &lt;&lt; "length: " &lt;&lt; myArray.size() &lt;&lt; '\n';</code></pre><p>This prints:</p><pre>length: 5
</pre><p>Because <code>std::array</code> doesn’t decay to a pointer when passed to a function, the <code>size()</code> function will work even if you call it from within a function:</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <iostream></iostream></code><code></code><code>void printLength(const std::array<double, 5="">&amp; myArray)</double,></code><code>{</code><code>    std::cout &lt;&lt; "length: " &lt;&lt; myArray.size() &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::array myArray { 9.0, 7.2, 5.4, 3.6, 1.8 };</code><code></code><code>    printLength(myArray);</code><code></code><code>    return 0;</code><code>}</code></pre><p>This also prints:</p><pre>length: 5
</pre><p>Note that the standard library uses the term “size” to mean the array length — do not get this confused with the results of <code>sizeof()</code> on a native fixed array, which returns the actual size of the array in memory (the size of an element multiplied by the array length). Yes, this nomenclature is inconsistent.</p><p>Also note that we passed <code>std::array</code> by (<code>const</code>) reference. This is to prevent the compiler from making a copy of the <code>std::array</code> when the <code>std::array</code> was passed to the function (for performance reasons).</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Always pass <code>std::array</code> by reference or <code>const</code> reference</p></div><p>Because the length is always known, range-based for-loops work with <code>std::array</code>:</p><pre class="language-cpp line-numbers"><code>std::array myArray{ 9, 7, 5, 3, 1 };</code><code></code><code>for (int element : myArray)</code><code>    std::cout &lt;&lt; element &lt;&lt; ' ';</code></pre><p>You can sort <code>std::array</code> using <code>std::sort</code>, which lives in the <code><algorithm></algorithm></code> header:</p><pre class="language-cpp line-numbers"><code>#include <algorithm> // for std::sort</algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::array myArray { 7, 3, 1, 9, 5 };</code><code>    std::sort(myArray.begin(), myArray.end()); // sort the array forwards</code><code>//  std::sort(myArray.rbegin(), myArray.rend()); // sort the array backwards</code><code></code><code>    for (int element : myArray)</code><code>        std::cout &lt;&lt; element &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>1 3 5 7 9
</pre><br><h3>Passing std::array of different lengths to a function</h3><p>With a std::array, the element type and array length are part of the type information. Therefore, when we use a std::array as a function parameter, we have to specify the element type and array length:</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <iostream></iostream></code><code></code><code>void printArray(const std::array<int, 5="">&amp; myArray)</int,></code><code>{</code><code>    for (auto element : myArray)</code><code>        std::cout &lt;&lt; element &lt;&lt; ' ';</code><code>    std::cout &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::array myArray5{ 9.0, 7.2, 5.4, 3.6, 1.8 }; // type deduced as std::array<double, 5=""></double,></code><code>    printArray(myArray5); // error: printArray expects a std::array<int, 5=""></int,></code><code></code><code>    return 0;</code><code>}</code></pre><p>The downside is that this limits our function to only handling arrays of this specific type and length. But what if we want to have our function handle arrays of different element types or lengths? We’d have to create a copy of the function for each different element type and/or array length we want to use. That’s a lot of duplication.</p><p>Fortunately, we can have C++ do this for us, using templates. We can create a template function that parameterizes part or all of the type information, and then C++ will use that template to create “real” functions (with actual types) as needed.</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <cstddef></cstddef></code><code>#include <iostream></iostream></code><code></code><code>// printArray is a template function</code><code>template <typename t,="" std::size_t="" size=""> // parameterize the element type and size</typename></code><code>void printArray(const std::array<t, size="">&amp; myArray)</t,></code><code>{</code><code>    for (auto element : myArray)</code><code>        std::cout &lt;&lt; element &lt;&lt; ' ';</code><code>    std::cout &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::array myArray5{ 9.0, 7.2, 5.4, 3.6, 1.8 };</code><code>    printArray(myArray5);</code><code></code><code>    std::array myArray7{ 9.0, 7.2, 5.4, 3.6, 1.8, 1.2, 0.7 };</code><code>    printArray(myArray7);</code><code></code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We cover function templates in lesson <a href="https://www.learncpp.com/cpp-tutorial/function-templates/">8.13 -- Function templates</a>.</p></div><br><h3>Manually indexing std::array via size_type</h3><p>Pop quiz: What’s wrong with the following code?</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <array></array></code><code></code><code>int main()</code><code>{</code><code>    std::array myArray { 7, 3, 1, 9, 5 };</code><code></code><code>    // Iterate through the array and print the value of the elements</code><code>    for (int i{ 0 }; i &lt; myArray.size(); ++i)</code><code>        std::cout &lt;&lt; myArray[i] &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>The answer is that there’s a likely signed/unsigned mismatch in this code! Due to a curious decision, the <code>size()</code> function and array index parameter to <code>operator[]</code> use a type called <code>size_type</code>, which is defined by the C++ standard as an <em>unsigned</em> integral type. Our loop counter/index (variable <code>i</code>) is a <code>signed int</code>. Therefore both the comparison <code>i &lt; myArray.size()</code> and the array index <code>myArray[i]</code> have type mismatches.</p><p>Interestingly enough, <code>size_type</code> isn’t a global type (like <code>int</code> or <code>std::size_t</code>). Rather, it’s defined inside the definition of <code>std::array</code> (C++ allows nested types). This means when we want to use <code>size_type</code>, we have to prefix it with the full array type (think of <code>std::array</code> acting as a namespace in this regard). In our above example, the fully-prefixed type of “size_type” is <code>std::array<int, 5="">::size_type</int,></code>!</p><p>Therefore, the correct way to write the above code is as follows:</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::array myArray { 7, 3, 1, 9, 5 };</code><code></code><code>    // std::array<int, 5="">::size_type is the return type of size()!</int,></code><code>    for (std::array<int, 5="">::size_type i{ 0 }; i &lt; myArray.size(); ++i)</int,></code><code>        std::cout &lt;&lt; myArray[i] &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>That’s not very readable. Fortunately, <code>std::array::size_type</code> is just an alias for <code>std::size_t</code>, so we can use that instead.</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <cstddef> // std::size_t</cstddef></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::array myArray { 7, 3, 1, 9, 5 };</code><code></code><code>    for (std::size_t i{ 0 }; i &lt; myArray.size(); ++i)</code><code>        std::cout &lt;&lt; myArray[i] &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>A better solution is to avoid manual indexing of <code>std::array</code> in the first place. Instead, use range-based for-loops (or iterators) if possible.</p><p>Keep in mind that unsigned integers wrap around when you reach their limits. A common mistake is to decrement an index that is 0 already, causing a wrap-around to the maximum value. You saw this in the lesson about for-loops, but let’s repeat.</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::array myArray { 7, 3, 1, 9, 5 };</code><code></code><code>    // Print the array in reverse order.</code><code>    // We can use auto, because we're not initializing i with 0.</code><code>    // Bad:</code><code>    for (auto i{ myArray.size() - 1 }; i &gt;= 0; --i)</code><code>        std::cout &lt;&lt; myArray[i] &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This is an infinite loop, producing undefined behavior once <code>i</code> wraps around. There are two issues here. If <code>myArray</code> is empty, i.e. <code>size()</code> returns 0 (which is possible with <code>std::array</code>), <code>myArray.size() - 1</code> wraps around. The other issue occurs no matter how many elements there are. <code>i &gt;= 0</code> is always true, because unsigned integers cannot be less than 0.</p><p>A working reverse for-loop for unsigned integers takes an odd shape:</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::array myArray { 7, 3, 1, 9, 5 };</code><code></code><code>    // Print the array in reverse order.</code><code>    for (auto i{ myArray.size() }; i-- &gt; 0; )</code><code>        std::cout &lt;&lt; myArray[i] &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Suddenly we decrement the index in the condition, and we use the postfix <code>--</code> operator. The condition runs before every iteration, including the first. In the first iteration, <code>i</code> is <code>myArray.size() - 1</code>, because <code>i</code> was decremented in the condition. When <code>i</code> is 0 and about to wrap around, the condition is no longer <code>true</code> and the loop stops. <code>i</code> actually wraps around when we do <code>i--</code> for the last time, but it’s not used afterwards.</p><br><h3>Array of struct </h3><p>Of course <code>std::array</code> isn’t limited to numbers as elements. Every type that can be used in a regular array can be used in a <code>std::array</code>. For example, we can have a <code>std::array</code> of struct:</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <iostream></iostream></code><code></code><code>struct House</code><code>{</code><code>    int number{};</code><code>    int stories{};</code><code>    int roomsPerStory{};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    std::array<house, 3=""> houses{};</house,></code><code></code><code>    houses[0] = { 13, 4, 30 };</code><code>    houses[1] = { 14, 3, 10 };</code><code>    houses[2] = { 15, 3, 40 };</code><code></code><code>    for (const auto&amp; house : houses)</code><code>    {</code><code>        std::cout &lt;&lt; "House number " &lt;&lt; house.number</code><code>                  &lt;&lt; " has " &lt;&lt; (house.stories * house.roomsPerStory)</code><code>                  &lt;&lt; " rooms\n";</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>The above outputs the following:</p><pre>House number 13 has 120 rooms
House number 14 has 30 rooms
House number 15 has 120 rooms
</pre><p>However, things get a little weird when we try to initialize an array whose element type requires a list of values (such as a <code>std::array</code> of struct). You might try to initialize such a <code>std::array</code> like this:</p><pre class="language-cpp line-numbers"><code>// Doesn't work.</code><code>std::array<house, 3=""> houses {</house,></code><code>    { 13, 4, 30 },</code><code>    { 14, 3, 10 },</code><code>    { 15, 3, 40 }</code><code>};</code></pre><p>But this doesn’t work.</p><p>A <code>std::array</code> is defined as a struct that contains a C-style array member (whose name is implementation defined). So when we try to initialize <code>houses</code> per the above, the compiler interprets the initialization like this:</p><pre class="language-cpp line-numbers"><code>// Doesn't work.</code><code>std::array<house, 3=""> houses { // initializer for houses</house,></code><code>    { 13, 4, 30 }, // initializer for the C-style array member inside the std::array struct</code><code>    { 14, 3, 10 }, // ?</code><code>    { 15, 3, 40 }  // ?</code><code>};</code></pre><p>The compiler will interpret <code>{ 13, 4, 30 }</code> as the initializer for the entire array. This has the effect of initializing the struct with index 0 with those values, and zero-initializing the rest of the struct elements. Then the compiler will discover we’ve provided two more initialization values (<code>{ 14, 3, 10 }</code> and <code>{ 15, 3, 40 }</code>) and produce a compilation error telling us that we’ve provided too many initialization values.</p><p>The correct way to initialize the above is to add an extra set of braces as follows:</p><pre class="language-cpp line-numbers"><code>// This works as expected</code><code>std::array<house, 3=""> houses { // initializer for houses</house,></code><code>    { // extra set of braces to initialize the C-style array member inside the std::array struct</code><code>        { 13, 4, 30 }, // initializer for array element 0</code><code>        { 14, 3, 10 }, // initializer for array element 1</code><code>        { 15, 3, 40 }, // initializer for array element 2</code><code>     }</code><code>};</code></pre><p>Note the extra set of braces that are required (to begin initialization of the C-style array member inside the std::array struct). Within those braces, we can then initialize each element individually, each inside its own set of braces.</p><p>This is why you’ll see <code>std::array</code> initializers with an extra set of braces when the element type requires a list of values.</p><br><h3>Summary</h3><p><code>std::array</code> is a great replacement for built-in fixed arrays. It’s efficient, in that it doesn’t use any more memory than built-in fixed arrays. The only real downside of a <code>std::array</code> over a built-in fixed array is a slightly more awkward syntax, that you have to explicitly specify the array length (the compiler won’t calculate it for you from the initializer, unless you also omit the type, which isn’t always possible), and the signed/unsigned issues with size and indexing. But those are comparatively minor quibbles — we recommend using <code>std::array</code> over built-in fixed arrays for any non-trivial array use.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.17 — An introduction to std::vector</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson, we introduced <code>std::array</code>, which provides the functionality of C++’s built-in fixed arrays in a safer and more usable form.</p><p>Analogously, the C++ standard library provides functionality that makes working with dynamic arrays safer and easier. This functionality is named <code>std::vector</code>.</p><p>Unlike <code>std::array</code>, which closely follows the basic functionality of fixed arrays, <code>std::vector</code> comes with some additional tricks up its sleeves. These help make <code>std::vector</code> one of the most useful and versatile tools to have in your C++ toolkit.</p><br><h3>An introduction to std::vector</h3><p>Introduced in C++03, <code>std::vector</code> provides dynamic array functionality that handles its own memory management. This means you can create arrays that have their length set at run-time, without having to explicitly allocate and deallocate memory using <code>new</code> and <code>delete</code>. <code>std::vector</code> lives in the <code><vector></vector></code> header.</p><p>Declaring a <code>std::vector</code> is simple:</p><pre class="language-cpp line-numbers"><code>#include <vector></vector></code><code></code><code>// no need to specify length at the declaration</code><code>std::vector<int> array; </int></code><code>std::vector<int> array2 = { 9, 7, 5, 3, 1 }; // use initializer list to initialize array (before C++11)</int></code><code>std::vector<int> array3 { 9, 7, 5, 3, 1 }; // use uniform initialization to initialize array</int></code><code></code><code>// as with std::array, the type can be omitted since C++17</code><code>std::vector array4 { 9, 7, 5, 3, 1 }; // deduced to std::vector<int></int></code></pre><p>Note that in both the uninitialized and initialized case, you do not need to include the array length at compile time. This is because <code>std::vector</code> will dynamically allocate memory for its contents as requested.</p><p>Just like <code>std::array</code>, accessing array elements can be done via the <code>[]</code> operator (which does no bounds checking) or the <code>at()</code> function (which does bounds checking):</p><pre class="language-cpp line-numbers"><code>array[6] = 2; // no bounds checking</code><code>array.at(7) = 3; // does bounds checking</code></pre><p>In either case, if you request an element that is off the end of the array, the vector will <em>not</em> automatically resize.</p><p>As of C++11, you can also assign values to a <code>std::vector</code> using an initializer-list:</p><pre class="language-cpp line-numbers"><code>array = { 0, 1, 2, 3, 4 }; // okay, array length is now 5</code><code>array = { 9, 8, 7 }; // okay, array length is now 3</code></pre><p>In this case, the vector will self-resize to match the number of elements provided.</p><p><strong>Self-cleanup prevents memory leaks</strong></p><p>When a vector variable goes out of scope, it automatically deallocates the memory it controls (if necessary). This is not only handy (as you don’t have to do it yourself), it also helps prevent memory leaks. Consider the following snippet:</p><pre class="language-cpp line-numbers"><code>void doSomething(bool earlyExit)</code><code>{</code><code>    int* array{ new int[5] { 9, 7, 5, 3, 1 } }; // allocated memory using new</code><code></code><code>    if (earlyExit)</code><code>        return; // exits the function without deallocating the memory allocated above</code><code></code><code>    // do stuff here</code><code></code><code>    delete[] array; // never called</code><code>}</code></pre><p>If earlyExit is set to true, array will never be deallocated, and the memory will be leaked.</p><p>However, if <code>array</code> is a <code>std::vector</code>, this won’t happen, because the memory will be deallocated as soon as <code>array</code> goes out of scope (regardless of whether the function exits early or not). This makes <code>std::vector</code> much safer to use than doing your own memory allocation.</p><p><strong>Vectors remember their length</strong></p><p>Unlike built-in dynamic arrays, which don’t know the length of the array they are pointing to, std::vector keeps track of its length. We can ask for the vector’s length via the <code>size()</code> function:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <vector></vector></code><code></code><code>void printLength(const std::vector<int>&amp; array)</int></code><code>{</code><code>    std::cout &lt;&lt; "The length is: " &lt;&lt; array.size() &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::vector array { 9, 7, 5, 3, 1 };</code><code>    printLength(array);</code><code></code><code>    std::vector<int> empty {};</int></code><code>    printLength(empty);</code><code></code><code>    return 0;</code><code>}</code></pre><p>The above example prints:</p><pre>The length is: 5
The length is: 0
</pre><p>Just like with <code>std::array</code>, <code>size()</code> returns a value of nested type <code>size_type</code> (full type in the above example would be <code>std::vector<int>::size_type</int></code>), which is an unsigned integer.</p><br><h3>Resizing a vector</h3><p>Resizing a built-in dynamically allocated array is complicated. Resizing a <code>std::vector</code> is as simple as calling the <code>resize()</code> function:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <vector></vector></code><code></code><code>int main()</code><code>{</code><code>    std::vector array { 0, 1, 2 };</code><code>    array.resize(5); // set size to 5</code><code></code><code>    std::cout &lt;&lt; "The length is: " &lt;&lt; array.size() &lt;&lt; '\n';</code><code></code><code>    for (int i : array)</code><code>        std::cout &lt;&lt; i &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>The length is: 5
0 1 2 0 0
</pre><p>There are two things to note here. First, when we resized the vector, the existing element values were preserved! Second, new elements are initialized to the default value for the type (which is 0 for integers).</p><p>Vectors may be resized to be smaller:</p><pre class="language-cpp line-numbers"><code>#include <vector></vector></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::vector array { 0, 1, 2, 3, 4 };</code><code>    array.resize(3); // set length to 3</code><code></code><code>    std::cout &lt;&lt; "The length is: " &lt;&lt; array.size() &lt;&lt; '\n';</code><code></code><code>    for (int i : array)</code><code>        std::cout &lt;&lt; i &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>The length is: 3
0 1 2
</pre><p>Resizing a vector is computationally expensive, so you should strive to minimize the number of times you do so. If you need a vector with a specific number of elements but don’t know the values of the elements at the point of declaration, you can create a vector with default elements like so:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <vector></vector></code><code></code><code>int main()</code><code>{</code><code>    // Using direct initialization, we can create a vector with 5 elements,</code><code>    // each element is a 0. If we use brace initialization, the vector would</code><code>    // have 1 element, a 5.</code><code>    std::vector<int> array(5);</int></code><code></code><code>    std::cout &lt;&lt; "The length is: " &lt;&lt; array.size() &lt;&lt; '\n';</code><code></code><code>    for (int i : array)</code><code>        std::cout &lt;&lt; i &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>The length is: 5
0 0 0 0 0
</pre><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>We’ll talk about why direct and brace-initialization are treated differently in lesson <a href="https://www.learncpp.com/cpp-tutorial/stdinitializer_list/">16.7 -- std::initializer_list</a>. A rule of thumb is, if the type is some kind of list and you don’t want to initialize it with a list, use direct initialization.</p></div><br><h3>Compacting bools</h3><p><code>std::vector</code> has another cool trick up its sleeves. There is a special implementation for <code>std::vector</code> of type bool that will compact 8 booleans into a byte! This happens behind the scenes, and doesn’t change how you use the std::vector.</p><pre class="language-cpp line-numbers"><code>#include <vector></vector></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::vector<bool> array { true, false, false, true, true };</bool></code><code>    std::cout &lt;&lt; "The length is: " &lt;&lt; array.size() &lt;&lt; '\n';</code><code></code><code>    for (int i : array)</code><code>        std::cout &lt;&lt; i &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>The length is: 5
1 0 0 1 1
</pre><br><h3>More to come</h3><p>Note that this is an introduction article intended to introduce the basics of <code>std::vector</code>. In lesson <a href="https://www.learncpp.com/cpp-tutorial/stdvector-capacity-and-stack-behavior/">12.3 -- std::vector capacity and stack behavior</a>, we’ll cover some additional capabilities of <code>std::vector</code>, including the difference between a vector’s length and capacity, and take a deeper look into how <code>std::vector</code> handles memory allocation.</p><br><h3>Conclusion</h3><p>Because variables of type <code>std::vector</code> handle their own memory management (which helps prevent memory leaks), remember their length, and can be easily resized, we recommend using <code>std::vector</code> in most cases where dynamic arrays are needed.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.18 — Introduction to iterators</h1></header><div class="entry-content" itemprop="articleBody"><p>Iterating through an array (or other structure) of data is quite a common thing to do in programming. And so far, we’ve covered many different ways to do so: with loops and an index (<code>for-loops</code> and <code>while loops</code>), with pointers and pointer arithmetic, and with <code>range-based for-loops</code>:</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <cstddef></cstddef></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    // In C++17, the type of variable data is deduced to std::array<int, 7=""></int,></code><code>    // If you get an error compiling this example, see the warning below</code><code>    std::array data{ 0, 1, 2, 3, 4, 5, 6 };</code><code>    std::size_t length{ std::size(data) };</code><code></code><code>    // while-loop with explicit index</code><code>    std::size_t index{ 0 };</code><code>    while (index &lt; length)</code><code>    {</code><code>        std::cout &lt;&lt; data[index] &lt;&lt; ' ';</code><code>        ++index;</code><code>    }</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    // for-loop with explicit index</code><code>    for (index = 0; index &lt; length; ++index)</code><code>    {</code><code>        std::cout &lt;&lt; data[index] &lt;&lt; ' ';</code><code>    }</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    // for-loop with pointer (Note: ptr can't be const, because we increment it)</code><code>    for (auto ptr{ &amp;data[0] }; ptr != (&amp;data[0] + length); ++ptr)</code><code>    {</code><code>        std::cout &lt;&lt; *ptr &lt;&lt; ' ';</code><code>    }</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    // ranged-based for loop</code><code>    for (int i : data)</code><code>    {</code><code>        std::cout &lt;&lt; i &lt;&lt; ' ';</code><code>    }</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>The examples in this lesson use a C++17 feature called <code>class template argument deduction</code> to deduce the template arguments for a template variable from its initializer. In the example above, when the compiler sees <code>std::array data{ 0, 1, 2, 3, 4, 5, 6 };</code>, it will deduce that we want <code>std::array<int, 7=""> data { 0, 1, 2, 3, 4, 5, 6 };</int,></code>.</p><p>If your compiler is not C++17 enabled, you’ll get an error that says something like, “missing template arguments before ‘data’”. In that case, your best bet is to enable C++17, as per lesson <a href="https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-choosing-a-language-standard/">0.12 -- Configuring your compiler: Choosing a language standard</a>. If you can not, you can replace the lines that use class template argument deduction with lines that have explicit template arguments (e.g. replace <code>std::array data{ 0, 1, 2, 3, 4, 5, 6 };</code> with <code>std::array<int, 7=""> data { 0, 1, 2, 3, 4, 5, 6 };</int,></code></p></div><p>Looping using indexes is more typing than needed if we only use the index to access elements. It also only works if the container (e.g. the array) provides direct access to elements (which arrays do, but some other types of containers, such as lists, do not).</p><p>Looping with pointers and pointer arithmetic is verbose, and can be confusing to readers who don’t know the rules of pointer arithmetic. Pointer arithmetic also only works if elements are consecutive in memory (which is true for arrays, but not true for other types of containers, such as lists, trees, and maps).</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>Pointers (without pointer arithmetic) can also be used to iterate through some non-sequential structures. In a linked list, each element is connected to the prior element by a pointer. We can iterate through the list by following the chain of pointers.</p></div><p>Range-based for-loops are a little more interesting, as the mechanism for iterating through our container is hidden -- and yet, they still work for all kinds of different structures (arrays, lists, trees, maps, etc…). How do these work? They use iterators.</p><br><h3>Iterators</h3><p>An <span class="cpp-definition">iterator</span> is an object designed to traverse through a container (e.g. the values in an array, or the characters in a string), providing access to each element along the way.</p><p>A container may provide different kinds of iterators. For example, an array container might offer a forwards iterator that walks through the array in forward order, and a reverse iterator that walks through the array in reverse order.</p><p>Once the appropriate type of iterator is created, the programmer can then use the interface provided by the iterator to traverse and access elements without having to worry about what kind of traversal is being done or how the data is being stored in the container. And because C++ iterators typically use the same interface for traversal (operator++ to move to the next element) and access (operator* to access the current element), we can iterate through a wide variety of different container types using a consistent method.</p><br><h3>Pointers as an iterator</h3><p>The simplest kind of iterator is a pointer, which (using pointer arithmetic) works for data stored sequentially in memory. Let’s revisit a simple array traversal using a pointer and pointer arithmetic:</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::array data{ 0, 1, 2, 3, 4, 5, 6 };</code><code></code><code>    auto begin{ &amp;data[0] };</code><code>    // note that this points to one spot beyond the last element</code><code>    auto end{ begin + std::size(data) };</code><code></code><code>    // for-loop with pointer</code><code>    for (auto ptr{ begin }; ptr != end; ++ptr) // ++ to move to next element</code><code>    {</code><code>        std::cout &lt;&lt; *ptr &lt;&lt; ' '; // Indirection to get value of current element</code><code>    }</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Output:</p><pre>0 1 2 3 4 5 6
</pre><p>In the above, we defined two variables: <code>begin</code> (which points to the beginning of our container), and <code>end</code> (which marks an end point). For arrays, the end marker is typically the place in memory where the last element would be if the container contained one more element.</p><p>The pointer then iterates between <code>begin</code> and <code>end</code>, and the current element can be accessed by indirection through the pointer.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>You might be tempted to calculate the end marker using the address-of operator and array syntax like so:</p><pre class="language-cpp line-numbers"><code>int* end{ &amp;data[std::size(data)] };</code></pre><p>But this causes undefined behavior, because <code>data[std::size(data)]</code> accesses an element that is off the end of the array.</p><p>Instead, use:</p><pre class="language-cpp line-numbers"><code>int* end{ data.data() + std::size(data) }; // data() returns a pointer to the first element</code></pre></div><br><h3>Standard library iterators</h3><p>Iterating is such a common operation that all standard library containers offer direct support for iteration. Instead of calculating our own begin and end points, we can simply ask the container for the begin and end points via functions conveniently named <code>begin()</code> and <code>end()</code>:</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::array array{ 1, 2, 3 };</code><code></code><code>    // Ask our array for the begin and end points (via the begin and end member functions).</code><code>    auto begin{ array.begin() };</code><code>    auto end{ array.end() };</code><code></code><code>    for (auto p{ begin }; p != end; ++p) // ++ to move to next element.</code><code>    {</code><code>        std::cout &lt;&lt; *p &lt;&lt; ' '; // Indirection to get value of current element.</code><code>    }</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>1 2 3
</pre><p>The <code>iterator</code> header also contains two generic functions (<code>std::begin</code> and <code>std::end</code>) that can be used:</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <iterator> // For std::begin and std::end</iterator></code><code></code><code>int main()</code><code>{</code><code>    std::array array{ 1, 2, 3 };</code><code></code><code>    // Use std::begin and std::end to get the begin and end points.</code><code>    auto begin{ std::begin(array) };</code><code>    auto end{ std::end(array) };</code><code></code><code>    for (auto p{ begin }; p != end; ++p) // ++ to move to next element</code><code>    {</code><code>        std::cout &lt;&lt; *p &lt;&lt; ' '; // Indirection to get value of current element</code><code>    }</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This also prints:</p><pre>1 2 3
</pre><p>Don’t worry about the types of the iterators for now, we’ll re-visit iterators in a later chapter. The important thing is that the iterator takes care of the details of iterating through the container. All we need are four things: the begin point, the end point, operator++ to move the iterator to the next element (or the end), and operator* to get the value of the current element.</p><br><h3>Back to range-based for loops</h3><p>All types that have both <code>begin()</code> and <code>end()</code> member functions, or that can be used with <code>std::begin()</code> and <code>std::end()</code>, are usable in range-based for-loops.</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::array array{ 1, 2, 3 };</code><code></code><code>    // This does exactly the same as the loop we used before.</code><code>    for (int i : array)</code><code>    {</code><code>        std::cout &lt;&lt; i &lt;&lt; ' ';</code><code>    }</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Behind the scenes, the range-based for-loop calls <code>begin()</code> and <code>end()</code> of the type to iterate over. <code>std::array</code> has <code>begin</code> and <code>end</code> member functions, so we can use it in a range-based loop. C-style fixed arrays can be used with <code>std::begin</code> and <code>std::end</code> functions, so we can loop through them with a range-based loop as well. Dynamic arrays don’t work though, because there is no <code>std::end</code> function for them (because the type information doesn’t contain the array’s length).</p><p>You’ll learn how to add functions to your types later, so that they can be used with range-based for-loops too.</p><p>Range-based for-loops aren’t the only thing that makes use of iterators. They’re also used in <code>std::sort</code> and other algorithms. Now that you know what they are, you’ll notice they’re used quite a bit in the standard library.</p><br><h3>Iterator invalidation (dangling iterators)</h3><p>Much like pointers and references, iterators can be left “dangling” if the elements being iterated over change address or are destroyed. When this happens, we say the iterator has been <span class="cpp-definition">invalidated</span>. Accessing an invalidated iterator produces undefined behavior.</p><p>Some operations that modify containers (such as adding an element to a <code>std::vector</code>) can have the side effect of causing the elements in the container to change addresses. When this happens, existing iterators to those elements will be invalidated. Good C++ reference documentation should note which container operations may or will invalidate iterators. As an example, see the <a href="https://en.cppreference.com/w/cpp/container/vector#Iterator_invalidation">“Iterator invalidation” section of <code>std::vector</code> on cppreference</a>.</p><p>Here’s an example of this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <vector></vector></code><code></code><code>int main()</code><code>{</code><code>	std::vector v{ 1, 2, 3, 4, 5, 6, 7 };</code><code></code><code>	auto it{ v.begin() };</code><code></code><code>	++it; // move to second element</code><code>	std::cout &lt;&lt; *it &lt;&lt; '\n'; // ok: prints 2</code><code></code><code>	v.erase(it); // erase the element currently being iterated over</code><code></code><code>	// erase() invalidates iterators to the erased element (and subsequent elements)</code><code>	// so iterator "it" is now invalidated</code><code></code><code>	++it; // undefined behavior</code><code>	std::cout &lt;&lt; *it &lt;&lt; '\n'; // undefined behavior</code><code></code><code>	return 0;</code><code>}</code></pre><p>(h/t to nascardriver for significant contributions to this lesson)</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.19 — Introduction to standard library algorithms</h1></header><div class="entry-content" itemprop="articleBody"><p>New programmers typically spend a lot of time writing custom loops to perform relatively simple tasks, such as sorting or counting or searching arrays. These loops can be problematic, both in terms of how easy it is to make an error, and in terms of overall maintainability, as loops can be hard to understand.</p><p>Because searching, counting, and sorting are such common operations to do, the C++ standard library comes with a bunch of functions to do these things in just a few lines of code. Additionally, these standard library functions come pre-tested, are efficient, work on a variety of different container types, and many support parallelization (the ability to devote multiple CPU threads to the same task in order to complete it faster).</p><p>The functionality provided in the algorithms library generally fall into one of three categories:</p><ul><li><span class="cpp-definition">Inspectors</span> -- Used to view (but not modify) data in a container. Examples include searching and counting.</li><li><span class="cpp-definition">Mutators</span> -- Used to modify data in a container. Examples include sorting and shuffling.</li><li><span class="cpp-definition">Facilitators</span> -- Used to generate a result based on values of the data members. Examples include objects that multiply values, or objects that determine what order pairs of elements should be sorted in.</li></ul><p>These algorithms live in the <a href="https://en.cppreference.com/w/cpp/algorithm">algorithms</a> library. In this lesson, we’ll explore some of the more common algorithms -- but there are many more, and we encourage you to read through the linked reference to see everything that’s available!</p><p>Note: All of these make use of iterators, so if you’re not familiar with basic iterators, please review lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-iterators/">11.18 -- Introduction to iterators</a>.</p><br><h3>Using std::find to find an element by value </h3><p><a href="https://en.cppreference.com/w/cpp/algorithm/find"><code>std::find</code></a> searches for the first occurrence of a value in a container. <code>std::find</code> takes 3 parameters: an iterator to the starting element in the sequence, an iterator to the ending element in the sequence, and a value to search for. It returns an iterator pointing to the element (if it is found) or the end of the container (if the element is not found).</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::array arr{ 13, 90, 99, 5, 40, 80 };</code><code></code><code>    std::cout &lt;&lt; "Enter a value to search for and replace with: ";</code><code>    int search{};</code><code>    int replace{};</code><code>    std::cin &gt;&gt; search &gt;&gt; replace;</code><code></code><code>    // Input validation omitted</code><code></code><code>    // std::find returns an iterator pointing to the found element (or the end of the container)</code><code>    // we'll store it in a variable, using type inference to deduce the type of</code><code>    // the iterator (since we don't care)</code><code>    auto found{ std::find(arr.begin(), arr.end(), search) };</code><code></code><code>    // Algorithms that don't find what they were looking for return the end iterator.</code><code>    // We can access it by using the end() member function.</code><code>    if (found == arr.end())</code><code>    {</code><code>        std::cout &lt;&lt; "Could not find " &lt;&lt; search &lt;&lt; '\n';</code><code>    }</code><code>    else</code><code>    {</code><code>        // Override the found element.</code><code>        *found = replace;</code><code>    }</code><code></code><code>    for (int i : arr)</code><code>    {</code><code>        std::cout &lt;&lt; i &lt;&lt; ' ';</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Sample run when the element is found</p><pre>Enter a value to search for and replace with: 5 234
13 90 99 234 40 80
</pre><p>Sample run when the element isn’t found</p><pre>Enter a value to search for and replace with: 0 234
Could not find 0
13 90 99 5 40 80
</pre><br><h3>Using std::find_if to find an element that matches some condition</h3><p>Sometimes we want to see if there is a value in a container that matches some condition (e.g. a string that contains a specific substring) rather than an exact value. In such cases, <code>std::find_if</code> is perfect. The <code>std::find_if</code> function works similarly to <code>std::find</code>, but instead of passing in a value to search for, we pass in a callable object, such as a function pointer (or a lambda, which we’ll cover later) that checks to see if a match is found. <code>std::find_if</code> will call this function for every element until a matching element is found (or no more elements remain in the container to check).</p><p>Here’s an example where we use <code>std::find_if</code> to check if any elements contain the substring “nut”:</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>// Our function will return true if the element matches</code><code>bool containsNut(std::string_view str)</code><code>{</code><code>    // std::string_view::find returns std::string_view::npos if it doesn't find</code><code>    // the substring. Otherwise it returns the index where the substring occurs</code><code>    // in str.</code><code>    return (str.find("nut") != std::string_view::npos);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::array<std::string_view, 4=""> arr{ "apple", "banana", "walnut", "lemon" };</std::string_view,></code><code></code><code>    // Scan our array to see if any elements contain the "nut" substring</code><code>    auto found{ std::find_if(arr.begin(), arr.end(), containsNut) };</code><code></code><code>    if (found == arr.end())</code><code>    {</code><code>        std::cout &lt;&lt; "No nuts\n";</code><code>    }</code><code>    else</code><code>    {</code><code>        std::cout &lt;&lt; "Found " &lt;&lt; *found &lt;&lt; '\n';</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>Output</p><pre>Found walnut
</pre><p>If you were to write the above example by hand, you’d need at least three loops (one to loop through the array, and two to match the substring). The standard library functions allow us to do the same thing in just a few lines of code!</p><br><h3>Using std::count and std::count_if to count how many occurrences there are </h3><p><a href="https://en.cppreference.com/w/cpp/algorithm/count"><code>std::count</code></a> and <code>std::count_if</code> search for all occurrences of an element or an element fulfilling a condition.</p><p>In the following example, we’ll count how many elements contain the substring “nut”:</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>bool containsNut(std::string_view str)</code><code>{</code><code>	return (str.find("nut") != std::string_view::npos);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::array<std::string_view, 5=""> arr{ "apple", "banana", "walnut", "lemon", "peanut" };</std::string_view,></code><code></code><code>	auto nuts{ std::count_if(arr.begin(), arr.end(), containsNut) };</code><code></code><code>	std::cout &lt;&lt; "Counted " &lt;&lt; nuts &lt;&lt; " nut(s)\n";</code><code></code><code>	return 0;</code><code>}</code></pre><p>Output</p><pre>Counted 2 nut(s)
</pre><br><h3>Using std::sort to custom sort </h3><p>We previously used <a href="https://en.cppreference.com/w/cpp/algorithm/sort"><code>std::sort</code></a> to sort an array in ascending order, but std::sort can do more than that. There’s a version of <code>std::sort</code> that takes a function as its third parameter that allows us to sort however we like. The function takes two parameters to compare, and returns true if the first argument should be ordered before the second. By default, <code>std::sort</code> sorts the elements in ascending order.</p><p>Let’s use <code>std::sort</code> to sort an array in reverse order using a custom comparison function named <code>greater</code>:</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code></code><code>bool greater(int a, int b)</code><code>{</code><code>    // Order @a before @b if @a is greater than @b.</code><code>    return (a &gt; b);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::array arr{ 13, 90, 99, 5, 40, 80 };</code><code></code><code>    // Pass greater to std::sort</code><code>    std::sort(arr.begin(), arr.end(), greater);</code><code></code><code>    for (int i : arr)</code><code>    {</code><code>        std::cout &lt;&lt; i &lt;&lt; ' ';</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Output</p><pre>99 90 80 40 13 5
</pre><p>Once again, instead of writing our own custom loop functions, we can sort our array however we like in just a few lines of code!</p><p>Our <code>greater</code> function needs 2 arguments, but we’re not passing it any, so where do they come from? When we use a function without parentheses (), it’s only a function pointer, not a call. You might remember this from when we tried to print a function without parentheses and <code>std::cout</code> printed “1”. <code>std::sort</code> uses this pointer and calls the actual <code>greater</code> function with any 2 elements of the array. We don’t know which elements <code>greater</code> will be called with, because it’s not defined which sorting algorithm <code>std::sort</code> is using under the hood. We talk more about function pointers in a later chapter.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>Because sorting in descending order is so common, C++ provides a custom type (named <code>std::greater</code>) for that too (which is part of the <a href="https://en.cppreference.com/w/cpp/header/functional">functional</a> header). In the above example, we can replace:</p><pre class="language-cpp line-numbers"><code>  std::sort(arr.begin(), arr.end(), greater); // call our custom greater function</code></pre><p>with:</p><pre class="language-cpp line-numbers"><code>  std::sort(arr.begin(), arr.end(), std::greater{}); // use the standard library greater comparison</code><code>  // Before C++17, we had to specify the element type when we create std::greater</code><code>  std::sort(arr.begin(), arr.end(), std::greater<int>{}); // use the standard library greater comparison</int></code></pre><p>Note that the <code>std::greater{}</code> needs the curly braces because it is not a callable function. It’s a type, and in order to use it, we need to instantiate an object of that type. The curly braces instantiate an anonymous object of that type (which then gets passed as an argument to std::sort).</p></div><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>To further explain how <code>std::sort</code> uses the comparison function, we’ll have to take a step back to a modified version of the selection sort example from lesson <a href="https://www.learncpp.com/cpp-tutorial/sorting-an-array-using-selection-sort/">11.4 -- Sorting an array using selection sort</a>.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator></iterator></code><code>#include <utility></utility></code><code></code><code>void sort(int* begin, int* end)</code><code>{</code><code>    for (auto startElement{ begin }; startElement != end; ++startElement)</code><code>    {</code><code>        auto smallestElement{ startElement };</code><code></code><code>        // std::next returns a pointer to the next element, just like (startElement + 1) would.</code><code>        for (auto currentElement{ std::next(startElement) }; currentElement != end; ++currentElement)</code><code>        {</code><code>            if (*currentElement &lt; *smallestElement)</code><code>            {</code><code>                smallestElement = currentElement;</code><code>            }</code><code>        }</code><code></code><code>        std::swap(*startElement, *smallestElement);</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int array[]{ 2, 1, 9, 4, 5 };</code><code></code><code>    sort(std::begin(array), std::end(array));</code><code></code><code>    for (auto i : array)</code><code>    {</code><code>        std::cout &lt;&lt; i &lt;&lt; ' ';</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>So far, this is nothing new and <code>sort</code> always sorts elements from low to high. To add a comparison function, we have to use a new type, <code>std::function<bool(int, int)=""></bool(int,></code>, to store a function that takes 2 int parameters and returns a bool. Treat this type as magic for now, we will explain it in <a href="https://www.learncpp.com#Chapter12">chapter 12</a>.</p><pre class="language-cpp line-numbers"><code>void sort(int* begin, int* end, std::function<bool(int, int)=""> compare)</bool(int,></code></pre><p>We can now pass a comparison function like <code>greater</code> to <code>sort</code>, but how does <code>sort</code> use it? All we need to do is replace the line</p><pre class="language-cpp line-numbers"><code>if (*currentElement &lt; *smallestElement)</code></pre><p>with</p><pre class="language-cpp line-numbers"><code>if (compare(*currentElement, *smallestElement))</code></pre><p>Now the caller of <code>sort</code> can choose how to compare two elements.</p><pre class="language-cpp line-numbers"><code>#include <functional> // std::function</functional></code><code>#include <iostream></iostream></code><code>#include <iterator></iterator></code><code>#include <utility></utility></code><code></code><code>// sort accepts a comparison function</code><code>void sort(int* begin, int* end, std::function<bool(int, int)=""> compare)</bool(int,></code><code>{</code><code>    for (auto startElement{ begin }; startElement != end; ++startElement)</code><code>    {</code><code>        auto smallestElement{ startElement };</code><code></code><code>        for (auto currentElement{ std::next(startElement) }; currentElement != end; ++currentElement)</code><code>        {</code><code>            // the comparison function is used to check if the current element should be ordered</code><code>            // before the currently "smallest" element.</code><code>            if (compare(*currentElement, *smallestElement))</code><code>            {</code><code>                smallestElement = currentElement;</code><code>            }</code><code>        }</code><code></code><code>        std::swap(*startElement, *smallestElement);</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int array[]{ 2, 1, 9, 4, 5 };</code><code></code><code>    // use std::greater to sort in descending order</code><code>    // (We have to use the global namespace selector to prevent a collision</code><code>    // between our sort function and std::sort.)</code><code>    ::sort(std::begin(array), std::end(array), std::greater{});</code><code></code><code>    for (auto i : array)</code><code>    {</code><code>        std::cout &lt;&lt; i &lt;&lt; ' ';</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre></div><br><h3>Using std::for_each to do something to all elements of a container </h3><p><a href="https://en.cppreference.com/w/cpp/algorithm/for_each"><code>std::for_each</code></a> takes a list as input and applies a custom function to every element. This is useful when we want to perform the same operation to every element in a list.</p><p>Here’s an example where we use <code>std::for_each</code> to double all the numbers in an array:</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code></code><code>void doubleNumber(int&amp; i)</code><code>{</code><code>    i *= 2;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::array arr{ 1, 2, 3, 4 };</code><code></code><code>    std::for_each(arr.begin(), arr.end(), doubleNumber);</code><code></code><code>    for (int i : arr)</code><code>    {</code><code>        std::cout &lt;&lt; i &lt;&lt; ' ';</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Output</p><pre>2 4 6 8
</pre><p>This often seems like the most unnecessary algorithm to new developers, because equivalent code with a range-based for-loop is shorter and easier. But there are benefits to <code>std::for_each</code>. Let’s compare <code>std::for_each</code> to a range-based for-loop.</p><pre class="language-cpp line-numbers"><code>std::ranges::for_each(arr, doubleNumber); // Since C++20, we don't have to use begin() and end().</code><code>// std::for_each(arr.begin(), arr.end(), doubleNumber); // Before C++20</code><code></code><code>for (auto&amp; i : arr)</code><code>{</code><code>    doubleNumber(i);</code><code>}</code></pre><p>With <code>std::for_each</code>, our intentions are clear. Call <code>doubleNumber</code> with each element of <code>arr</code>. In the range-based for-loop, we have to add a new variable, <code>i</code>. This leads to several mistakes that a programmer could do when they’re tired or not paying attention. For one, there could be an implicit conversion if we don’t use <code>auto</code>. We could forget the ampersand, and <code>doubleNumber</code> wouldn’t affect the array. We could accidentally pass a variable other than <code>i</code> to <code>doubleNumber</code>. These mistakes cannot happen with <code>std::for_each</code>.</p><p>Additionally, <code>std::for_each</code> can skip elements at the beginning or end of a container, for example to skip the first element of <code>arr</code>, <a href="https://en.cppreference.com/w/cpp/iterator/next"><code>std::next</code></a> can be used to advance begin to the next element.</p><pre class="language-cpp line-numbers"><code>std::for_each(std::next(arr.begin()), arr.end(), doubleNumber);</code><code>// Now arr is [1, 4, 6, 8]. The first element wasn't doubled.</code></pre><p>This isn’t possible with a range-based for-loop.</p><p>Like many algorithms, <code>std::for_each</code> can be parallelized to achieve faster processing, making it better suited for large projects and big data than a range-based for-loop.</p><br><h3>Order of execution</h3><p>Note that most of the algorithms in the algorithms library do not guarantee a particular order of execution. For such algorithms, take care to ensure any functions you pass in do not assume a particular ordering, as the order of invocation may not be the same on every compiler.</p><p>The following algorithms do guarantee sequential execution: <code>std::for_each</code>, <code>std::copy</code>, <code>std::copy_backward</code>, <code>std::move</code>, and <code>std::move_backward</code>.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Unless otherwise specified, do not assume that standard library algorithms will execute in a particular sequence. <code>std::for_each</code>, <code>std::copy</code>, <code>std::copy_backward</code>, <code>std::move</code>, and <code>std::move_backward</code> have sequential guarantees.</p></div><p></p><br><h3>Ranges in C++20</h3><p>Having to explicitly pass <code>arr.begin()</code> and <code>arr.end()</code> to every algorithm is a bit annoying. But fear not -- C++20 adds <em>ranges</em>, which allow us to simply pass <code>arr</code>. This will make our code even shorter and more readable.</p><br><h3>Conclusion</h3><p>The algorithms library has a ton of useful functionality that can make your code simpler and more robust. We only cover a small subset in this lesson, but because most of these functions work very similarly, once you know how a few work, you can make use of most of them.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Favor using functions from the algorithms library over writing your own functionality to do the same thing</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">11.x — Chapter 11 comprehensive quiz</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Words of encouragement</h3><p>Congratulations on reaching the end of the longest chapter in the tutorials! Unless you have previous programming experience, this chapter was probably the most challenging one so far. If you made it this far, you’re doing great!</p><p>The good news is that the next chapter is easy in comparison. And in the chapter beyond that, we reach the heart of the tutorials: Object-oriented programming!</p><br><h3>Chapter summary</h3><p>Arrays allow us to store and access many variables of the same type through a single identifier. Array elements can be accessed using the subscript operator (<code>[]</code>). Be careful not to index an array out of the array’s range. Arrays can be initialized using an initializer list or uniform initialization.</p><p>Fixed arrays must have a length that is set at compile time. Fixed arrays will usually decay into a pointer when evaluated or passed to a function.</p><p>Loops can be used to iterate through an array. Beware of off-by-one errors, so you don’t iterate off the end of your array. Range-based for-loops are useful when the array hasn’t decayed into a pointer.</p><p>Arrays can be made multidimensional by using multiple indices.</p><p>Arrays can be used to do C-style strings. You should generally avoid these and use <code>std::string_view</code> and <code>std::string</code> instead.</p><p>Pointers are variables that store the memory address of (point at) another variable. The address-of operator (<code>&amp;</code>) can be used to get the address of a variable. The indirection operator (<code>*</code>) can be used to get the value that a pointer points at.</p><p>A null pointer is a pointer that is not pointing at anything. Pointers can be made null by initializing or assigning the value <code>nullptr</code> to them. Avoid the <code>NULL</code> macro. Indirection through a null pointer can cause bad things to happen. Deleting a null pointer is okay (it doesn’t do anything).</p><p>A pointer to an array doesn’t know how large the array it is pointing to is. This means <code>sizeof()</code> and range-based for-loops won’t work.</p><p>The <code>new</code> and <code>delete</code> operators can be used to dynamically allocate memory for a pointer variable or array. Although it’s unlikely to happen, operator <code>new</code> can fail if the operating system runs out of memory. If you’re writing software for a memory-limited system, make sure to check if <code>new</code> was successful.</p><p>Make sure to use the array delete (<code>delete[]</code>) when deleting an array. Pointers pointing to deallocated memory are called dangling pointers. Using the wrong <code>delete</code>, or indirection through a dangling pointer causes undefined behavior.</p><p>Failing to delete dynamically allocated memory can result in memory leaks when the last pointer to that memory goes out of scope.</p><p>Normal variables are allocated from limited memory called the stack. Dynamically allocated variables are allocated from a general pool of memory called the heap.</p><p>A pointer to a <code>const</code> value treats the value it is pointing to as <code>const</code>.</p><pre class="language-cpp line-numbers"><code>int value{ 5 };</code><code>const int* ptr{ &amp;value }; // this is okay, ptr is pointing to a "const int"</code></pre><p>A <code>const</code> pointer is a pointer whose value can not be changed after initialization.</p><pre class="language-cpp line-numbers"><code>int value{ 5 };</code><code>int* const ptr{ &amp;value }; // ptr is const, but *ptr is non-const</code></pre><p>A reference is an alias to another variable. References are declared using an ampersand (<code>&amp;</code>), but this does not mean address-of in this context. References are implicitly <code>const</code> -- they must be initialized with a value, and a new value can not be assigned to them. References can be used to prevent copies from being made when passing data to or from a function.</p><p>The member selection operator (<code>-&gt;</code>) can be used to select a member from a pointer to a struct. It combines both an indirection and normal member access (<code>.</code>).</p><p>Void pointers are pointers that can point to any type of data. Indirection through them is not possible directly. You can use <code>static_cast</code> to convert them back to their original pointer type. It’s up to you to remember what type they originally were.</p><p>Pointers to pointers allow us to create a pointer that points to another pointer.</p><p><code>std::array</code> provides all of the functionality of C++ built-in arrays (and more) in a form that won’t decay into a pointer. These should generally be preferred over built-in fixed arrays.</p><p><code>std::vector</code> provides dynamic array functionality, handles its own memory management and remembers its size. These should generally be favored over built-in dynamic arrays.</p><p>Thanks to iterators, we don’t have to know how a container is implemented to loop through its elements.</p><p>The algorithms library helps us to save a lot of time by providing many off-the-shelf functions. In combination with iterators (and later lambdas), the algorithms library is an important part of C++.</p><br><h3>Quiz time</h3><p>To make the quizzes a little easier, we have to introduce a couple of new algorithms.</p><p><a href="https://en.cppreference.com/w/cpp/algorithm/reduce"><code>std::reduce</code></a> applies a function, by default the <code>+</code> operator, to all elements in a list, resulting in a single value. When we use the <code>+</code> operator, the result is the sum of all elements in the list. Note that there’s also <a href="https://en.cppreference.com/w/cpp/algorithm/accumulate"><code>std::accumulate</code></a>. <code>std::accumulate</code> cannot be parallelized, because it applies the function left-to-right. <code>std::reduce</code> segments the list, which means that the function is applied in an unknown order, allowing the operation to be parallelized. If we want to sum up a list, we don’t care about the order and we use <code>std::reduce</code>.</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p><code>std::reduce</code> is currently not fully implemented in all major standard libraries. If it doesn’t work for you, fall back to <code>std::accumulate</code>.</p></div><p><a href="https://en.cppreference.com/w/cpp/algorithm/random_shuffle"><code>std::shuffle</code></a> takes a list and randomly re-orders its elements. We covered <code>std::mt19937</code> in lesson <a href="https://www.learncpp.com/cpp-tutorial/generating-random-numbers-using-mersenne-twister/">7.19 -- Generating random numbers using Mersenne Twister</a>.</p><pre class="language-cpp line-numbers"><code>#include <algorithm> // std::shuffle</algorithm></code><code>#include <array></array></code><code>#include <ctime></ctime></code><code>#include <iostream></iostream></code><code>#include <numeric> // std::reduce</numeric></code><code>#include <random></random></code><code></code><code>int main()</code><code>{</code><code>  std::array arr{ 1, 2, 3, 4 };</code><code></code><code>  std::cout &lt;&lt; std::reduce(arr.begin(), arr.end()) &lt;&lt; '\n'; // 10</code><code></code><code>  // If you can't use std::reduce, use std::accumulate. The 0 is the initial value</code><code>  // of the result: (((0 + 1) + 2) + 3) + 4</code><code>  std::cout &lt;&lt; std::accumulate(arr.begin(), arr.end(), 0) &lt;&lt; '\n'; // 10</code><code></code><code>  std::mt19937 mt{ static_cast<std::mt19937::result_type>(std::time(nullptr)) };</std::mt19937::result_type></code><code>  std::shuffle(arr.begin(), arr.end(), mt);</code><code></code><code>  for (int i : arr)</code><code>  {</code><code>    std::cout &lt;&lt; i &lt;&lt; ' ';</code><code>  }</code><code></code><code>  std::cout &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><p>Possible output</p><pre>10
10
2 1 4 3
</pre><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Pretend you’re writing a game where the player can hold 3 types of items: health potions, torches, and arrows. Create an <code>enum</code> to identify the different types of items, and an <code>std::array</code> to store the number of each item the player is carrying (the enumerators are used as indexes of the array). The player should start with 2 health potions, 5 torches, and 10 arrows. Write a function called <code>countTotalItems()</code> that returns how many items the player has in total. Have your <code>main()</code> function print the output of <code>countTotalItems()</code> as well as the number of torches.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <numeric> // std::reduce</numeric></code><code>#include <iostream></iostream></code><code></code><code>// We want to use ItemTypes to index an array. Use enum rather than enum class.</code><code>enum ItemTypes</code><code>{</code><code>  item_health_potion,</code><code>  item_torch,</code><code>  item_arrow,</code><code>  max_items</code><code>};</code><code></code><code>using Inventory = std::array<int, itemtypes::max_items="">;</int,></code><code></code><code>int countTotalItems(const Inventory&amp; items)</code><code>{</code><code>  return std::reduce(items.begin(), items.end());</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  Inventory items{ 2, 5, 10 };</code><code></code><code>  std::cout &lt;&lt; "The player has " &lt;&lt; countTotalItems(items) &lt;&lt; " item(s) in total.\n";</code><code></code><code>  // We can access individual items using the enumerators:</code><code>  std::cout &lt;&lt; "The player has " &lt;&lt; items[ItemTypes::item_torch] &lt;&lt; " torch(es)\n";</code><code></code><code>  return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>Write the following program: Create a <code>struct</code> that holds a student’s first name and grade (on a scale of 0-100). Ask the user how many students they want to enter. Create a <code>std::vector</code> to hold all of the students. Then prompt the user for each name and grade. Once the user has entered all the names and grade pairs, sort the list by grade (highest first). Then print all the names and grades in sorted order.</p><p>For the following input:</p><pre>Joe
82
Terry
73
Ralph
4
Alex
94
Mark
88
</pre><p>The output should look like this:</p><pre>Alex got a grade of 94
Mark got a grade of 88
Joe got a grade of 82
Terry got a grade of 73
Ralph got a grade of 4
</pre><p>You can assume that names don’t contain spaces and that input extraction doesn’t fail.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <algorithm> // std::sort</algorithm></code><code>#include <cstddef> // std::size_t</cstddef></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <vector></vector></code><code></code><code>struct Student</code><code>{</code><code>  std::string name{};</code><code>  int grade{};</code><code>};</code><code></code><code>int getNumberOfStudents()</code><code>{</code><code>  int numberOfStudents{};</code><code></code><code>  do</code><code>  {</code><code>    std::cout &lt;&lt; "How many students do you want to enter? ";</code><code>    std::cin &gt;&gt; numberOfStudents;</code><code>  } while (numberOfStudents &lt;= 0);</code><code></code><code>  return numberOfStudents;</code><code>}</code><code></code><code>std::vector<student> getStudents()</student></code><code>{</code><code>  using Students = std::vector<student>;</student></code><code></code><code>  int numberOfStudents{ getNumberOfStudents() };</code><code></code><code>  // Create a vector with numberOfStudents elements.</code><code>  Students students(static_cast<students::size_type>(numberOfStudents));</students::size_type></code><code></code><code>  int studentNumber{ 1 };</code><code></code><code>  for (auto&amp; student : students)</code><code>  {</code><code>    std::cout &lt;&lt; "Enter name #" &lt;&lt; studentNumber &lt;&lt; ": ";</code><code>    std::cin &gt;&gt; student.name;</code><code>    std::cout &lt;&lt; "Enter grade #" &lt;&lt; studentNumber &lt;&lt; ": ";</code><code>    std::cin &gt;&gt; student.grade;</code><code></code><code>    ++studentNumber;</code><code>  }</code><code></code><code>  return students;</code><code>}</code><code></code><code>// Pass by reference to avoid slow copies.</code><code>bool compareStudents(const Student&amp; a, const Student&amp; b)</code><code>{</code><code>  return (a.grade &gt; b.grade);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  auto students{ getStudents() };</code><code></code><code>  std::sort(students.begin(), students.end(), compareStudents);</code><code></code><code>  // Print out all the names</code><code>  for (const auto&amp; student : students)</code><code>  {</code><code>    std::cout &lt;&lt; student.name &lt;&lt; " got a grade of " &lt;&lt; student.grade &lt;&lt; '\n';</code><code>  }</code><code></code><code>  return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>Write your own function to swap the value of two integer variables. Write a <code>main()</code> function to test it.</p><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">Hint: Use reference parameters<pre class="language-cpp line-numbers"><code>void swap(int&amp; a, int&amp; b)</code></pre></div><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// Use reference parameters so we can modify the values of the arguments passed in</code><code>void swap(int&amp; a, int&amp; b)</code><code>{</code><code>  // Temporarily save value of a</code><code>  int temp{ a };</code><code></code><code>  // Put value of b in a</code><code>  a = b;</code><code>  // Put previous value of a in b</code><code>  b = temp;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  int a{ 6 };</code><code>  int b{ 8 };</code><code>  swap(a, b);</code><code></code><code>  if (a == 8 &amp;&amp; b == 6)</code><code>    std::cout &lt;&lt; "It works!\n";</code><code>  else</code><code>    std::cout &lt;&lt; "It's broken!\n";</code><code></code><code>  return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #4</p><p>Write a function to print a C-style string character by character. Use a pointer to step through each character of the string and print that character. Stop when you hit the null terminator. Write a <code>main</code> function that tests the function with the string literal “Hello, world!”.</p><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_1'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_1" style="display:none;margin-bottom:1em">Hint: Use the ++ operator to advance the pointer to the next character.<pre class="language-cpp line-numbers"><code>const char* str{ "Hello, world!" };</code><code>std::cout &lt;&lt; *str; // H</code><code>++str;</code><code>std::cout &lt;&lt; *str; // e</code><code>// ...</code></pre></div><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// str will point to the first letter of the C-style string.</code><code>// Note that str points to a const char, so we can not change the values it points to.</code><code>// However, we can point str at something else.  This does not change the value of the argument.</code><code>void printCString(const char* str)</code><code>{</code><code>  // While we haven't encountered a null terminator</code><code>  while (*str != '\0')</code><code>  {</code><code>    // print the current character</code><code>    std::cout &lt;&lt; *str;</code><code></code><code>    // and point str at the next character</code><code>    ++str;</code><code>  }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  printCString("Hello world!");</code><code></code><code>  std::cout &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #5</p><p>What’s wrong with each of these snippets, and how would you fix it?</p><p>a)</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>  int array[]{ 0, 1, 2, 3 };</code><code></code><code>  for (std::size_t count{ 0 }; count &lt;= std::size(array); ++count)</code><code>  {</code><code>    std::cout &lt;&lt; array[count] &lt;&lt; ' ';</code><code>  }</code><code></code><code>  std::cout &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><p>The loop has an off-by-one error, and tries to access the array element with index 4, which does not exist. The conditional in the for loop should use &lt; instead of &lt;=.</p></div><p>b)</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>  int x{ 5 };</code><code>  int y{ 7 };</code><code></code><code>  const int* ptr{ &amp;x };</code><code>  std::cout &lt;&lt; *ptr &lt;&lt; '\n';</code><code>  *ptr = 6;</code><code>  std::cout &lt;&lt; *ptr &lt;&lt; '\n';</code><code>  ptr = &amp;y;</code><code>  std::cout &lt;&lt; *ptr &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><p><code>ptr</code> is a pointer to a <code>const int</code>. You can’t assign the value 6 to it. You can fix this by making <code>ptr</code> non-const.</p></div><p>c)</p><pre class="language-cpp line-numbers"><code>void printArray(int array[])</code><code>{</code><code>  for (int element : array)</code><code>  {</code><code>    std::cout &lt;&lt; element &lt;&lt; ' ';</code><code>  }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  int array[]{ 9, 7, 5, 3, 1 };</code><code></code><code>  printArray(array);</code><code></code><code>  std::cout &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none"><p><code>array</code> decays to a pointer when it is passed to <code>printArray()</code>. Range-based for-loops can’t work with a pointer to an array because the size of the array isn’t known. One solution is to add a length parameter to function <code>printArray()</code>, and use a normal for loop. A better solution is to use <code>std::array</code> instead of built-in fixed arrays.</p></div><p>d)</p><pre class="language-cpp line-numbers"><code>int* allocateArray(const int length)</code><code>{</code><code>  int temp[length]{};</code><code>  return temp;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_7'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_7" style="display:none"><p><code>temp</code> is a fixed array, but <code>length</code> is not a compile-time constant, so we can’t use <code>length</code> to create a C-style array. Variable <code>temp</code> will also go out of scope at the end of the function, the return value will be pointing to something invalid. <code>temp</code> should use dynamic memory allocation or be a <code>std::vector</code>.</p></div><p>e)</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>  double d{ 5.5 };</code><code>  int* ptr{ &amp;d };</code><code>  std::cout &lt;&lt; ptr &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_8'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_8" style="display:none"><p>You can’t make an <code>int</code> pointer point at a non-<code>int</code> variable. <code>ptr</code> should be of type <code>double*</code>.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #6</p><p>Let’s pretend we’re writing a card game.</p><p>a) A deck of cards has 52 unique cards (13 card ranks of 4 suits). Create enumerations for the card ranks (2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Ace) and suits (clubs, diamonds, hearts, spades). Those enumerators will not be used to index arrays.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_9'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_9" style="display:none"><pre class="language-cpp line-numbers"><code>enum class CardSuit</code><code>{</code><code>    club,</code><code>    diamond,</code><code>    heart,</code><code>    spade,</code><code></code><code>    max_suits</code><code>};</code><code></code><code>enum class CardRank</code><code>{</code><code>    rank_2,</code><code>    rank_3,</code><code>    rank_4,</code><code>    rank_5,</code><code>    rank_6,</code><code>    rank_7,</code><code>    rank_8,</code><code>    rank_9,</code><code>    rank_10,</code><code>    rank_jack,</code><code>    rank_queen,</code><code>    rank_king,</code><code>    rank_ace,</code><code></code><code>    max_ranks</code><code>};</code></pre></div><p>b) Each card will be represented by a <code>struct</code> named <code>Card</code> that contains a rank and a suit. Create the <code>struct</code>.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_10'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_10" style="display:none"><pre class="language-cpp line-numbers"><code>struct Card</code><code>{</code><code>  CardRank rank{};</code><code>  CardSuit suit{};</code><code>};</code></pre></div><p>c) Create a <code>printCard()</code> function that takes a <code>const Card</code> reference as a parameter and prints the card rank and suit as a 2-letter code (e.g. the jack of spades would print as JS).</p><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_2'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_2" style="display:none;margin-bottom:1em">Hint: Use a <code>switch</code>-statement.</div><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_11'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_11" style="display:none"><pre class="language-cpp line-numbers"><code>void printCard(const Card&amp; card)</code><code>{</code><code>    switch (card.rank)</code><code>    {</code><code>    case CardRank::rank_2:      std::cout &lt;&lt; '2';   break;</code><code>    case CardRank::rank_3:      std::cout &lt;&lt; '3';   break;</code><code>    case CardRank::rank_4:      std::cout &lt;&lt; '4';   break;</code><code>    case CardRank::rank_5:      std::cout &lt;&lt; '5';   break;</code><code>    case CardRank::rank_6:      std::cout &lt;&lt; '6';   break;</code><code>    case CardRank::rank_7:      std::cout &lt;&lt; '7';   break;</code><code>    case CardRank::rank_8:      std::cout &lt;&lt; '8';   break;</code><code>    case CardRank::rank_9:      std::cout &lt;&lt; '9';   break;</code><code>    case CardRank::rank_10:     std::cout &lt;&lt; 'T';   break;</code><code>    case CardRank::rank_jack:   std::cout &lt;&lt; 'J';   break;</code><code>    case CardRank::rank_queen:  std::cout &lt;&lt; 'Q';   break;</code><code>    case CardRank::rank_king:   std::cout &lt;&lt; 'K';   break;</code><code>    case CardRank::rank_ace:    std::cout &lt;&lt; 'A';   break;</code><code>    default:</code><code>        std::cout &lt;&lt; '?';</code><code>        break;</code><code>    }</code><code></code><code>    switch (card.suit)</code><code>    {</code><code>    case CardSuit::club:       std::cout &lt;&lt; 'C';   break;</code><code>    case CardSuit::diamond:    std::cout &lt;&lt; 'D';   break;</code><code>    case CardSuit::heart:      std::cout &lt;&lt; 'H';   break;</code><code>    case CardSuit::spade:      std::cout &lt;&lt; 'S';   break;</code><code>    default:</code><code>        std::cout &lt;&lt; '?';</code><code>        break;</code><code>    }</code><code>}</code></pre></div><p>d) A deck of cards has 52 cards. Create an array (using <code>std::array</code>) to represent the deck of cards, and initialize it with one of each card. Do this in a function named <code>createDeck</code> and call <code>createDeck</code> from <code>main</code>. <code>createDeck</code> should return the deck to <code>main</code>.</p><p>Hint: Use static_cast if you need to convert an integer into an enumerated type.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_12'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_12" style="display:none"><pre class="language-cpp line-numbers"><code>#include <array></array></code><code></code><code>// We'll need these many more times, create an aliases.</code><code>using Deck = std::array<card, 52="">;</card,></code><code>using Index = Deck::size_type;</code><code></code><code>Deck createDeck()</code><code>{</code><code>  Deck deck{};</code><code></code><code>  // We could initialize each card individually, but that would be a pain.  Let's use a loop.</code><code></code><code>  Index index{ 0 };</code><code></code><code>  for (int suit{ 0 }; suit &lt; static_cast<int>(CardSuit::max_suits); ++suit)</int></code><code>  {</code><code>    for (int rank{ 0 }; rank &lt; static_cast<int>(CardRank::max_ranks); ++rank)</int></code><code>    {</code><code>      deck[index].suit = static_cast<cardsuit>(suit);</cardsuit></code><code>      deck[index].rank = static_cast<cardrank>(rank);</cardrank></code><code>      ++index;</code><code>    }</code><code>  }</code><code></code><code>  return deck;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  auto deck{ createDeck() };</code><code></code><code>  return 0;</code><code>}</code></pre></div><p>e) Write a function named <code>printDeck()</code> that takes the deck as a <code>const</code> reference parameter and prints the cards in the deck. Use a range-based for-loop. When you can <code>printDeck</code> with the deck you generated in the previous task, the output should be</p><pre>2C 3C 4C 5C 6C 7C 8C 9C TC JC QC KC AC 2D 3D 4D 5D 6D 7D 8D 9D TD JD QD KD AD 2H 3H 4H 5H 6H 7H 8H 9H TH JH QH KH AH 2S 3S 4S 5S 6S 7S 8S 9S TS JS QS KS AS
</pre><p>If you used different characters, that’s fine too.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_13'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_13" style="display:none"><pre class="language-cpp line-numbers"><code>void printDeck(const Deck&amp; deck)</code><code>{</code><code>  for (const auto&amp; card : deck)</code><code>  {</code><code>    printCard(card);</code><code>    std::cout &lt;&lt; ' ';</code><code>  }</code><code></code><code>  std::cout &lt;&lt; '\n';</code><code>}</code></pre></div><p>f) Write a function named <code>shuffleDeck</code> to shuffle the deck of cards using <code>std::shuffle</code>. Update your main function to shuffle the deck and print out the shuffled deck.</p><p>Reminder: Only seed your random number generator once.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_14'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_14" style="display:none"><pre class="language-cpp line-numbers"><code>#include <algorithm> // for std::shuffle</algorithm></code><code>#include <ctime> // for std::time</ctime></code><code>#include <random> // for std::mt19937</random></code><code></code><code>// ...</code><code></code><code>void shuffleDeck(Deck&amp; deck)</code><code>{</code><code>  // mt is static so it only gets seeded once.</code><code>  static std::mt19937 mt{ static_cast<std::mt19937::result_type>(std::time(nullptr)) };</std::mt19937::result_type></code><code></code><code>  std::shuffle(deck.begin(), deck.end(), mt);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  auto deck{ createDeck() };</code><code></code><code>  shuffleDeck(deck);</code><code></code><code>  printDeck(deck);</code><code></code><code>  return 0;</code><code>}</code></pre></div><p>g) Write a function named <code>getCardValue()</code> that returns the value of a <code>Card</code> (e.g. a 2 is worth 2, a ten, jack, queen, or king is worth 10. Assume an Ace is worth 11).</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_15'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_15" style="display:none"><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code></code><code>int getCardValue(const Card&amp; card)</code><code>{</code><code>  switch (card.rank)</code><code>  {</code><code>  case CardRank::rank_2:        return 2;</code><code>  case CardRank::rank_3:        return 3;</code><code>  case CardRank::rank_4:        return 4;</code><code>  case CardRank::rank_5:        return 5;</code><code>  case CardRank::rank_6:        return 6;</code><code>  case CardRank::rank_7:        return 7;</code><code>  case CardRank::rank_8:        return 8;</code><code>  case CardRank::rank_9:        return 9;</code><code>  case CardRank::rank_10:       return 10;</code><code>  case CardRank::rank_jack:     return 10;</code><code>  case CardRank::rank_queen:    return 10;</code><code>  case CardRank::rank_king:     return 10;</code><code>  case CardRank::rank_ace:      return 11;</code><code>  default:</code><code>    assert(false &amp;&amp; "should never happen");</code><code>    return 0;</code><code>  }</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #7</p><p>a) Alright, challenge time! Let’s write a simplified version of Blackjack. If you’re not already familiar with Blackjack, the Wikipedia article for <a href="https://en.wikipedia.org/wiki/Blackjack">Blackjack</a> has a summary.</p><p>Here are the rules for our version of Blackjack:</p><ul><li>The dealer gets one card to start (in real life, the dealer gets two, but one is face down so it doesn’t matter at this point).</li><li>The player gets two cards to start.</li><li>The player goes first.</li><li>A player can repeatedly “hit” or “stand”.</li><li>If the player “stands”, their turn is over, and their score is calculated based on the cards they have been dealt.</li><li>If the player “hits”, they get another card and the value of that card is added to their total score.</li><li>An ace normally counts as a 1 or an 11 (whichever is better for the total score). For simplicity, we’ll count it as an 11 here.</li><li>If the player goes over a score of 21, they bust and lose immediately.</li><li>The dealer goes after the player.</li><li>The dealer repeatedly draws until they reach a score of 17 or more, at which point they stand.</li><li>If the dealer goes over a score of 21, they bust and the player wins immediately.</li><li>Otherwise, if the player has a higher score than the dealer, the player wins. Otherwise, the player loses (we’ll consider ties as dealer wins for simplicity).</li></ul><p>In our simplified version of Blackjack, we’re not going to keep track of which specific cards the player and the dealer have been dealt. We’ll only track the sum of the values of the cards they have been dealt for the player and dealer. This keeps things simpler.</p><p>Start with the code you wrote in quiz #6. Create a function named <code>playBlackjack()</code>. This function should:</p><ul><li>Accept a shuffled deck of cards as a parameter.</li><li>Implement Blackjack as defined above (note: you can define other functions to help with this).</li><li>Returns <code>true</code> if the player won, and <code>false</code> if they lost.</li></ul><p>Also write a <code>main()</code> function to play a single game of Blackjack.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_16'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_16" style="display:none"><pre class="language-cpp line-numbers"><code>#include <algorithm> // std::shuffle</algorithm></code><code>#include <array></array></code><code>#include <cassert></cassert></code><code>#include <ctime> // std::time</ctime></code><code>#include <iostream></iostream></code><code>#include <random> // std::mt19937</random></code><code></code><code>enum class CardSuit</code><code>{</code><code>    club,</code><code>    diamond,</code><code>    heart,</code><code>    spade,</code><code></code><code>    max_suits</code><code>};</code><code></code><code>enum class CardRank</code><code>{</code><code>    rank_2,</code><code>    rank_3,</code><code>    rank_4,</code><code>    rank_5,</code><code>    rank_6,</code><code>    rank_7,</code><code>    rank_8,</code><code>    rank_9,</code><code>    rank_10,</code><code>    rank_jack,</code><code>    rank_queen,</code><code>    rank_king,</code><code>    rank_ace,</code><code></code><code>    max_ranks</code><code>};</code><code></code><code>struct Card</code><code>{</code><code>    CardRank rank{};</code><code>    CardSuit suit{};</code><code>};</code><code></code><code>struct Player</code><code>{</code><code>    int score{};</code><code>};</code><code></code><code>using Deck = std::array<card, 52="">;</card,></code><code>using Index = Deck::size_type;</code><code></code><code>// Maximum score before losing.</code><code>constexpr int g_maximumScore{ 21 };</code><code></code><code>// Minimum score that the dealer has to have.</code><code>constexpr int g_minimumDealerScore{ 17 };</code><code></code><code>void printCard(const Card&amp; card)</code><code>{</code><code>    switch (card.rank)</code><code>    {</code><code>    case CardRank::rank_2:      std::cout &lt;&lt; '2';   break;</code><code>    case CardRank::rank_3:      std::cout &lt;&lt; '3';   break;</code><code>    case CardRank::rank_4:      std::cout &lt;&lt; '4';   break;</code><code>    case CardRank::rank_5:      std::cout &lt;&lt; '5';   break;</code><code>    case CardRank::rank_6:      std::cout &lt;&lt; '6';   break;</code><code>    case CardRank::rank_7:      std::cout &lt;&lt; '7';   break;</code><code>    case CardRank::rank_8:      std::cout &lt;&lt; '8';   break;</code><code>    case CardRank::rank_9:      std::cout &lt;&lt; '9';   break;</code><code>    case CardRank::rank_10:     std::cout &lt;&lt; 'T';   break;</code><code>    case CardRank::rank_jack:   std::cout &lt;&lt; 'J';   break;</code><code>    case CardRank::rank_queen:  std::cout &lt;&lt; 'Q';   break;</code><code>    case CardRank::rank_king:   std::cout &lt;&lt; 'K';   break;</code><code>    case CardRank::rank_ace:    std::cout &lt;&lt; 'A';   break;</code><code>    default:</code><code>        std::cout &lt;&lt; '?';</code><code>        break;</code><code>    }</code><code></code><code>    switch (card.suit)</code><code>    {</code><code>    case CardSuit::club:       std::cout &lt;&lt; 'C';   break;</code><code>    case CardSuit::diamond:    std::cout &lt;&lt; 'D';   break;</code><code>    case CardSuit::heart:      std::cout &lt;&lt; 'H';   break;</code><code>    case CardSuit::spade:      std::cout &lt;&lt; 'S';   break;</code><code>    default:</code><code>        std::cout &lt;&lt; '?';</code><code>        break;</code><code>    }</code><code>}</code><code></code><code>int getCardValue(const Card&amp; card)</code><code>{</code><code>    switch (card.rank)</code><code>    {</code><code>    case CardRank::rank_2:        return 2;</code><code>    case CardRank::rank_3:        return 3;</code><code>    case CardRank::rank_4:        return 4;</code><code>    case CardRank::rank_5:        return 5;</code><code>    case CardRank::rank_6:        return 6;</code><code>    case CardRank::rank_7:        return 7;</code><code>    case CardRank::rank_8:        return 8;</code><code>    case CardRank::rank_9:        return 9;</code><code>    case CardRank::rank_10:       return 10;</code><code>    case CardRank::rank_jack:     return 10;</code><code>    case CardRank::rank_queen:    return 10;</code><code>    case CardRank::rank_king:     return 10;</code><code>    case CardRank::rank_ace:      return 11;</code><code>    default:</code><code>        assert(false &amp;&amp; "should never happen");</code><code>        return 0;</code><code>    }</code><code>}</code><code></code><code>void printDeck(const Deck&amp; deck)</code><code>{</code><code>    for (const auto&amp; card : deck)</code><code>    {</code><code>        printCard(card);</code><code>        std::cout &lt;&lt; ' ';</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code>}</code><code></code><code>Deck createDeck()</code><code>{</code><code>    Deck deck{};</code><code></code><code>    // We could initialize each card individually, but that would be a pain.  Let's use a loop.</code><code></code><code>    Index index{ 0 };</code><code></code><code>    for (int suit{ 0 }; suit &lt; static_cast<int>(CardSuit::max_suits); ++suit)</int></code><code>    {</code><code>        for (int rank{ 0 }; rank &lt; static_cast<int>(CardRank::max_ranks); ++rank)</int></code><code>        {</code><code>            deck[index].suit = static_cast<cardsuit>(suit);</cardsuit></code><code>            deck[index].rank = static_cast<cardrank>(rank);</cardrank></code><code>            ++index;</code><code>        }</code><code>    }</code><code></code><code>    return deck;</code><code>}</code><code></code><code>void shuffleDeck(Deck&amp; deck)</code><code>{</code><code>    static std::mt19937 mt{ static_cast<std::mt19937::result_type>(std::time(nullptr)) };</std::mt19937::result_type></code><code></code><code>    std::shuffle(deck.begin(), deck.end(), mt);</code><code>}</code><code></code><code>bool playerWantsHit()</code><code>{</code><code>    while (true)</code><code>    {</code><code>        std::cout &lt;&lt; "(h) to hit, or (s) to stand: ";</code><code></code><code>        char ch{};</code><code>        std::cin &gt;&gt; ch;</code><code></code><code>        switch (ch)</code><code>        {</code><code>        case 'h':</code><code>            return true;</code><code>        case 's':</code><code>            return false;</code><code>        }</code><code>    }</code><code>}</code><code></code><code>// Returns true if the player went bust. False otherwise.</code><code>bool playerTurn(const Deck&amp; deck, Index&amp; nextCardIndex, Player&amp; player)</code><code>{</code><code>    while (true)</code><code>    {</code><code>        if (player.score &gt; g_maximumScore)</code><code>        {</code><code>            // This can happen even before the player had a choice if they drew 2</code><code>            // aces.</code><code>            std::cout &lt;&lt; "You busted!\n";</code><code>            return true;</code><code>        }</code><code>        else</code><code>        {</code><code>            if (playerWantsHit())</code><code>            {</code><code>                int cardValue{ getCardValue(deck.at(nextCardIndex++)) };</code><code>                player.score += cardValue;</code><code>                std::cout &lt;&lt; "You were dealt a " &lt;&lt; cardValue &lt;&lt; " and now have " &lt;&lt; player.score &lt;&lt; '\n';</code><code>            }</code><code>            else</code><code>            {</code><code>                // The player didn't go bust.</code><code>                return false;</code><code>            }</code><code>        }</code><code>    }</code><code>}</code><code></code><code>// Returns true if the dealer went bust. False otherwise.</code><code>bool dealerTurn(const Deck&amp; deck, Index&amp; nextCardIndex, Player&amp; dealer)</code><code>{</code><code>    // Draw cards until we reach the minimum value.</code><code>    while (dealer.score &lt; g_minimumDealerScore)</code><code>    {</code><code>        int cardValue{ getCardValue(deck.at(nextCardIndex++)) };</code><code>        dealer.score += cardValue;</code><code>        std::cout &lt;&lt; "The dealer turned up a " &lt;&lt; cardValue &lt;&lt; " and now has " &lt;&lt; dealer.score &lt;&lt; '\n';</code><code></code><code>    }</code><code></code><code>    // If the dealer's score is too high, they went bust.</code><code>    if (dealer.score &gt; g_maximumScore)</code><code>    {</code><code>        std::cout &lt;&lt; "The dealer busted!\n";</code><code>        return true;</code><code>    }</code><code></code><code>    return false;</code><code>}</code><code></code><code>bool playBlackjack(const Deck&amp; deck)</code><code>{</code><code>    // Index of the card that will be drawn next. This cannot overrun</code><code>    // the array, because a player will lose before all cards are used up.</code><code>    Index nextCardIndex{ 0 };</code><code></code><code>    // Create the dealer and give them 1 card.</code><code>    Player dealer{ getCardValue(deck.at(nextCardIndex++)) };</code><code></code><code>    // The dealer's card is face up, the player can see it.</code><code>    std::cout &lt;&lt; "The dealer is showing: " &lt;&lt; dealer.score &lt;&lt; '\n';</code><code></code><code>    // Create the player and give them 2 cards.</code><code>    Player player{ getCardValue(deck.at(nextCardIndex)) + getCardValue(deck.at(nextCardIndex + 1)) };</code><code>    nextCardIndex += 2;</code><code></code><code>    std::cout &lt;&lt; "You have: " &lt;&lt; player.score &lt;&lt; '\n';</code><code></code><code>    if (playerTurn(deck, nextCardIndex, player))</code><code>    {</code><code>        // The player went bust.</code><code>        return false;</code><code>    }</code><code></code><code>    if (dealerTurn(deck, nextCardIndex, dealer))</code><code>    {</code><code>        // The dealer went bust, the player wins.</code><code>        return true;</code><code>    }</code><code></code><code>    return (player.score &gt; dealer.score);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    auto deck{ createDeck() };</code><code></code><code>    shuffleDeck(deck);</code><code></code><code>    if (playBlackjack(deck))</code><code>    {</code><code>        std::cout &lt;&lt; "You win!\n";</code><code>    }</code><code>    else</code><code>    {</code><code>        std::cout &lt;&lt; "You lose!\n";</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre></div><p>Once you’ve solved the quiz, have a look at some of the most common mistakes:</p><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_3'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_3" style="display:none;margin-bottom:1em">Hint: <strong>Random number generation</strong><p>If your Mersenne twister is non-static, it will be seeded every time <code>shuffleDeck</code> gets called. If <code>shuffleDeck</code> gets called twice in one second, it will produce exactly the same result. Don’t re-seed a random number generator unless you want to reset it.</p><pre class="language-cpp line-numbers"><code>void shuffleDeck(Deck&amp; deck)</code><code>{</code><code>  /* static */ std::mt19937 mt{ static_cast<std::mt19937::result_type>(std::time(nullptr)) }; // non-random</std::mt19937::result_type></code><code>  static std::mt19937 mt{ static_cast<std::mt19937::result_type>(std::time(nullptr)) }; // random</std::mt19937::result_type></code><code> </code><code>  std::shuffle(deck.begin(), deck.end(), mt);</code><code>}</code></pre><p><strong>Magic numbers</strong></p><p>If your code contains the numbers 10, 11, 17, 21, or 52 inside the body of a function, you got magic numbers that should be removed.</p><p>If you used 10 or 11, you probably didn’t use <code>getCardValue</code> to get the value of the card. Also, to check if a card is an ace, don’t check its value, check its rank.<br>If you used 17 or 21, these should be <code>constexpr</code> variables to allow fast changes to the game’s configuration and make your code easier to read.<br>If you used 52, you should use <code>deck.size()</code> instead.</p></div><p>b) Extra credit: Critical thinking time: Describe how you could modify the above program to handle the case where aces can be equal to 1 or 11.</p><p>It’s important to note that we’re only keeping track of the sum of the cards, not which specific cards the user has.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_17'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_17" style="display:none"><p>One way would be to keep track of how many aces the player and the dealer got dealt (In the <code>Player</code> <code>struct</code>, as an integer). If either the player or dealer go over 21 and their ace counter is greater than zero, you can reduce their score by 10 (convert an ace from 11 points to 1 point) and “remove” one from the ace counter. This can be done as many times as needed until the ace counter reaches zero.</p></div><p>c) In actual blackjack, if the player and dealer have the same score (and the player has not gone bust), the result is a tie and neither wins. Describe how you’d modify the above program to account for this.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_18'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_18" style="display:none"><p><code>playBlackjack()</code> currently returns <code>true</code> if the player wins and <code>false</code> otherwise. We’ll need to update this function to return three possibilities: Dealer win, Player win, tie. The best way to do this would be to define an enumeration for these three options, and have the function return the appropriate enumerator:</p><pre class="language-cpp line-numbers"><code>enum class BlackjackResult</code><code>{</code><code>    player_win,</code><code>    dealer_win,</code><code>    tie</code><code>};</code><code></code><code>BlackjackResult playBlackjack(const Deck&amp; deck);</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">12.1 — Function Pointers</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-pointers/">9.6 -- Introduction to pointers</a>, you learned that a pointer is a variable that holds the address of another variable. Function pointers are similar, except that instead of pointing to variables, they point to functions!</p><p>Consider the following function:</p><pre class="language-cpp line-numbers"><code>int foo()</code><code>{</code><code>    return 5;</code><code>}</code></pre><p>Identifier foo is the function’s name. But what type is the function? Functions have their own l-value function type -- in this case, a function type that returns an integer and takes no parameters. Much like variables, functions live at an assigned address in memory.</p><p>When a function is called (via the () operator), execution jumps to the address of the function being called:</p><pre class="language-cpp line-numbers"><code>int foo() // code for foo starts at memory address 0x002717f0</code><code>{</code><code>    return 5;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    foo(); // jump to address 0x002717f0</code><code></code><code>    return 0;</code><code>}</code></pre><p>At some point in your programming career (if you haven’t already), you’ll probably make a simple mistake:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int foo() // code starts at memory address 0x002717f0</code><code>{</code><code>    return 5;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; foo &lt;&lt; '\n'; // we meant to call foo(), but instead we're printing foo itself!</code><code></code><code>    return 0;</code><code>}</code></pre><p>Instead of calling function foo() and printing the return value, we’ve unintentionally sent function foo directly to std::cout. What happens in this case?</p><p>On the author’s machine, this printed:</p><pre>0x002717f0
</pre><p>…but it may print some other value (e.g. 1) on your machine, depending on how your compiler decides to convert the function pointer to another type for printing. If your machine doesn’t print the function’s address, you may be able to force it to do so by converting the function to a void pointer and printing that:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int foo() // code starts at memory address 0x002717f0</code><code>{</code><code>    return 5;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; reinterpret_cast<void*>(foo) &lt;&lt; '\n'; // Tell C++ to interpret function foo as a void pointer</void*></code><code></code><code>    return 0;</code><code>}</code></pre><p>Just like it is possible to declare a non-constant pointer to a normal variable, it’s also possible to declare a non-constant pointer to a function. In the rest of this lesson, we’ll examine these function pointers and their uses. Function pointers are a fairly advanced topic, and the rest of this lesson can be safely skipped or skimmed by those only looking for C++ basics.</p><p><strong>Pointers to functions</strong></p><p>The syntax for creating a non-const function pointer is one of the ugliest things you will ever see in C++:</p><pre class="language-cpp line-numbers"><code>// fcnPtr is a pointer to a function that takes no arguments and returns an integer</code><code>int (*fcnPtr)();</code></pre><p>In the above snippet, fcnPtr is a pointer to a function that has no parameters and returns an integer. fcnPtr can point to any function that matches this type.</p><p>The parentheses around *fcnPtr are necessary for precedence reasons, as <code>int* fcnPtr()</code> would be interpreted as a forward declaration for a function named fcnPtr that takes no parameters and returns a pointer to an integer.</p><p>To make a const function pointer, the const goes after the asterisk:</p><pre class="language-cpp line-numbers"><code>int (*const fcnPtr)();</code></pre><p>If you put the const before the int, then that would indicate the function being pointed to would return a const int.</p><p><strong>Assigning a function to a function pointer</strong></p><p>Function pointers can be initialized with a function (and non-const function pointers can be assigned a function). In the above example, we have used foo directly, and it has been converted to a function pointer. Like with pointers to variables, we can also use &amp;foo to get a function pointer to foo.</p><pre class="language-cpp line-numbers"><code>int foo()</code><code>{</code><code>    return 5;</code><code>}</code><code></code><code>int goo()</code><code>{</code><code>    return 6;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int (*fcnPtr)(){ &amp;foo }; // fcnPtr points to function foo</code><code>    fcnPtr = &amp;goo; // fcnPtr now points to function goo</code><code></code><code>    return 0;</code><code>}</code></pre><p>One common mistake is to do this:</p><pre class="language-cpp line-numbers"><code>fcnPtr = goo();</code></pre><p>This tries to assign the return value from a call to function goo() (which has type <code>int</code>) to fcnPtr (which is expecting a value of type <code>int(*)()</code>), which isn’t what we want. We want fcnPtr to be assigned the address of function goo, not the return value from function goo(). So no parentheses are needed.</p><p>Note that the type (parameters and return type) of the function pointer must match the type of the function. Here are some examples of this:</p><pre class="language-cpp line-numbers"><code>// function prototypes</code><code>int foo();</code><code>double goo();</code><code>int hoo(int x);</code><code></code><code>// function pointer assignments</code><code>int (*fcnPtr1)(){ &amp;foo }; // okay</code><code>int (*fcnPtr2)(){ &amp;goo }; // wrong -- return types don't match!</code><code>double (*fcnPtr4)(){ &amp;goo }; // okay</code><code>fcnPtr1 = &amp;hoo; // wrong -- fcnPtr1 has no parameters, but hoo() does</code><code>int (*fcnPtr3)(int){ &amp;hoo }; // okay</code></pre><p>Unlike fundamental types, C++ <em>will</em> implicitly convert a function into a function pointer if needed (so you don’t need to use the address-of operator (&amp;) to get the function’s address). However, it will not implicitly convert function pointers to void pointers, or vice-versa.</p><p>Function pointers can also be initialized or assigned the value nullptr:</p><pre class="language-cpp line-numbers"><code>int (*fcnptr)() { nullptr }; // okay</code></pre><p><strong>Calling a function using a function pointer</strong></p><p>The other primary thing you can do with a function pointer is use it to actually call the function. There are two ways to do this. The first is via explicit dereference:</p><pre class="language-cpp line-numbers"><code>int foo(int x)</code><code>{</code><code>    return x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int (*fcnPtr)(int){ &amp;foo }; // Initialize fcnPtr with function foo</code><code>    (*fcnPtr)(5); // call function foo(5) through fcnPtr.</code><code></code><code>    return 0;</code><code>}</code></pre><p>The second way is via implicit dereference:</p><pre class="language-cpp line-numbers"><code>int foo(int x)</code><code>{</code><code>    return x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int (*fcnPtr)(int){ &amp;foo }; // Initialize fcnPtr with function foo</code><code>    fcnPtr(5); // call function foo(5) through fcnPtr.</code><code></code><code>    return 0;</code><code>}</code></pre><p>As you can see, the implicit dereference method looks just like a normal function call -- which is what you’d expect, since normal function names are pointers to functions anyway! However, some older compilers do not support the implicit dereference method, but all modern compilers should.</p><p>One interesting note: Default parameters won’t work for functions called through function pointers. Default parameters are resolved at compile-time (that is, if you don’t supply an argument for a defaulted parameter, the compiler substitutes one in for you when the code is compiled). However, function pointers are resolved at run-time. Consequently, default parameters can not be resolved when making a function call with a function pointer. You’ll explicitly have to pass in values for any defaulted parameters in this case.</p><p>Also note that because function pointers can be set to nullptr, it’s a good idea to assert or conditionally test whether your function pointer is a null pointer before calling it. Just like with normal pointers, dereferencing a null function pointer lead to undefined behavior.</p><pre class="language-cpp line-numbers"><code>int foo(int x)</code><code>{</code><code>    return x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int (*fcnPtr)(int){ &amp;foo }; // Initialize fcnPtr with function foo</code><code>    if (fcnPtr) // make sure fcnPtr isn't a null pointer    </code><code>        fcnPtr(5); // otherwise this will lead to undefined behavior</code><code></code><code>    return 0;</code><code>}</code></pre><p><strong>Passing functions as arguments to other functions</strong></p><p>One of the most useful things to do with function pointers is pass a function as an argument to another function. Functions used as arguments to another function are sometimes called <strong>callback functions</strong>.</p><p>Consider a case where you are writing a function to perform a task (such as sorting an array), but you want the user to be able to define how a particular part of that task will be performed (such as whether the array is sorted in ascending or descending order). Let’s take a closer look at this problem as applied specifically to sorting, as an example that can be generalized to other similar problems.</p><p>Many comparison-based sorting algorithms work on a similar concept: the sorting algorithm iterates through a list of numbers, does comparisons on pairs of numbers, and reorders the numbers based on the results of those comparisons. Consequently, by varying the comparison, we can change the way the algorithm sorts without affecting the rest of the sorting code.</p><p>Here is our selection sort routine from a previous lesson:</p><pre class="language-cpp line-numbers"><code>#include <utility> // for std::swap</utility></code><code></code><code>void SelectionSort(int* array, int size)</code><code>{</code><code>    // Step through each element of the array</code><code>    for (int startIndex{ 0 }; startIndex &lt; (size - 1); ++startIndex)</code><code>    {</code><code>        // smallestIndex is the index of the smallest element we've encountered so far.</code><code>        int smallestIndex{ startIndex };</code><code> </code><code>        // Look for smallest element remaining in the array (starting at startIndex+1)</code><code>        for (int currentIndex{ startIndex + 1 }; currentIndex &lt; size; ++currentIndex)</code><code>        {</code><code>            // If the current element is smaller than our previously found smallest</code><code>            if (array[smallestIndex] &gt; array[currentIndex]) // COMPARISON DONE HERE</code><code>            {</code><code>                // This is the new smallest number for this iteration</code><code>                smallestIndex = currentIndex;</code><code>            }</code><code>        }</code><code> </code><code>        // Swap our start element with our smallest element</code><code>        std::swap(array[startIndex], array[smallestIndex]);</code><code>    }</code><code>}</code></pre><p>Let’s replace that comparison with a function to do the comparison. Because our comparison function is going to compare two integers and return a boolean value to indicate whether the elements should be swapped, it will look something like this:</p><pre class="language-cpp line-numbers"><code>bool ascending(int x, int y)</code><code>{</code><code>    return x &gt; y; // swap if the first element is greater than the second</code><code>}</code></pre><p>And here’s our selection sort routine using the ascending() function to do the comparison:</p><pre class="language-cpp line-numbers"><code>#include <utility> // for std::swap</utility></code><code></code><code>void SelectionSort(int* array, int size)</code><code>{</code><code>    // Step through each element of the array</code><code>    for (int startIndex{ 0 }; startIndex &lt; (size - 1); ++startIndex)</code><code>    {</code><code>        // smallestIndex is the index of the smallest element we've encountered so far.</code><code>        int smallestIndex{ startIndex };</code><code> </code><code>        // Look for smallest element remaining in the array (starting at startIndex+1)</code><code>        for (int currentIndex{ startIndex + 1 }; currentIndex &lt; size; ++currentIndex)</code><code>        {</code><code>            // If the current element is smaller than our previously found smallest</code><code>            if (ascending(array[smallestIndex], array[currentIndex])) // COMPARISON DONE HERE</code><code>            {</code><code>                // This is the new smallest number for this iteration</code><code>                smallestIndex = currentIndex;</code><code>            }</code><code>        }</code><code> </code><code>        // Swap our start element with our smallest element</code><code>        std::swap(array[startIndex], array[smallestIndex]);</code><code>    }</code><code>}</code></pre><p>Now, in order to let the caller decide how the sorting will be done, instead of using our own hard-coded comparison function, we’ll allow the caller to provide their own sorting function! This is done via a function pointer.</p><p>Because the caller’s comparison function is going to compare two integers and return a boolean value, a pointer to such a function would look something like this:</p><pre class="language-cpp line-numbers"><code>bool (*comparisonFcn)(int, int);</code></pre><p>So, we’ll allow the caller to pass our sort routine a pointer to their desired comparison function as the third parameter, and then we’ll use the caller’s function to do the comparison.</p><p>Here’s a full example of a selection sort that uses a function pointer parameter to do a user-defined comparison, along with an example of how to call it:</p><pre class="language-cpp line-numbers"><code>#include <utility> // for std::swap</utility></code><code>#include <iostream></iostream></code><code></code><code>// Note our user-defined comparison is the third parameter</code><code>void selectionSort(int* array, int size, bool (*comparisonFcn)(int, int))</code><code>{</code><code>    // Step through each element of the array</code><code>    for (int startIndex{ 0 }; startIndex &lt; (size - 1); ++startIndex)</code><code>    {</code><code>        // bestIndex is the index of the smallest/largest element we've encountered so far.</code><code>        int bestIndex{ startIndex };</code><code> </code><code>        // Look for smallest/largest element remaining in the array (starting at startIndex+1)</code><code>        for (int currentIndex{ startIndex + 1 }; currentIndex &lt; size; ++currentIndex)</code><code>        {</code><code>            // If the current element is smaller/larger than our previously found smallest</code><code>            if (comparisonFcn(array[bestIndex], array[currentIndex])) // COMPARISON DONE HERE</code><code>            {</code><code>                // This is the new smallest/largest number for this iteration</code><code>                bestIndex = currentIndex;</code><code>            }</code><code>        }</code><code> </code><code>        // Swap our start element with our smallest/largest element</code><code>        std::swap(array[startIndex], array[bestIndex]);</code><code>    }</code><code>}</code><code></code><code>// Here is a comparison function that sorts in ascending order</code><code>// (Note: it's exactly the same as the previous ascending() function)</code><code>bool ascending(int x, int y)</code><code>{</code><code>    return x &gt; y; // swap if the first element is greater than the second</code><code>}</code><code></code><code>// Here is a comparison function that sorts in descending order</code><code>bool descending(int x, int y)</code><code>{</code><code>    return x &lt; y; // swap if the second element is greater than the first</code><code>}</code><code></code><code>// This function prints out the values in the array</code><code>void printArray(int* array, int size)</code><code>{</code><code>    for (int index{ 0 }; index &lt; size; ++index)</code><code>    {</code><code>        std::cout &lt;&lt; array[index] &lt;&lt; ' ';</code><code>    }</code><code>    </code><code>    std::cout &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int array[9]{ 3, 7, 9, 5, 6, 1, 8, 2, 4 };</code><code></code><code>    // Sort the array in descending order using the descending() function</code><code>    selectionSort(array, 9, descending);</code><code>    printArray(array, 9);</code><code></code><code>    // Sort the array in ascending order using the ascending() function</code><code>    selectionSort(array, 9, ascending);</code><code>    printArray(array, 9);</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program produces the result:</p><pre>9 8 7 6 5 4 3 2 1
1 2 3 4 5 6 7 8 9
</pre><p>Is that cool or what? We’ve given the caller the ability to control how our selection sort does its job.</p><p>The caller can even define their own “strange” comparison functions:</p><pre class="language-cpp line-numbers"><code>bool evensFirst(int x, int y)</code><code>{</code><code>	// if x is even and y is odd, x goes first (no swap needed)</code><code>	if ((x % 2 == 0) &amp;&amp; !(y % 2 == 0))</code><code>		return false;</code><code> </code><code>	// if x is odd and y is even, y goes first (swap needed)</code><code>	if (!(x % 2 == 0) &amp;&amp; (y % 2 == 0))</code><code>		return true;</code><code></code><code>        // otherwise sort in ascending order</code><code>	return ascending(x, y);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int array[9]{ 3, 7, 9, 5, 6, 1, 8, 2, 4 };</code><code></code><code>    selectionSort(array, 9, evensFirst);</code><code>    printArray(array, 9);</code><code></code><code>    return 0;</code><code>}</code></pre><p>The above snippet produces the following result:</p><pre>2 4 6 8 1 3 5 7 9
</pre><p>As you can see, using a function pointer in this context provides a nice way to allow a caller to “hook” their own functionality into something you’ve previously written and tested, which helps facilitate code reuse! Previously, if you wanted to sort one array in descending order and another in ascending order, you’d need multiple versions of the sort routine. Now you can have one version that can sort any way the caller desires!</p><p>Note: If a function parameter is of a function type, it will be converted to a pointer to the function type. This means</p><pre class="language-cpp line-numbers"><code>void selectionSort(int* array, int size, bool (*comparisonFcn)(int, int))</code></pre><p>can be equivalently written as:</p><pre class="language-cpp line-numbers"><code>void selectionSort(int* array, int size, bool comparisonFcn(int, int))</code></pre><p>This only works for function parameters, not stand-alone function pointers, and so is of somewhat limited use.</p><p><strong>Providing default functions</strong></p><p>If you’re going to allow the caller to pass in a function as a parameter, it can often be useful to provide some standard functions for the caller to use for their convenience. For example, in the selection sort example above, providing the ascending() and descending() function along with the selectionSort() function would make the caller’s life easier, as they wouldn’t have to rewrite ascending() or descending() every time they want to use them.</p><p>You can even set one of these as a default parameter:</p><pre class="language-cpp line-numbers"><code>// Default the sort to ascending sort</code><code>void selectionSort(int* array, int size, bool (*comparisonFcn)(int, int) = ascending);</code></pre><p>In this case, as long as the user calls selectionSort normally (not through a function pointer), the comparisonFcn parameter will default to ascending. You will need to make sure that the <code>ascending</code> function is declared prior to this point, otherwise the compiler will complain it doesn’t know what <code>ascending</code> is.</p><p><strong>Making function pointers prettier with type aliases</strong></p><p>Let’s face it -- the syntax for pointers to functions is ugly. However, type aliases can be used to make pointers to functions look more like regular variables:</p><pre class="language-cpp line-numbers"><code>using ValidateFunction = bool(*)(int, int);</code></pre><p>This defines a type alias called “ValidateFunction” that is a pointer to a function that takes two ints and returns a bool.</p><p>Now instead of doing this:</p><pre class="language-cpp line-numbers"><code>bool validate(int x, int y, bool (*fcnPtr)(int, int)); // ugly</code></pre><p>You can do this:</p><pre class="language-cpp line-numbers"><code>bool validate(int x, int y, ValidateFunction pfcn) // clean</code></pre><p><strong>Using std::function</strong></p><p>An alternate method of defining and storing function pointers is to use std::function, which is part of the standard library &lt;functional&gt; header. To define a function pointer using this method, declare a std::function object like so:</p><pre class="language-cpp line-numbers"><code>#include <functional></functional></code><code>bool validate(int x, int y, std::function<bool(int, int)=""> fcn); // std::function method that returns a bool and takes two int parameters</bool(int,></code></pre><p>As you see, both the return type and parameters go inside angled brackets, with the parameters inside parentheses. If there are no parameters, the parentheses can be left empty.</p><p>Updating our earlier example with std::function:</p><pre class="language-cpp line-numbers"><code>#include <functional></functional></code><code>#include <iostream></iostream></code><code></code><code>int foo()</code><code>{</code><code>    return 5;</code><code>}</code><code></code><code>int goo()</code><code>{</code><code>    return 6;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::function<int()> fcnPtr{ &amp;foo }; // declare function pointer that returns an int and takes no parameters</int()></code><code>    fcnPtr = &amp;goo; // fcnPtr now points to function goo</code><code>    std::cout &lt;&lt; fcnPtr() &lt;&lt; '\n'; // call the function just like normal</code><code></code><code>    return 0;</code><code>}</code></pre><p>Type aliasing std::function can be helpful for readability:</p><pre class="language-cpp line-numbers"><code>using ValidateFunctionRaw = bool(*)(int, int); // type alias to raw function pointer</code><code>using ValidateFunction = std::function<bool(int, int)="">; // type alias to std::function</bool(int,></code></pre><p>Also note that std::function only allows calling the function via implicit dereference (e.g. <code>fcnPtr()</code>), not explicit dereference (e.g. <code>(*fcnPtr)()</code>).</p><p>As of C++17, CTAD can be used to deduce the template parameters of a std::function from an initializer. In the example above, we could have written <code>std::function fcnPtr{ &amp;foo };</code> instead of <code>std::function<int()> fcnPtr{ &amp;foo };</int()></code> and let the compiler figure out the template type. However, CTAD doesn’t work for the type alias definitions since no initializer is provided.</p><p><strong>Type inference for function pointers</strong></p><p>Much like the <em>auto</em> keyword can be used to infer the type of normal variables, the <em>auto</em> keyword can also infer the type of a function pointer.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int foo(int x)</code><code>{</code><code>	return x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	auto fcnPtr{ &amp;foo };</code><code>	std::cout &lt;&lt; fcnPtr(5) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This works exactly like you’d expect, and the syntax is very clean. The downside is, of course, that all of the details about the function’s parameters types and return type are hidden, so it’s easier to make a mistake when making a call with the function, or using its return value.</p><p><strong>Conclusion</strong></p><p>Function pointers are useful primarily when you want to store functions in an array (or other structure), or when you need to pass a function to another function. Because the native syntax to declare function pointers is ugly and error prone, we recommend using std::function. In places where a function pointer type is only used once (e.g. a single parameter or return value), std::function can be used directly. In places where a function pointer type is used multiple times, a type alias to a std::function is a better choice (to prevent repeating yourself).</p><p><strong>Quiz time!</strong></p><ol start="1"><li>In this quiz, we’re going to write a version of our basic calculator using function pointers.</li></ol><p>1a) Create a short program asking the user for two integer inputs and a mathematical operation (‘+’, ‘-‘, ‘*’, ‘/’). Ensure the user enters a valid operation.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int getInteger()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code>    return x;</code><code>}</code><code></code><code>char getOperation()</code><code>{</code><code>    char op{};</code><code></code><code>    do</code><code>    {   </code><code>        std::cout &lt;&lt; "Enter an operation ('+', '-', '*', '/'): ";</code><code>        std::cin &gt;&gt; op;</code><code>    }</code><code>    while (op!='+' &amp;&amp; op!='-' &amp;&amp; op!='*' &amp;&amp; op!='/');</code><code></code><code>    return op;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x{ getInteger() };</code><code>    char op{ getOperation() };</code><code>    int y{ getInteger() };</code><code></code><code>    return 0;</code><code>}</code></pre></div><p>1b) Write functions named add(), subtract(), multiply(), and divide(). These should take two integer parameters and return an integer.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code><code></code><code>int subtract(int x, int y)</code><code>{</code><code>    return x - y;</code><code>}</code><code></code><code>int multiply(int x, int y)</code><code>{</code><code>    return x * y;</code><code>}</code><code></code><code>int divide(int x, int y)</code><code>{</code><code>    return x / y;</code><code>}</code></pre></div><p>1c) Create a type alias named ArithmeticFunction for a pointer to a function that takes two integer parameters and returns an integer. Use std::function, and include the appropriate header.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><pre class="language-cpp line-numbers"><code>#include <functional></functional></code><code>using ArithmeticFunction = std::function<int(int, int)="">;</int(int,></code></pre></div><p>1d) Write a function named getArithmeticFunction() that takes an operator character and returns the appropriate function as a function pointer.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><pre class="language-cpp line-numbers"><code>ArithmeticFunction getArithmeticFunction(char op)</code><code>{</code><code>    switch (op)</code><code>    {</code><code>    case '+': return &amp;add;</code><code>    case '-': return &amp;subtract;</code><code>    case '*': return &amp;multiply;</code><code>    case '/': return ÷</code><code>    }</code><code></code><code>    return nullptr;</code><code>}</code></pre></div><p>1e) Modify your main() function to call getArithmeticFunction(). Call the return value from that function with your inputs and print the result.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int x{ getInteger() };</code><code>    char op{ getOperation() };</code><code>    int y{ getInteger() };</code><code></code><code>    ArithmeticFunction fcn{ getArithmeticFunction(op) };</code><code>    if (fcn)</code><code>        std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; op &lt;&lt; ' ' &lt;&lt; y &lt;&lt; " = " &lt;&lt; fcn(x, y) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre></div><p>Here’s the full program:</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <functional></functional></code><code></code><code>int getInteger()</code><code>{</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    int x{};</code><code>    std::cin &gt;&gt; x;</code><code>    return x;</code><code>}</code><code></code><code>char getOperation()</code><code>{</code><code>    char op{};</code><code></code><code>    do</code><code>    {   </code><code>        std::cout &lt;&lt; "Enter an operation ('+', '-', '*', '/'): ";</code><code>        std::cin &gt;&gt; op;</code><code>    }</code><code>    while (op!='+' &amp;&amp; op!='-' &amp;&amp; op!='*' &amp;&amp; op!='/');</code><code></code><code>    return op;</code><code>}</code><code></code><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code><code></code><code>int subtract(int x, int y)</code><code>{</code><code>    return x - y;</code><code>}</code><code></code><code>int multiply(int x, int y)</code><code>{</code><code>    return x * y;</code><code>}</code><code></code><code>int divide(int x, int y)</code><code>{</code><code>    return x / y;</code><code>}</code><code></code><code>using ArithmeticFunction = std::function<int(int, int)="">;</int(int,></code><code></code><code>ArithmeticFunction getArithmeticFunction(char op)</code><code>{</code><code>    switch (op)</code><code>    {</code><code>    case '+': return &amp;add;</code><code>    case '-': return &amp;subtract;</code><code>    case '*': return &amp;multiply;</code><code>    case '/': return ÷</code><code>    }</code><code></code><code>    return nullptr;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x{ getInteger() };</code><code>    char op{ getOperation() };</code><code>    int y{ getInteger() };</code><code></code><code>    ArithmeticFunction fcn{ getArithmeticFunction(op) };</code><code>    if (fcn)</code><code>        std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; op &lt;&lt; ' ' &lt;&lt; y &lt;&lt; " = " &lt;&lt; fcn(x, y) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">12.2 — The stack and the heap</h1></header><div class="entry-content" itemprop="articleBody"><p>The memory that a program uses is typically divided into a few different areas, called segments:</p><ul><li>The code segment (also called a text segment), where the compiled program sits in memory. The code segment is typically read-only.</li><li>The bss segment (also called the uninitialized data segment), where zero-initialized global and static variables are stored.</li><li>The data segment (also called the initialized data segment), where initialized global and static variables are stored.</li><li>The heap, where dynamically allocated variables are allocated from.</li><li>The call stack, where function parameters, local variables, and other function-related information are stored.</li></ul><p>For this lesson, we’ll focus primarily on the heap and the stack, as that is where most of the interesting stuff takes place.</p><p><strong>The heap segment</strong></p><p>The heap segment (also known as the “free store”) keeps track of memory used for dynamic memory allocation. We talked about the heap a bit already in lesson <a href="https://www.learncpp.com/cpp-tutorial/dynamic-memory-allocation-with-new-and-delete/">11.11 -- Dynamic memory allocation with new and delete</a>, so this will be a recap.</p><p>In C++, when you use the new operator to allocate memory, this memory is allocated in the application’s heap segment.</p><pre class="language-cpp line-numbers"><code>int* ptr { new int }; // ptr is assigned 4 bytes in the heap</code><code>int* array { new int[10] }; // array is assigned 40 bytes in the heap</code></pre><p>The address of this memory is passed back by operator new, and can then be stored in a pointer. You do not have to worry about the mechanics behind the process of how free memory is located and allocated to the user. However, it is worth knowing that sequential memory requests may not result in sequential memory addresses being allocated!</p><pre class="language-cpp line-numbers"><code>int* ptr1 { new int };</code><code>int* ptr2 { new int };</code><code>// ptr1 and ptr2 may not have sequential addresses</code></pre><p>When a dynamically allocated variable is deleted, the memory is “returned” to the heap and can then be reassigned as future allocation requests are received. Remember that deleting a pointer does not delete the variable, it just returns the memory at the associated address back to the operating system.</p><p>The heap has advantages and disadvantages:</p><ul><li>Allocating memory on the heap is comparatively slow.</li><li>Allocated memory stays allocated until it is specifically deallocated (beware memory leaks) or the application ends (at which point the OS should clean it up).</li><li>Dynamically allocated memory must be accessed through a pointer. Dereferencing a pointer is slower than accessing a variable directly.</li><li>Because the heap is a big pool of memory, large arrays, structures, or classes can be allocated here.</li></ul><p><strong>The call stack</strong></p><p>The <strong>call stack</strong> (usually referred to as “the stack”) has a much more interesting role to play. The call stack keeps track of all the active functions (those that have been called but have not yet terminated) from the start of the program to the current point of execution, and handles allocation of all function parameters and local variables.</p><p>The call stack is implemented as a stack data structure. So before we can talk about how the call stack works, we need to understand what a stack data structure is.</p><p><strong>The stack data structure</strong></p><p>A <strong>data structure</strong> is a programming mechanism for organizing data so that it can be used efficiently. You’ve already seen several types of data structures, such as arrays and structs. Both of these data structures provide mechanisms for storing data and accessing that data in an efficient way. There are many additional data structures that are commonly used in programming, quite a few of which are implemented in the standard library, and a stack is one of those.</p><p>Consider a stack of plates in a cafeteria. Because each plate is heavy and they are stacked, you can really only do one of three things:</p><ol start="1"><li>Look at the surface of the top plate</li><li>Take the top plate off the stack (exposing the one underneath, if it exists)</li><li>Put a new plate on top of the stack (hiding the one underneath, if it exists)</li></ol><p>In computer programming, a stack is a container data structure that holds multiple variables (much like an array). However, whereas an array lets you access and modify elements in any order you wish (called <strong>random access</strong>), a stack is more limited. The operations that can be performed on a stack correspond to the three things mentioned above:</p><ol start="1"><li>Look at the top item on the stack (usually done via a function called top(), but sometimes called peek())</li><li>Take the top item off of the stack (done via a function called pop())</li><li>Put a new item on top of the stack (done via a function called push())</li></ol><p>A stack is a last-in, first-out (LIFO) structure. The last item pushed onto the stack will be the first item popped off. If you put a new plate on top of the stack, the first plate removed from the stack will be the plate you just pushed on last. Last on, first off. As items are pushed onto a stack, the stack grows larger -- as items are popped off, the stack grows smaller.</p><p>For example, here’s a short sequence showing how pushing and popping on a stack works:</p><pre>Stack: empty
Push 1
Stack: 1
Push 2
Stack: 1 2
Push 3
Stack: 1 2 3
Pop
Stack: 1 2
Pop
Stack: 1
</pre><p>The plate analogy is a pretty good analogy as to how the call stack works, but we can make a better analogy. Consider a bunch of mailboxes, all stacked on top of each other. Each mailbox can only hold one item, and all mailboxes start out empty. Furthermore, each mailbox is nailed to the mailbox below it, so the number of mailboxes can not be changed. If we can’t change the number of mailboxes, how do we get a stack-like behavior?</p><p>First, we use a marker (like a post-it note) to keep track of where the bottom-most empty mailbox is. In the beginning, this will be the lowest mailbox (on the bottom of the stack). When we push an item onto our mailbox stack, we put it in the mailbox that is marked (which is the first empty mailbox), and move the marker up one mailbox. When we pop an item off the stack, we move the marker down one mailbox (so it’s pointed at the top non-empty mailbox) and remove the item from that mailbox. Anything below the marker is considered “on the stack”. Anything at the marker or above the marker is not on the stack.</p><p><strong>The call stack segment</strong></p><p>The call stack segment holds the memory used for the call stack. When the application starts, the main() function is pushed on the call stack by the operating system. Then the program begins executing.</p><p>When a function call is encountered, the function is pushed onto the call stack. When the current function ends, that function is popped off the call stack. Thus, by looking at the functions pushed on the call stack, we can see all of the functions that were called to get to the current point of execution.</p><p>Our mailbox analogy above is fairly analogous to how the call stack works. The stack itself is a fixed-size chunk of memory addresses. The mailboxes are memory addresses, and the “items” we’re pushing and popping on the stack are called <strong>stack frames</strong>. A stack frame keeps track of all of the data associated with one function call. We’ll talk more about stack frames in a bit. The “marker” is a register (a small piece of memory in the CPU) known as the stack pointer (sometimes abbreviated “SP”). The stack pointer keeps track of where the top of the call stack currently is.</p><p>We can make one further optimization: When we pop an item off the call stack, we only have to move the stack pointer down -- we don’t have to clean up or zero the memory used by the popped stack frame (the equivalent of emptying the mailbox). This memory is no longer considered to be “on the stack” (the stack pointer will be at or below this address), so it won’t be accessed. If we later push a new stack frame to this same memory, it will overwrite the old value we never cleaned up.</p><p><strong>The call stack in action</strong></p><p>Let’s examine in more detail how the call stack works. Here is the sequence of steps that takes place when a function is called:</p><ol start="1"><li>The program encounters a function call.</li><li>A stack frame is constructed and pushed on the stack. The stack frame consists of:</li></ol><ul><li>The address of the instruction beyond the function call (called the <strong>return address</strong>). This is how the CPU remembers where to return to after the called function exits.</li><li>All function arguments.</li><li>Memory for any local variables</li><li>Saved copies of any registers modified by the function that need to be restored when the function returns</li></ul><ol start="3"><li>The CPU jumps to the function’s start point.</li><li>The instructions inside of the function begin executing.</li></ol><p>When the function terminates, the following steps happen:</p><ol><li>Registers are restored from the call stack</li><li>The stack frame is popped off the stack. This frees the memory for all local variables and arguments.</li><li>The return value is handled.</li><li>The CPU resumes execution at the return address.</li></ol><p>Return values can be handled in a number of different ways, depending on the computer’s architecture. Some architectures include the return value as part of the stack frame. Others use CPU registers.</p><p>Typically, it is not important to know all the details about how the call stack works. However, understanding that functions are effectively pushed on the stack when they are called and popped off when they return gives you the fundamentals needed to understand recursion, as well as some other concepts that are useful when debugging.</p><p>A technical note: on some architectures, the call stack grows away from memory address 0. On others, it grows towards memory address 0. As a consequence, newly pushed stack frames may have a higher or a lower memory address than the previous ones.</p><p><strong>A quick and dirty call stack example</strong></p><p>Consider the following simple application:</p><pre class="language-cpp line-numbers"><code>int foo(int x)</code><code>{</code><code>    // b</code><code>    return x;</code><code>} // foo is popped off the call stack here</code><code></code><code>int main()</code><code>{</code><code>    // a</code><code>    foo(5); // foo is pushed on the call stack here</code><code>    // c</code><code></code><code>    return 0;</code><code>}</code></pre><p>The call stack looks like the following at the labeled points:</p><p>a:</p><pre>main()
</pre><p>b:</p><pre>foo() (including parameter x)
main()
</pre><p>c:</p><pre>main()
</pre><p><strong>Stack overflow</strong></p><p>The stack has a limited size, and consequently can only hold a limited amount of information. On Visual Studio for Windows, the default stack size is 1MB. With g++/Clang for Unix variants, it can be as large as 8MB. If the program tries to put too much information on the stack, stack overflow will result. <strong>Stack overflow</strong> happens when all the memory in the stack has been allocated -- in that case, further allocations begin overflowing into other sections of memory.</p><p>Stack overflow is generally the result of allocating too many variables on the stack, and/or making too many nested function calls (where function A calls function B calls function C calls function D etc…) On modern operating systems, overflowing the stack will generally cause your OS to issue an access violation and terminate the program.</p><p>Here is an example program that will likely cause a stack overflow. You can run it on your system and watch it crash:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int stack[10000000];</code><code>    std::cout &lt;&lt; "hi" &lt;&lt; stack[0]; // we'll use stack[0] here so the compiler won't optimize the array away</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program tries to allocate a huge (likely 40MB) array on the stack. Because the stack is not large enough to handle this array, the array allocation overflows into portions of memory the program is not allowed to use.</p><p>On Windows (Visual Studio), this program produces the result:</p><pre>HelloWorld.exe (process 15916) exited with code -1073741571.
</pre><p>-1073741571 is c0000005 in hex, which is the Windows OS code for an access violation. Note that “hi” is never printed because the program is terminated prior to that point.</p><p>Here’s another program that will cause a stack overflow for a different reason:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void foo()</code><code>{</code><code>    foo();</code><code>    std::cout &lt;&lt; "hi";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    foo();</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above program, a stack frame is pushed on the stack every time function foo() is called. Since foo() calls itself infinitely, eventually the stack will run out of memory and cause an overflow.</p><p>The stack has advantages and disadvantages:</p><ul><li>Allocating memory on the stack is comparatively fast.</li><li>Memory allocated on the stack stays in scope as long as it is on the stack. It is destroyed when it is popped off the stack.</li><li>All memory allocated on the stack is known at compile time. Consequently, this memory can be accessed directly through a variable.</li><li>Because the stack is relatively small, it is generally not a good idea to do anything that eats up lots of stack space. This includes passing by value or creating local variables of large arrays or other memory-intensive structures.</li></ul><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p><a href="https://www.learncpp.com/cpp-tutorial/introduction-to-objects-and-variables/#comment-560618">This comment</a> has some additional (simplified) information about how variables on the stack are laid out and receive actual memory addresses at runtime.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">12.3 — std::vector capacity and stack behavior</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/an-introduction-to-stdvector/">11.17 -- An introduction to std::vector</a>, we introduced std::vector and talked about how std::vector can be used as a dynamic array that both remembers its length and can be dynamically resized as required.</p><p>Although this is the most useful and commonly used part of std::vector, std::vector has some additional attributes and capabilities that make it useful in some other capacities as well.</p><p><strong>Length vs capacity</strong></p><p>Consider the following example:</p><pre class="language-cpp line-numbers"><code>int* array{ new int[10] { 1, 2, 3, 4, 5 } };</code></pre><p>We would say that this array has a length of 10, even though we’re only using 5 of the elements that we allocated.</p><p>However, what if we only wanted to iterate over the elements we’ve initialized, reserving the unused ones for future expansion? In that case, we’d need to separately track how many elements were “used” from how many elements were allocated. Unlike a built-in array or a std::array, which only remembers its length, std::vector contains two separate attributes: length and capacity. In the context of a std::vector, <strong>length</strong> is how many elements are being used in the array, whereas <strong>capacity</strong> is how many elements were allocated in memory.</p><p>Taking a look at an example from the previous lesson on std::vector:</p><pre class="language-cpp line-numbers"><code>#include <vector></vector></code><code>#include <iostream></iostream></code><code> </code><code>int main()</code><code>{</code><code>    std::vector array { 0, 1, 2 };</code><code>    array.resize(5); // set length to 5</code><code> </code><code>    std::cout &lt;&lt; "The length is: " &lt;&lt; array.size() &lt;&lt; '\n';</code><code> </code><code>    for (auto element: array)</code><code>        std::cout &lt;&lt; element &lt;&lt; ' ';</code><code> </code><code>    return 0;</code><code>};</code></pre><pre>The length is: 5
0 1 2 0 0
</pre><p>In the above example, we’ve used the resize() function to set the vector’s length to 5. This tells variable array that we’re intending to use the first 5 elements of the array, so it should consider those in active use. However, that leaves an interesting question: what is the capacity of this array?</p><p>We can ask the std::vector what its capacity is via the capacity() function:</p><pre class="language-cpp line-numbers"><code>#include <vector></vector></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::vector array { 0, 1, 2 };</code><code>    array.resize(5); // set length to 5</code><code> </code><code>    std::cout &lt;&lt; "The length is: " &lt;&lt; array.size() &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "The capacity is: " &lt;&lt; array.capacity() &lt;&lt; '\n';</code><code>}</code></pre><p>On the authors machine, this printed:</p><pre>The length is: 5
The capacity is: 5
</pre><p>In this case, the resize() function caused the std::vector to change both its length and capacity. Note that the capacity is guaranteed to be at least as large as the array length (but could be larger), otherwise accessing the elements at the end of the array would be outside of the allocated memory!</p><p><strong>More length vs. capacity</strong></p><p>Why differentiate between length and capacity? std::vector will reallocate its memory if needed, but like Melville’s Bartleby, it would prefer not to, because resizing an array is computationally expensive. Consider the following:</p><pre class="language-cpp line-numbers"><code>#include <vector></vector></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>  std::vector array{};</code><code>  array = { 0, 1, 2, 3, 4 }; // okay, array length = 5</code><code>  std::cout &lt;&lt; "length: " &lt;&lt; array.size() &lt;&lt; "  capacity: " &lt;&lt; array.capacity() &lt;&lt; '\n';</code><code></code><code>  array = { 9, 8, 7 }; // okay, array length is now 3!</code><code>  std::cout &lt;&lt; "length: " &lt;&lt; array.size() &lt;&lt; "  capacity: " &lt;&lt; array.capacity() &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><p>This produces the following:</p><pre>length: 5  capacity: 5
length: 3  capacity: 5
</pre><p>Note that although we assigned a smaller array to our vector, it did not reallocate its memory (the capacity is still 5). It simply changed its length, so it knows that only the first 3 elements are valid at this time.</p><p><strong>Array subscripts and at() are based on length, not capacity</strong></p><p>The range for the subscript operator ([]) and at() function is based on the vector’s length, not the capacity. Consider the array in the previous example, which has length 3 and capacity 5. What happens if we try to access the array element with index 4? The answer is that it fails, since 4 is greater than the length of the array.</p><p>Note that a vector will not resize itself based on a call to the subscript operator or at() function!</p><p><strong>Stack behavior with std::vector</strong></p><p>If the subscript operator and at() function are based on the array length, and the capacity is always at least as large as the array length, why even worry about the capacity at all? Although std::vector can be used as a dynamic array, it can also be used as a stack. To do this, we can use 3 functions that match our key stack operations:</p><ul><li>push_back() pushes an element on the stack.</li><li>back() returns the value of the top element on the stack.</li><li>pop_back() pops an element off the stack.</li></ul><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <vector></vector></code><code></code><code>void printStack(const std::vector<int>&amp; stack)</int></code><code>{</code><code>	for (auto element : stack)</code><code>		std::cout &lt;&lt; element &lt;&lt; ' ';</code><code>	std::cout &lt;&lt; "(cap " &lt;&lt; stack.capacity() &lt;&lt; " length " &lt;&lt; stack.size() &lt;&lt; ")\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::vector<int> stack{};</int></code><code></code><code>	printStack(stack);</code><code></code><code>	stack.push_back(5); // push_back() pushes an element on the stack</code><code>	printStack(stack);</code><code></code><code>	stack.push_back(3);</code><code>	printStack(stack);</code><code></code><code>	stack.push_back(2);</code><code>	printStack(stack);</code><code></code><code>	std::cout &lt;&lt; "top: " &lt;&lt; stack.back() &lt;&lt; '\n'; // back() returns the last element</code><code></code><code>	stack.pop_back(); // pop_back() pops an element off the stack</code><code>	printStack(stack);</code><code></code><code>	stack.pop_back();</code><code>	printStack(stack);</code><code></code><code>	stack.pop_back();</code><code>	printStack(stack);</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>(cap 0 length 0)
5 (cap 1 length 1)
5 3 (cap 2 length 2)
5 3 2 (cap 3 length 3)
top: 2
5 3 (cap 3 length 2)
5 (cap 3 length 1)
(cap 3 length 0)
</pre><p>Unlike array subscripts or at(), the stack-based functions <em>will</em> resize the std::vector if necessary. In the example above, the vector gets resized 3 times (from a capacity of 0 to 1, 1 to 2, and 2 to 3).</p><p>Because resizing the vector is expensive, we can tell the vector to allocate a certain amount of capacity up front using the reserve() function:</p><pre class="language-cpp line-numbers"><code>#include <vector></vector></code><code>#include <iostream></iostream></code><code></code><code>void printStack(const std::vector<int>&amp; stack)</int></code><code>{</code><code>	for (auto element : stack)</code><code>		std::cout &lt;&lt; element &lt;&lt; ' ';</code><code>	std::cout &lt;&lt; "(cap " &lt;&lt; stack.capacity() &lt;&lt; " length " &lt;&lt; stack.size() &lt;&lt; ")\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::vector<int> stack{};</int></code><code></code><code>	stack.reserve(5); // Set the capacity to (at least) 5</code><code></code><code>	printStack(stack);</code><code></code><code>	stack.push_back(5);</code><code>	printStack(stack);</code><code></code><code>	stack.push_back(3);</code><code>	printStack(stack);</code><code></code><code>	stack.push_back(2);</code><code>	printStack(stack);</code><code></code><code>	std::cout &lt;&lt; "top: " &lt;&lt; stack.back() &lt;&lt; '\n';</code><code></code><code>	stack.pop_back();</code><code>	printStack(stack);</code><code></code><code>	stack.pop_back();</code><code>	printStack(stack);</code><code></code><code>	stack.pop_back();</code><code>	printStack(stack);</code><code></code><code>	return 0;</code><code>}</code></pre><p>This program prints:</p><pre>(cap 5 length 0)
5 (cap 5 length 1)
5 3 (cap 5 length 2)
5 3 2 (cap 5 length 3)
top: 2
5 3 (cap 5 length 2)
5 (cap 5 length 1)
(cap 5 length 0)
</pre><p>We can see that the capacity was preset to 5 and didn’t change over the lifetime of the program.</p><p><strong>Vectors may allocate extra capacity</strong></p><p>When a vector is resized, the vector may allocate more capacity than is needed. This is done to provide some “breathing room” for additional elements, to minimize the number of resize operations needed. Let’s take a look at this:</p><pre class="language-cpp line-numbers"><code>#include <vector></vector></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::vector v{ 0, 1, 2, 3, 4 };</code><code>	std::cout &lt;&lt; "size: " &lt;&lt; v.size() &lt;&lt; "  cap: " &lt;&lt; v.capacity() &lt;&lt; '\n';</code><code>	</code><code>	v.push_back(5); // add another element</code><code>	std::cout &lt;&lt; "size: " &lt;&lt; v.size() &lt;&lt; "  cap: " &lt;&lt; v.capacity() &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>On the author’s machine, this prints:</p><pre>size: 5  cap: 5
size: 6  cap: 7
</pre><p>When we used push_back() to add a new element, our vector only needed room for 6 elements, but allocated room for 7. This was done so that if we were to push_back() another element, it wouldn’t need to resize immediately.</p><p>If, when, and how much additional capacity is allocated is left up to the compiler implementer.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">12.4 — Recursion</h1></header><div class="entry-content" itemprop="articleBody"><p>A <strong>recursive function</strong> in C++ is a function that calls itself. Here is an example of a poorly-written recursive function:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void countDown(int count)</code><code>{</code><code>    std::cout &lt;&lt; "push " &lt;&lt; count &lt;&lt; '\n';</code><code>    countDown(count-1); // countDown() calls itself recursively</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    countDown(5);</code><code></code><code>    return 0;</code><code>}</code></pre><p>When countDown(5) is called, “push 5” is printed, and countDown(4) is called. countDown(4) prints “push 4” and calls countDown(3). countDown(3) prints “push 3” and calls countDown(2). The sequence of countDown(n) calling countDown(n-1) is repeated indefinitely, effectively forming the recursive equivalent of an infinite loop.</p><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/the-stack-and-the-heap/">12.2 -- The stack and the heap</a>, you learned that every function call causes data to be placed on the call stack. Because the countDown() function never returns (it just calls countDown() again), this information is never being popped off the stack! Consequently, at some point, the computer will run out of stack memory, stack overflow will result, and the program will crash or terminate. On the author’s machine, this program counted down to -11732 before terminating!</p><p><strong>Recursive termination conditions</strong></p><p>Recursive function calls generally work just like normal function calls. However, the program above illustrates the most important difference with recursive functions: you must include a recursive termination condition, or they will run “forever” (actually, until the call stack runs out of memory). A <strong>recursive termination</strong> is a condition that, when met, will cause the recursive function to stop calling itself.</p><p>Recursive termination generally involves using an if statement. Here is our function redesigned with a termination condition (and some extra output):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void countDown(int count)</code><code>{</code><code>    std::cout &lt;&lt; "push " &lt;&lt; count &lt;&lt; '\n';</code><code></code><code>    if (count &gt; 1) // termination condition</code><code>        countDown(count-1);</code><code></code><code>    std::cout &lt;&lt; "pop " &lt;&lt; count &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    countDown(5);</code><code>    return 0;</code><code>}</code></pre><p>Now when we run our program, countDown() will start by outputting the following:</p><pre>push 5
push 4
push 3
push 2
push 1
</pre><p>If you were to look at the call stack at this point, you would see the following:</p><pre>countDown(1)
countDown(2)
countDown(3)
countDown(4)
countDown(5)
main()
</pre><p>Because of the termination condition, countDown(1) does not call countDown(0) -- instead, the “if statement” does not execute, so it prints “pop 1” and then terminates. At this point, countDown(1) is popped off the stack, and control returns to countDown(2). countDown(2) resumes execution at the point after countDown(1) was called, so it prints “pop 2” and then terminates. The recursive function calls get subsequently popped off the stack until all instances of countDown have been removed.</p><p>Thus, this program in total outputs:</p><pre>push 5
push 4
push 3
push 2
push 1
pop 1
pop 2
pop 3
pop 4
pop 5
</pre><p>It’s worth noting that the “push” outputs happen in forward order since they occur before the recursive function call. The “pop” outputs occur in reverse order because they occur after the recursive function call, as the functions are being popped off the stack (which happens in the reverse order that they were put on).</p><p><strong>A more useful example</strong></p><p>Now that we’ve discussed the basic mechanics of recursive function calls, let’s take a look at another recursive function that is slightly more typical:</p><pre class="language-cpp line-numbers"><code>// return the sum of all the integers between 1 (inclusive) and sumto (inclusive)</code><code>// returns 0 for negative numbers</code><code>int sumTo(int sumto)</code><code>{</code><code>    if (sumto &lt;= 0)</code><code>        return 0; // base case (termination condition) when user passed in an unexpected argument (0 or negative)</code><code>    if (sumto == 1)</code><code>        return 1; // normal base case (termination condition)</code><code></code><code>    return sumTo(sumto - 1) + sumto; // recursive function call</code><code>}</code></pre><p>Recursive programs are often hard to figure out just by looking at them. It’s often instructive to see what happens when we call a recursive function with a particular value. So let’s see what happens when we call this function with parameter sumto = 5.</p><pre>sumTo(5) called, 5 &lt;= 1 is false, so we return sumTo(4) + 5.
sumTo(4) called, 4 &lt;= 1 is false, so we return sumTo(3) + 4.
sumTo(3) called, 3 &lt;= 1 is false, so we return sumTo(2) + 3.
sumTo(2) called, 2 &lt;= 1 is false, so we return sumTo(1) + 2.
sumTo(1) called, 1 &lt;= 1 is true, so we return 1.  This is the termination condition.
</pre><p>Now we unwind the call stack (popping each function off the call stack as it returns):</p><pre>sumTo(1) returns 1.
sumTo(2) returns sumTo(1) + 2, which is 1 + 2 = 3.
sumTo(3) returns sumTo(2) + 3, which is 3 + 3 = 6.
sumTo(4) returns sumTo(3) + 4, which is 6 + 4 = 10.
sumTo(5) returns sumTo(4) + 5, which is 10 + 5 = 15.
</pre><p>At this point, it’s easier to see that we’re adding numbers between 1 and the value passed in (both inclusive).</p><p>Because recursive functions can be hard to understand by looking at them, good comments are particularly important.</p><p>Note that in the above code, we recurse with value <code>sumto - 1</code> rather than <code>--sumto</code>. We do this because <code>operator--</code> has a side effect, and using a variable that has a side effect applied more than once in a given expression will result in undefined behavior. Using <code>sumto - 1</code> avoids side effects, making sumto safe to use more than once in the expression.</p><p><strong>Recursive algorithms</strong></p><p>Recursive functions typically solve a problem by first finding the solution to a subset of the problem (recursively), and then modifying that sub-solution to get to a solution. In the above algorithm, sumTo(value) first solves sumTo(value-1), and then adds the value of variable value to find the solution for sumTo(value).</p><p>In many recursive algorithms, some inputs produce trivial outputs. For example, sumTo(1) has the trivial output 1 (you can calculate this in your head), and does not benefit from further recursion. Inputs for which an algorithm trivially produces an output is called a <strong>base case</strong>. Base cases act as termination conditions for the algorithm. Base cases can often be identified by considering the output for an input of 0, 1, “”, ”, or null.</p><p><strong>Fibonacci numbers</strong></p><p>One of the most famous mathematical recursive algorithms is the Fibonacci sequence. Fibonacci sequences appear in many places in nature, such as branching of trees, the spiral of shells, the fruitlets of a pineapple, an uncurling fern frond, and the arrangement of a pine cone.</p><p>Here is a picture of a Fibonacci spiral:<br><img src="https://www.learncpp.com/images/CppTutorial/Section7/Fibonacci.png" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Section7/Fibonacci.png"></p><p>Each of the Fibonacci numbers is the length of the side of the square that the number appears in.</p><p>Fibonacci numbers are defined mathematically as:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td>F(n) =</td><td>0 if n = 0<br>1 if n = 1<br>f(n-1) + f(n-2) if n &gt; 1</td></tr></tbody></table></div><p>Consequently, it’s rather simple to write a (not very efficient) recursive function to calculate the nth Fibonacci number:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int fibonacci(int count)</code><code>{</code><code>    if (count == 0)</code><code>        return 0; // base case (termination condition)</code><code>    if (count == 1)</code><code>        return 1; // base case (termination condition)</code><code>    return fibonacci(count-1) + fibonacci(count-2);</code><code>}</code><code></code><code>// And a main program to display the first 13 Fibonacci numbers</code><code>int main()</code><code>{</code><code>    for (int count { 0 }; count &lt; 13; ++count)</code><code>        std:: cout &lt;&lt; fibonacci(count) &lt;&lt; ' ';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Running the program produces the following result:</p><pre>0 1 1 2 3 5 8 13 21 34 55 89 144
</pre><p>Which you will note are exactly the numbers that appear in the Fibonacci spiral diagram.</p><p><strong>Memoization algorithms</strong></p><p>The above recursive Fibonacci algorithm isn’t very efficient, in part because each call to a Fibonacci non-base case results in two more Fibonacci calls. This produces an exponential number of function calls (in fact, the above example calls fibonacci() 1205 times!). There are techniques that can be used to reduce the number of calls necessary. One technique, called <strong>memoization</strong>, caches the results of expensive function calls so the result can be returned when the same input occurs again.</p><p>Here’s a memoized version of the recursive Fibonacci algorithm:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <vector></vector></code><code></code><code>// h/t to potterman28wxcv for a variant of this code</code><code>int fibonacci(int count)</code><code>{</code><code>	// We'll use a static std::vector to cache calculated results</code><code>	static std::vector results{ 0, 1 };</code><code></code><code>	// If we've already seen this count, then use the cache'd result</code><code>	if (count &lt; static_cast<int>(std::size(results)))</int></code><code>		return results[count];</code><code></code><code>	// Otherwise calculate the new result and add it</code><code>	results.push_back(fibonacci(count - 1) + fibonacci(count - 2));</code><code>	return results[count];</code><code>}</code><code></code><code>// And a main program to display the first 13 Fibonacci numbers</code><code>int main()</code><code>{</code><code>	for (int count { 0 }; count &lt; 13; ++count)</code><code>		std::cout &lt;&lt; fibonacci(count) &lt;&lt; ' ';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This memoized version makes 35 function calls, which is much better than the 1205 of the original algorithm.</p><p><strong>Recursive vs iterative</strong></p><p>One question that is often asked about recursive functions is, “Why use a recursive function if you can do many of the same tasks iteratively (using a <em>for loop</em> or <em>while loop</em>)?”. It turns out that you can always solve a recursive problem iteratively -- however, for non-trivial problems, the recursive version is often much simpler to write (and read). For example, while it’s possible to write the Fibonacci function iteratively, it’s a little more difficult! (Try it!)</p><p>Iterative functions (those using a for-loop or while-loop) are almost always more efficient than their recursive counterparts. This is because every time you call a function there is some amount of overhead that takes place in pushing and popping stack frames. Iterative functions avoid this overhead.</p><p>That’s not to say iterative functions are always a better choice. Sometimes the recursive implementation of a function is so much cleaner and easier to follow that incurring a little extra overhead is more than worth it for the benefit in maintainability, particularly if the algorithm doesn’t need to recurse too many times to find a solution.</p><p>In general, recursion is a good choice when most of the following are true:</p><ul><li>The recursive code is much simpler to implement.</li><li>The recursion depth can be limited (e.g. there’s no way to provide an input that will cause it to recurse down 100,000 levels).</li><li>The iterative version of the algorithm requires managing a stack of data.</li><li>This isn’t a performance-critical section of code.</li></ul><p>However, if the recursive algorithm is simpler to implement, it may make sense to start recursively and then optimize to an iterative algorithm later.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Generally favor iteration over recursion, except when recursion really makes sense.</p></div><p><strong>Quiz time</strong></p><ol start="1"><li>A factorial of an integer N (written N!) is defined as the product (multiplication) of all the numbers between 1 and N (0! = 1). Write a recursive function called factorial that returns the factorial of the input. Test it with the first 7 factorials.</li></ol><p>Hint: Remember that (x * y) = (y * x), so the product of all the numbers between 1 and N is the same as the product of all the numbers between N and 1.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int factorial(int n)</code><code>{</code><code>	if (n &lt;= 0)</code><code>		return 1;</code><code></code><code>	return factorial(n - 1) * n;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	for (int count { 0 }; count &lt; 7; ++count)</code><code>		std::cout &lt;&lt; factorial(count) &lt;&lt; '\n';</code><code>}</code></pre></div><ol start="2"><li>Write a recursive function that takes an integer as input and returns the sum of each individual digit in the integer (e.g. 357 = 3 + 5 + 7 = 15). Print the answer for input 93427 (which is 25). Assume the input values are positive.</li></ol><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int sumDigits(int x)</code><code>{</code><code>	if (x &lt; 10)</code><code>		return x;</code><code></code><code>	return sumDigits(x / 10) + x % 10;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; sumDigits(93427);</code><code>}</code></pre></div><p>3a) This one is slightly trickier. Write a program that asks the user to enter a positive integer, and then uses a recursive function to print out the binary representation for that number. Use method 1 from lesson <a href="https://www.learncpp.com/cpp-tutorial/converting-between-binary-and-decimal/">O.4 -- Converting between binary and decimal</a>.</p><p>Hint: Using method 1, we want to print the bits from the “bottom up”, which means in reverse order. This means your print statement should be <em>after</em> the recursive call.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// h/t to reader Gapo for this solution</code><code>void printBinary(int x)</code><code>{</code><code>        // Termination case</code><code>	if (x == 0)</code><code>		return;</code><code>	</code><code>	// Recurse to the next bit</code><code>	printBinary(x / 2);</code><code></code><code>	// Print out the remainders (in reverse order)</code><code>	std::cout &lt;&lt; x % 2;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int x;</code><code>	std::cout &lt;&lt; "Enter a positive integer: ";</code><code>	std::cin &gt;&gt; x;</code><code></code><code>	printBinary(x);</code><code>}</code></pre></div><p>3b) Update your code from 3a to handle the case where the user may enter 0 or a negative number.</p><p>Here’s a sample output (assuming 32-bit integers):</p><pre>Enter an integer: -15
11111111111111111111111111110001
</pre><p>Hint: You can turn a negative integer into a positive one by converting it to an unsigned integer. These have identical bit representations (the type is used to determine how to interpret the number into decimal).</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><pre class="language-cpp line-numbers"><code>// h/t to reader Donlod for this solution</code><code>#include <iostream></iostream></code><code></code><code>void printBinary(unsigned int n)</code><code>{</code><code>	if (n &gt; 1) // we only recurse if n &gt; 1, so this is our termination case for n == 0</code><code>	{</code><code>		printBinary(n / 2);</code><code>	}</code><code></code><code>	std::cout &lt;&lt; n % 2;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int x{};</code><code>	std::cout &lt;&lt; "Enter an integer: ";</code><code>	std::cin &gt;&gt; x;</code><code></code><code>	printBinary(static_cast<unsigned int="">(x));</unsigned></code><code>}</code></pre></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">12.5 — Command line arguments</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>The need for command line arguments</strong></p><p>As you learned in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-the-compiler-linker-and-libraries/">0.5 -- Introduction to the compiler, linker, and libraries</a>, when you compile and link your program, the output is an executable file. When a program is run, execution starts at the top of the function called main(). Up to this point, we’ve declared main like this:</p><pre class="language-cpp line-numbers"><code>int main()</code></pre><p>Notice that this version of main() takes no parameters. However, many programs need some kind of input to work with. For example, let’s say you were writing a program called Thumbnail that read in an image file, and then produced a thumbnail (a smaller version of the image). How would Thumbnail know which image to read and process? The user has to have some way of telling the program which file to open. To do this, you might take this approach:</p><pre class="language-cpp line-numbers"><code>// Program: Thumbnail</code><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Please enter an image filename to create a thumbnail for: ";</code><code>    std::string filename{};</code><code>    std::cin &gt;&gt; filename;</code><code></code><code>    // open image file</code><code>    // create thumbnail</code><code>    // output thumbnail</code><code>}</code></pre><p>However, there is a potential problem with this approach. Every time the program is run, the program will wait for the user to enter input. This may not be a problem if you’re manually running this program once from the command line. But it is problematic in other cases, such as when you want to run this program on many files, or have this program run by another program.</p><p>Let’s look into these cases further.</p><p>Consider the case where you want to create thumbnails for all the image files in a given directory. How would you do that? You could run this program as many times as there are images in the directory, typing out each filename by hand. However, if there were hundreds of images, this could take all day! A good solution here would be to write a program that loops through each filename in the directory, calling Thumbnail once for each file.</p><p>Now consider the case where you’re running a website, and you want to have your website create a Thumbnail every time a user uploads an image to your website. This program isn’t set up to accept input from the web, so how would the uploader enter a filename in this case? A good solution here would be to have your web server call Thumbnail automatically after upload.</p><p>In both of these cases, we really need a way for an external <em>program</em> to pass in the filename as input to our Thumbnail program when Thumbnail is launched, rather than having Thumbnail wait for the <em>user</em> to enter the filename after it has started.</p><p><strong>Command line arguments</strong> are optional string arguments that are passed by the operating system to the program when it is launched. The program can then use them as input (or ignore them). Much like function parameters provide a way for a function to provide inputs to another function, command line arguments provide a way for people or programs to provide inputs to a <em>program</em>.</p><p><strong>Passing command line arguments</strong></p><p>Executable programs can be run on the command line by invoking them by name. For example, to run the executable file “WordCount” that is located in the current directory of a Windows machine, you could type:</p><pre>WordCount
</pre><p>The equivalent command line on a Unix-based OS would be:</p><pre>./WordCount
</pre><p>In order to pass command line arguments to WordCount, we simply list the command line arguments after the executable name:</p><pre>WordCount Myfile.txt
</pre><p>Now when WordCount is executed, Myfile.txt will be provided as a command line argument. A program can have multiple command line arguments, separated by spaces:</p><pre>WordCount Myfile.txt Myotherfile.txt
</pre><p>If you are running your program from an IDE, the IDE should provide a way to enter command line arguments.</p><p>In Microsoft Visual Studio, right click on your project in the solution explorer, then choose properties. Open the “Configuration Properties” tree element, and choose “Debugging”. In the right pane, there is a line called “Command Arguments”. You can enter your command line arguments there for testing, and they will be automatically passed to your program when you run it.</p><p>In Code::Blocks, choose “Project -&gt; Set program’s arguments”.</p><p><strong>Using command line arguments</strong></p><p>Now that you know how to provide command line arguments to a program, the next step is to access them from within our C++ program. To do that, we use a different form of main() than we’ve seen before. This new form of main() takes two arguments (named argc and argv by convention) as follows:</p><pre class="language-cpp line-numbers"><code>int main(int argc, char* argv[])</code></pre><p>You will sometimes also see it written as:</p><pre class="language-cpp line-numbers"><code>int main(int argc, char** argv)</code></pre><p>Even though these are treated identically, we prefer the first representation because it’s intuitively easier to understand.</p><p><strong>argc</strong> is an integer parameter containing a count of the number of arguments passed to the program (think: argc = <b>arg</b>ument <b>c</b>ount). argc will always be at least 1, because the first argument is always the name of the program itself. Each command line argument the user provides will cause argc to increase by 1.</p><p><strong>argv</strong> is where the actual argument values are stored (think: argv = <b>arg</b>ument <b>v</b>alues, though the proper name is “argument vectors”). Although the declaration of argv looks intimidating, argv is really just an array of C-style strings. The length of this array is argc.</p><p>Let’s write a short program named “MyArgs” to print the value of all the command line parameters:</p><pre class="language-cpp line-numbers"><code>// Program: MyArgs</code><code>#include <iostream></iostream></code><code></code><code>int main(int argc, char* argv[])</code><code>{</code><code>    std::cout &lt;&lt; "There are " &lt;&lt; argc &lt;&lt; " arguments:\n";</code><code></code><code>    // Loop through each argument and print its number and value</code><code>    for (int count{ 0 }; count &lt; argc; ++count)</code><code>    {</code><code>        std::cout &lt;&lt; count &lt;&lt; ' ' &lt;&lt; argv[count] &lt;&lt; '\n';</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>Now, when we invoke this program (MyArgs) with the command line arguments “Myfile.txt” and “100”, the output will be as follows:</p><pre>There are 3 arguments:
0 C:\MyArgs
1 Myfile.txt
2 100
</pre><p>Argument 0 is the path and name of the current program being run. Argument 1 and 2 in this case are the two command line parameters we passed in.</p><p><strong>Dealing with numeric arguments</strong></p><p>Command line arguments are always passed as strings, even if the value provided is numeric in nature. To use a command line argument as a number, you must convert it from a string to a number. Unfortunately, C++ makes this a little more difficult than it should be.</p><p>The C++ way to do this follows:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <sstream> // for std::stringstream</sstream></code><code>#include <string></string></code><code></code><code>int main(int argc, char* argv[])</code><code>{</code><code>	if (argc &lt;= 1)</code><code>	{</code><code>		// On some operating systems, argv[0] can end up as an empty string instead of the program's name.</code><code>		// We'll conditionalize our response on whether argv[0] is empty or not.</code><code>		if (argv[0])</code><code>			std::cout &lt;&lt; "Usage: " &lt;&lt; argv[0] &lt;&lt; " <number>" &lt;&lt; '\n';</number></code><code>		else</code><code>			std::cout &lt;&lt; "Usage: <program name=""> <number>" &lt;&lt; '\n';</number></program></code><code>            </code><code>		return 1;</code><code>	}</code><code></code><code>	std::stringstream convert{ argv[1] }; // set up a stringstream variable named convert, initialized with the input from argv[1]</code><code></code><code>	int myint{};</code><code>	if (!(convert &gt;&gt; myint)) // do the conversion</code><code>		myint = 0; // if conversion fails, set myint to a default value</code><code></code><code>	std::cout &lt;&lt; "Got integer: " &lt;&lt; myint &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>When run with input “567”, this program prints:</p><pre>Got integer: 567
</pre><p>std::stringstream works much like std::cin. In this case, we’re initializing it with the value of argv[1], so that we can use operator&gt;&gt; to extract the value to an integer variable (the same as we would with std::cin).</p><p>We’ll talk more about std::stringstream in a future chapter.</p><p><strong>The OS parses command line arguments first</strong></p><p>When you type something at the command line (or run your program from the IDE), it is the operating system’s responsibility to translate and route that request as appropriate. This not only involves running the executable, it also involves parsing any arguments to determine how they should be handled and passed to the application.</p><p>Generally, operating systems have special rules about how special characters like double quotes and backslashes are handled.</p><p>For example:</p><pre>MyArgs Hello world!</pre><p>prints:</p><pre>There are 3 arguments:
0 C:\MyArgs
1 Hello
2 world!
</pre><p>Typically, strings passed in double quotes are considered to be part of the same string:</p><pre>MyArgs "Hello world!"</pre><p>prints:</p><pre>There are 2 arguments:
0 C:\MyArgs
1 Hello world!
</pre><p>Most operating systems will allow you to include a literal double quote by backslashing the double quote:</p><pre>MyArgs \"Hello world!\"</pre><p>prints:</p><pre>There are 3 arguments:
0 C:\MyArgs
1 "Hello
2 world!"
</pre><p>Other characters may also require backslashing or escaping depending on how your OS interprets them.</p><p><strong>Conclusion</strong></p><p>Command line arguments provide a great way for users or other programs to pass input data into a program at startup. Consider making any input data that a program requires at startup to operate a command line parameter. If the command line isn’t passed in, you can always detect that and ask the user for input. That way, your program can operate either way.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">12.6 — Ellipsis (and why to avoid them)</h1></header><div class="entry-content" itemprop="articleBody"><p>In all of the functions we’ve seen so far, the number of parameters a function will take must be known in advance (even if they have default values). However, there are certain cases where it can be useful to be able to pass a variable number of parameters to a function. C++ provides a special specifier known as ellipsis (aka “…”) that allow us to do precisely this.</p><p>Because ellipsis are rarely used, potentially dangerous, and we recommend avoiding their use, this section can be considered optional reading.</p><p>Functions that use ellipsis take the form:</p><pre>return_type function_name(argument_list, ...)
</pre><p>The <em>argument_list</em> is one or more normal function parameters. Note that functions that use ellipsis must have at least one non-ellipsis parameter. Any arguments passed to the function must match the argument_list parameters first.</p><p>The ellipsis (which are represented as three periods in a row) must always be the last parameter in the function. The ellipsis capture any additional arguments (if there are any). Though it is not quite accurate, it is conceptually useful to think of the ellipsis as an array that holds any additional parameters beyond those in the argument_list.</p><p><strong>An ellipsis example</strong></p><p>The best way to learn about ellipsis is by example. So let’s write a simple program that uses ellipsis. Let’s say we want to write a function that calculates the average of a bunch of integers. We’d do it like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cstdarg> // needed to use ellipsis</cstdarg></code><code></code><code>// The ellipsis must be the last parameter</code><code>// count is how many additional arguments we're passing</code><code>double findAverage(int count, ...)</code><code>{</code><code>    int sum{ 0 };</code><code></code><code>    // We access the ellipsis through a va_list, so let's declare one</code><code>    std::va_list list;</code><code></code><code>    // We initialize the va_list using va_start.  The first argument is</code><code>    // the list to initialize.  The second argument is the last non-ellipsis</code><code>    // parameter.</code><code>    va_start(list, count);</code><code></code><code>    // Loop through all the ellipsis values</code><code>    for (int arg{ 0 }; arg &lt; count; ++arg)</code><code>    {</code><code>         // We use va_arg to get values out of our ellipsis</code><code>         // The first argument is the va_list we're using</code><code>         // The second argument is the type of the value</code><code>         sum += va_arg(list, int);</code><code>    }</code><code></code><code>    // Cleanup the va_list when we're done.</code><code>    va_end(list);</code><code></code><code>    return static_cast<double>(sum) / count;</double></code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; findAverage(5, 1, 2, 3, 4, 5) &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; findAverage(6, 1, 2, 3, 4, 5, 6) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This code prints:</p><pre>3
3.5
</pre><p>As you can see, this function takes a variable number of parameters! Now, let’s take a look at the components that make up this example.</p><p>First, we have to include the cstdarg header. This header defines va_list, va_arg, va_start, and va_end, which are macros that we need to use to access the parameters that are part of the ellipsis.</p><p>We then declare our function that uses the ellipsis. Remember that the argument list must be one or more fixed parameters. In this case, we’re passing in a single integer that tells us how many numbers to average. The ellipsis always comes last.</p><p>Note that the ellipsis parameter has no name! Instead, we access the values in the ellipsis through a special type known as va_list. It is conceptually useful to think of va_list as a pointer that points to the ellipsis array. First, we declare a va_list, which we’ve called “list” for simplicity.</p><p>The next thing we need to do is make list point to our ellipsis parameters. We do this by calling va_start(). va_start() takes two parameters: the va_list itself, and the name of the <em>last</em> non-ellipsis parameter in the function. Once va_start() has been called, va_list points to the first parameter in the ellipsis.</p><p>To get the value of the parameter that va_list currently points to, we use va_arg(). va_arg() also takes two parameters: the va_list itself, and the type of the parameter we’re trying to access. Note that va_arg() also moves the va_list to the next parameter in the ellipsis!</p><p>Finally, to clean up when we are done, we call va_end(), with va_list as the parameter.</p><p>Note that va_start() can be called again any time we want to reset the va_list to point to the first parameter in the ellipses again.</p><p><strong>Why ellipsis are dangerous: Type checking is suspended</strong></p><p>Ellipsis offer the programmer a lot of flexibility to implement functions that can take a variable number of parameters. However, this flexibility comes with some downsides.</p><p>With regular function parameters, the compiler uses type checking to ensure the types of the function arguments match the types of the function parameters (or can be implicitly converted so they match). This helps ensure you don’t pass a function an integer when it was expecting a string, or vice versa. However, note that ellipsis parameters have no type declarations. When using ellipsis, the compiler completely suspends type checking for ellipsis parameters. This means it is possible to send arguments of any type to the ellipsis! However, the downside is that the compiler will no longer be able to warn you if you call the function with ellipsis arguments that do not make sense. When using the ellipsis, it is completely up to the caller to ensure the function is called with ellipsis arguments that the function can handle. Obviously that leaves quite a bit of room for error (especially if the caller wasn’t the one who wrote the function).</p><p>Let’s look at an example of a mistake that is pretty subtle:</p><pre class="language-cpp line-numbers"><code>    std::cout &lt;&lt; findAverage(6, 1.0, 2, 3, 4, 5, 6) &lt;&lt; '\n';</code></pre><p>Although this may look harmless enough at first glance, note that the second argument (the first ellipsis argument) is a double instead of an integer. This compiles fine, and produces a somewhat surprising result:</p><pre>1.78782e+008
</pre><p>which is a REALLY big number. How did this happen?</p><p>As you have learned in previous lessons, a computer stores all data as a sequence of bits. A variable’s type tells the computer how to translate that sequence of bits into a meaningful value. However, you just learned that the ellipsis throw away the variable’s type! Consequently, the only way to get a meaningful value back from the ellipsis is to manually tell va_arg() what the expected type of the next parameter is. This is what the second parameter of va_arg() does. If the actual parameter type doesn’t match the expected parameter type, bad things will usually happen.</p><p>In the above findAverage program, we told va_arg() that our variables are all expected to have a type of int. Consequently, each call to va_arg() will return the next sequence of bits translated as an integer.</p><p>In this case, the problem is that the double we passed in as the first ellipsis argument is 8 bytes, whereas va_arg(list, int) will only return 4 bytes of data with each call. Consequently, the first call to va_arg will only read the first 4 bytes of the double (producing a garbage result), and the second call to va_arg will read the second 4 bytes of the double (producing another garbage result). Thus, our overall result is garbage.</p><p>Because type checking is suspended, the compiler won’t even complain if we do something completely ridiculous, like this:</p><pre class="language-cpp line-numbers"><code>    int value{ 7 };</code><code>    std::cout &lt;&lt; findAverage(6, 1.0, 2, "Hello, world!", 'G', &amp;value, &amp;findAverage) &lt;&lt; '\n';</code></pre><p>Believe it or not, this actually compiles just fine, and produces the following result on the author’s machine:</p><pre>1.79766e+008
</pre><p>This result epitomizes the phrase, “Garbage in, garbage out”, which is a popular computer science phrase “used primarily to call attention to the fact that computers, unlike humans, will unquestioningly process the most nonsensical of input data and produce nonsensical output” (<a href="https://en.wikipedia.org/wiki/Garbage_in,_garbage_out">Wikipedia</a>).</p><p>So, in summary, type checking on the parameters is suspended, and we have to trust the caller to pass in the right type of parameters. If they don’t, the compiler won’t complain -- our program will just produce garbage (or maybe crash).</p><p><strong>Why ellipsis are dangerous: ellipsis don’t know how many parameters were passed</strong></p><p>Not only do the ellipsis throw away the <em>type</em> of the parameters, it also throws away the <em>number</em> of parameters in the ellipsis. This means we have to devise our own solution for keeping track of the number of parameters passed into the ellipsis. Typically, this is done in one of three ways.</p><p><strong>Method 1: Pass a length parameter</strong></p><p>Method #1 is to have one of the fixed parameters represent the number of optional parameters passed. This is the solution we use in the findAverage() example above.</p><p>However, even here we run into trouble. For example, consider the following call:</p><pre class="language-cpp line-numbers"><code>    std::cout &lt;&lt; findAverage(6, 1, 2, 3, 4, 5) &lt;&lt; '\n';</code></pre><p>On the author’s machine at the time of writing, this produced the result:</p><pre>699773
</pre><p>What happened? We told findAverage() we were going to provide 6 additional values, but we only gave it 5. Consequently, the first five values that va_arg() returns were the ones we passed in. The 6th value it returns was a garbage value somewhere in the stack. Consequently, we got a garbage answer.</p><p>A more insidious case:</p><pre class="language-cpp line-numbers"><code>    std::cout &lt;&lt; findAverage(6, 1, 2, 3, 4, 5, 6, 7) &lt;&lt; '\n';</code></pre><p>This produces the answer 3.5, which may look correct at first glance, but omits the last number in the average, because we only told it we were going to provide 6 additional values (and then actually provided 7). These kind of mistakes can be very hard to catch.</p><p><strong>Method 2: Use a sentinel value</strong></p><p>Method #2 is to use a sentinel value. A <strong>sentinel</strong> is a special value that is used to terminate a loop when it is encountered. For example, with strings, the null terminator is used as a sentinel value to denote the end of the string. With ellipsis, the sentinel is typically passed in as the last parameter. Here’s an example of findAverage() rewritten to use a sentinel value of -1:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cstdarg> // needed to use ellipsis</cstdarg></code><code></code><code>// The ellipsis must be the last parameter</code><code>double findAverage(int first, ...)</code><code>{</code><code>	// We have to deal with the first number specially</code><code>	int sum{ first };</code><code></code><code>	// We access the ellipsis through a va_list, so let's declare one</code><code>	std::va_list list;</code><code></code><code>	// We initialize the va_list using va_start.  The first argument is</code><code>	// the list to initialize.  The second argument is the last non-ellipsis</code><code>	// parameter.</code><code>	va_start(list, first);</code><code></code><code>	int count{ 1 };</code><code>	// Loop indefinitely</code><code>	while (true)</code><code>	{</code><code>		// We use va_arg to get values out of our ellipsis</code><code>		// The first argument is the va_list we're using</code><code>		// The second argument is the type of the value</code><code>		int arg{ va_arg(list, int) };</code><code></code><code>		// If this parameter is our sentinel value, stop looping</code><code>		if (arg == -1)</code><code>			break;</code><code></code><code>		sum += arg;</code><code>		++count;</code><code>	}</code><code></code><code>	// Cleanup the va_list when we're done.</code><code>	va_end(list);</code><code></code><code>	return static_cast<double>(sum) / count;</double></code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; findAverage(1, 2, 3, 4, 5, -1) &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; findAverage(1, 2, 3, 4, 5, 6, -1) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>Note that we no longer need to pass an explicit length as the first parameter. Instead, we pass a sentinel value as the last parameter.</p><p>However, there are a couple of challenges here. First, C++ requires that we pass at least one fixed parameter. In the previous example, this was our count variable. In this example, the first value is actually part of the numbers to be averaged. So instead of treating the first value to be averaged as part of the ellipsis parameters, we explicitly declare it as a normal parameter. We then need special handling for it inside the function (in this case, we set sum to first instead of 0 to start).</p><p>Second, this requires the user to pass in the sentinel as the last value. If the user forgets to pass in the sentinel value (or passes in the wrong value), the function will loop continuously until it runs into garbage that matches the sentinel (or crashes).</p><p>Finally, note that we’ve chosen -1 as our sentinel. That’s fine if we only wanted to find the average of positive numbers, but what if we wanted to include negative numbers? Sentinel values only work well if there is a value that falls outside the valid set of values for the problem you are trying to solve.</p><p><strong>Method 3: Use a decoder string</strong></p><p>Method #3 involves passing a “decoder string” that tells the program how to interpret the parameters.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code>#include <cstdarg> // needed to use ellipsis</cstdarg></code><code></code><code>// The ellipsis must be the last parameter</code><code>double findAverage(std::string_view decoder, ...)</code><code>{</code><code>	double sum{ 0 };</code><code></code><code>	// We access the ellipsis through a va_list, so let's declare one</code><code>	std::va_list list;</code><code></code><code>	// We initialize the va_list using va_start.  The first argument is</code><code>	// the list to initialize.  The second argument is the last non-ellipsis</code><code>	// parameter.</code><code>	va_start(list, decoder);</code><code></code><code>	for (auto codetype: decoder)</code><code>	{</code><code>		switch (codetype)</code><code>		{</code><code>		case 'i':</code><code>			sum += va_arg(list, int);</code><code>			break;</code><code></code><code>		case 'd':</code><code>			sum += va_arg(list, double);</code><code>			break;</code><code>		}</code><code>	}</code><code></code><code>	// Cleanup the va_list when we're done.</code><code>	va_end(list);</code><code></code><code>	return sum / std::size(decoder);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; findAverage("iiiii", 1, 2, 3, 4, 5) &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; findAverage("iiiiii", 1, 2, 3, 4, 5, 6) &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; findAverage("iiddi", 1, 2, 3.5, 4.5, 5) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>In this example, we pass a string that encodes both the number of optional variables and their types. The cool thing is that this lets us deal with parameters of different types. However, this method has downsides as well: the decoder string can be a bit cryptic, and if the number or types of the optional parameters don’t match the decoder string precisely, bad things can happen.</p><p>For those of you coming from C, this is what printf does!</p><p><strong>Recommendations for safer use of ellipsis</strong></p><p>First, if possible, do not use ellipsis at all! Oftentimes, other reasonable solutions are available, even if they require slightly more work. For example, in our findAverage() program, we could have passed in a dynamically sized array of integers instead. This would have provided both strong type checking (to make sure the caller doesn’t try to do something nonsensical) while preserving the ability to pass a variable number of integers to be averaged.</p><p>Second, if you do use ellipsis, do not mix expected argument types within your ellipsis if possible. Doing so vastly increases the possibility of the caller inadvertently passing in data of the wrong type and va_arg() producing a garbage result.</p><p>Third, using a count parameter or decoder string as part of the argument list is generally safer than using a sentinel as an ellipsis parameter. This forces the user to pick an appropriate value for the count/decoder parameter, which ensures the ellipsis loop will terminate after a reasonable number of iterations even if it produces a garbage value.</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>To improve upon ellipses-like functionality, C++11 introduced <code>parameter packs</code> and <code>variadic templates</code>, which offers functionality similar to ellipses, but with strong type checking. However, significant usability challenges impeded adoption of this feature.</p><p>In C++17, <a href="https://en.cppreference.com/w/cpp/language/fold">fold expressions</a> were added, which significantly improves the usability of parameter packs, to the point where they are now a viable option.</p><p>We hope to introduce lessons on these topics in a future site update.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">12.7 — Introduction to lambdas (anonymous functions)</h1></header><div class="entry-content" itemprop="articleBody"><p>Consider this snippet of code that we introduced in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-standard-library-algorithms/">11.19 -- Introduction to standard library algorithms</a>:</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>// Our function will return true if the element matches</code><code>bool containsNut(std::string_view str)</code><code>{</code><code>    // std::string_view::find returns std::string_view::npos if it doesn't find</code><code>    // the substring. Otherwise it returns the index where the substring occurs</code><code>    // in str.</code><code>    return (str.find("nut") != std::string_view::npos);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::array<std::string_view, 4=""> arr{ "apple", "banana", "walnut", "lemon" };</std::string_view,></code><code></code><code>    // Scan our array to see if any elements contain the "nut" substring</code><code>    auto found{ std::find_if(arr.begin(), arr.end(), containsNut) };</code><code></code><code>    if (found == arr.end())</code><code>    {</code><code>        std::cout &lt;&lt; "No nuts\n";</code><code>    }</code><code>    else</code><code>    {</code><code>        std::cout &lt;&lt; "Found " &lt;&lt; *found &lt;&lt; '\n';</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>This code searches through an array of strings looking for the first element that contains the substring “nut”. Thus, it produces the result:</p><pre>Found walnut
</pre><p>And while it works, it could be improved.</p><p>The root of the issue here is that <code>std::find_if</code> requires that we pass it a function pointer. Because of that, we are forced to define a function that’s only going to be used once, that must be given a name, and that must be put in the global scope (because functions can’t be nested!). The function is also so short, it’s almost easier to discern what it does from the one line of code than from the name and comments.</p><br><h3>Lambdas to the rescue</h3><p>A <span class="cpp-definition">lambda expression</span> (also called a <span class="cpp-definition">lambda</span> or <span class="cpp-definition">closure</span>) allows us to define an anonymous function inside another function. The nesting is important, as it allows us both to avoid namespace naming pollution, and to define the function as close to where it is used as possible (providing additional context).</p><p>The syntax for lambdas is one of the weirder things in C++, and takes a bit of getting used to. Lambdas take the form:</p><pre>[ captureClause ] ( parameters ) -&gt; returnType
{
    statements;
}
</pre><ul><li>The capture clause can be empty if no captures are needed.</li><li>The parameter list can be either empty or omitted if no parameters are required.</li><li>The return type is optional, and if omitted, <code>auto</code> will be assumed (thus using type deduction used to determine the return type). While we previously noted that type deduction for function return types should be avoided, in this context, it’s fine to use (because these functions are typically so trivial).</li></ul><p>Also note that lambdas (being anonymous) have no name, so we don’t need to provide one.</p><div class="cpp-note cpp-lightgraybackground"><h4>As an aside…</h4><p>This means a trivial lambda definition looks like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>  [] {}; // a lambda with an omitted return type, no captures, and omitted parameters.</code><code></code><code>  return 0;</code><code>}</code></pre></div><p>Let’s rewrite the above example using a lambda:</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>int main()</code><code>{</code><code>  constexpr std::array<std::string_view, 4=""> arr{ "apple", "banana", "walnut", "lemon" };</std::string_view,></code><code></code><code>  // Define the function right where we use it.</code><code>  const auto found{ std::find_if(arr.begin(), arr.end(),</code><code>                           [](std::string_view str) // here's our lambda, no capture clause</code><code>                           {</code><code>                             return (str.find("nut") != std::string_view::npos);</code><code>                           }) };</code><code></code><code>  if (found == arr.end())</code><code>  {</code><code>    std::cout &lt;&lt; "No nuts\n";</code><code>  }</code><code>  else</code><code>  {</code><code>    std::cout &lt;&lt; "Found " &lt;&lt; *found &lt;&lt; '\n';</code><code>  }</code><code></code><code>  return 0;</code><code>}</code></pre><p>This works just like the function pointer case, and produces an identical result:</p><pre>Found walnut
</pre><p>Note how similar our lambda is to our <code>containsNut</code> function. They both have identical parameters and function bodies. The lambda has no capture clause (we’ll explain what a capture clause is in the next lesson) because it doesn’t need one. And we’ve omitted the trailing return type in the lambda (for conciseness), but since <code>operator!=</code> returns a <code>bool</code>, our lambda will return a <code>bool</code> too.</p><br><h3>Type of a lambda</h3><p>In the above example, we defined a lambda right where it was needed. This use of a lambda is sometimes called a <span class="cpp-definition">function literal</span>.</p><p>However, writing a lambda in the same line as it’s used can sometimes make code harder to read. Much like we can initialize a variable with a literal value (or a function pointer) for use later, we can also initialize a lambda variable with a lambda definition and then use it later. A named lambda along with a good function name can make code easier to read.</p><p>For example, in the following snippet, we’re using <code>std::all_of</code> to check if all elements of an array are even:</p><pre class="language-cpp line-numbers"><code>// Bad: We have to read the lambda to understand what's happening.</code><code>return std::all_of(array.begin(), array.end(), [](int i){ return ((i % 2) == 0); });</code></pre><p>We can improve the readability of this as follows:</p><pre class="language-cpp line-numbers"><code>// Good: Instead, we can store the lambda in a named variable and pass it to the function.</code><code>auto isEven{</code><code>  [](int i)</code><code>  {</code><code>    return ((i % 2) == 0);</code><code>  }</code><code>};</code><code></code><code>return std::all_of(array.begin(), array.end(), isEven);</code></pre><p>Note how well the last line reads: “return whether <em>all of</em> the elements in the <em>array</em> are <em>even</em>”</p><p>But what is the type of lambda <code>isEven</code>?</p><p>As it turns out, lambdas don’t have a type that we can explicitly use. When we write a lambda, the compiler generates a unique type just for the lambda that is not exposed to us.</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>In actuality, lambdas aren’t functions (which is part of how they avoid the limitation of C++ not supporting nested functions). They’re a special kind of object called a functor. Functors are objects that contain an overloaded <code>operator()</code> that make them callable like a function.</p></div><p>Although we don’t know the type of a lambda, there are several ways of storing a lambda for use post-definition. If the lambda has an empty capture clause (nothing between the hard brackets []), we can use a regular function pointer. <code>std::function</code> or type deduction via the <code>auto</code> keyword will also work (even if the lambda has a non-empty capture clause).</p><pre class="language-cpp line-numbers"><code>#include <functional></functional></code><code></code><code>int main()</code><code>{</code><code>  // A regular function pointer. Only works with an empty capture clause (empty []).</code><code>  double (*addNumbers1)(double, double){</code><code>    [](double a, double b) {</code><code>      return (a + b);</code><code>    }</code><code>  };</code><code></code><code>  addNumbers1(1, 2);</code><code></code><code>  // Using std::function. The lambda could have a non-empty capture clause (discussed next lesson).</code><code>  std::function addNumbers2{ // note: pre-C++17, use std::function<double(double, double)=""> instead</double(double,></code><code>    [](double a, double b) {</code><code>      return (a + b);</code><code>    }</code><code>  };</code><code></code><code>  addNumbers2(3, 4);</code><code></code><code>  // Using auto. Stores the lambda with its real type.</code><code>  auto addNumbers3{</code><code>    [](double a, double b) {</code><code>      return (a + b);</code><code>    }</code><code>  };</code><code></code><code>  addNumbers3(5, 6);</code><code></code><code>  return 0;</code><code>}</code></pre><p>The only way of using the lambda’s actual type is by means of <code>auto</code>. <code>auto</code> also has the benefit of having no overhead compared to <code>std::function</code>.</p><p>Unfortunately, prior to C++20, we can’t always use <code>auto</code>. In cases where the actual lambda is unknown (e.g. because we’re passing a lambda to a function as a parameter and the caller determines what lambda will be passed in), we can’t use <code>auto</code> without compromises. In such cases, <code>std::function</code> can be used instead.</p><pre class="language-cpp line-numbers"><code>#include <functional></functional></code><code>#include <iostream></iostream></code><code></code><code>// We don't know what fn will be. std::function works with regular functions and lambdas.</code><code>void repeat(int repetitions, const std::function<void(int)>&amp; fn)</void(int)></code><code>{</code><code>  for (int i{ 0 }; i &lt; repetitions; ++i)</code><code>  {</code><code>    fn(i);</code><code>  }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  repeat(3, [](int i) {</code><code>    std::cout &lt;&lt; i &lt;&lt; '\n';</code><code>  });</code><code></code><code>  return 0;</code><code>}</code></pre><p>Output</p><pre>0
1
2
</pre><p>If we had used <code>auto</code> for the type of <code>fn</code>, the caller of the function wouldn’t know what parameters and return type <code>fn</code> needs to have. This limitation was lifted in C++20 when abbreviated function templates were added.</p><p>Furthermore, because they are actually templates, functions with <code>auto</code> parameters cannot be separated into a header and source file.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Rule</h4><p>Use <code>auto</code> when initializing variables with lambdas, and <code>std::function</code> if you can’t initialize the variable with the lambda.</p></div><br><h3>Generic lambdas</h3><p>For the most part, lambda parameters work by the same rules as regular function parameters.</p><p>One notable exception is that since C++14 we’re allowed to use <code>auto</code> for parameters (note: in C++20, regular functions are able to use <code>auto</code> for parameters too). When a lambda has one or more <code>auto</code> parameter, the compiler will infer what parameter types are needed from the calls to the lambda.</p><p>Because lambdas with one or more <code>auto</code> parameter can potentially work with a wide variety of types, they are called <span class="cpp-definition">generic lambdas</span>.</p><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>When used in the context of a lambda, <code>auto</code> is just a shorthand for a template parameter.</p></div><p>Let’s take a look at a generic lambda:</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>int main()</code><code>{</code><code>  constexpr std::array months{ // pre-C++17 use std::array<const 12="" char*,=""></const></code><code>    "January",</code><code>    "February",</code><code>    "March",</code><code>    "April",</code><code>    "May",</code><code>    "June",</code><code>    "July",</code><code>    "August",</code><code>    "September",</code><code>    "October",</code><code>    "November",</code><code>    "December"</code><code>  };</code><code></code><code>  // Search for two consecutive months that start with the same letter.</code><code>  const auto sameLetter{ std::adjacent_find(months.begin(), months.end(),</code><code>                                      [](const auto&amp; a, const auto&amp; b) {</code><code>                                        return (a[0] == b[0]);</code><code>                                      }) };</code><code></code><code>  // Make sure that two months were found.</code><code>  if (sameLetter != months.end())</code><code>  {</code><code>    // std::next returns the next iterator after sameLetter</code><code>    std::cout &lt;&lt; *sameLetter &lt;&lt; " and " &lt;&lt; *std::next(sameLetter)</code><code>              &lt;&lt; " start with the same letter\n";</code><code>  }</code><code></code><code>  return 0;</code><code>}</code></pre><p>Output:</p><pre>June and July start with the same letter
</pre><p>In the above example, we use <code>auto</code> parameters to capture our strings by <code>const</code> reference. Because all string types allow access to their individual characters via <code>operator[]</code>, we don’t need to care whether the user is passing in a <code>std::string</code>, C-style string, or something else. This allows us to write a lambda that could accept any of these, meaning if we change the type of <code>months</code> later, we won’t have to rewrite the lambda.</p><p>However, <code>auto</code> isn’t always the best choice. Consider:</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>int main()</code><code>{</code><code>  constexpr std::array months{ // pre-C++17 use std::array<const 12="" char*,=""></const></code><code>    "January",</code><code>    "February",</code><code>    "March",</code><code>    "April",</code><code>    "May",</code><code>    "June",</code><code>    "July",</code><code>    "August",</code><code>    "September",</code><code>    "October",</code><code>    "November",</code><code>    "December"</code><code>  };</code><code></code><code>  // Count how many months consist of 5 letters</code><code>  const auto fiveLetterMonths{ std::count_if(months.begin(), months.end(),</code><code>                                       [](std::string_view str) {</code><code>                                         return (str.length() == 5);</code><code>                                       }) };</code><code></code><code>  std::cout &lt;&lt; "There are " &lt;&lt; fiveLetterMonths &lt;&lt; " months with 5 letters\n";</code><code></code><code>  return 0;</code><code>}</code></pre><p>Output:</p><pre>There are 2 months with 5 letters
</pre><p>In this example, using <code>auto</code> would infer a type of <code>const char*</code>. C-style strings aren’t easy to work with (apart from using <code>operator[]</code>). In this case, we prefer to explicitly define the parameter as a <code>std::string_view</code>, which allows us to work with the underlying data much more easily (e.g. we can ask the string view for its length, even if the user passed in a C-style array).</p><br><h3>Generic lambdas and static variables</h3><p>One thing to be aware of is that a unique lambda will be generated for each different type that <code>auto</code> resolves to. The following example shows how one generic lambda turns into two distinct lambdas:</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>int main()</code><code>{</code><code>  // Print a value and count how many times @print has been called.</code><code>  auto print{</code><code>    [](auto value) {</code><code>      static int callCount{ 0 };</code><code>      std::cout &lt;&lt; callCount++ &lt;&lt; ": " &lt;&lt; value &lt;&lt; '\n';</code><code>    }</code><code>  };</code><code></code><code>  print("hello"); // 0: hello</code><code>  print("world"); // 1: world</code><code></code><code>  print(1); // 0: 1</code><code>  print(2); // 1: 2</code><code></code><code>  print("ding dong"); // 2: ding dong</code><code></code><code>  return 0;</code><code>}</code></pre><p>Output</p><pre>0: hello
1: world
0: 1
1: 2
2: ding dong
</pre><p>In the above example, we define a lambda and then call it with two different parameters (a string literal parameter, and an integer parameter). This generates two different versions of the lambda (one with a string literal parameter, and one with an integer parameter).</p><p>Most of the time, this is inconsequential. However, note that if the generic lambda uses static duration variables, those variables are not shared between the generated lambdas.</p><p>We can see this in the example above, where each type (string literals and integers) has its own unique count! Although we only wrote the lambda once, two lambdas were generated -- and each has its own version of <code>callCount</code>. To have a shared counter between the two generated lambdas, we’d have to define a global variable or a <code>static</code> local variable outside of the lambda. As you know from previous lessons, both global- and static local variables can cause problems and make it more difficult to understand code. We’ll be able to avoid those variables after talking about lambda captures in the next lesson.</p><br><h3>Return type deduction and trailing return types</h3><p>If return type deduction is used, a lambda’s return type is deduced from the <code>return</code>-statements inside the lambda, and all return statements in the lambda must return the same type (otherwise the compiler won’t know which one to prefer).</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>  auto divide{ [](int x, int y, bool intDivision) { // note: no specified return type</code><code>    if (intDivision)</code><code>      return x / y; // return type is int</code><code>    else</code><code>      return static_cast<double>(x) / y; // ERROR: return type doesn't match previous return type</double></code><code>  } };</code><code></code><code>  std::cout &lt;&lt; divide(3, 2, true) &lt;&lt; '\n';</code><code>  std::cout &lt;&lt; divide(3, 2, false) &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><p>This produces a compile error because the return type of the first return statement (int) doesn’t match the return type of the second return statement (double).</p><p>In the case where we’re returning different types, we have two options:</p><ol start="1"><li>Do explicit casts to make all the return types match, or</li><li>explicitly specify a return type for the lambda, and let the compiler do implicit conversions.</li></ol><p>The second case is usually the better choice:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>  // note: explicitly specifying this returns a double</code><code>  auto divide{ [](int x, int y, bool intDivision) -&gt; double {</code><code>    if (intDivision)</code><code>      return x / y; // will do an implicit conversion of result to double</code><code>    else</code><code>      return static_cast<double>(x) / y;</double></code><code>  } };</code><code></code><code>  std::cout &lt;&lt; divide(3, 2, true) &lt;&lt; '\n';</code><code>  std::cout &lt;&lt; divide(3, 2, false) &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><p>That way, if you ever decide to change the return type, you (usually) only need to change the lambda’s return type, and not touch the lambda body.</p><br><h3>Standard library function objects</h3><p>For common operations (e.g. addition, negation, or comparison) you don’t need to write your own lambdas, because the standard library comes with many basic callable objects that can be used instead. These are defined in the <a href="https://en.cppreference.com/w/cpp/utility/functional#Operator_function_objects">&lt;functional&gt;</a> header.</p><p>In the following example:</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code></code><code>bool greater(int a, int b)</code><code>{</code><code>  // Order @a before @b if @a is greater than @b.</code><code>  return (a &gt; b);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  std::array arr{ 13, 90, 99, 5, 40, 80 };</code><code></code><code>  // Pass greater to std::sort</code><code>  std::sort(arr.begin(), arr.end(), greater);</code><code></code><code>  for (int i : arr)</code><code>  {</code><code>    std::cout &lt;&lt; i &lt;&lt; ' ';</code><code>  }</code><code></code><code>  std::cout &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><p>Output</p><pre>99 90 80 40 13 5
</pre><p>Instead of converting our <code>greater</code> function to a lambda (which would obscure its meaning a bit), we can instead use <code>std::greater</code>:</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <functional> // for std::greater</functional></code><code></code><code>int main()</code><code>{</code><code>  std::array arr{ 13, 90, 99, 5, 40, 80 };</code><code></code><code>  // Pass std::greater to std::sort</code><code>  std::sort(arr.begin(), arr.end(), std::greater{}); // note: need curly braces to instantiate object</code><code></code><code>  for (int i : arr)</code><code>  {</code><code>    std::cout &lt;&lt; i &lt;&lt; ' ';</code><code>  }</code><code></code><code>  std::cout &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><p>Output</p><pre>99 90 80 40 13 5
</pre><br><h3>Conclusion</h3><p>Lambdas and the algorithm library may seem unnecessarily complicated when compared to a solution that uses a loop. However, this combination can allow some very powerful operations in just a few lines of code, and can be more readable than writing your own loops. On top of that, the algorithm library features powerful and easy-to-use parallelism, which you won’t get with loops. Upgrading source code that uses library functions is easier than upgrading code that uses loops.</p><p>Lambdas are great, but they don’t replace regular functions for all cases. Prefer regular functions for non-trivial and reusable cases.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Create a <code>struct Student</code> that stores the name and points of a student. Create an array of students and use <a href="https://en.cppreference.com/w/cpp/algorithm/max_element"><code>std::max_element</code></a> to find the student with the most points, then print that student’s name. <code>std::max_element</code> takes the <code>begin</code> and <code>end</code> of a list, and a function that takes 2 parameters and returns <code>true</code> if the first argument is less than the second.</p><p>Given the following array</p><pre class="language-cpp line-numbers"><code>std::array<student, 8=""> arr{</student,></code><code>  { { "Albert", 3 },</code><code>    { "Ben", 5 },</code><code>    { "Christine", 2 },</code><code>    { "Dan", 8 }, // Dan has the most points (8).</code><code>    { "Enchilada", 4 },</code><code>    { "Francis", 1 },</code><code>    { "Greg", 3 },</code><code>    { "Hagrid", 5 } }</code><code>};</code></pre><p>your program should print</p><pre>Dan is the best student
</pre><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">Hint:<pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>struct Student</code><code>{</code><code>  std::string name{};</code><code>  int points{};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>  const std::array<student, 8=""> arr{</student,></code><code>    { { "Albert", 3 },</code><code>      { "Ben", 5 },</code><code>      { "Christine", 2 },</code><code>      { "Dan", 8 },</code><code>      { "Enchilada", 4 },</code><code>      { "Francis", 1 },</code><code>      { "Greg", 3 },</code><code>      { "Hagrid", 5 } }</code><code>  };</code><code></code><code>  const auto best{</code><code>    std::max_element(arr.begin(), arr.end(), /* lambda */)</code><code>  };</code><code></code><code>  std::cout &lt;&lt; best-&gt;name &lt;&lt; " is the best student\n";</code><code></code><code>  return 0;</code><code>}</code></pre></div><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>struct Student</code><code>{</code><code>  std::string name{};</code><code>  int points{};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>  const std::array<student, 8=""> arr{</student,></code><code>    { { "Albert", 3 },</code><code>      { "Ben", 5 },</code><code>      { "Christine", 2 },</code><code>      { "Dan", 8 },</code><code>      { "Enchilada", 4 },</code><code>      { "Francis", 1 },</code><code>      { "Greg", 3 },</code><code>      { "Hagrid", 5 } }</code><code>  };</code><code></code><code>  const auto best{</code><code>    std::max_element(arr.begin(), arr.end(), [](const auto&amp; a, const auto&amp; b) {</code><code>      return (a.points &lt; b.points);</code><code>    })</code><code>  };</code><code></code><code>  std::cout &lt;&lt; best-&gt;name &lt;&lt; " is the best student\n";</code><code></code><code>  return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>Use <code>std::sort</code> and a lambda in the following code to sort the seasons by ascending average temperature.</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>struct Season</code><code>{</code><code>  std::string_view name{};</code><code>  double averageTemperature{};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>  std::array<season, 4=""> seasons{</season,></code><code>    { { "Spring", 285.0 },</code><code>      { "Summer", 296.0 },</code><code>      { "Fall", 288.0 },</code><code>      { "Winter", 263.0 } }</code><code>  };</code><code></code><code>  /*</code><code>   * Use std::sort here</code><code>   */</code><code></code><code>  for (const auto&amp; season : seasons)</code><code>  {</code><code>    std::cout &lt;&lt; season.name &lt;&lt; '\n';</code><code>  }</code><code></code><code>  return 0;</code><code>}</code></pre><p>The program should print</p><pre>Winter
Spring
Fall
Summer
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>struct Season</code><code>{</code><code>  std::string_view name{};</code><code>  double averageTemperature{};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>  std::array<season, 4=""> seasons{</season,></code><code>    { { "Spring", 285.0 },</code><code>      { "Summer", 296.0 },</code><code>      { "Fall", 288.0 },</code><code>      { "Winter", 263.0 } }</code><code>  };</code><code></code><code>  // We can compare averageTemperature of the two arguments to</code><code>  // sort the array.</code><code>  std::sort(seasons.begin(), seasons.end(),</code><code>            [](const auto&amp; a, const auto&amp; b) {</code><code>              return (a.averageTemperature &lt; b.averageTemperature);</code><code>            });</code><code></code><code>  for (const auto&amp; season : seasons)</code><code>  {</code><code>    std::cout &lt;&lt; season.name &lt;&lt; '\n';</code><code>  }</code><code></code><code>  return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">12.8 — Lambda captures</h1></header><div class="entry-content" itemprop="articleBody"><p><br></p><br><h3>Capture clauses and capture by value</h3><p>In the previous lesson (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-lambdas-anonymous-functions/">12.7 -- Introduction to lambdas (anonymous functions)</a>), we introduced this example:</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>int main()</code><code>{</code><code>  std::array<std::string_view, 4=""> arr{ "apple", "banana", "walnut", "lemon" };</std::string_view,></code><code></code><code>  auto found{ std::find_if(arr.begin(), arr.end(),</code><code>                           [](std::string_view str)</code><code>                           {</code><code>                             return (str.find("nut") != std::string_view::npos);</code><code>                           }) };</code><code></code><code>  if (found == arr.end())</code><code>  {</code><code>    std::cout &lt;&lt; "No nuts\n";</code><code>  }</code><code>  else</code><code>  {</code><code>    std::cout &lt;&lt; "Found " &lt;&lt; *found &lt;&lt; '\n';</code><code>  }</code><code></code><code>  return 0;</code><code>}</code></pre><p>Now, let’s modify the nut example and let the user pick a substring to search for. This isn’t as intuitive as you might expect.</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>  std::array<std::string_view, 4=""> arr{ "apple", "banana", "walnut", "lemon" };</std::string_view,></code><code></code><code>  // Ask the user what to search for.</code><code>  std::cout &lt;&lt; "search for: ";</code><code></code><code>  std::string search{};</code><code>  std::cin &gt;&gt; search;</code><code></code><code>  auto found{ std::find_if(arr.begin(), arr.end(), [](std::string_view str) {</code><code>    // Search for @search rather than "nut".</code><code>    return (str.find(search) != std::string_view::npos); // Error: search not accessible in this scope</code><code>  }) };</code><code></code><code>  if (found == arr.end())</code><code>  {</code><code>    std::cout &lt;&lt; "Not found\n";</code><code>  }</code><code>  else</code><code>  {</code><code>    std::cout &lt;&lt; "Found " &lt;&lt; *found &lt;&lt; '\n';</code><code>  }</code><code></code><code>  return 0;</code><code>}</code></pre><p>This code won’t compile. Unlike nested blocks, where any identifier defined in an outer block is accessible in the scope of the nested block, lambdas can only access specific kinds of identifiers: global identifiers, entities that are known at compile time, and entities with static storage duration. <code>search</code> fulfills none of these requirements, so the lambda can’t see it. That’s what the capture clause is there for.</p><br><h3>The capture clause</h3><p>The <span class="cpp-definition">capture clause</span> is used to (indirectly) give a lambda access to variables available in the surrounding scope that it normally would not have access to. All we need to do is list the entities we want to access from within the lambda as part of the capture clause. In this case, we want to give our lambda access to the value of variable <code>search</code>, so we add it to the capture clause:</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>  std::array<std::string_view, 4=""> arr{ "apple", "banana", "walnut", "lemon" };</std::string_view,></code><code></code><code>  std::cout &lt;&lt; "search for: ";</code><code></code><code>  std::string search{};</code><code>  std::cin &gt;&gt; search;</code><code></code><code>  // Capture @search                                vvvvvv</code><code>  auto found{ std::find_if(arr.begin(), arr.end(), [search](std::string_view str) {</code><code>    return (str.find(search) != std::string_view::npos);</code><code>  }) };</code><code></code><code>  if (found == arr.end())</code><code>  {</code><code>    std::cout &lt;&lt; "Not found\n";</code><code>  }</code><code>  else</code><code>  {</code><code>    std::cout &lt;&lt; "Found " &lt;&lt; *found &lt;&lt; '\n';</code><code>  }</code><code></code><code>  return 0;</code><code>}</code></pre><p>The user can now search for an element of our array.</p><p>Output</p><pre>search for: nana
Found banana
</pre><br><h3>So how do captures actually work?</h3><p>While it might look like our lambda in the example above is directly accessing the value of <code>main</code>‘s <code>search</code> variable, this is not the case. Lambdas might look like nested blocks, but they work slightly differently (and the distinction is important).</p><p>When a lambda definition is executed, for each variable that the lambda captures, a clone of that variable is made (with an identical name) inside the lambda. These cloned variables are initialized from the outer scope variables of the same name at this point.</p><p>Thus, in the above example, when the lambda object is created, the lambda gets its own cloned variable named <code>search</code>. This cloned <code>search</code> has the same value as <code>main</code>‘s <code>search</code>, so it behaves like we’re accessing <code>main</code>‘s <code>search</code>, but we’re not.</p><p>While these cloned variables have the same name, they don’t necessarily have the same type as the original variable. We’ll explore this in the upcoming sections of this lesson.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p>The captured variables of a lambda are <em>clones</em> of the outer scope variables, not the actual variables.</p></div><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>Although lambdas look like functions, they’re actually objects that can be called like functions (these are called <span class="cpp-definition">functors</span> -- we’ll discuss how to create your own functors from scratch in a future lesson).</p><p>When the compiler encounters a lambda definition, it creates a custom object definition for the lambda. Each captured variable becomes a data member of the object.</p><p>At runtime, when the lambda definition is encountered, the lambda object is instantiated, and the members of the lambda are initialized at that point.</p></div><br><h3>Captures default to const value</h3><p>By default, variables are captured by <code>const value</code>. This means when the lambda is created, the lambda captures a constant copy of the outer scope variable, which means that the lambda is not allowed to modify them. In the following example, we capture the variable <code>ammo</code> and try to decrement it.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>  int ammo{ 10 };</code><code></code><code>  // Define a lambda and store it in a variable called "shoot".</code><code>  auto shoot{</code><code>    [ammo]() {</code><code>      // Illegal, ammo was captured as a const copy.</code><code>      --ammo;</code><code></code><code>      std::cout &lt;&lt; "Pew! " &lt;&lt; ammo &lt;&lt; " shot(s) left.\n";</code><code>    }</code><code>  };</code><code></code><code>  // Call the lambda</code><code>  shoot();</code><code></code><code>  std::cout &lt;&lt; ammo &lt;&lt; " shot(s) left\n";</code><code></code><code>  return 0;</code><code>}</code></pre><p>In the above example, when we capture <code>ammo</code>, a new <code>const</code> variable with the same name and value is created in the lambda. We can’t modify it, because it is <code>const</code>, which causes a compile error.</p><br><h3>Mutable capture by value</h3><p>To allow modifications of variables that were captured by value, we can mark the lambda as <code>mutable</code>. The <span class="cpp-definition">mutable</span> keyword in this context removes the <code>const</code> qualification from <em>all</em> variables captured by value.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>  int ammo{ 10 };</code><code></code><code>  auto shoot{</code><code>    // Added mutable after the parameter list.</code><code>    [ammo]() mutable {</code><code>      // We're allowed to modify ammo now</code><code>      --ammo;</code><code></code><code>      std::cout &lt;&lt; "Pew! " &lt;&lt; ammo &lt;&lt; " shot(s) left.\n";</code><code>    }</code><code>  };</code><code></code><code>  shoot();</code><code>  shoot();</code><code></code><code>  std::cout &lt;&lt; ammo &lt;&lt; " shot(s) left\n";</code><code></code><code>  return 0;</code><code>}</code></pre><p>Output:</p><pre>Pew! 9 shot(s) left.
Pew! 8 shot(s) left.
10 shot(s) left
</pre><p>While this now compiles, there’s still a logic error. What happened? When the lambda was called, the lambda captured a <em>copy</em> of <code>ammo</code>. When the lambda decremented <code>ammo</code> from <code>10</code> to <code>9</code> to <code>8</code>, it decremented its own copy, not the original value.</p><p>Note that the value of <code>ammo</code> is preserved across calls to the lambda!</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Because captured variables are members of the lambda object, their values are persisted across multiple calls to the lambda!</p></div><br><h3>Capture by reference</h3><p>Much like functions can change the value of arguments passed by reference, we can also capture variables by reference to allow our lambda to affect the value of the argument.</p><p>To capture a variable by reference, we prepend an ampersand (<code>&amp;</code>) to the variable name in the capture. Unlike variables that are captured by value, variables that are captured by reference are non-const, unless the variable they’re capturing is <code>const</code>. Capture by reference should be preferred over capture by value whenever you would normally prefer passing an argument to a function by reference (e.g. for non-fundamental types).</p><p>Here’s the above code with <code>ammo</code> captured by reference:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>  int ammo{ 10 };</code><code></code><code>  auto shoot{</code><code>    // We don't need mutable anymore</code><code>    [&amp;ammo]() { // &amp;ammo means ammo is captured by reference</code><code>      // Changes to ammo will affect main's ammo</code><code>      --ammo;</code><code></code><code>      std::cout &lt;&lt; "Pew! " &lt;&lt; ammo &lt;&lt; " shot(s) left.\n";</code><code>    }</code><code>  };</code><code></code><code>  shoot();</code><code></code><code>  std::cout &lt;&lt; ammo &lt;&lt; " shot(s) left\n";</code><code></code><code>  return 0;</code><code>}</code></pre><p>This produces the expected answer:</p><pre>Pew! 9 shot(s) left.
9 shot(s) left
</pre><p>Now, let’s use a reference capture to count how many comparisons <code>std::sort</code> makes when it sorts an array.</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>struct Car</code><code>{</code><code>  std::string make{};</code><code>  std::string model{};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>  std::array<car, 3=""> cars{ { { "Volkswagen", "Golf" },</car,></code><code>                             { "Toyota", "Corolla" },</code><code>                             { "Honda", "Civic" } } };</code><code></code><code>  int comparisons{ 0 };</code><code></code><code>  std::sort(cars.begin(), cars.end(),</code><code>    // Capture @comparisons by reference.</code><code>    [&amp;comparisons](const auto&amp; a, const auto&amp; b) {</code><code>      // We captured comparisons by reference. We can modify it without "mutable".</code><code>      ++comparisons;</code><code></code><code>      // Sort the cars by their make.</code><code>      return (a.make &lt; b.make);</code><code>  });</code><code></code><code>  std::cout &lt;&lt; "Comparisons: " &lt;&lt; comparisons &lt;&lt; '\n';</code><code></code><code>  for (const auto&amp; car : cars)</code><code>  {</code><code>    std::cout &lt;&lt; car.make &lt;&lt; ' ' &lt;&lt; car.model &lt;&lt; '\n';</code><code>  }</code><code></code><code>  return 0;</code><code>}</code></pre><p>Possible output</p><pre>Comparisons: 2
Honda Civic
Toyota Corolla
Volkswagen Golf
</pre><br><h3>Capturing multiple variables</h3><p>Multiple variables can be captured by separating them with a comma. This can include a mix of variables captured by value or by reference:</p><pre class="language-cpp line-numbers"><code>int health{ 33 };</code><code>int armor{ 100 };</code><code>std::vector<cenemy> enemies{};</cenemy></code><code></code><code>// Capture health and armor by value, and enemies by reference.</code><code>[health, armor, &amp;enemies](){};</code></pre><br><h3>Default captures</h3><p>Having to explicitly list the variables you want to capture can be burdensome. If you modify your lambda, you may forget to add or remove captured variables. Fortunately, we can enlist the compiler’s help to auto-generate a list of variables we need to capture.</p><p>A <span class="cpp-definition">default capture</span> (also called a <span class="cpp-definition">capture-default</span>) captures all variables that are mentioned in the lambda. Variables not mentioned in the lambda are not captured if a default capture is used.</p><p>To capture all used variables by value, use a capture value of <code>=</code>.<br>To capture all used variables by reference, use a capture value of <code>&amp;</code>.</p><p>Here’s an example of using a default capture by value:</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>  std::array areas{ 100, 25, 121, 40, 56 };</code><code></code><code>  int width{};</code><code>  int height{};</code><code></code><code>  std::cout &lt;&lt; "Enter width and height: ";</code><code>  std::cin &gt;&gt; width &gt;&gt; height;</code><code></code><code>  auto found{ std::find_if(areas.begin(), areas.end(),</code><code>                           [=](int knownArea) { // will default capture width and height by value</code><code>                             return (width * height == knownArea); // because they're mentioned here</code><code>                           }) };</code><code></code><code>  if (found == areas.end())</code><code>  {</code><code>    std::cout &lt;&lt; "I don't know this area :(\n";</code><code>  }</code><code>  else</code><code>  {</code><code>    std::cout &lt;&lt; "Area found :)\n";</code><code>  }</code><code></code><code>  return 0;</code><code>}</code></pre><p>Default captures can be mixed with normal captures. We can capture some variables by value and others by reference, but each variable can only be captured once.</p><pre class="language-cpp line-numbers"><code>int health{ 33 };</code><code>int armor{ 100 };</code><code>std::vector<cenemy> enemies{};</cenemy></code><code></code><code>// Capture health and armor by value, and enemies by reference.</code><code>[health, armor, &amp;enemies](){};</code><code></code><code>// Capture enemies by reference and everything else by value.</code><code>[=, &amp;enemies](){};</code><code></code><code>// Capture armor by value and everything else by reference.</code><code>[&amp;, armor](){};</code><code></code><code>// Illegal, we already said we want to capture everything by reference.</code><code>[&amp;, &amp;armor](){};</code><code></code><code>// Illegal, we already said we want to capture everything by value.</code><code>[=, armor](){};</code><code></code><code>// Illegal, armor appears twice.</code><code>[armor, &amp;health, &amp;armor](){};</code><code></code><code>// Illegal, the default capture has to be the first element in the capture group.</code><code>[armor, &amp;](){};</code></pre><br><h3>Defining new variables in the lambda-capture</h3><p>Sometimes we want to capture a variable with a slight modification or declare a new variable that is only visible in the scope of the lambda. We can do so by defining a variable in the lambda-capture without specifying its type.</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <algorithm></algorithm></code><code></code><code>int main()</code><code>{</code><code>  std::array areas{ 100, 25, 121, 40, 56 };</code><code></code><code>  int width{};</code><code>  int height{};</code><code></code><code>  std::cout &lt;&lt; "Enter width and height: ";</code><code>  std::cin &gt;&gt; width &gt;&gt; height;</code><code></code><code>  // We store areas, but the user entered width and height.</code><code>  // We need to calculate the area before we can search for it.</code><code>  auto found{ std::find_if(areas.begin(), areas.end(),</code><code>                           // Declare a new variable that's visible only to the lambda.</code><code>                           // The type of userArea is automatically deduced to int.</code><code>                           [userArea{ width * height }](int knownArea) {</code><code>                             return (userArea == knownArea);</code><code>                           }) };</code><code></code><code>  if (found == areas.end())</code><code>  {</code><code>    std::cout &lt;&lt; "I don't know this area :(\n";</code><code>  }</code><code>  else</code><code>  {</code><code>    std::cout &lt;&lt; "Area found :)\n";</code><code>  }</code><code></code><code>  return 0;</code><code>}</code></pre><p><code>userArea</code> will only be calculated once when the lambda is defined. The calculated area is stored in the lambda object and is the same for every call. If a lambda is mutable and modifies a variable that was defined in the capture, the original value will be overridden.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Only initialize variables in the capture if their value is short and their type is obvious. Otherwise it’s best to define the variable outside of the lambda and capture it.</p></div><br><h3>Dangling captured variables</h3><p>Variables are captured at the point where the lambda is defined. If a variable captured by reference dies before the lambda, the lambda will be left holding a dangling reference.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>// returns a lambda</code><code>auto makeWalrus(const std::string&amp; name)</code><code>{</code><code>  // Capture name by reference and return the lambda.</code><code>  return [&amp;]() {</code><code>    std::cout &lt;&lt; "I am a walrus, my name is " &lt;&lt; name &lt;&lt; '\n'; // Undefined behavior</code><code>  };</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  // Create a new walrus whose name is Roofus.</code><code>  // sayName is the lambda returned by makeWalrus.</code><code>  auto sayName{ makeWalrus("Roofus") };</code><code></code><code>  // Call the lambda function that makeWalrus returned.</code><code>  sayName();</code><code></code><code>  return 0;</code><code>}</code></pre><p>The call to <code>makeWalrus</code> creates a temporary <code>std::string</code> from the string literal “Roofus”. The lambda in <code>makeWalrus</code> captures the temporary string by reference. The temporary string dies when <code>makeWalrus</code> returns, but the lambda still references it. Then when we call <code>sayName</code>, the dangling reference is accessed, causing undefined behavior.</p><p>Note that this also happens if <code>name</code> is passed to <code>makeWalrus</code> by value. The variable <code>name</code> still dies at the end of <code>makeWalrus</code>, and the lambda is left holding a dangling reference.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Be extra careful when you capture variables by reference, especially with a default reference capture. The captured variables must outlive the lambda.</p></div><p>If we want the captured <code>name</code> to be valid when the lambda is used, we need to capture it by value instead (either explicitly or using a default-capture by value).</p><br><h3>Unintended copies of mutable lambdas </h3><p>Because lambdas are objects, they can be copied. In some cases, this can cause problems. Consider the following code:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>  int i{ 0 };</code><code></code><code>  // Create a new lambda named count</code><code>  auto count{ [i]() mutable {</code><code>    std::cout &lt;&lt; ++i &lt;&lt; '\n';</code><code>  } };</code><code></code><code>  count(); // invoke count</code><code></code><code>  auto otherCount{ count }; // create a copy of count</code><code></code><code>  // invoke both count and the copy</code><code>  count();</code><code>  otherCount();</code><code></code><code>  return 0;</code><code>}</code></pre><p>Output</p><pre>1
2
2
</pre><p>Rather than printing 1, 2, 3, the code prints 2 twice. When we created <code>otherCount</code> as a copy of <code>count</code>, we created a copy of <code>count</code> in its current state. <code>count</code>‘s <code>i</code> was 1, so <code>otherCount</code>‘s <code>i</code> is 1 as well. Since <code>otherCount</code> is a copy of <code>count</code>, they each have their own <code>i</code>.</p><p>Now let’s take a look at a slightly less obvious example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <functional></functional></code><code></code><code>void myInvoke(const std::function<void()>&amp; fn)</void()></code><code>{</code><code>    fn();</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int i{ 0 };</code><code></code><code>    // Increments and prints its local copy of @i.</code><code>    auto count{ [i]() mutable {</code><code>      std::cout &lt;&lt; ++i &lt;&lt; '\n';</code><code>    } };</code><code></code><code>    myInvoke(count);</code><code>    myInvoke(count);</code><code>    myInvoke(count);</code><code></code><code>    return 0;</code><code>}</code></pre><p>Output:</p><pre>1
1
1
</pre><p>This exhibits the same problem as the prior example in a more obscure form. When <code>std::function</code> is created with a lambda, the <code>std::function</code> internally makes a copy of the lambda object. Thus, our call to <code>fn()</code> is actually being executed on the copy of our lambda, not the actual lambda.</p><p>If we need to pass a mutable lambda, and want to avoid the possibility of inadvertent copies being made, there are two options. One option is to use a non-capturing lambda instead -- in the above case, we could remove the capture and track our state using a static local variable instead. But static local variables can be difficult to keep track of and make our code less readable. A better option is to prevent copies of our lambda from being made in the first place. But since we can’t affect how <code>std::function</code> (or other standard library functions or objects) are implemented, how can we do this?</p><p>Fortunately, C++ provides a convenient type (as part of the &lt;functional&gt; header) called <code>std::reference_wrapper</code> that allows us to pass a normal type as if it was a reference. For even more convenience, a <code>std::reference_wrapper</code> can be created by using the <code>std::ref()</code> function. By wrapping our lambda in a <code>std::reference_wrapper</code>, whenever anybody tries to make a copy of our lambda, they’ll make a copy of the reference instead, which will copy the reference rather than the actual object.</p><p>Here’s our updated code using <code>std::ref</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <functional></functional></code><code></code><code>void myInvoke(const std::function<void()>&amp; fn)</void()></code><code>{</code><code>    fn();</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int i{ 0 };</code><code></code><code>    // Increments and prints its local copy of @i.</code><code>    auto count{ [i]() mutable {</code><code>      std::cout &lt;&lt; ++i &lt;&lt; '\n';</code><code>    } };</code><code></code><code>    // std::ref(count) ensures count is treated like a reference</code><code>    // thus, anything that tries to copy count will actually copy the reference</code><code>    // ensuring that only one count exists</code><code>    myInvoke(std::ref(count));</code><code>    myInvoke(std::ref(count));</code><code>    myInvoke(std::ref(count));</code><code></code><code>    return 0;</code><code>}</code></pre><p>Our output is now as expected:</p><pre>1
2
3
</pre><p>Note that the output doesn’t change even if <code>invoke</code> takes <code>fn</code> by value. <code>std::function</code> doesn’t create a copy of the lambda if we create it with <code>std::ref</code>.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Rule</h4><p>Standard library functions may copy function objects (reminder: lambdas are function objects). If you want to provide lambdas with mutable captured variables, pass them by reference using <code>std::ref</code>.</p></div><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Try to avoid mutable lambdas. Non-mutable lambdas are easier to understand and don’t suffer from the above issues, as well as more dangerous issues that arise when you add parallel execution.</p></div><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Which of the following variables can be used by the lambda in <code>main</code> without explicitly capturing them?</p><pre class="language-cpp line-numbers"><code>int i{};</code><code>static int j{};</code><code></code><code>int getValue()</code><code>{</code><code>  return 0;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  int a{};</code><code>  constexpr int b{};</code><code>  static int c{};</code><code>  static constexpr int d{};</code><code>  const int e{};</code><code>  const int f{ getValue() };</code><code>  static const int g{}; </code><code>  static const int h{ getValue() }; </code><code></code><code>  [](){</code><code>    // Try to use the variables without explicitly capturing them.</code><code>    a;</code><code>    b;</code><code>    c;</code><code>    d;</code><code>    e;</code><code>    f;</code><code>    g;</code><code>    h;</code><code>    i;</code><code>    j;</code><code>  }();</code><code></code><code>  return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Variable</th><th>Usable without explicit capture</th></tr><tr><td><code>a</code></td><td>No. <code>a</code> has automatic storage duration.</td></tr><tr><td><code>b</code></td><td>Yes. <code>b</code> is usable in a constant expression.</td></tr><tr><td><code>c</code></td><td>Yes. <code>c</code> has static storage duration.</td></tr><tr><td><code>d</code></td><td>Yes.</td></tr><tr><td><code>e</code></td><td>Yes. <code>e</code> is usable in a constant expression.</td></tr><tr><td><code>f</code></td><td>No. <code>f</code>‘s value depends on <code>getValue</code>, which might require the program to run.</td></tr><tr><td><code>g</code></td><td>Yes.</td></tr><tr><td><code>h</code></td><td>Yes. <code>h</code> has static storage duration.</td></tr><tr><td><code>i</code></td><td>Yes. <code>i</code> is a global variable.</td></tr><tr><td><code>j</code></td><td>Yes. <code>j</code> is accessible in the entire file.</td></tr></tbody></table></div></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>What does the following code print? Don’t run the code, work it out in your head.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>  std::string favoriteFruit{ "grapes" };</code><code></code><code>  auto printFavoriteFruit{</code><code>    [=]() {</code><code>      std::cout &lt;&lt; "I like " &lt;&lt; favoriteFruit &lt;&lt; '\n';</code><code>    }</code><code>  };</code><code></code><code>  favoriteFruit = "bananas with chocolate";</code><code></code><code>  printFavoriteFruit();</code><code></code><code>  return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre>I like grapes
</pre><p><code>printFavoriteFruit</code> captured <code>favoriteFruit</code> by value. Modifying <code>main</code>‘s <code>favoriteFruit</code> doesn’t affect the lambda’s <code>favoriteFruit</code>.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>We’re going to write a little game with square numbers (numbers which can be created by multiplying an integer with itself (1, 4, 9, 16, 25, …)).</p><p>Ask the user to input 2 numbers, the first is the square root of the number to start at, the second is the amount of numbers to generate. Generate a random integer from 2 to 4, and square numbers in the range that was chosen by the user. Multiply each square number by the random number. You can assume that the user enters valid numbers.</p><p>The user has to calculate which numbers have been generated. The program checks if the user guessed correctly and removes the guessed number from the list. If the user guessed wrong, the game is over and the program prints the number that was closest to the user’s final guess, but only if the final guess was not off by more than 4.</p><p>Here are a couple of sample sessions to give you a better understanding of how the game works:</p><pre>Start where? 4
How many? 8
I generated 8 square numbers. Do you know what each number is after multiplying it by 2?
&gt; 32
Nice! 7 number(s) left.
&gt; 72
Nice! 6 number(s) left.
&gt; 50
Nice! 5 number(s) left.
&gt; 126
126 is wrong! Try 128 next time.
</pre><ul><li>The user chose to start at 4 and wants to play with 8 numbers.</li><li>Each square number will be multiplied by 2. 2 was randomly chosen by the program.</li><li>The program generates 8 square numbers, starting with 4 as a base:</li><li>16 25 36 49 64 81 100 121</li><li>But each number is multiplied by 2, so we get:</li><li>32 50 72 98 128 162 200 242</li><li>Now the user starts to guess. The order in which the guesses are entered doesn’t matter.</li><li>32 is in the list.</li><li>72 is in the list.</li><li>126 is not in the list, the user loses. There is a number in the list (128) that is not more then 4 away from the user’s guess, so that number is printed.</li></ul><pre>Start where? 1
How many? 3
I generated 3 square numbers. Do you know what each number is after multiplying it by 4?
&gt; 4
Nice! 2 numbers left.
&gt; 16
Nice! 1 numbers left.
&gt; 36
Nice! You found all numbers, good job!
</pre><ul><li>The user chose to start at 1 and wants to play with 3 numbers.</li><li>Each square number will be multiplied by 4.</li><li>The program generates these square numbers:</li><li>1 4 9</li><li>Multiplied by 4</li><li>4 16 36</li><li>The user guesses all numbers correctly and wins the game.</li></ul><pre>Start where? 2
How many? 2
I generated 2 square numbers. Do you know what each number is after multiplying it by 4?
&gt; 21
21 is wrong!
</pre><ul><li>The user chose to start at 2 and wants to play with 2 numbers.</li><li>Each square number will be multiplied by 4.</li><li>The program generates these numbers:</li><li>16 36</li><li>The user guesses 21 and loses. 21 is not close enough to any of the remaining numbers, so no number is printed.</li></ul><p>Use <code>std::find</code> (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-standard-library-algorithms/#std_find">11.19 -- Introduction to standard library algorithms</a>) to search for a number in the list.<br>Use <code>std::vector::erase</code> to remove an element, e.g.</p><pre class="language-cpp line-numbers"><code>auto found{ std::find(/* ... */) };</code><code></code><code>// Make sure the element was found</code><code></code><code>myVector.erase(found);</code></pre><p>Use <code>std::min_element</code> and a lambda to find the number closest to the user’s guess. <code>std::min_element</code> works analogous to <code>std::max_element</code> from the previous quiz.</p><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">Hint: Use <code>std::abs</code> from &lt;cmath&gt; to calculate the positive difference between two numbers.<pre class="language-cpp line-numbers"><code>int distance{ std::abs(3 - 5) }; // 2</code></pre></div><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><pre class="language-cpp line-numbers"><code>#include <algorithm> // std::find, std::min_element</algorithm></code><code>#include <cmath> // std::abs</cmath></code><code>#include <ctime></ctime></code><code>#include <iostream></iostream></code><code>#include <random></random></code><code>#include <vector></vector></code><code></code><code>using Numbers = std::vector<int>;</int></code><code></code><code>namespace config</code><code>{</code><code>  constexpr int multiplierMin{ 2 };</code><code>  constexpr int multiplierMax{ 4 };</code><code>  constexpr int maximumWrongAnswer{ 4 };</code><code>}</code><code></code><code>int getRandomInt(int min, int max)</code><code>{</code><code>  static std::mt19937 mt{ static_cast<std::mt19937::result_type>(std::time(nullptr)) };</std::mt19937::result_type></code><code></code><code>  return std::uniform_int_distribution{ min, max }(mt);</code><code>}</code><code></code><code>// Generates @count numbers starting at @start*@start and multiplies</code><code>// every square number by multiplier.</code><code>Numbers generateNumbers(int start, int count, int multiplier)</code><code>{</code><code>  Numbers numbers(static_cast<numbers::size_type>(count));</numbers::size_type></code><code></code><code>  int i{ start };</code><code></code><code>  for (auto&amp; number : numbers)</code><code>  {</code><code>    number = ((i * i) * multiplier);</code><code>    ++i;</code><code>  }</code><code></code><code>  return numbers;</code><code>}</code><code></code><code>// Asks the user to input start and amount, then calls @generateNumbers.</code><code>Numbers generateUserNumbers(int multiplier)</code><code>{</code><code>  int start{};</code><code>  int count{};</code><code></code><code>  std::cout &lt;&lt; "Start where? ";</code><code>  std::cin &gt;&gt; start;</code><code></code><code>  std::cout &lt;&lt; "How many? ";</code><code>  std::cin &gt;&gt; count;</code><code></code><code>  // Input validation omitted. All functions assume valid input.</code><code></code><code>  return generateNumbers(start, count, multiplier);</code><code>}</code><code></code><code>int getUserGuess()</code><code>{</code><code>  int guess{};</code><code></code><code>  std::cout &lt;&lt; "&gt; ";</code><code>  std::cin &gt;&gt; guess;</code><code></code><code>  return guess;</code><code>}</code><code></code><code>// Searches for the value @guess in @numbers and removes it.</code><code>// Returns true if the value was found. False otherwise.</code><code>bool findAndRemove(Numbers&amp; numbers, int guess)</code><code>{</code><code>  auto found{ std::find(numbers.begin(), numbers.end(), guess) };</code><code></code><code>  if (found == numbers.end())</code><code>  {</code><code>    return false;</code><code>  }</code><code>  else</code><code>  {</code><code>    numbers.erase(found);</code><code>    return true;</code><code>  }</code><code>}</code><code></code><code>// Finds the value in @numbers that is closest to @guess.</code><code>int findClosestNumber(const Numbers&amp; numbers, int guess)</code><code>{</code><code>  return *std::min_element(numbers.begin(), numbers.end(), [=](int a, int b) {</code><code>    return (std::abs(a - guess) &lt; std::abs(b - guess));</code><code>  });</code><code>}</code><code></code><code>void printTask(Numbers::size_type count, int multiplier)</code><code>{</code><code>  std::cout &lt;&lt; "I generated " &lt;&lt; count</code><code>            &lt;&lt; " square numbers. Do you know what each number is after multiplying it by "</code><code>            &lt;&lt; multiplier &lt;&lt; "?\n";</code><code>}</code><code></code><code>// Called when the user guesses a number correctly.</code><code>void printSuccess(Numbers::size_type numbersLeft)</code><code>{</code><code>  std::cout &lt;&lt; "Nice! ";</code><code></code><code>  if (numbersLeft == 0)</code><code>  {</code><code>    std::cout &lt;&lt; "You found all numbers, good job!\n";</code><code>  }</code><code>  else</code><code>  {</code><code>    std::cout &lt;&lt; numbersLeft &lt;&lt; " number(s) left.\n";</code><code>  }</code><code>}</code><code></code><code>// Called when the user guesses a number that is not in the numbers.</code><code>void printFailure(const Numbers&amp; numbers, int guess)</code><code>{</code><code>  int closest{ findClosestNumber(numbers, guess) };</code><code></code><code>  std::cout &lt;&lt; guess &lt;&lt; " is wrong!";</code><code></code><code>  if (std::abs(closest - guess) &lt;= config::maximumWrongAnswer)</code><code>  {</code><code>    std::cout &lt;&lt; " Try " &lt;&lt; closest &lt;&lt; " next time.\n";</code><code>  }</code><code>  else</code><code>  {</code><code>    std::cout &lt;&lt; '\n';</code><code>  }</code><code>}</code><code></code><code>// Returns false if the game is over. True otherwise.</code><code>bool playRound(Numbers&amp; numbers)</code><code>{</code><code>  int guess{ getUserGuess() };</code><code></code><code>  if (findAndRemove(numbers, guess))</code><code>  {</code><code>    printSuccess(numbers.size());</code><code></code><code>    return !numbers.empty();</code><code>  }</code><code>  else</code><code>  {</code><code>    printFailure(numbers, guess);</code><code>    return false;</code><code>  }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  int multiplier{ getRandomInt(config::multiplierMin, config::multiplierMax) };</code><code>  Numbers numbers{ generateUserNumbers(multiplier) };</code><code></code><code>  printTask(numbers.size(), multiplier);</code><code></code><code>  while (playRound(numbers))</code><code>    ;</code><code></code><code>  return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">12.x — Chapter 12 comprehensive quiz</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Chapter Review</h3><p>Another chapter down! The next chapter is the best one, and you’re almost there! There’s just this pesky quiz to get past…</p><p>Function arguments can be passed by value, reference or address. Use pass by value for fundamental data types and enumerators. Use pass by reference for structs, classes, or when you need the function to modify an argument. Use pass by address for passing pointers or built-in arrays. Make your pass by reference and address parameters const whenever possible.</p><p>Values can be returned by value, reference, or address. Most of the time, return by value is fine, however return by reference or address can be useful when working with dynamically allocated data, structs, or classes. If returning by reference or address, remember to make sure you’re not returning something that will go out of scope.</p><p>Function pointers allow us to pass a function to another function. This can be useful to allow the caller to customize the behavior of a function, such as the way a list gets sorted.</p><p>Dynamic memory is allocated on the heap.</p><p>The call stack keeps track of all of the active functions (those that have been called but have not yet terminated) from the start of the program to the current point of execution. Local variables are allocated on the stack. The stack has a limited size. std::vector can be used to implement stack-like behavior.</p><p>A recursive function is a function that calls itself. All recursive functions need a termination condition.</p><p>Command line arguments allow users or other programs to pass data into our program at startup. Command line arguments are always C-style strings, and have to be converted to numbers if numeric values are desired.</p><p>Ellipsis allow you to pass a variable number of arguments to a function. However, ellipsis arguments suspend type checking, and do not know how many arguments were passed. It is up to the program to keep track of these details.</p><p>Lambda functions are functions that can be nested inside other functions. They don’t need a name and are very useful in combination with the algorithms library.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Write function prototypes for the following cases. Use const if/when necessary.</p><p>a) A function named max() that takes two doubles and returns the larger of the two.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>double max(double x, double y);</code></pre></div><p>b) A function named swap() that swaps two integers.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>void swap(int&amp; x, int&amp; y);</code></pre></div><p>c) A function named getLargestElement() that takes a dynamically allocated array of integers and returns the largest number in such a way that the caller can change the value of the element returned (don’t forget the length parameter).</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><pre class="language-cpp line-numbers"><code>// Note: array can't be const in this case, because returning a non-const reference to a const element would be a const violation.</code><code>int&amp; getLargestElement(int* array, int length);</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>What’s wrong with these programs?</p><p>a)</p><pre class="language-cpp line-numbers"><code>int&amp; doSomething()</code><code>{</code><code>    int array[]{ 1, 2, 3, 4, 5 };</code><code>    return array[3];</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><p>doSomething() returns a reference to a local variable that will be destroyed when doSomething terminates.</p></div><p>b)</p><pre class="language-cpp line-numbers"><code>int sumTo(int value)</code><code>{</code><code>    return value + sumTo(value - 1);</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><p>function sumTo () has no termination condition. Variable value will eventually go negative, and the function will loop infinitely until the stack overflows.</p></div><p>c)</p><pre class="language-cpp line-numbers"><code>float divide(float x, float y)</code><code>{</code><code>    return x / y;</code><code>}</code><code></code><code>double divide(float x, float y)</code><code>{</code><code>    return x / y;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><p>The two divide functions are not distinct, as they have the same name and same parameters. There is also a potential divide by 0 issue.</p></div><p>d)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int array[100000000]{};</code><code></code><code>    for (auto x: array)</code><code>        std::cout &lt;&lt; x &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none"><p>The array is too large to be allocated on the stack. It should be dynamically allocated.</p></div><p>e)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main(int argc, char* argv[])</code><code>{</code><code>    int age{ argv[1] };</code><code>    std::cout &lt;&lt; "The user's age is " &lt;&lt; age &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_7'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_7" style="display:none"><p>argv[1] may not exist. If it does, argv[1] is a string argument, and can’t be converted to an integer via assignment.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>The best algorithm for determining whether a value exists in a sorted array is called binary search.</p><p>Binary search works as follows:</p><ul><li>Look at the center element of the array (if the array has an even number of elements, round down).</li><li>If the center element is greater than the target element, discard the top half of the array (or recurse on the bottom half)</li><li>If the center element is less than the target element, discard the bottom half of the array (or recurse on the top half).</li><li>If the center element equals the target element, return the index of the center element.</li><li>If you discard the entire array without finding the target element, return a sentinel that represents “not found” (in this case, we’ll use -1, since it’s an invalid array index).</li></ul><p>Because we can throw out half of the array with each iteration, this algorithm is very fast. Even with an array of a million elements, it only takes at most 20 iterations to determine whether a value exists in the array or not! However, it only works on sorted arrays.</p><p>Modifying an array (e.g. discarding half the elements in an array) is expensive, so typically we do not modify the array. Instead, we use two integers (min and max) to hold the indices of the minimum and maximum elements of the array that we’re interested in examining.</p><p>Let’s look at a sample of how this algorithm works, given an array { 3, 6, 7, 9, 12, 15, 18, 21, 24 }, and a target value of 7. At first, min = 0, max = 8, because we’re searching the whole array (the array is length 9, so the index of the last element is 8).</p><ul><li>Pass 1) We calculate the midpoint of min (0) and max (8), which is 4. Element #4 has value 12, which is larger than our target value. Because the array is sorted, we know that all elements with index equal to or greater than the midpoint (4) must be too large. So we leave min alone, and set max to 3.</li><li>Pass 2) We calculate the midpoint of min (0) and max (3), which is 1. Element #1 has value 6, which is smaller than our target value. Because the array is sorted, we know that all elements with index equal to or lesser than the midpoint (1) must be too small. So we set min to 2, and leave max alone.</li><li>Pass 3) We calculate the midpoint of min (2) and max (3), which is 2. Element #2 has value 7, which is our target value. So we return 2.</li></ul><p>Given the following code:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <iterator></iterator></code><code></code><code>// array is the array to search over.</code><code>// target is the value we're trying to determine exists or not.</code><code>// min is the index of the lower bounds of the array we're searching.</code><code>// max is the index of the upper bounds of the array we're searching.</code><code>// binarySearch() should return the index of the target element if the target is found, -1 otherwise</code><code>int binarySearch(const int* array, int target, int min, int max)</code><code>{</code><code></code><code>}</code><code></code><code>int main()</code><code>{</code><code>    constexpr int array[]{ 3, 6, 8, 12, 14, 17, 20, 21, 26, 32, 36, 37, 42, 44, 48 };</code><code></code><code>    // We're going to test a bunch of values to see if they produce the expected results</code><code>    constexpr int numTestValues{ 9 };</code><code>    // Here are the test values</code><code>    constexpr int testValues[numTestValues]{ 0, 3, 12, 13, 22, 26, 43, 44, 49 };</code><code>    // And here are the expected results for each value</code><code>    int expectedValues[numTestValues]{ -1, 0, 3, -1, -1, 8, -1, 13, -1 };</code><code></code><code>    // Loop through all of the test values</code><code>    for (int count{ 0 }; count &lt; numTestValues; ++count)</code><code>    {</code><code>        // See if our test value is in the array</code><code>        int index{ binarySearch(array, testValues[count], 0, static_cast<int>(std::size(array)) - 1) };</int></code><code>        // If it matches our expected value, then great!</code><code>        if (index == expectedValues[count])</code><code>             std::cout &lt;&lt; "test value " &lt;&lt; testValues[count] &lt;&lt; " passed!\n";</code><code>        else // otherwise, our binarySearch() function must be broken</code><code>             std::cout &lt;&lt; "test value " &lt;&lt; testValues[count] &lt;&lt; " failed.  There's something wrong with your code!\n";</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>a) Write an iterative version of the binarySearch function.</p><p>Hint: You can safely say the target element doesn’t exist when the min index is greater than the max index.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_8'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_8" style="display:none"><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code>#include <numeric> // for std::midpoint</numeric></code><code></code><code>// array is the array to search over.</code><code>// target is the value we're trying to determine exists or not.</code><code>// min is the index of the lower bounds of the array we're searching.</code><code>// max is the index of the upper bounds of the array we're searching.</code><code>// binarySearch() should return the index of the target element if the target is found, -1 otherwise</code><code>int binarySearch(const int* array, int target, int min, int max)</code><code>{</code><code>    assert(array); // make sure array exists</code><code></code><code>    while (min &lt;= max)</code><code>    {</code><code>        // implement this iteratively</code><code>        int midpoint{ std::midpoint(min, max) };</code><code>        // Before C++20</code><code>        // int midpoint{ min + ((max-min) / 2) }; // this way of calculating midpoint avoids overflow</code><code></code><code>        if (array[midpoint] &gt; target)</code><code>        {</code><code>            // if array[midpoint] &gt; target, then we know the number must be in the lower half of the array</code><code>            // we can use midpoint - 1 as the upper index, since we don't need to retest the midpoint next iteration</code><code>            max = midpoint - 1;</code><code>        }</code><code>        else if (array[midpoint] &lt; target)</code><code>        {</code><code>            // if array[midpoint] &lt; target, then we know the number must be in the upper half of the array</code><code>            // we can use midpoint + 1 as the lower index, since we don't need to retest the midpoint next iteration</code><code>            min = midpoint + 1;</code><code>        }</code><code>        else</code><code>        {</code><code>            return midpoint;</code><code>        }</code><code>    }</code><code>    </code><code>    return -1;</code><code>}</code></pre></div><p>b) Write a recursive version of the binarySearch function.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_9'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_9" style="display:none"><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code>#include <numeric> // for std::midpoint</numeric></code><code></code><code>// array is the array to search over.</code><code>// target is the value we're trying to determine exists or not.</code><code>// min is the index of the lower bounds of the array we're searching.</code><code>// max is the index of the upper bounds of the array we're searching.</code><code>// binarySearch() should return the index of the target element if the target is found, -1 otherwise</code><code>int binarySearch(const int* array, int target, int min, int max)</code><code>{</code><code>    assert(array); // make sure array exists</code><code></code><code>    // implement this recursively</code><code></code><code>    if (min &gt; max)</code><code>        return -1;</code><code></code><code>    int midpoint{ std::midpoint(min, max) };</code><code>    // Before C++20</code><code>    // int midpoint{ min + ((max-min) / 2) }; // this way of calculating midpoint avoids overflow</code><code></code><code>    if (array[midpoint] &gt; target)</code><code>    {</code><code>        return binarySearch(array, target, min, midpoint - 1);</code><code>    }</code><code>    else if (array[midpoint] &lt; target)</code><code>    {</code><code>        return binarySearch(array, target, midpoint + 1, max);</code><code>    }</code><code>    else</code><code>    {</code><code>        return midpoint;</code><code>    }</code><code>}</code></pre></div><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p><a href="https://en.cppreference.com/w/cpp/algorithm/binary_search"><code>std::binary_search</code></a> returns true if a value exists in a sorted list.<br><a href="https://en.cppreference.com/w/cpp/algorithm/equal_range"><code>std::equal_range</code></a> returns the iterators to the first and last element with a given value.</p><p>Don’t use these functions to solve the quiz, but use them in the future if you need a binary search.</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">13.1 — Welcome to object-oriented programming</h1></header><div class="entry-content" itemprop="articleBody"><p>Back in lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-objects-and-variables/">1.3 -- Introduction to objects and variables</a>, we defined an object in C++ as, “a piece of memory that can be used to store values”. An object with a name is called a variable.</p><p>In traditional programming (what we’ve been doing prior to this point), programs are basically lists of instructions to the computer that define data (via objects) and then work with that data (via statements and functions). Data and the functions that work on that data are separate entities that are combined together to produce the desired result. Because of this separation, traditional programming often does not provide a very intuitive representation of reality. It’s up to the programmer to manage and connect the properties (variables) to the behaviors (functions) in an appropriate manner. This leads to code that looks like this:</p><pre class="language-cpp line-numbers"><code>driveTo(you, work);</code></pre><p>So what is object-oriented programming? As with many things, it is perhaps understood most easily through use of an analogy. Take a look around you -- everywhere you look are objects: books and buildings and food and even you. Objects have two major components to them: 1) A list of relevant properties (e.g. weight, color, size, solidity, shape, etc…), and 2) Some number of behaviors that they can exhibit (e.g. being opened, making something else hot, etc…). These properties and behaviors are inseparable.</p><p>Object-oriented programming (OOP) provides us with the ability to create objects that tie together both properties and behaviors into a self-contained, reusable package. This leads to code that looks more like this:</p><pre class="language-cpp line-numbers"><code>you.driveTo(work);</code></pre><p>This not only reads more clearly, it also makes it clearer who the subject is (you) and what behavior is being invoked (driving somewhere). Rather than being focused on writing functions, we’re focused on defining objects that have a well-defined set of behaviors. This is why the paradigm is called “object-oriented”.</p><p>This allows programs to be written in a more modular fashion, which makes them easier to write and understand, and also provides a higher degree of code-reusability. These objects also provide a more intuitive way to work with our data by allowing us to define how we interact with the objects, and how they interact with other objects.</p><p>Note that OOP doesn’t replace traditional programming methods. Rather, it gives you additional tools in your programming tool belt to manage complexity when needed.</p><p>Object-oriented programming also brings several other useful concepts to the table: inheritance, encapsulation, abstraction, and polymorphism (language designers have a philosophy: never use a short word where a long one will do). We will be covering all of these concepts in the upcoming tutorials over the next few chapters. It’s a lot of new material, but once you’ve been properly familiarized with OOP and it clicks, you may never want to go back to pure traditional programming again.</p><p>Note that the term “object” is overloaded a bit, and this causes some amount of confusion. In traditional programming, an object is a piece of memory to store values. And that’s it. In object-oriented programming, an “object” implies that it is both an object in the traditional programming sense, and that it combines both properties and behaviors. From this point forward, when we use the term “object”, we’ll be referring to “objects” in the object-oriented sense.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">13.2 — Classes and class members</h1></header><div class="entry-content" itemprop="articleBody"><p>While C++ provides a number of fundamental data types (e.g. char, int, long, float, double, etc…) that are often sufficient for solving relatively simple problems, it can be difficult to solve complex problems using just these types. One of C++’s more useful features is the ability to define your own data types that better correspond to the problem being solved. You have already seen how <a href="https://www.learncpp.com/cpp-tutorial/45-enumerated-types/">enumerated types</a> and <a href="https://www.learncpp.com/cpp-tutorial/47-structs/">structs</a> can be used to create your own custom data types.</p><p>Here is an example of a struct used to hold a date:</p><pre class="language-cpp line-numbers"><code>struct DateStruct</code><code>{</code><code>    int year {};</code><code>    int month {};</code><code>    int day {};</code><code>};</code></pre><p>Enumerated types and data-only structs (structs that only contain variables) represent the traditional non-object-oriented programming world, as they can only hold data. We can create and initialize this struct as follows:</p><pre class="language-cpp line-numbers"><code>DateStruct today { 2020, 10, 14 }; // use uniform initialization</code></pre><p>Now, if we want to print the date to the screen (something we probably want to do a lot), it makes sense to write a function to do this. Here’s a full program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>struct DateStruct</code><code>{</code><code>    int year {};</code><code>    int month {};</code><code>    int day {};</code><code>};</code><code></code><code>void print(const DateStruct&amp; date)</code><code>{</code><code>    std::cout &lt;&lt; date.year &lt;&lt; '/' &lt;&lt; date.month &lt;&lt; '/' &lt;&lt; date.day;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    DateStruct today { 2020, 10, 14 }; // use uniform initialization</code><code></code><code>    today.day = 16; // use member selection operator to select a member of the struct</code><code>    print(today);</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>2020/10/16
</pre><br><h3>Classes</h3><p>In the world of object-oriented programming, we often want our types to not only hold data, but provide functions that work with the data as well. In C++, this is typically done via the <strong>class</strong> keyword. The class keyword defines a new user-defined type called a class.</p><p>In C++, classes and structs are essentially the same. In fact, the following struct and class are effectively identical:</p><pre class="language-cpp line-numbers"><code>struct DateStruct</code><code>{</code><code>    int year {};</code><code>    int month {};</code><code>    int day {};</code><code>};</code><code></code><code>class DateClass</code><code>{</code><code>public:</code><code>    int m_year {};</code><code>    int m_month {};</code><code>    int m_day {};</code><code>};</code></pre><p>Note that the only significant difference is the <em>public:</em> keyword in the class. We will discuss the function of this keyword in the next lesson.</p><p>Just like a struct declaration, a class declaration does not allocate any memory. It only defines what the class looks like.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Just like with structs, one of the easiest mistakes to make in C++ is to forget the semicolon at the end of a class declaration. This will cause a compiler error on the <em>next</em> line of code. Modern compilers like Visual Studio 2010 will give you an indication that you may have forgotten a semicolon, but older or less sophisticated compilers may not, which can make the actual error hard to find.</p></div><p>Class (and struct) definitions are like a blueprint -- they describe what the resulting object will look like, but they do not actually create the object. To actually create an object of the class, a variable of that class type must be defined:</p><pre class="language-cpp line-numbers"><code>DateClass today { 2020, 10, 14 }; // declare a variable of class DateClass</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>A reminder</h4><p>Initialize the member variables of a class at the point of declaration.</p></div><br><h3>Member Functions</h3><p>In addition to holding data, classes (and structs) can also contain functions! Functions defined inside of a class are called <strong>member functions</strong> (or sometimes <strong>methods</strong>). Member functions can be defined inside or outside of the class definition. We’ll define them inside the class for now (for simplicity), and show how to define them outside the class later.</p><p>Here is our Date class with a member function to print the date:</p><pre class="language-cpp line-numbers"><code>class DateClass</code><code>{</code><code>public:</code><code>    int m_year {};</code><code>    int m_month {};</code><code>    int m_day {};</code><code></code><code>    void print() // defines a member function named print()</code><code>    {</code><code>        std::cout &lt;&lt; m_year &lt;&lt; '/' &lt;&lt; m_month &lt;&lt; '/' &lt;&lt; m_day;</code><code>    }</code><code>};</code></pre><p>Just like members of a struct, members (variables and functions) of a class are accessed using the member selection operator (.):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class DateClass</code><code>{</code><code>public:</code><code>    int m_year {};</code><code>    int m_month {};</code><code>    int m_day {};</code><code></code><code>    void print()</code><code>    {</code><code>        std::cout &lt;&lt; m_year &lt;&lt; '/' &lt;&lt; m_month &lt;&lt; '/' &lt;&lt; m_day;</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    DateClass today { 2020, 10, 14 };</code><code></code><code>    today.m_day = 16; // use member selection operator to select a member variable of the class</code><code>    today.print(); // use member selection operator to call a member function of the class</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>2020/10/16
</pre><p>Note how similar this program is to the struct version we wrote above.</p><p>However, there are a few differences. In the DateStruct version of print() from the example above, we needed to pass the struct itself to the print() function as the first parameter. Otherwise, print() wouldn’t know what DateStruct we wanted to use. We then had to reference this parameter inside the function explicitly.</p><p>Member functions work slightly differently: All member function calls must be associated with an object of the class. When we call “today.print()”, we’re telling the compiler to call the print() member function, associated with the today object.</p><p>Now let’s take a look at the definition of the print member function again:</p><pre class="language-cpp line-numbers"><code>    void print() // defines a member function named print()</code><code>    {</code><code>        std::cout &lt;&lt; m_year &lt;&lt; '/' &lt;&lt; m_month &lt;&lt; '/' &lt;&lt; m_day;</code><code>    }</code></pre><p>What do m_year, m_month, and m_day actually refer to? They refer to the associated object (as determined by the caller).</p><p>So when we call “today.print()”, the compiler interprets <code>m_day</code> as <code>today.m_day</code>, <code>m_month</code> as <code>today.m_month</code>, and <code>m_year</code> as <code>today.m_year</code>. If we called “tomorrow.print()”, <code>m_day</code> would refer to <code>tomorrow.m_day</code> instead.</p><p>In this way, the associated object is essentially implicitly passed to the member function. For this reason, it is often called <strong>the implicit object</strong>.</p><p>We’ll talk more about how the implicit object passing works in detail in a later lesson in this chapter.</p><p>The key point is that with non-member functions, we have to pass data to the function to work with. With member functions, we can assume we always have an implicit object of the class to work with!</p><p>Using the “m_” prefix for member variables helps distinguish member variables from function parameters or local variables inside member functions. This is useful for several reasons. First, when we see an assignment to a variable with the “m_” prefix, we know that we are changing the state of the class instance. Second, unlike function parameters or local variables, which are declared within the function, member variables are declared in the class definition. Consequently, if we want to know how a variable with the “m_” prefix is declared, we know that we should look in the class definition instead of within the function.</p><p>By convention, class names should begin with an upper-case letter.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Name your classes starting with a capital letter.</p></div><p>Here’s another example of a class:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>class Employee</code><code>{</code><code>public:</code><code>    std::string m_name {};</code><code>    int m_id {};</code><code>    double m_wage {};</code><code></code><code>    // Print employee information to the screen</code><code>    void print()</code><code>    {</code><code>        std::cout &lt;&lt; "Name: " &lt;&lt; m_name &lt;&lt;</code><code>                "  Id: " &lt;&lt; m_id &lt;&lt; </code><code>                "  Wage: $" &lt;&lt; m_wage &lt;&lt; '\n'; </code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    // Declare two employees</code><code>    Employee alex { "Alex", 1, 25.00 };</code><code>    Employee joe { "Joe", 2, 22.25 };</code><code></code><code>    // Print out the employee information</code><code>    alex.print();</code><code>    joe.print();</code><code></code><code>    return 0;</code><code>}</code></pre><p>This produces the output:</p><pre>Name: Alex  Id: 1  Wage: $25
Name: Joe  Id: 2  Wage: $22.25
</pre><p>With normal non-member functions, a function can’t call a function that’s defined “below” it (without a forward declaration):</p><pre class="language-cpp line-numbers"><code>void x()</code><code>{</code><code>// You can't call y() from here unless the compiler has already seen a forward declaration for y()</code><code>}</code><code> </code><code>void y()</code><code>{</code><code>}</code></pre><p>With member functions, this limitation doesn’t apply:</p><pre class="language-cpp line-numbers"><code>class foo</code><code>{</code><code>public:</code><code>     void x() { y(); } // okay to call y() here, even though y() isn't defined until later in this class</code><code>     void y() { };</code><code>};</code></pre><br><h3>Member types</h3><p>In addition to member variables and member functions, classes can have <span class="cpp-definition">member types</span> or <span class="cpp-definition">nested types</span> (including type aliases).</p><pre class="language-cpp line-numbers"><code>class Employee</code><code>{</code><code>public:</code><code>    using IDType = int;</code><code></code><code>    std::string m_name{};</code><code>    IDType m_id{};</code><code>    double m_wage{};</code><code></code><code>    // Print employee information to the screen</code><code>    void print()</code><code>    {</code><code>        std::cout &lt;&lt; "Name: " &lt;&lt; m_name &lt;&lt;</code><code>            "  Id: " &lt;&lt; m_id &lt;&lt;</code><code>            "  Wage: $" &lt;&lt; m_wage &lt;&lt; '\n';</code><code>    }</code><code>};</code></pre><p>In such a context, the class name effectively acts like a namespace for the nested type. From inside the class, we only need reference <code>IDType</code>. From outside the class, we can access the type via <code>Employee::IDType</code>.</p><p>If we ever decide that an <code>int</code> no longer fulfills our needs and we want to use a <code>std::string</code> instead, we only need to update the type alias, rather than having to replace every occurrence of <code>int</code> with <code>std::string</code>.</p><p>Nested types cannot be forward declared. Generally, nested types should only be used when the nested type is used exclusively within that class. Note that since classes are types, it’s possible to nest classes inside other classes -- this is uncommon and is typically only done by advanced programmers.</p><br><h3>A note about structs in C++</h3><p>In C, structs only have data members, not member functions. In C++, after designing classes (using the class keyword), Bjarne Stroustrup spent some amount of time considering whether structs (which were inherited from C) should be granted the ability to have member functions. Upon consideration, he determined that they should, in part to have a unified ruleset for both. So although we wrote the above programs using the class keyword, we could have used the struct keyword instead.</p><p>Many developers (including myself) feel this was the incorrect decision to be made, as it can lead to dangerous assumptions. For example, it’s fair to assume a class will clean up after itself (e.g. a class that allocates memory will deallocate it before being destroyed), but it’s not safe to assume a struct will. Consequently, we recommend using the struct keyword for data-only structures, and the class keyword for defining objects that require both data and functions to be bundled together.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use the struct keyword for data-only structures. Use the class keyword for objects that have both data and functions.</p></div><br><h3>You have already been using classes without knowing it</h3><p>It turns out that the C++ standard library is full of classes that have been created for your benefit. std::string, std::vector, and std::array are all class types! So when you create an object of any of these types, you’re instantiating a class object. And when you call a function using these objects, you’re calling a member function.</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code>#include <array></array></code><code>#include <vector></vector></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::string s { "Hello, world!" }; // instantiate a string class object</code><code>    std::array<int, 3=""> a { 1, 2, 3 }; // instantiate an array class object</int,></code><code>    std::vector<double> v { 1.1, 2.2, 3.3 }; // instantiate a vector class object</double></code><code></code><code>    std::cout &lt;&lt; "length: " &lt;&lt; s.length() &lt;&lt; '\n'; // call a member function</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>Conclusion</h3><p>The class keyword lets us create a custom type in C++ that can contain both member variables and member functions. Classes form the basis for Object-oriented programming, and we’ll spend the rest of this chapter and many of the future chapters exploring all they have to offer!</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>a) Create a class called IntPair that holds two integers. This class should have two member variables to hold the integers. You should also create two member functions: one named “set” that will let you assign values to the integers, and one named “print” that will print the values of the variables.</p><p>The following main function should execute:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	IntPair p1;</code><code>	p1.set(1, 1); // set p1 values to (1, 1)</code><code>	</code><code>	IntPair p2 { 2, 2 }; // initialize p2 values to (2, 2)</code><code></code><code>	p1.print();</code><code>	p2.print();</code><code></code><code>	return 0;</code><code>}</code></pre><p>and produce the output:</p><pre>Pair(1, 1)
Pair(2, 2)
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class IntPair</code><code>{</code><code>public:</code><code>	int m_first{};</code><code>	int m_second{};</code><code>	</code><code>	void set(int first, int second)</code><code>	{</code><code>		m_first = first;</code><code>		m_second = second;</code><code>	}</code><code>	void print()</code><code>	{</code><code>		std::cout &lt;&lt; "Pair(" &lt;&lt; m_first &lt;&lt; ", " &lt;&lt; m_second &lt;&lt; ")\n";</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	IntPair p1;</code><code>	p1.set(1, 1);</code><code>	</code><code>	IntPair p2 { 2, 2 };</code><code></code><code>	p1.print();</code><code>	p2.print();</code><code></code><code>	return 0;</code><code>}</code></pre></div><p>(h/t to reader Pashka2107 for this quiz idea)</p><p>b) Why should we use a class for IntPair instead of a struct?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none">This object contains both member data and member functions, so we should use a class. We should not use structs for objects that have member functions.</div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">13.3 — Public vs private access specifiers</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Public and private members</h3><p>Consider the following struct:</p><pre class="language-cpp line-numbers"><code>struct DateStruct // members are public by default</code><code>{</code><code>    int month {}; // public by default, can be accessed by anyone</code><code>    int day {}; // public by default, can be accessed by anyone</code><code>    int year {}; // public by default, can be accessed by anyone</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    DateStruct date;</code><code>    date.month = 10;</code><code>    date.day = 14;</code><code>    date.year= 2020;</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the main() function of the example above, we declare a DateStruct and then we directly access its members in order to assign values to them. This works because all members of a struct are public members by default. <strong>Public members</strong> are members of a struct or class that can be accessed directly by anyone, including from code that exists outside the struct or class. In this case, function main() exists outside of the struct, but it can directly access members month, day, and year, because they are public members.</p><p>The code outside of a struct or class is sometimes called <strong>the public</strong>: the public is only allowed to access the public members of a struct or class, which makes sense.</p><p>Now consider the following almost-identical class:</p><pre class="language-cpp line-numbers"><code>class DateClass // members are private by default</code><code>{</code><code>    int m_month {}; // private by default, can only be accessed by other members</code><code>    int m_day {}; // private by default, can only be accessed by other members</code><code>    int m_year {}; // private by default, can only be accessed by other members</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    DateClass date;</code><code>    date.m_month = 10; // error</code><code>    date.m_day = 14; // error</code><code>    date.m_year = 2020; // error</code><code></code><code>    return 0;</code><code>}</code></pre><p>If you were to compile this program, you would receive errors. This is because by default, all members of a class are private. <strong>Private members</strong> are members of a class that can only be accessed by other members of the class (not by the public). Because main() is not a member of DateClass, it does not have access to date’s private members.</p><br><h3>Access specifiers</h3><p>Although class members are private by default, we can make them public by using the public keyword:</p><pre class="language-cpp line-numbers"><code>class DateClass</code><code>{</code><code>public: // note use of public keyword here, and the colon</code><code>    int m_month {}; // public, can be accessed by anyone</code><code>    int m_day {}; // public, can be accessed by anyone</code><code>    int m_year {}; // public, can be accessed by anyone</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    DateClass date;</code><code>    date.m_month = 10; // okay because m_month is public</code><code>    date.m_day = 14;  // okay because m_day is public</code><code>    date.m_year = 2020;  // okay because m_year is public</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because DateClass’s members are now public, they can be accessed directly by main().</p><p>The public keyword, along with the following colon, is called an access specifier. <strong>Access specifiers</strong> determine who has access to the members that follow the specifier. Each of the members “acquires” the access level of the previous access specifier (or, if none is provided, the default access specifier).</p><p>C++ provides 3 different access specifier keywords: public, private, and protected. Public and private are used to make the members that follow them public members or private members respectively. The third access specifier, protected, works much like private does. We will discuss the difference between the private and protected access specifier when we cover inheritance.</p><br><h3>Mixing access specifiers</h3><p>A class can (and almost always does) use multiple access specifiers to set the access levels of each of its members. There is no limit to the number of access specifiers you can use in a class.</p><p>In general, member variables are usually made private, and member functions are usually made public. We’ll take a closer look at why in the next lesson.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Make member variables private, and member functions public, unless you have a good reason not to.</p></div><p>Let’s take a look at an example of a class that uses both private and public access:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class DateClass // members are private by default</code><code>{</code><code>    int m_month {}; // private by default, can only be accessed by other members</code><code>    int m_day {}; // private by default, can only be accessed by other members</code><code>    int m_year {}; // private by default, can only be accessed by other members</code><code></code><code>public:</code><code>    void setDate(int month, int day, int year) // public, can be accessed by anyone</code><code>    {</code><code>        // setDate() can access the private members of the class because it is a member of the class itself</code><code>        m_month = month;</code><code>        m_day = day;</code><code>        m_year = year;</code><code>    }</code><code></code><code>    void print() // public, can be accessed by anyone</code><code>    {</code><code>        std::cout &lt;&lt; m_month &lt;&lt; '/' &lt;&lt; m_day &lt;&lt; '/' &lt;&lt; m_year;</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    DateClass date;</code><code>    date.setDate(10, 14, 2020); // okay, because setDate() is public</code><code>    date.print(); // okay, because print() is public</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>10/14/2020
</pre><p>Note that although we can’t access date’s members variables m_month, m_day, and m_year directly from main (because they are private), we are able to access them indirectly through public member functions setDate() and print()!</p><p>The group of public members of a class are often referred to as a <strong>public interface</strong>. Because only public members can be accessed from outside of the class, the public interface defines how programs using the class will interact with the class. Note that main() is restricted to setting the date and printing the date. The class protects the member variables from being accessed or edited directly.</p><p>Some programmers prefer to list private members first, because the public members typically use the private ones, so it makes sense to define the private ones first. However, a good counterargument is that users of the class don’t care about the private members, so the public ones should come first. Either way is fine.</p><br><h3>Access controls work on a per-class basis</h3><p>Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class DateClass // members are private by default</code><code>{</code><code>	int m_month {}; // private by default, can only be accessed by other members</code><code>	int m_day {}; // private by default, can only be accessed by other members</code><code>	int m_year {}; // private by default, can only be accessed by other members</code><code></code><code>public:</code><code>	void setDate(int month, int day, int year)</code><code>	{</code><code>		m_month = month;</code><code>		m_day = day;</code><code>		m_year = year;</code><code>	}</code><code></code><code>	void print()</code><code>	{</code><code>		std::cout &lt;&lt; m_month &lt;&lt; '/' &lt;&lt; m_day &lt;&lt; '/' &lt;&lt; m_year;</code><code>	}</code><code></code><code>	// Note the addition of this function</code><code>	void copyFrom(const DateClass&amp; d)</code><code>	{</code><code>		// Note that we can access the private members of d directly</code><code>		m_month = d.m_month;</code><code>		m_day = d.m_day;</code><code>		m_year = d.m_year;</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	DateClass date;</code><code>	date.setDate(10, 14, 2020); // okay, because setDate() is public</code><code>	</code><code>	DateClass copy {};</code><code>	copy.copyFrom(date); // okay, because copyFrom() is public</code><code>	copy.print();</code><code>	std::cout &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>One nuance of C++ that is often missed or misunderstood is that access control works on a per-class basis, not a per-object basis. This means that when a function has access to the private members of a class, it can access the private members of <em>any</em> object of that class type that it can see.</p><p>In the above example, copyFrom() is a member of DateClass, which gives it access to the private members of DateClass. This means copyFrom() can not only directly access the private members of the implicit object it is operating on (copy), it also means it has direct access to the private members of DateClass parameter d! If parameter d were some other type, this would not be the case.</p><p>This can be particularly useful when we need to copy members from one object of a class to another object of the same class. We’ll also see this topic show up again when we talk about overloading operator&lt;&lt; to print members of a class in the next chapter.</p><br><h3>Structs vs classes revisited</h3><p>Now that we’ve talked about access specifiers, we can talk about the actual differences between a class and a struct in C++. A class defaults its members to private. A struct defaults its members to public.</p><p>That’s it!</p><p>(Okay, to be pedantic, there’s one more minor difference -- structs inherit from other classes publicly and classes inherit privately. We’ll cover what this means in a future chapter, but this particular point is practically irrelevant since you should never rely on the defaults anyway).</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>a) What is a public member?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none">A public member is a member of a class that can be accessed by anyone.</div><p>b) What is a private member?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none">A private member is a member of a class that can only be accessed by other members of the class.</div><p>c) What is an access specifier?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none">An access specifier determines who has access to the members that follow the specifier.</div><p>d) How many access specifiers are there, and what are they?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none">Three. Public, private, and protected.</div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>a) Write a simple class named Point3d. The class should contain:</p><ul><li>Three private member variables of type int named m_x, m_y, and m_z;</li><li>A public member function named setValues() that allows you to set values for m_x, m_y, and m_z.</li><li>A public member function named print() that prints the Point in the following format: &lt;m_x, m_y, m_z&gt;</li></ul><p>Make sure the following program executes correctly:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Point3d point;</code><code>    point.setValues(1, 2, 3);</code><code></code><code>    point.print();</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This should print:</p><pre>&lt;1, 2, 3&gt;
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Point3d</code><code>{</code><code>private:</code><code>    int m_x {};</code><code>    int m_y {};</code><code>    int m_z {};</code><code></code><code>public:</code><code>	void setValues(int x, int y, int z)</code><code>	{</code><code>		m_x = x;</code><code>		m_y = y;</code><code>		m_z = z;</code><code>	}</code><code></code><code>	void print()</code><code>	{</code><code>		std::cout &lt;&lt; '&lt;' &lt;&lt; m_x &lt;&lt; ", " &lt;&lt; m_y &lt;&lt; ", " &lt;&lt; m_z &lt;&lt; '&gt;';</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Point3d point;</code><code>    point.setValues(1, 2, 3);</code><code></code><code>    point.print();</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre></div><p>b) Add a function named isEqual() to your Point3d class. The following code should run correctly:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Point3d point1;</code><code>    point1.setValues(1, 2, 3);</code><code></code><code>    Point3d point2;</code><code>    point2.setValues(1, 2, 3);</code><code></code><code>    if (point1.isEqual(point2))</code><code>    {</code><code>        std::cout &lt;&lt; "point1 and point2 are equal\n";</code><code>    }</code><code>    else</code><code>    {</code><code>        std::cout &lt;&lt; "point1 and point2 are not equal\n";</code><code>    }</code><code></code><code>    Point3d point3;</code><code>    point3.setValues(3, 4, 5);</code><code></code><code>    if (point1.isEqual(point3))</code><code>    {</code><code>        std::cout &lt;&lt; "point1 and point3 are equal\n";</code><code>    }</code><code>    else</code><code>    {</code><code>        std::cout &lt;&lt; "point1 and point3 are not equal\n";</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Point3d</code><code>{</code><code>private:</code><code>	int m_x {};</code><code>	int m_y {};</code><code>	int m_z {};</code><code></code><code>public:</code><code>	void setValues(int x, int y, int z)</code><code>	{</code><code>		m_x = x;</code><code>		m_y = y;</code><code>		m_z = z;</code><code>	}</code><code></code><code>	void print()</code><code>	{</code><code>		std::cout &lt;&lt; '&lt;' &lt;&lt; m_x &lt;&lt; ", " &lt;&lt; m_y &lt;&lt; ", " &lt;&lt; m_z &lt;&lt; '&gt;';</code><code>	}</code><code></code><code>	// We can use the fact that access controls work on a per-class basis here</code><code>	// to directly access the private members of Point3d parameter p</code><code>	bool isEqual(const Point3d&amp; p)</code><code>	{</code><code>		return (m_x == p.m_x &amp;&amp; m_y == p.m_y &amp;&amp; m_z == p.m_z);</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Point3d point1;</code><code>	point1.setValues(1, 2, 3);</code><code></code><code>	Point3d point2;</code><code>	point2.setValues(1, 2, 3);</code><code></code><code>	if (point1.isEqual(point2))</code><code>	{</code><code>		std::cout &lt;&lt; "point1 and point2 are equal\n";</code><code>	}</code><code>	else</code><code>	{</code><code>		std::cout &lt;&lt; "point1 and point2 are not equal\n";</code><code>	}</code><code></code><code>	Point3d point3;</code><code>	point3.setValues(3, 4, 5);</code><code></code><code>	if (point1.isEqual(point3))</code><code>	{</code><code>		std::cout &lt;&lt; "point1 and point3 are equal\n";</code><code>	}</code><code>	else</code><code>	{</code><code>		std::cout &lt;&lt; "point1 and point3 are not equal\n";</code><code>	}</code><code></code><code>	return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>Now let’s try something a little more complex. Let’s write a class that implements a simple stack from scratch. Review lesson <a href="https://www.learncpp.com/cpp-tutorial/the-stack-and-the-heap/">12.2 -- The stack and the heap</a> if you need a refresher on what a stack is.</p><p>The class should be named Stack, and should contain:</p><ul><li>A private array of integers of length 10.</li><li>A private integer to keep track of the size of the stack.</li><li>A public member function named reset() that sets the size to 0.</li><li>A public member function named push() that pushes a value on the stack. push() should return false if the array is already full, and true otherwise.</li><li>A public member function named pop() that pops a value off the stack and returns it. If there are no values on the stack, the code should exit via an assert.</li><li>A public member function named print() that prints all the values in the stack.</li></ul><p>Make sure the following program executes correctly:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	Stack stack;</code><code>	stack.reset();</code><code></code><code>	stack.print();</code><code></code><code>	stack.push(5);</code><code>	stack.push(3);</code><code>	stack.push(8);</code><code>	stack.print();</code><code></code><code>	stack.pop();</code><code>	stack.print();</code><code></code><code>	stack.pop();</code><code>	stack.pop();</code><code></code><code>	stack.print();</code><code></code><code>	return 0;</code><code>}</code></pre><p>This should print:</p><pre>( )
( 5 3 8 )
( 5 3 )
( )
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none"><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <cassert></cassert></code><code>#include <iostream></iostream></code><code></code><code>class Stack</code><code>{</code><code>private:</code><code>	// We use a std::array to store the elements</code><code>	using Array = std::array<int, 10="">;</int,></code><code>	// For convenience, add a type alias for the type of the indexes</code><code>	using Index = Array::size_type;</code><code></code><code>	Array m_array {}; // Here's where we're going to store our stack data</code><code>	Index m_next{ 0 }; // This will hold the index of the next free element on the stack</code><code></code><code>public:</code><code></code><code>	void reset()</code><code>	{</code><code>		m_next = 0;</code><code>	}</code><code></code><code>	bool push(int value)</code><code>	{</code><code>		// If the stack is already full, return false now</code><code>		if (m_next == m_array.size())</code><code>			return false;</code><code>		</code><code>		m_array[m_next++] = value; // set the next free element to the value, then increase m_next</code><code>		return true;</code><code>	}</code><code></code><code>	int pop()</code><code>	{</code><code>		// If there are no elements on the stack, assert out</code><code>		assert (m_next &gt; 0 &amp;&amp; "Can not pop empty stack");</code><code></code><code>		// m_next points to the next free element, so the last valid element is m_next -1.</code><code>		// what we want to do is something like this:</code><code>		// int val = m_array[m_next-1]; // get the last valid element</code><code>		// --m_next; // m_next is now one less since we just removed the top element</code><code>		// return val; // return the element</code><code>		// that can be condensed down into this:</code><code>		return m_array[--m_next];</code><code>	}</code><code></code><code>	void print()</code><code>	{</code><code>		std::cout &lt;&lt; "( ";</code><code>		for (Index i{ 0 }; i &lt; m_next; ++i)</code><code>			std::cout &lt;&lt; m_array[i] &lt;&lt; ' ';</code><code>		std::cout &lt;&lt; ")\n";</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Stack stack;</code><code></code><code>	stack.print();</code><code></code><code>	stack.push(5);</code><code>	stack.push(3);</code><code>	stack.push(8);</code><code>	stack.print();</code><code></code><code>	stack.pop();</code><code>	stack.print();</code><code></code><code>	stack.reset();</code><code>	stack.print();</code><code></code><code>	return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>Rather than writing a custom stack implementation every time you need a stack, use <code>std::vector</code> (or <code>std::stack</code>) instead:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <vector></vector></code><code></code><code>// std::stack only provides access to the topmost element. If we want to</code><code>// print all elements, we need to copy the stack (by passing it by value)</code><code>// and pop elements until the stack is empty.</code><code>void printStack(std::vector<int> stack)</int></code><code>{</code><code>	std::cout &lt;&lt; "( ";</code><code>	for (auto e : stack)</code><code>		std::cout &lt;&lt; e &lt;&lt; ' ';</code><code>	std::cout &lt;&lt; ")\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	// Create a std::stack that holds ints.</code><code>	std::vector<int> stack;</int></code><code></code><code>	printStack(stack);</code><code></code><code>	stack.push_back(5);</code><code>	stack.push_back(3);</code><code>	stack.push_back(8);</code><code>	printStack(stack);</code><code></code><code>	stack.pop_back();</code><code>	printStack(stack);</code><code></code><code>	// To clear the stack, assign it an empty vector.</code><code>	stack = {};</code><code>	printStack(stack);</code><code></code><code>	return 0;</code><code>}</code></pre><p>Note that <code>std::stack</code> only allows push, pop, and top. It does not provide a way to iterate through elements easily, so if you want to print your stack in forwards order, <code>std::stack</code> is probably not the best choice.</p></div></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">13.4 — Access functions and encapsulation</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>Why make member variables private?</strong></p><p>In the previous lesson, we mentioned that class member variables are typically made private. Developers who are learning about object-oriented programming often have a hard time understanding why you’d want to do this. To answer that question, let’s start with an analogy.</p><p>In modern life, we have access to many electronic devices. Your TV has a remote control that you can use to turn the TV on/off. You drive a car (or scooter) to work. You take a picture on your smartphone. All three of these things use a common pattern: They provide a simple interface for you to use (a button, a steering wheel, etc…) to perform an action. However, how these devices actually operate is hidden away from you. When you press the button on your remote control, you don’t need to know what it’s doing to communicate with your TV. When you press the gas pedal on your car, you don’t need to know how the combustion engine makes the wheels turn. When you take a picture, you don’t need to know how the sensors gather light into a pixellated image. This separation of interface and implementation is extremely useful because it allows us to use objects without understanding how they work. This vastly reduces the complexity of using these objects, and increases the number of objects we’re capable of interacting with.</p><p>For similar reasons, the separation of implementation and interface is useful in programming.</p><p><strong>Encapsulation</strong></p><p>In object-oriented programming, <strong>Encapsulation</strong> (also called <strong>information hiding</strong>) is the process of keeping the details about how an object is implemented hidden away from users of the object. Instead, users of the object access the object through a public interface. In this way, users are able to use the object without having to understand how it is implemented.</p><p>In C++, we implement encapsulation via access specifiers. Typically, all member variables of the class are made private (hiding the implementation details), and most member functions are made public (exposing an interface for the user). Although requiring users of the class to use the public interface may seem more burdensome than providing public access to the member variables directly, doing so actually provides a large number of useful benefits that help encourage class re-usability and maintainability.</p><p>Note: The word encapsulation is also sometimes used to refer to the packaging of data and functions that work on that data together. We prefer to just call that object-oriented programming.</p><p><strong>Benefit: encapsulated classes are easier to use and reduce the complexity of your programs</strong></p><p>With a fully encapsulated class, you only need to know what member functions are publicly available to use the class, what arguments they take, and what values they return. It doesn’t matter how the class was implemented internally. For example, a class holding a list of names could have been implemented using a dynamic array of C-style strings, std::array, std::vector, std::map, std::list, or one of many other data structures. In order to use the class, you don’t need to know (or care) which. This dramatically reduces the complexity of your programs, and also reduces mistakes. More than any other reason, this is the key advantage of encapsulation.</p><p>All of the classes in the C++ standard library are encapsulated. Imagine how much more complicated C++ would be if you had to understand how std::string, std::vector, or std::cout were implemented in order to use them!</p><p><strong>Benefit: encapsulated classes help protect your data and prevent misuse</strong></p><p>Global variables are dangerous because you don’t have strict control over who has access to the global variable, or how they use it. Classes with public members suffer from the same problem, just on a smaller scale.</p><p>For example, let’s say we were writing a string class. We might start out like this:</p><pre class="language-cpp line-numbers"><code>class MyString</code><code>{</code><code>    char* m_string; // we'll dynamically allocate our string here</code><code>    int m_length; // we need to keep track of the string length</code><code>};</code></pre><p>These two variables have an intrinsic connection: m_length should always equal the length of the string held by m_string (this connection is called an <span class="cpp-definition">invariant</span>). If m_length were public, anybody could change the length of the string without changing m_string (or vice-versa). This would put the class into an inconsistent state, which could cause all sorts of bizarre problems. By making both m_length and m_string private, users are forced to use whatever public member functions are available to work with the class (and those member functions can ensure that m_length and m_string are always set appropriately).</p><p>We can also help protect the user from mistakes in using our class. Consider a class with a public array member variable:</p><pre class="language-cpp line-numbers"><code>class IntArray</code><code>{</code><code>public:</code><code>    int m_array[10];</code><code>};</code></pre><p>If users can access the array directly, they could subscript the array with an invalid index, producing unexpected results:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    IntArray array;</code><code>    array.m_array[16] = 2; // invalid array index, now we overwrote memory that we don't own</code><code>}</code></pre><p>However, if we make the array private, we can force the user to use a function that validates that the index is valid first:</p><pre class="language-cpp line-numbers"><code>#include <iterator> // For std::size()</iterator></code><code></code><code>class IntArray</code><code>{</code><code>private:</code><code>    int m_array[10]; // user can not access this directly any more</code><code></code><code>public:</code><code>    void setValue(int index, int value)</code><code>    {</code><code>        // If the index is invalid, do nothing</code><code>        if (index &lt; 0 || index &gt;= std::size(m_array))</code><code>            return;</code><code></code><code>        m_array[index] = value;</code><code>    }</code><code>};</code></pre><p>In this way, we’ve protected the integrity of our program. As a side note, the at() functions of std::array and std::vector do something very similar!</p><p><strong>Benefit: encapsulated classes are easier to change</strong></p><p>Consider this simple example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Something</code><code>{</code><code>public:</code><code>    int m_value1;</code><code>    int m_value2;</code><code>    int m_value3;</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Something something;</code><code>    something.m_value1 = 5;</code><code>    std::cout &lt;&lt; something.m_value1 &lt;&lt; '\n';</code><code>}</code></pre><p>While this program works fine, what would happen if we decided to rename m_value1, or change its type? We’d break not only this program, but likely most of the programs that use class Something as well!</p><p>Encapsulation gives us the ability to change how classes are implemented without breaking all of the programs that use them.</p><p>Here is the encapsulated version of this class that uses functions to access m_value1:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Something</code><code>{</code><code>private:</code><code>    int m_value1;</code><code>    int m_value2;</code><code>    int m_value3;</code><code></code><code>public:</code><code>    void setValue1(int value) { m_value1 = value; }</code><code>    int getValue1() { return m_value1; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Something something;</code><code>    something.setValue1(5);</code><code>    std::cout &lt;&lt; something.getValue1() &lt;&lt; '\n';</code><code>}</code></pre><p>Now, let’s change the class’s implementation:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Something</code><code>{</code><code>private:</code><code>    int m_value[3]; // note: we changed the implementation of this class!</code><code></code><code>public:</code><code>    // We have to update any member functions to reflect the new implementation</code><code>    void setValue1(int value) { m_value[0] = value; }</code><code>    int getValue1() { return m_value[0]; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    // But our program still works just fine!</code><code>    Something something;</code><code>    something.setValue1(5);</code><code>    std::cout &lt;&lt; something.getValue1() &lt;&lt; '\n';</code><code>}</code></pre><p>Note that because we did not alter any of the function headers (return type, name, or parameters) in our class’s public interface, our program that uses the class continues to work without any changes.</p><p>Similarly, if gnomes snuck into your house at night and replaced the internals of your TV remote with a different (but compatible) technology, you probably wouldn’t even notice!</p><p><strong>Benefit: encapsulated classes are easier to debug</strong></p><p>And finally, encapsulation helps you debug the program when something goes wrong. Often when a program does not work correctly, it is because one of our member variables has an incorrect value. If everyone is able to access the variable directly, tracking down which piece of code modified the variable can be difficult (it could be any of them, and you’ll need to breakpoint them all to figure out which). However, if everybody has to call the same public function to modify a value, then you can simply breakpoint that function and watch as each caller changes the value until you see where it goes wrong.</p><p><strong>Access functions</strong></p><p>Depending on the class, it can be appropriate (in the context of what the class does) for us to be able to directly get or set the value of a private member variable.</p><p>An <strong>access function</strong> is a short public function whose job is to retrieve or change the value of a private member variable. For example, in a String class, you might see something like this:</p><pre class="language-cpp line-numbers"><code>class MyString</code><code>{</code><code>private:</code><code>    char* m_string; // we'll dynamically allocate our string here</code><code>    int m_length; // we need to keep track of the string length</code><code></code><code>public:</code><code>    int getLength() { return m_length; } // access function to get value of m_length</code><code>};</code></pre><p>getLength() is an access function that simply returns the value of m_length.</p><p>Access functions typically come in two flavors: getters and setters. <strong>Getters</strong> (also sometimes called <strong>accessors</strong>) are functions that return the value of a private member variable. <strong>Setters</strong> (also sometimes called <strong>mutators</strong>) are functions that set the value of a private member variable.</p><p>Here’s a sample class that has getters and setters for all of its members:</p><pre class="language-cpp line-numbers"><code>class Date</code><code>{</code><code>private:</code><code>    int m_month;</code><code>    int m_day;</code><code>    int m_year;</code><code></code><code>public:</code><code>    int getMonth() { return m_month; } // getter for month</code><code>    void setMonth(int month) { m_month = month; } // setter for month</code><code></code><code>    int getDay() { return m_day; } // getter for day</code><code>    void setDay(int day) { m_day = day; } // setter for day</code><code></code><code>    int getYear() { return m_year; } // getter for year</code><code>    void setYear(int year) { m_year = year; } // setter for year</code><code>};</code></pre><p>The Date class above is essentially an encapsulated struct with a trivial implementation, and a user of the class might reasonably expect to be able to get or set the day, month, or year.</p><p>The MyString class above isn’t used just to transport data -- it has more complex functionality and has an invariant that needs to be maintained. No setter was provided for variable m_length because we don’t want the user to be able to set the length directly (length should only be set whenever the string is changed). In this class, it does make sense to allow the user to get the string length directly, so a getter for the length was provided.</p><p>Getters should provide “read-only” access to data. Therefore, the best practice is that they should return by value or const reference (not by non-const reference). A getter that returns a non-const reference would allow the caller to modify the actual object being referenced, which violates the read-only nature of the getter (and violates encapsulation).</p><p>Here’s a trivial example of what can happen if your getter returns a non-const reference:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Foo</code><code>{</code><code>private:</code><code>    int m_value{ 4 };</code><code></code><code>public:</code><code>    int&amp; getValue() { return m_value; } // returns a non-const reference</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Foo f;                     // f.m_value is initialized to 4</code><code>    f.getValue() = 5;          // use the non-const reference to assign value 5 to m_value</code><code>    std::cout &lt;&lt; f.getValue(); // prints 5</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>5
</pre><p>Because getValue() is returning a non-const reference, we can use that reference to modify the value being referenced (m_value)!</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Getters should return by value or const reference.</p></div><p><strong>Access functions concerns</strong></p><p>There is a fair bit of discussion around in which cases access functions should be used or avoided. Although they don’t violate encapsulation, some developers would argue that use of access functions violates good OOP class design (a topic that could easily fill an entire book).</p><p>For now, we’ll recommend a pragmatic approach. As you create your classes, consider the following:</p><ul><li>If nobody outside your class needs to access a member, don’t provide access functions for that member.</li><li>If someone outside your class needs to access a member, think about whether you can expose a behavior or action instead (e.g. rather than a setAlive(bool) setter, implement a kill() function instead).</li><li>If you can’t, consider whether you can provide only a getter.</li></ul><p><strong>Summary</strong></p><p>As you can see, encapsulation provides a lot of benefits for just a little bit of extra effort. The primary benefit is that encapsulation allows us to use a class without having to know how it was implemented. This makes it a lot easier to use classes we’re not familiar with.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">13.5 — Constructors</h1></header><div class="entry-content" itemprop="articleBody"><p>When all members of a class (or struct) are public, we can use <span class="cpp-definition">aggregate initialization</span> to initialize the class (or struct) directly using list-initialization:</p><pre class="language-cpp line-numbers"><code>class Foo</code><code>{</code><code>public:</code><code>    int m_x {};</code><code>    int m_y {};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Foo foo { 6, 7 }; // list-initialization</code><code></code><code>    return 0;</code><code>}</code></pre><p>However, as soon as we make any member variables private, we’re no longer able to initialize classes in this way. It does make sense: if you can’t directly access a variable (because it’s private), you shouldn’t be able to directly initialize it.</p><p>So then how do we initialize a class with private member variables? The answer is through constructors.</p><br><h3>Constructors</h3><p>A <strong>constructor</strong> is a special kind of class member function that is automatically called when an object of that class is created. Constructors are typically used to initialize member variables of the class to appropriate user-provided values, or to do any setup steps necessary for the class to be used (e.g. open a file or database).</p><p>After a constructor executes, the object should be in a well-defined, usable state.</p><p>Unlike normal member functions, constructors have specific rules for how they must be named:</p><ol><li>Constructors must have the same name as the class (with the same capitalization)</li><li>Constructors have no return type (not even void)</li></ol><br><h3>Default constructors and default initialization</h3><p>A constructor that takes no parameters (or has parameters that all have default values) is called a <strong>default constructor</strong>. The default constructor is called if no user-provided initialization values are provided.</p><p>Here is an example of a class that has a default constructor:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>    int m_numerator {};</code><code>    int m_denominator {};</code><code></code><code>public:</code><code>    Fraction() // default constructor</code><code>    {</code><code>        m_numerator = 0;</code><code>        m_denominator = 1;</code><code>    }</code><code></code><code>    int getNumerator() { return m_numerator; }</code><code>    int getDenominator() { return m_denominator; }</code><code>    double getValue() { return static_cast<double>(m_numerator) / m_denominator; }</double></code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Fraction frac{}; // calls Fraction() default constructor</code><code>    std::cout &lt;&lt; frac.getNumerator() &lt;&lt; '/' &lt;&lt; frac.getDenominator() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This class was designed to hold a fractional value as an integer numerator and denominator. We have defined a default constructor named Fraction (the same as the class).</p><p>When the line <code>Fraction frac{};</code> executes, the compiler will see that we’re instantiating an object of type Fraction with no arguments. It then performs value-initialization of <code>frac</code>, that is, the default constructor gets called. Although technically incorrect, this is often called <span class="cpp-definition">default initialization</span>. The default constructor runs just like a normal function (assigning the values 0 to m_numerator and 1 to m_denominator).</p><p>This program produces the result:</p><pre>0/1
</pre><br><h3>Value-initialization</h3><p>In the above program, we initialized our class object using value-initialization:</p><pre class="language-cpp line-numbers"><code>    Fraction frac {}; // Value initialization using empty set of braces</code></pre><p>We can also initialize class objects using default-initialization:</p><pre class="language-cpp line-numbers"><code>    Fraction frac; // Default-initialization, calls default constructor</code></pre><p>For the most part, default- and value-initialization of a class object results in the same outcome: the default constructor is called.</p><p>Many programmers favor default-initialization over value-initialization for class objects. This is because when using value-initialization, the compiler may zero-initialize the class members before calling the default constructor in certain cases, which is slightly inefficient (C++ programmers don’t like paying for features they’re not using).</p><p>However, favoring default-initialization also comes with a downside: you have to know whether a type will initialize itself, i.e. it is a class-type and all members have an initializer, or there is a default-constructor that initializes all member variables. If you see a defined variable without an initializer, you have to think about whether that’s a mistake or not (depending on what type the object is).</p><p>For example, the following code causes undefined behavior</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>    // Removed initializers</code><code>    int m_numerator;</code><code>    int m_denominator;</code><code></code><code>public:</code><code>    // Removed default-constructor</code><code></code><code>    int getNumerator() { return m_numerator; }</code><code>    int getDenominator() { return m_denominator; }</code><code>    double getValue() { return static_cast<double>(m_numerator) / m_denominator; }</double></code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Fraction frac;</code><code>    // frac is uninitialized, accessing its members causes undefined behavior</code><code>    std::cout &lt;&lt; frac.getNumerator() &lt;&lt; '/' &lt;&lt; frac.getDenominator() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>While you might be able to initialize all members in the classes you write, it’s not feasible to read the definitions of all classes you use to make sure they do the same.</p><p>Favoring value initialization for class objects is simple, consistent, and can help you catch errors, particularly while you are learning.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Favor value-initialization over default-initialization for class objects.</p></div><br><h3>Direct- and list-initialization using constructors with parameters</h3><p>While the default constructor is great for ensuring our classes are initialized with reasonable default values, often times we want instances of our class to have specific values that we provide. Fortunately, constructors can also be declared with parameters. Here is an example of a constructor that takes two integer parameters that are used to initialize the numerator and denominator:</p><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>    int m_numerator {};</code><code>    int m_denominator {};</code><code></code><code>public:</code><code>    Fraction() // default constructor</code><code>    {</code><code>         m_numerator = 0;</code><code>         m_denominator = 1;</code><code>    }</code><code></code><code>    // Constructor with two parameters, one parameter having a default value</code><code>    Fraction(int numerator, int denominator=1)</code><code>    {</code><code>        assert(denominator != 0);</code><code>        m_numerator = numerator;</code><code>        m_denominator = denominator;</code><code>    }</code><code></code><code>    int getNumerator() { return m_numerator; }</code><code>    int getDenominator() { return m_denominator; }</code><code>    double getValue() { return static_cast<double>(m_numerator) / m_denominator; }</double></code><code>};</code></pre><p>Note that we now have two constructors: a default constructor that will be called in the default case, and a second constructor that takes two parameters. These two constructors can coexist peacefully in the same class due to function overloading. In fact, you can define as many constructors as you want, so long as each has a unique signature (number and type of parameters).</p><p>So how do we use this constructor with parameters? It’s simple! We can use list or direct initialization:</p><pre class="language-cpp line-numbers"><code>Fraction fiveThirds{ 5, 3 }; // List initialization, calls Fraction(int, int)</code><code>Fraction threeQuarters(3, 4); // Direct initialization, also calls Fraction(int, int)</code></pre><p>As always, we prefer list initialization. We’ll discover reasons (templates and std::initializer_list) to use direct initialization when calling constructors later in the tutorials. There is another special constructor that might make brace initialization do something different, in that case we have to use direct initialization. We’ll talk about these constructors later.</p><p>Note that we have given the second parameter of the constructor with parameters a default value, so the following is also legal:</p><pre class="language-cpp line-numbers"><code>Fraction six{ 6 }; // calls Fraction(int, int) constructor, second parameter uses default value of 1</code></pre><p>Default values for constructors work exactly the same way as with any other functions, so in the above case where we call <code>six{ 6 }</code>, the <code>Fraction(int, int)</code> function is called with the second parameter defaulted to value 1.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Favor brace initialization to initialize class objects.</p></div><br><h3>Copy initialization using equals with classes</h3><p>Much like with fundamental variables, it’s also possible to initialize classes using copy initialization:</p><pre class="language-cpp line-numbers"><code>Fraction six = Fraction{ 6 }; // Copy initialize a Fraction, will call Fraction(6, 1)</code><code>Fraction seven = 7; // Copy initialize a Fraction.  The compiler will try to find a way to convert 7 to a Fraction, which will invoke the Fraction(7, 1) constructor.</code></pre><p>However, we recommend you avoid this form of initialization with classes, as it may be less efficient. Although direct-initialization, list-initialization, and copy-initialization all work identically with fundamental types, copy-initialization does not work the same with classes (though the end-result is often the same). We’ll explore the differences in more detail in a future chapter.</p><br><h3>Reducing your constructors</h3><p>In the above two-constructor declaration of the Fraction class, the default constructor is actually somewhat redundant. We could simplify this class as follows:</p><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>    int m_numerator {};</code><code>    int m_denominator {};</code><code></code><code>public:</code><code>    // Default constructor</code><code>    Fraction(int numerator=0, int denominator=1)</code><code>    {</code><code>        assert(denominator != 0);</code><code></code><code>        m_numerator = numerator;</code><code>        m_denominator = denominator;</code><code>    }</code><code></code><code>    int getNumerator() { return m_numerator; }</code><code>    int getDenominator() { return m_denominator; }</code><code>    double getValue() { return static_cast<double>(m_numerator) / m_denominator; }</double></code><code>};</code></pre><p>Although this constructor is still a default constructor, it has now been defined in a way that it can accept one or two user-provided values as well.</p><pre class="language-cpp line-numbers"><code>Fraction zero; // will call Fraction(0, 1)</code><code>Fraction zero{}; // will call Fraction(0, 1)</code><code>Fraction six{ 6 }; // will call Fraction(6, 1)</code><code>Fraction fiveThirds{ 5, 3 }; // will call Fraction(5, 3)</code></pre><p>When implementing your constructors, consider how you might keep the number of constructors down through smart defaulting of values.</p><br><h3>A reminder about default parameters</h3><p>The rules around defining and calling functions that have default parameters (described in lesson <a href="https://www.learncpp.com/cpp-tutorial/default-arguments/">8.12 -- Default arguments</a>) apply to constructors too. To recap, when defining a function with default parameters, all default parameters must follow any non-default parameters, i.e. there cannot be non-defaulted parameters after a defaulted parameter.</p><p>This may produce unexpected results for classes that have multiple default parameters of different types. Consider:</p><pre class="language-cpp line-numbers"><code>class Something</code><code>{</code><code>public:</code><code>	// Default constructor</code><code>	Something(int n = 0, double d = 1.2) // allows us to construct a Something(int, double), Something(int), or Something()</code><code>	{</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Something s1 { 1, 2.4 }; // calls Something(int, double)</code><code>	Something s2 { 1 }; // calls Something(int, double)</code><code>	Something s3 {}; // calls Something(int, double)</code><code></code><code>	Something s4 { 2.4 }; // will not compile, as there's no constructor to handle Something(double)</code><code></code><code>	return 0;</code><code>}</code></pre><p>With <code>s4</code>, we’ve attempted to construct a <code>Something</code> by providing only a <code>double</code>. This won’t compile, as the rules for how arguments match with default parameters won’t allow us to skip a non-rightmost parameter (in this case, the leftmost int parameter).</p><p>If we want to be able to construct a <code>Something</code> with only a <code>double</code>, we’ll need to add a second (non-default) constructor:</p><pre class="language-cpp line-numbers"><code>class Something</code><code>{</code><code>public:</code><code>	// Default constructor</code><code>	Something(int n = 0, double d = 1.2) // allows us to construct a Something(int, double), Something(int), or Something()</code><code>	{</code><code>	}</code><code></code><code>	Something(double d)</code><code>	{</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Something s1 { 1, 2.4 }; // calls Something(int, double)</code><code>	Something s2 { 1 }; // calls Something(int, double)</code><code>	Something s3 {}; // calls Something(int, double)</code><code></code><code>	Something s4 { 2.4 }; // calls Something(double)</code><code></code><code>	return 0;</code><code>}</code></pre><br><h3>An implicitly generated default constructor</h3><p>If your class has no constructors, C++ will automatically generate a public default constructor for you. This is sometimes called an <strong>implicit constructor</strong> (or implicitly generated constructor).</p><p>Consider the following class:</p><pre class="language-cpp line-numbers"><code>class Date</code><code>{</code><code>private:</code><code>    int m_year{ 1900 };</code><code>    int m_month{ 1 };</code><code>    int m_day{ 1 };</code><code></code><code>    // No user-provided constructors, the compiler generates a default constructor.</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Date date{};</code><code></code><code>    return 0;</code><code>}</code></pre><p>The Date class has no constructors. Therefore, the compiler will generate a default constructor that allows us to create a <code>Date</code> object without arguments.</p><p>When the generated default constructor is called, members will still be initialized if they have non-static member initializers (covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/default-member-initialization/">10.7 -- Default member initialization</a> and <a href="https://www.learncpp.com/cpp-tutorial/non-static-member-initialization/">13.7 -- Non-static member initialization</a>).</p><p>If your class has any other constructors, the implicitly generated constructor will not be provided. For example:</p><pre class="language-cpp line-numbers"><code>class Date</code><code>{</code><code>private:</code><code>    int m_year{ 1900 };</code><code>    int m_month{ 1 };</code><code>    int m_day{ 1 };</code><code></code><code>public:</code><code>    Date(int year, int month, int day) // normal non-default constructor</code><code>    {</code><code>        m_year = year;</code><code>        m_month = month;</code><code>        m_day = day;</code><code>    }</code><code></code><code>    // No implicit constructor provided because we already defined our own constructor</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Date date{}; // error: Can't instantiate object because default constructor doesn't exist and the compiler won't generate one</code><code>    Date today{ 2020, 1, 19 }; // today is initialized to Jan 19th, 2020</code><code></code><code>    return 0;</code><code>}</code></pre><p>If your class has another constructor and you want to allow default construction, you can either add default arguments to every parameter of a constructor with parameters, or explicitly define a default constructor.</p><p>There’s a third option as well: you can use the default keyword to tell the compiler to create a default constructor for us anyway:</p><pre class="language-cpp line-numbers"><code>class Date</code><code>{</code><code>private:</code><code>    int m_year{ 1900 };</code><code>    int m_month{ 1 };</code><code>    int m_day{ 1 };</code><code></code><code>public:</code><code>    // Tell the compiler to create a default constructor, even if</code><code>    // there are other user-provided constructors.</code><code>    Date() = default;</code><code></code><code>    Date(int year, int month, int day) // normal non-default constructor</code><code>    {</code><code>        m_year = year;</code><code>        m_month = month;</code><code>        m_day = day;</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Date date{}; // date is initialized to Jan 1st, 1900</code><code>    Date today{ 2020, 10, 14 }; // today is initialized to Oct 14th, 2020</code><code></code><code>    return 0;</code><code>}</code></pre><p>Using <code>= default</code> is longer than writing a constructor with an empty body, but expresses better what your intentions are (To create a default constructor), and it’s safer, because it can zero-initialize members even if they have not been initialized at their declaration. <code>= default</code> also works for other special constructors, which we’ll talk about in the future.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>If you have constructors in your <code>class</code> and need a default constructor that does nothing (e.g. because all your members are initialized using non-static member initialization), use <code>= default</code>.</p></div><br><h3>Classes containing class members</h3><p>A <code>class</code> may contain other class objects as member variables. By default, when the outer class is constructed, the member variables will have their default constructors called. This happens before the body of the constructor executes.</p><p>This can be demonstrated thusly:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class A</code><code>{</code><code>public:</code><code>    A() { std::cout &lt;&lt; "A\n"; }</code><code>};</code><code></code><code>class B</code><code>{</code><code>private:</code><code>    A m_a; // B contains A as a member variable</code><code></code><code>public:</code><code>    B() { std::cout &lt;&lt; "B\n"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    B b;</code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>A
B
</pre><p>When variable <code>b</code> is constructed, the <code>B()</code> constructor is called. Before the body of the constructor executes, <code>m_a</code> is initialized, calling the <code>class A</code> default constructor. This prints “A”. Then control returns back to the <code>B</code> constructor, and the body of the B constructor executes.</p><p>This makes sense when you think about it, as the <code>B()</code> constructor may want to use variable <code>m_a</code> -- so <code>m_a</code> had better be initialized first!</p><p>The difference to the last example in the previous section is that <code>m_a</code> is a <code>class</code>-type. <code>class</code>-type members get initialized even if we don’t explicitly initialize them.</p><p>In the next lesson, we’ll talk about how to initialize these class member variables.</p><br><h3>Constructor notes</h3><p>Many new programmers are confused about whether constructors create the objects or not. They do not -- the compiler sets up the memory allocation for the object prior to the constructor call.</p><p>Constructors actually serve two purposes.</p><ol start="1"><li>Constructors determine who is allowed to create an object of the class type. That is, an object of a class can only be created if a matching constructor can be found.</li><li>Constructors can be used to initialize objects. Whether the constructor actually does an initialization is up to the programmer. It’s syntactically valid to have a constructor that does no initialization at all (the constructor still serves the purpose of allowing the object to be created, as per the above).</li></ol><p>However, much like it is a best practice to initialize all local variables, it’s also a best practice to initialize all member variables on creation of the object. This can be done via a constructor or via non-static member initialization.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Always initialize all member variables in your objects.</p></div><p>Finally, constructors are only intended to be used for initialization when the object is created. You should not try to call a constructor to re-initialize an existing object. While it may compile, the results will not be what you intended (instead, the compiler will create a temporary object and then discard it).</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>a) Write a <code>class</code> named Ball. Ball should have two private member variables with default values: <code>m_color</code> (“black”) and <code>m_radius</code> (10.0). <code>Ball</code> should provide constructors to set only <code>m_color</code>, set only <code>m_radius</code>, set both, or set neither value. For this quiz question, do not use default parameters for your constructors. Also write a function to print out the color and radius of the ball.</p><p>The following sample program should compile:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	Ball def{};</code><code>	def.print();</code><code></code><code>	Ball blue{ "blue" };</code><code>	blue.print();</code><code></code><code>	Ball twenty{ 20.0 };</code><code>	twenty.print();</code><code></code><code>	Ball blueTwenty{ "blue", 20.0 };</code><code>	blueTwenty.print();</code><code></code><code>	return 0;</code><code>}</code></pre><p>and produce the result:</p><pre>color: black, radius: 10
color: blue, radius: 10
color: black, radius: 20
color: blue, radius: 20
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class Ball</code><code>{</code><code>private:</code><code>	std::string m_color{};</code><code>	double m_radius{};</code><code></code><code>public:</code><code>	// Default constructor with no parameters</code><code>	Ball()</code><code>	{</code><code>		m_color = "black";</code><code>		m_radius = 10.0;</code><code>	}</code><code></code><code>	// Constructor with only color parameter (radius will use default value)</code><code>	Ball(std::string_view color)</code><code>	{</code><code>		m_color = color;</code><code>		m_radius = 10.0;</code><code>	}</code><code></code><code>	// Constructor with only radius parameter (color will use default value)</code><code>	Ball(double radius)</code><code>	{</code><code>		m_color = "black";</code><code>		m_radius = radius;</code><code>	}</code><code></code><code>	// Constructor with both color and radius parameters</code><code>	Ball(std::string_view color, double radius)</code><code>	{</code><code>		m_color = color;</code><code>		m_radius = radius;</code><code>	}</code><code></code><code>	void print()</code><code>	{</code><code>		std::cout &lt;&lt; "color: " &lt;&lt; m_color &lt;&lt; ", radius: " &lt;&lt; m_radius &lt;&lt; '\n';</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Ball def{};</code><code>	def.print();</code><code></code><code>	Ball blue{ "blue" };</code><code>	blue.print();</code><code></code><code>	Ball twenty{ 20.0 };</code><code>	twenty.print();</code><code></code><code>	Ball blueTwenty{ "blue", 20.0 };</code><code>	blueTwenty.print();</code><code></code><code>	return 0;</code><code>}</code></pre></div><p>b) Update your answer to the previous question to use constructors with default parameters. Use as few constructors as possible.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class Ball</code><code>{</code><code>private:</code><code>	std::string m_color{};</code><code>	double m_radius{};</code><code></code><code>public:</code><code>	// Constructor with only radius parameter (color will use default value)</code><code>	Ball(double radius)</code><code>	{</code><code>		m_color = "black";</code><code>		m_radius = radius;</code><code>	}</code><code></code><code>	// Constructor with both color and radius parameters</code><code>	// handles no parameter, color only, and color + radius cases.</code><code>	Ball(std::string_view color = "black", double radius = 10.0)</code><code>	{</code><code>		m_color = color;</code><code>		m_radius = radius;</code><code>	}</code><code></code><code>	void print()</code><code>	{</code><code>		std::cout &lt;&lt; "color: " &lt;&lt; m_color &lt;&lt; ", radius: " &lt;&lt; m_radius &lt;&lt; '\n';</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Ball def{};</code><code>	def.print();</code><code></code><code>	Ball blue{ "blue" };</code><code>	blue.print();</code><code></code><code>	Ball twenty{ 20.0 };</code><code>	twenty.print();</code><code></code><code>	Ball blueTwenty{ "blue", 20.0 };</code><code>	blueTwenty.print();</code><code></code><code>	return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>What happens if you don’t declare a default constructor?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none">If you haven’t defined any other constructors, the compiler will create an empty public default constructor for you. This means your objects will be instantiable with no parameters. If you have defined other constructors (default or otherwise), the compiler will not create a default constructor for you. Assuming you haven’t provided a default constructor yourself, your objects will not be instantiable without arguments.</div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">13.6 — Constructor member initializer lists</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson, for simplicity, we initialized our class member data in the constructor using the assignment operator. For example:</p><pre class="language-cpp line-numbers"><code>class Something</code><code>{</code><code>private:</code><code>    int m_value1 {};</code><code>    double m_value2 {};</code><code>    char m_value3 {};</code><code></code><code>public:</code><code>    Something()</code><code>    {</code><code>        // These are all assignments, not initializations</code><code>        m_value1 = 1;</code><code>        m_value2 = 2.2;</code><code>        m_value3 = 'c';</code><code>    }</code><code>};</code></pre><p>When the class’s constructor is executed, m_value1, m_value2, and m_value3 are created. Then the body of the constructor is run, where the member data variables are assigned values. This is similar to the flow of the following code in non-object-oriented C++:</p><pre class="language-cpp line-numbers"><code>int m_value1 {};</code><code>double m_value2 {};</code><code>char m_value3 {};</code><code></code><code>m_value1 = 1;</code><code>m_value2 = 2.2;</code><code>m_value3 = 'c';</code></pre><p>While this is valid within the syntax of the C++ language, it does not exhibit good style (and may be less efficient than initialization).</p><p>However, as you have learned in previous lessons, some types of data (e.g. const and reference variables) must be initialized on the line they are declared. Consider the following example:</p><pre class="language-cpp line-numbers"><code>class Something</code><code>{</code><code>private:</code><code>    const int m_value;</code><code></code><code>public:</code><code>    Something()</code><code>    {</code><code>        m_value = 1; // error: const vars can not be assigned to</code><code>    } </code><code>};</code></pre><p>This produces code similar to the following:</p><pre class="language-cpp line-numbers"><code>const int m_value; // error: const vars must be initialized with a value</code><code>m_value = 5; //  error: const vars can not be assigned to</code></pre><p>Assigning values to const or reference member variables in the body of the constructor is clearly not possible in some cases.</p><br><h3>Member initializer lists</h3><p>To solve this problem, C++ provides a method for initializing class member variables (rather than assigning values to them after they are created) via a <strong>member initializer list</strong> (often called a “member initialization list”). Do not confuse these with the similarly named initializer list that we can use to assign values to arrays.</p><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/variable-assignment-and-initialization/">1.4 -- Variable assignment and initialization</a>, you learned that you could initialize variables in three ways: copy, direct, and via uniform initialization.</p><pre class="language-cpp line-numbers"><code>int value1 = 1; // copy initialization</code><code>double value2(2.2); // direct initialization</code><code>char value3 {'c'}; // uniform initialization</code></pre><p>Using an initialization list is almost identical to doing direct initialization or uniform initialization.</p><p>This is something that is best learned by example. Revisiting our code that does assignments in the constructor body:</p><pre class="language-cpp line-numbers"><code>class Something</code><code>{</code><code>private:</code><code>    int m_value1 {};</code><code>    double m_value2 {};</code><code>    char m_value3 {};</code><code></code><code>public:</code><code>    Something()</code><code>    {</code><code>        // These are all assignments, not initializations</code><code>        m_value1 = 1;</code><code>        m_value2 = 2.2;</code><code>        m_value3 = 'c';</code><code>    }</code><code>};</code></pre><p>Now let’s write the same code using an initialization list:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Something</code><code>{</code><code>private:</code><code>    int m_value1 {};</code><code>    double m_value2 {};</code><code>    char m_value3 {};</code><code></code><code>public:</code><code>    Something() : m_value1{ 1 }, m_value2{ 2.2 }, m_value3{ 'c' } // Initialize our member variables</code><code>    {</code><code>    // No need for assignment here</code><code>    }</code><code></code><code>    void print()</code><code>    {</code><code>         std::cout &lt;&lt; "Something(" &lt;&lt; m_value1 &lt;&lt; ", " &lt;&lt; m_value2 &lt;&lt; ", " &lt;&lt; m_value3 &lt;&lt; ")\n";</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Something something{};</code><code>    something.print();</code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>Something(1, 2.2, c)
</pre><p>The member initializer list is inserted after the constructor parameters. It begins with a colon (:), and then lists each variable to initialize along with the value for that variable separated by a comma.</p><p>Note that we no longer need to do the assignments in the constructor body, since the initializer list replaces that functionality. Also note that the initializer list does not end in a semicolon.</p><p>Of course, constructors are more useful when we allow the caller to pass in the initialization values:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Something</code><code>{</code><code>private:</code><code>    int m_value1 {};</code><code>    double m_value2 {};</code><code>    char m_value3 {};</code><code></code><code>public:</code><code>    Something(int value1, double value2, char value3='c')</code><code>        : m_value1{ value1 }, m_value2{ value2 }, m_value3{ value3 } // directly initialize our member variables</code><code>    {</code><code>    // No need for assignment here</code><code>    }</code><code></code><code>    void print()</code><code>    {</code><code>         std::cout &lt;&lt; "Something(" &lt;&lt; m_value1 &lt;&lt; ", " &lt;&lt; m_value2 &lt;&lt; ", " &lt;&lt; m_value3 &lt;&lt; ")\n";</code><code>    }</code><code></code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Something something{ 1, 2.2 }; // value1 = 1, value2=2.2, value3 gets default value 'c'</code><code>    something.print();</code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>Something(1, 2.2, c)
</pre><p>Note that you can use default parameters to provide a default value in case the user didn’t pass one in.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use member initializer lists to initialize your class member variables instead of assignment.</p></div><br><h3>Initializing const member variables</h3><p>Classes can contain const member variables. Const member variables act just like normal const variables -- they must be initialized, and then their values can’t be changed thereafter.</p><p>We can initialize a const member using the constructor member initialization list (just like a non-const member), and the initialization value can be either constant or non-constant.</p><p>Here’s an example of a class that has a const member variable. We use the constructor’s member initialization list to initialize the const member with the non-const value that the user entered.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Something</code><code>{</code><code>private:</code><code>	const int m_value;</code><code></code><code>public:</code><code>	Something(int x) : m_value{ x } // directly initialize our const member variable</code><code>	{</code><code>	}</code><code></code><code>	void print()</code><code>	{</code><code>		std::cout &lt;&lt; "Something(" &lt;&lt; m_value &lt;&lt; ")\n";</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Enter an integer: ";</code><code>	int x{};</code><code>	std::cin &gt;&gt; x;</code><code></code><code>	Something s{ x };</code><code>	s.print();</code><code></code><code>	return 0;</code><code>}</code></pre><p>Here’s the output from one run of this program:</p><pre>Enter an integer: 4
Something(4)
</pre><div class="cpp-note cpp-lightgreenbackground"><h4>Rule</h4><p>Const member variables must be initialized.</p></div><br><h3>Initializing array members with member initializer lists</h3><p>Consider a class with an array member:</p><pre class="language-cpp line-numbers"><code>class Something</code><code>{</code><code>private:</code><code>    const int m_array[5];</code><code></code><code>};</code></pre><p>Prior to C++11, you can only zero initialize an array member via a member initialization list:</p><pre class="language-cpp line-numbers"><code>class Something</code><code>{</code><code>private:</code><code>    const int m_array[5];</code><code></code><code>public:</code><code>    Something(): m_array {} // zero initialize the member array</code><code>    {</code><code>    }</code><code></code><code>};</code></pre><p>However, since C++11, you can fully initialize a member array using uniform initialization:</p><pre class="language-cpp line-numbers"><code>class Something</code><code>{</code><code>private:</code><code>    const int m_array[5];</code><code></code><code>public:</code><code>    Something(): m_array { 1, 2, 3, 4, 5 } // use uniform initialization to initialize our member array</code><code>    {</code><code>    }</code><code></code><code>};</code></pre><br><h3>Initializing member variables that are classes</h3><p>A member initialization list can also be used to initialize members that are classes.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class A</code><code>{</code><code>public:</code><code>    A(int x = 0) { std::cout &lt;&lt; "A " &lt;&lt; x &lt;&lt; '\n'; }</code><code>};</code><code></code><code>class B</code><code>{</code><code>private:</code><code>    A m_a {};</code><code>public:</code><code>    B(int y)</code><code>        : m_a{ y - 1 } // call A(int) constructor to initialize member m_a</code><code>    {</code><code>        std::cout &lt;&lt; "B " &lt;&lt; y &lt;&lt; '\n';</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    B b{ 5 };</code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>A 4
B 5
</pre><p>When variable b is constructed, the B(int) constructor is called with value 5. Before the body of the constructor executes, m_a is initialized, calling the A(int) constructor with value 4. This prints “A 4”. Then control returns back to the B constructor, and the body of the B constructor executes, printing “B 5”.</p><br><h3>Formatting your initializer lists</h3><p>C++ gives you a lot of flexibility in how to format your initializer lists, and it’s really up to you how you’d like to proceed. But here are some recommendations:</p><p>If the initializer list fits on the same line as the function name, then it’s fine to put everything on one line:</p><pre class="language-cpp line-numbers"><code>class Something</code><code>{</code><code>private:</code><code>    int m_value1 {};</code><code>    double m_value2 {};</code><code>    char m_value3 {};</code><code></code><code>public:</code><code>    Something() : m_value1{ 1 }, m_value2{ 2.2 }, m_value3{ 'c' } // everything on one line</code><code>    {</code><code>    }</code><code>};</code></pre><p>If the initializer list doesn’t fit on the same line as the function name, then it should go indented on the next line.</p><pre class="language-cpp line-numbers"><code>class Something</code><code>{</code><code>private:</code><code>    int m_value1;</code><code>    double m_value2;</code><code>    char m_value3;</code><code></code><code>public:</code><code>    Something(int value1, double value2, char value3='c') // this line already has a lot of stuff on it</code><code>        : m_value1{ value1 }, m_value2{ value2 }, m_value3{ value3 } // so we can put everything indented on next line</code><code>    {</code><code>    }</code><code></code><code>};</code></pre><p>If all of the initializers don’t fit on a single line (or the initializers are non-trivial), then you can space them out, one per line:</p><pre class="language-cpp line-numbers"><code>class Something</code><code>{</code><code>private:</code><code>    int m_value1 {};</code><code>    double m_value2 {};</code><code>    char m_value3 {};</code><code>    float m_value4 {};</code><code></code><code>public:</code><code>    Something(int value1, double value2, char value3='c', float value4=34.6f) // this line already has a lot of stuff on it</code><code>        : m_value1{ value1 } // one per line</code><code>        , m_value2{ value2 }</code><code>        , m_value3{ value3 }</code><code>        , m_value4{ value4 } </code><code>    {</code><code>    }</code><code></code><code>};</code></pre><br><h3>Initializer list order</h3><p>Perhaps surprisingly, variables in the initializer list are not initialized in the order that they are specified in the initializer list. Instead, they are initialized in the order in which they are declared in the class.</p><p>For best results, the following recommendations should be observed:</p><ol start="1"><li>Don’t initialize member variables in such a way that they are dependent upon other member variables being initialized first (in other words, ensure your member variables will properly initialize even if the initialization ordering is different).</li><li>Initialize variables in the initializer list in the same order in which they are declared in your class. This isn’t strictly required so long as the prior recommendation has been followed, but your compiler may give you a warning if you don’t do so and you have all warnings turned on.</li></ol><br><h3>Summary</h3><p>Member initializer lists allow us to initialize our members rather than assign values to them. This is the only way to initialize members that require values upon initialization, such as const or reference members, and it can be more performant than assigning values in the body of the constructor. Member initializer lists work both with fundamental types and members that are classes themselves.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Write a class named RGBA that contains 4 member variables of type std::uint8_t named m_red, m_green, m_blue, and m_alpha (#include cstdint to access type std::uint8_t). Assign default values of 0 to m_red, m_green, and m_blue, and 255 to m_alpha. Create a constructor that uses a member initializer list that allows the user to initialize values for m_red, m_blue, m_green, and m_alpha. Include a print() function that outputs the value of the member variables.</p><p>If you need a reminder about how to use the fixed width integers, please review lesson <a href="https://www.learncpp.com/cpp-tutorial/fixed-width-integers-and-size-t/">4.6 -- Fixed-width integers and size_t</a>.</p><p>Hint: If your print() function isn’t working correctly, make sure you’re casting uint8_t to an int.</p><p>The following code should run:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	RGBA teal{ 0, 127, 127 };</code><code>	teal.print();</code><code></code><code>	return 0;</code><code>}</code></pre><p>and produce the result:</p><pre>r=0 g=127 b=127 a=255</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cstdint> // for std::uint8_t</cstdint></code><code></code><code>class RGBA</code><code>{</code><code>public:</code><code>	// A type alias saves us some typing and makes the class easier to maintain</code><code>	using Channel = std::uint8_t;</code><code></code><code>private:</code><code>	Channel m_red {};</code><code>	Channel m_green {};</code><code>	Channel m_blue {};</code><code>	Channel m_alpha {};</code><code></code><code>public:</code><code>	RGBA(Channel red=0, Channel green=0, Channel blue=0, Channel alpha=255) :</code><code>		m_red{ red }, m_green{ green }, m_blue{ blue }, m_alpha{ alpha }</code><code>	{</code><code>	}</code><code></code><code>	void print()</code><code>	{</code><code>		std::cout &lt;&lt; "r=" &lt;&lt; static_cast<int>(m_red) </int></code><code>			&lt;&lt; " g=" &lt;&lt; static_cast<int>(m_green) </int></code><code>			&lt;&lt; " b=" &lt;&lt; static_cast<int>(m_blue) </int></code><code>			&lt;&lt; " a=" &lt;&lt; static_cast<int>(m_alpha)</int></code><code>			&lt;&lt; '\n';</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	RGBA teal{ 0, 127, 127 };</code><code>	teal.print();</code><code></code><code>	return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">13.7 — Non-static member initialization</h1></header><div class="entry-content" itemprop="articleBody"><p>When writing a class that has multiple constructors (which is most of them), having to specify default values for all members in each constructor results in redundant code. If you update the default value for a member, you need to touch each constructor.</p><p>It’s possible to give normal class member variables (those that don’t use the static keyword) a default initialization value directly:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Rectangle</code><code>{</code><code>private:</code><code>    double m_length{ 1.0 }; // m_length has a default value of 1.0</code><code>    double m_width{ 1.0 }; // m_width has a default value of 1.0</code><code></code><code>public:</code><code>    void print()</code><code>    {</code><code>        std::cout &lt;&lt; "length: " &lt;&lt; m_length &lt;&lt; ", width: " &lt;&lt; m_width &lt;&lt; '\n';</code><code>    }</code><code>};</code><code> </code><code>int main()</code><code>{</code><code>    Rectangle x{}; // x.m_length = 1.0, x.m_width = 1.0</code><code>    x.print();</code><code> </code><code>    return 0;</code><code>}</code></pre><p>This program produces the result:</p><pre>length: 1.0, width: 1.0
</pre><p>Non-static member initialization (also called in-class member initializers) provides default values for your member variables that your constructors will use if the constructors do not provide initialization values for the members themselves (via the member initialization list).</p><p>However, note that constructors still determine what kind of objects may be created. Consider the following case:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Rectangle</code><code>{</code><code>private:</code><code>    double m_length{ 1.0 };</code><code>    double m_width{ 1.0 };</code><code></code><code>public:</code><code></code><code>    // note: No default constructor provided in this example</code><code></code><code>    Rectangle(double length, double width)</code><code>        : m_length{ length },</code><code>          m_width{ width }</code><code>    {</code><code>        // m_length and m_width are initialized by the constructor (the default values aren't used)</code><code>    }</code><code></code><code>    void print()</code><code>    {</code><code>        std::cout &lt;&lt; "length: " &lt;&lt; m_length &lt;&lt; ", width: " &lt;&lt; m_width &lt;&lt; '\n';</code><code>    }</code><code></code><code>};</code><code> </code><code>int main()</code><code>{</code><code>    Rectangle x{}; // will not compile, no default constructor exists, even though members have default initialization values</code><code> </code><code>    return 0;</code><code>}</code></pre><p>Even though we’ve provided default values for all members, no default constructor has been provided, so we are unable to create Rectangle objects with no arguments.</p><p>If a default initialization value is provided and the constructor initializes the member via the member initializer list, the member initializer list will take precedence. The following example shows this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Rectangle</code><code>{</code><code>private:</code><code>    double m_length{ 1.0 };</code><code>    double m_width{ 1.0 };</code><code></code><code>public:</code><code></code><code>    Rectangle(double length, double width)</code><code>        : m_length{ length },</code><code>          m_width{ width }</code><code>    {</code><code>        // m_length and m_width are initialized by the constructor (the default values aren't used)</code><code>    }</code><code></code><code>    Rectangle(double length)</code><code>        : m_length{ length }</code><code>    {</code><code>        // m_length is initialized by the constructor.</code><code>        // m_width's default value (1.0) is used.</code><code>    }</code><code></code><code>    void print()</code><code>    {</code><code>        std::cout &lt;&lt; "length: " &lt;&lt; m_length &lt;&lt; ", width: " &lt;&lt; m_width &lt;&lt; '\n';</code><code>    }</code><code></code><code>};</code><code> </code><code>int main()</code><code>{</code><code>    Rectangle x{ 2.0, 3.0 };</code><code>    x.print();</code><code></code><code>    Rectangle y{ 4.0 };</code><code>    y.print();</code><code> </code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>length: 2.0, width: 3.0
length: 4.0, width: 1.0
</pre><p>Note that initializing members using non-static member initialization requires using either an equals sign, or a brace (uniform) initializer -- the parenthesis initialization form doesn’t work here:</p><pre class="language-cpp line-numbers"><code>class A</code><code>{</code><code>    int m_a = 1;  // ok (copy initialization)</code><code>    int m_b{ 2 }; // ok (brace initialization)</code><code>    int m_c(3);   // doesn't work (parenthesis initialization)</code><code>};</code></pre><div class="cpp-note cpp-lightgreenbackground"><h4>Rule</h4><p>Favor use of non-static member initialization to give default values for your member variables.</p></div><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>The program below has a lot of redundancy. Update the following program to use non-static member initialization and member initializer lists.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class Ball</code><code>{</code><code>private:</code><code>	std::string m_color;</code><code>	double m_radius;</code><code></code><code>public:</code><code>	// Default constructor with no parameters</code><code>	Ball()</code><code>	{</code><code>		m_color = "black";</code><code>		m_radius = 10.0;</code><code>	}</code><code></code><code>	// Constructor with only color parameter (radius will use default value)</code><code>	Ball(std::string_view color)</code><code>	{</code><code>		m_color = color;</code><code>		m_radius = 10.0;</code><code>	}</code><code></code><code>	// Constructor with only radius parameter (color will use default value)</code><code>	Ball(double radius)</code><code>	{</code><code>		m_color = "black";</code><code>		m_radius = radius;</code><code>	}</code><code></code><code>	// Constructor with both color and radius parameters</code><code>	Ball(std::string_view color, double radius)</code><code>	{</code><code>		m_color = color;</code><code>		m_radius = radius;</code><code>	}</code><code></code><code>	void print()</code><code>	{</code><code>		std::cout &lt;&lt; "color: " &lt;&lt; m_color &lt;&lt; ", radius: " &lt;&lt; m_radius &lt;&lt; '\n';</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Ball def;</code><code>	def.print();</code><code></code><code>	Ball blue{ "blue" };</code><code>	blue.print();</code><code></code><code>	Ball twenty{ 20.0 };</code><code>	twenty.print();</code><code></code><code>	Ball blueTwenty{ "blue", 20.0 };</code><code>	blueTwenty.print();</code><code></code><code>	return 0;</code><code>}</code></pre><p>This program should produce the result:</p><pre>color: black, radius: 10
color: blue, radius: 10
color: black, radius: 20
color: blue, radius: 20
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class Ball</code><code>{</code><code>private:</code><code>    // Our non-static member initializers</code><code>    std::string m_color{ "black" };</code><code>    double m_radius{ 10.0 };</code><code></code><code>public:</code><code>    // Default constructor (color and radius will use default value)</code><code>    Ball() = default;</code><code></code><code>    // Constructor with only radius parameter (color will use default value)</code><code>    Ball(double radius)</code><code>        : m_radius{ radius }</code><code>    {</code><code>    }</code><code></code><code>    // Constructor with only color parameter (radius will use default value)</code><code>    Ball(std::string_view color)</code><code>        : m_color{ color }</code><code>    {</code><code>    }</code><code></code><code>    // Constructor with both color and radius parameters</code><code>    Ball(std::string_view color, double radius)</code><code>        : m_color{ color }, m_radius{ radius }</code><code>    {</code><code>    }</code><code></code><code></code><code>    void print()</code><code>    {</code><code>        std::cout &lt;&lt; "color: " &lt;&lt; m_color &lt;&lt; ", radius: " &lt;&lt; m_radius &lt;&lt; '\n';</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Ball def{};</code><code>    def.print();</code><code></code><code>    Ball blue{ "blue" };</code><code>    blue.print();</code><code></code><code>    Ball twenty{ 20.0 };</code><code>    twenty.print();</code><code></code><code>    Ball blueTwenty{ "blue", 20.0 };</code><code>    blueTwenty.print();</code><code></code><code>    return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">13.8 — Overlapping and delegating constructors</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Constructors with overlapping functionality</h3><p>When you instantiate a new object, the object’s constructor is called implicitly. It’s not uncommon to have a class with multiple constructors that have overlapping functionality. Consider the following class:</p><pre class="language-cpp line-numbers"><code>class Foo</code><code>{</code><code>public:</code><code>    Foo()</code><code>    {</code><code>        // code to do A</code><code>    }</code><code></code><code>    Foo(int value)</code><code>    {</code><code>        // code to do A</code><code>        // code to do B</code><code>    }</code><code>};</code></pre><p>This class has two constructors: a default constructor, and a constructor that takes an integer. Because the “code to do A” portion of the constructor is required by both constructors, the code is duplicated in each constructor.</p><p>As you’ve (hopefully) learned by now, having duplicate code is something to be avoided as much as possible, so let’s take a look at some ways to address this.</p><br><h3>The obvious solution doesn’t work</h3><p>The obvious solution would be to have the Foo(int) constructor call the Foo() constructor to do the A portion.</p><pre class="language-cpp line-numbers"><code>class Foo</code><code>{</code><code>public:</code><code>    Foo()</code><code>    {</code><code>        // code to do A</code><code>    }</code><code></code><code>    Foo(int value)</code><code>    {</code><code>        Foo(); // use the above constructor to do A (doesn't work)</code><code>        // code to do B</code><code>    }</code><code>};</code></pre><p>However, if you try to have one constructor call another constructor in this way, it will compile and maybe cause a warning, but it will not work as you expect, and you will likely spend a long time trying to figure out why, even with a debugger. What’s happening is that <code>Foo();</code> instantiates a new <code>Foo</code> object, which is immediately discarded, because it’s not stored in a variable.</p><br><h3>Delegating constructors</h3><p>Constructors are allowed to call other constructors from the same class. This process is called <strong>delegating constructors</strong> (or <strong>constructor chaining</strong>).</p><p>To have one constructor call another, simply call the constructor in the member initializer list. This is one case where calling another constructor directly is acceptable. Applied to our example above:</p><pre class="language-cpp line-numbers"><code>class Foo</code><code>{</code><code>private:</code><code></code><code>public:</code><code>    Foo()</code><code>    {</code><code>        // code to do A</code><code>    }</code><code></code><code>    Foo(int value): Foo{} // use Foo() default constructor to do A</code><code>    {</code><code>        // code to do B</code><code>    }</code><code></code><code>};</code></pre><p>This works exactly as you’d expect. Make sure you’re calling the constructor from the member initializer list, not in the body of the constructor.</p><p>Here’s another example of using delegating constructors to reduce redundant code:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class Employee</code><code>{</code><code>private:</code><code>    int m_id{};</code><code>    std::string m_name{};</code><code> </code><code>public:</code><code>    Employee(int id=0, std::string_view name=""):</code><code>        m_id{ id }, m_name{ name }</code><code>    {</code><code>        std::cout &lt;&lt; "Employee " &lt;&lt; m_name &lt;&lt; " created.\n";</code><code>    }</code><code> </code><code>    // Use a delegating constructor to minimize redundant code</code><code>    Employee(std::string_view name) : Employee{ 0, name }</code><code>    { }</code><code>};</code></pre><p>This class has 2 constructors, one of which delegates to Employee(int, std::string_view). In this way, the amount of redundant code is minimized (we only have to write one constructor body instead of two).</p><p>A few additional notes about delegating constructors. First, a constructor that delegates to another constructor is not allowed to do any member initialization itself. So your constructors can delegate or initialize, but not both.</p><p>Second, it’s possible for one constructor to delegate to another constructor, which delegates back to the first constructor. This forms an infinite loop, and will cause your program to run out of stack space and crash. You can avoid this by ensuring all of your constructors resolve to a non-delegating constructor.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>If you have multiple constructors that have the same functionality, use delegating constructors to avoid duplicate code.</p></div><br><h3>Using a normal member function for setup</h3><p>Because a constructor can only initialize or delegate, this leads to a challenge if our default constructor does some common initialization. Consider the following class:</p><pre class="language-cpp line-numbers"><code>class Foo</code><code>{</code><code>private:</code><code>    const int m_value { 0 };</code><code></code><code>public:</code><code>    Foo()</code><code>    {</code><code>         // code to do some common setup tasks (e.g. open a file or database)</code><code>    }</code><code></code><code>    Foo(int value) : m_value { value } // we must initialize m_value since it's const</code><code>    {</code><code>        // how do we get to the common initialization code in Foo()?</code><code>    }</code><code></code><code>};</code></pre><p>Our <code>Foo(int)</code> constructor can either initialize <code>m_value</code>, or delegate to <code>Foo()</code> to access the setup code, but not both. But what if we need to do both? A bad solution would be to copy the setup code from our default constructor to each of our other constructors. But this will result in duplicate code, and a potential maintenance headache.</p><p>Constructors are allowed to call non-constructor member functions (and non-member functions), so a better solution is to use a normal (non-constructor) member function to handle the common setup tasks, like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Foo</code><code>{</code><code>private:</code><code>    const int m_value { 0 };</code><code></code><code>    void setup() // setup is private so it can only be used by our constructors</code><code>    {</code><code>        // code to do some common setup tasks (e.g. open a file or database)</code><code>        std::cout &lt;&lt; "Setting things up...\n";</code><code>    }</code><code></code><code>public:</code><code>    Foo()</code><code>    {</code><code>        setup();</code><code>    }</code><code></code><code>    Foo(int value) : m_value { value } // we must initialize m_value since it's const</code><code>    {</code><code>        setup();</code><code>    }</code><code></code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Foo a;</code><code>    Foo b{ 5 };</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this case, we’ve created a <code>setup()</code> member function to handle various setup tasks that we need, and both of our constructors call <code>setup()</code>. We’ve made this function private so we can ensure that only members of our class can call it.</p><p>Of course, <code>setup()</code> isn’t a constructor, so it can’t initialize members. By the time the constructor calls <code>setup()</code>, the members have already been created (and initialized if an initialization value was provided). The <code>setup()</code> function can only assign values to members or do other types of setup tasks that can be done through normal statements (e.g. open files or databases). The <code>setup()</code> function can’t do things like bind a member reference or set a const value (both of which must be done on initialization), or assign values to members that don’t support assignment.</p><br><h3>Resetting a class object</h3><p>Relatedly, you may find yourself in the situation where you want to write a member function (e.g. named <code>reset()</code>) to reset a class object back to the default state.</p><p>Because you probably already have a default constructor that initializes your members to the appropriate default values, you may be tempted to try to call the default constructor directly from <code>reset()</code>. However, trying to call a constructor directly will generally result in unexpected behavior as we have shown above, so that won’t work.</p><p>A mediocre implementation of a <code>reset()</code> function might look like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Foo</code><code>{</code><code>private:</code><code>    int m_a{ 1 };</code><code>    int m_b{ 2 };</code><code></code><code>public:</code><code>    Foo()</code><code>    {</code><code>    }</code><code></code><code>    Foo(int a, int b)</code><code>        : m_a{ a }, m_b{ b }</code><code>    {</code><code>    }</code><code></code><code>    void print()</code><code>    {</code><code>        std::cout &lt;&lt; m_a &lt;&lt; ' ' &lt;&lt; m_b &lt;&lt; '\n';</code><code>    }</code><code></code><code>    void reset()</code><code>    {</code><code>        m_a = 1;</code><code>        m_b = 2;</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Foo a{ 3, 4 };</code><code>    a.reset();</code><code></code><code>    a.print();</code><code></code><code>    return 0;</code><code>}</code></pre><p>While this works, it violates the DRY principle, as we have our “default” values in two places: once in the non-static member initializers, and again in the body of <code>reset()</code>. There is no way for the <code>reset()</code> function to get the default values from the non-static initializer.</p><p>However, if the class is assignable (meaning it has an accessible assignment operator), we can create a new class object, and then use assignment to overwrite the values in the object we want to reset:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Foo</code><code>{</code><code>private:</code><code>    int m_a{ 5 };</code><code>    int m_b{ 6 };</code><code></code><code></code><code>public:</code><code>    Foo()</code><code>    {</code><code>    }</code><code></code><code>    Foo(int a, int b)</code><code>        : m_a{ a }, m_b{ b }</code><code>    {</code><code>    }</code><code></code><code>    void print()</code><code>    {</code><code>        std::cout &lt;&lt; m_a &lt;&lt; ' ' &lt;&lt; m_b &lt;&lt; '\n';</code><code>    }</code><code></code><code>    void reset()</code><code>    {</code><code>        // consider this a bit of magic for now</code><code>        *this = Foo(); // create new Foo object, then use assignment to overwrite our implicit object</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Foo a{ 1, 2 };</code><code>    a.reset();</code><code></code><code>    a.print();</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above <code>reset()</code> function, we first create a default <code>Foo</code> object (which will have default values). Then we assign that default <code>Foo</code> object to the object that member function <code>reset()</code> was called on (<code>*this</code>). The compiler will do a memberwise copy.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>We cover the <code>this</code> pointer in upcoming lesson <a href="https://www.learncpp.com/cpp-tutorial/the-hidden-this-pointer/">13.10 -- The hidden “this” pointer</a>, and assignment of classes in upcoming lesson <a href="https://www.learncpp.com/cpp-tutorial/overloading-the-assignment-operator/">14.15 -- Overloading the assignment operator</a>.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">13.9 — Destructors</h1></header><div class="entry-content" itemprop="articleBody"><p>A <strong>destructor</strong> is another special kind of class member function that is executed when an object of that class is destroyed. Whereas constructors are designed to initialize a class, destructors are designed to help clean up.</p><p>When an object goes out of scope normally, or a dynamically allocated object is explicitly deleted using the delete keyword, the class destructor is automatically called (if it exists) to do any necessary clean up before the object is removed from memory. For simple classes (those that just initialize the values of normal member variables), a destructor is not needed because C++ will automatically clean up the memory for you.</p><p>However, if your class object is holding any resources (e.g. dynamic memory, or a file or database handle), or if you need to do any kind of maintenance before the object is destroyed, the destructor is the perfect place to do so, as it is typically the last thing to happen before the object is destroyed.</p><br><h3>Destructor naming</h3><p>Like constructors, destructors have specific naming rules:</p><ol start="1"><li>The destructor must have the same name as the class, preceded by a tilde (~).</li><li>The destructor can not take arguments.</li><li>The destructor has no return type.</li></ol><p>A class can only have a single destructor.</p><p>Generally you should not call a destructor explicitly (as it will be called automatically when the object is destroyed), since there are rarely cases where you’d want to clean up an object more than once. However, destructors may safely call other member functions since the object isn’t destroyed until after the destructor executes.</p><br><h3>A destructor example</h3><p>Let’s take a look at a simple class that uses a destructor:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cassert></cassert></code><code>#include <cstddef></cstddef></code><code></code><code>class IntArray</code><code>{</code><code>private:</code><code>	int* m_array{};</code><code>	int m_length{};</code><code></code><code>public:</code><code>	IntArray(int length) // constructor</code><code>	{</code><code>		assert(length &gt; 0);</code><code></code><code>		m_array = new int[static_cast<std::size_t>(length)]{};</std::size_t></code><code>		m_length = length;</code><code>	}</code><code></code><code>	~IntArray() // destructor</code><code>	{</code><code>		// Dynamically delete the array we allocated earlier</code><code>		delete[] m_array;</code><code>	}</code><code></code><code>	void setValue(int index, int value) { m_array[index] = value; }</code><code>	int getValue(int index) { return m_array[index]; }</code><code></code><code>	int getLength() { return m_length; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	IntArray ar ( 10 ); // allocate 10 integers</code><code>	for (int count{ 0 }; count &lt; ar.getLength(); ++count)</code><code>		ar.setValue(count, count+1);</code><code></code><code>	std::cout &lt;&lt; "The value of element 5 is: " &lt;&lt; ar.getValue(5) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>} // ar is destroyed here, so the ~IntArray() destructor function is called here</code></pre><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>If you compile the above example and get the following error:</p><pre>error: 'class IntArray' has pointer data members [-Werror=effc++]|
error:   but does not override 'IntArray(const IntArray&amp;)' [-Werror=effc++]|
error:   or 'operator=(const IntArray&amp;)' [-Werror=effc++]|
</pre><p>Then you can either remove the “-Weffc++” flag from your compile settings for this example, or you can add the following two lines to the class:</p><pre class="language-cpp line-numbers"><code>	IntArray(const IntArray&amp;) = delete;</code><code>	IntArray&amp; operator=(const IntArray&amp;) = delete;</code></pre><p>We’ll discuss what these do in <a href="https://www.learncpp.com/cpp-tutorial/converting-constructors-explicit-and-delete/">14.14 -- Converting constructors, explicit, and delete</a></p></div><p>This program produces the result:</p><pre>The value of element 5 is: 6
</pre><p>On the first line of main(), we instantiate a new IntArray class object called ar, and pass in a length of 10. This calls the constructor, which dynamically allocates memory for the array member. We must use dynamic allocation here because we do not know at compile time what the length of the array is (the caller decides that).</p><p>At the end of main(), ar goes out of scope. This causes the ~IntArray() destructor to be called, which deletes the array that we allocated in the constructor!</p><div class="cpp-note cpp-lightgraybackground"><h4>A reminder</h4><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/an-introduction-to-stdvector/">11.17 -- An introduction to std::vector</a>, we note that parentheses based initialization should be used when initializing an array/container/list class with a length (as opposed to a list of elements). For this reason, we initialize IntArray using <code>IntArray ar ( 10 );</code>.</p></div><br><h3>Constructor and destructor timing</h3><p>As mentioned previously, the constructor is called when an object is created, and the destructor is called when an object is destroyed. In the following example, we use cout statements inside the constructor and destructor to show this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Simple</code><code>{</code><code>private:</code><code>    int m_nID{};</code><code></code><code>public:</code><code>    Simple(int nID)</code><code>        : m_nID{ nID }</code><code>    {</code><code>        std::cout &lt;&lt; "Constructing Simple " &lt;&lt; nID &lt;&lt; '\n';</code><code>    }</code><code></code><code>    ~Simple()</code><code>    {</code><code>        std::cout &lt;&lt; "Destructing Simple" &lt;&lt; m_nID &lt;&lt; '\n';</code><code>    }</code><code></code><code>    int getID() { return m_nID; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    // Allocate a Simple on the stack</code><code>    Simple simple{ 1 };</code><code>    std::cout &lt;&lt; simple.getID() &lt;&lt; '\n';</code><code></code><code>    // Allocate a Simple dynamically</code><code>    Simple* pSimple{ new Simple{ 2 } };</code><code>    </code><code>    std::cout &lt;&lt; pSimple-&gt;getID() &lt;&lt; '\n';</code><code></code><code>    // We allocated pSimple dynamically, so we have to delete it.</code><code>    delete pSimple;</code><code></code><code>    return 0;</code><code>} // simple goes out of scope here</code></pre><p>This program produces the following result:</p><pre>Constructing Simple 1
1
Constructing Simple 2
2
Destructing Simple 2
Destructing Simple 1
</pre><p>Note that “Simple 1” is destroyed after “Simple 2” because we deleted pSimple before the end of the function, whereas simple was not destroyed until the end of main().</p><p>Global variables are constructed before main() and destroyed after main().</p><br><h3>RAII</h3><p>RAII (Resource Acquisition Is Initialization) is a programming technique whereby resource use is tied to the lifetime of objects with automatic duration (e.g. non-dynamically allocated objects). In C++, RAII is implemented via classes with constructors and destructors. A resource (such as memory, a file or database handle, etc…) is typically acquired in the object’s constructor (though it can be acquired after the object is created if that makes sense). That resource can then be used while the object is alive. The resource is released in the destructor, when the object is destroyed. The primary advantage of RAII is that it helps prevent resource leaks (e.g. memory not being deallocated) as all resource-holding objects are cleaned up automatically.</p><p>The IntArray class at the top of this lesson is an example of a class that implements RAII -- allocation in the constructor, deallocation in the destructor. std::string and std::vector are examples of classes in the standard library that follow RAII -- dynamic memory is acquired on initialization, and cleaned up automatically on destruction.</p><br><h3>A warning about the exit() function</h3><p>Note that if you use the exit() function, your program will terminate and no destructors will be called. Be wary if you’re relying on your destructors to do necessary cleanup work (e.g. write something to a log file or database before exiting).</p><br><h3>Summary</h3><p>As you can see, when constructors and destructors are used together, your classes can initialize and clean up after themselves without the programmer having to do any special work! This reduces the probability of making an error, and makes classes easier to use.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">13.10 — The hidden “this” pointer</h1></header><div class="entry-content" itemprop="articleBody"><p>One of the questions about classes that new object-oriented programmers often ask is, “When a member function is called, how does C++ keep track of which object it was called on?”. The answer is that C++ utilizes a hidden pointer named “this”! Let’s take a look at “this” in more detail.</p><p>The following is a simple class that holds an integer and provides a constructor and access functions. Note that no destructor is needed because C++ can clean up integer member variables for us.</p><pre class="language-cpp line-numbers"><code>class Simple</code><code>{</code><code>private:</code><code>    int m_id;</code><code> </code><code>public:</code><code>    Simple(int id)</code><code>        : m_id{ id }</code><code>    {</code><code>    }</code><code></code><code>    void setID(int id) { m_id = id; }</code><code>    int getID() { return m_id; }</code><code>};</code></pre><p>Here’s a sample program that uses this class:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    Simple simple{1};</code><code>    simple.setID(2);</code><code>    std::cout &lt;&lt; simple.getID() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>As you would expect, this program produces the result:</p><pre>2
</pre><p>Somehow, when we call <code>simple.setID(2);</code>, C++ knows that function setID() should operate on object simple, and that m_id actually refers to simple.m_id. Let’s examine the mechanics behind how this works.</p><br><h3>The hidden *this pointer</h3><p>Take a look at the following line of code from the example above:</p><pre class="language-cpp line-numbers"><code>    simple.setID(2);</code></pre><p>Although the call to function setID() looks like it only has one argument, it actually has two! When compiled, the compiler converts <code>simple.setID(2);</code> into the following:</p><pre class="language-cpp line-numbers"><code>    setID(&amp;simple, 2); // note that simple has been changed from an object prefix to a function argument!</code></pre><p>Note that this is now just a standard function call, and the object simple (which was formerly an object prefix) is now passed by address as an argument to the function.</p><p>But that’s only half of the answer. Since the function call now has an added argument, the member function definition needs to be modified to accept (and use) this argument as a parameter. Consequently, the following member function:</p><pre class="language-cpp line-numbers"><code>    void setID(int id) { m_id = id; }</code></pre><p>is converted by the compiler into:</p><pre class="language-cpp line-numbers"><code>    void setID(Simple* const this, int id) { this-&gt;m_id = id; }</code></pre><p>When the compiler compiles a normal member function, it implicitly adds a new parameter to the function named “this”. The <strong>this pointer</strong> is a hidden const pointer that holds the address of the object the member function was called on.</p><p>There’s just one more detail to take care of. Inside the member function, any class members (functions and variables) also need to be updated so they refer to the object the member function was called on. This is easily done by adding a “this-&gt;” prefix to each of them. Thus, in the body of function setID(), <code>m_id</code> (which is a class member variable) has been converted to <code>this-&gt;m_id</code>. Thus, when “this” points to the address of simple, this-&gt;m_id will resolve to simple.m_id.</p><p>Putting it all together:</p><ol start="1"><li>When we call <code>simple.setID(2)</code>, the compiler actually calls setID(&amp;simple, 2).</li><li>Inside setID(), the “this” pointer holds the address of object simple.</li><li>Any member variables inside setID() are prefixed with “this-&gt;”. So when we say <code>m_id = id</code>, the compiler is actually executing <code>this-&gt;m_id = id</code>, which in this case updates simple.m_id to id.</li></ol><p>The good news is that all of this happens automatically, and it doesn’t really matter whether you remember how it works or not. All you need to remember is that all normal member functions have a “this” pointer that refers to the object the function was called on.</p><br><h3>“this” always points to the object being operated on</h3><p>New programmers are sometimes confused about how many “this” pointers exist. Each member function has a “this” pointer parameter that is set to the address of the object being operated on. Consider:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Simple A{1}; // this = &amp;A inside the Simple constructor</code><code>    Simple B{2}; // this = &amp;B inside the Simple constructor</code><code>    A.setID(3); // this = &amp;A inside member function setID</code><code>    B.setID(4); // this = &amp;B inside member function setID</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note that the “this” pointer alternately holds the address of object A or B depending on whether we’ve called a member function on object A or B.</p><p>Because “this” is just a function parameter, it doesn’t add any memory usage to your class (just to the member function call, since that parameter needs to be passed to the function and stored in memory).</p><br><h3>Explicitly referencing “this”</h3><p>Most of the time, you never need to explicitly reference the “this” pointer. However, there are a few occasions where doing so can be useful:</p><p>First, if you have a constructor (or member function) that has a parameter with the same name as a member variable, you can disambiguate them by using “this”:</p><pre class="language-cpp line-numbers"><code>class Something</code><code>{</code><code>private:</code><code>    int data;</code><code></code><code>public:</code><code>    Something(int data)</code><code>    {</code><code>        this-&gt;data = data; // this-&gt;data is the member, data is the local parameter</code><code>    }</code><code>};</code></pre><p>Note that our constructor is taking a parameter of the same name as a member variable. In this case, “data” refers to the parameter, and “this-&gt;data” refers to the member variable. Although this is acceptable coding practice, we find using the “m_” prefix on all member variable names provides a better solution by preventing duplicate names altogether!</p><p>Some developers prefer to explicitly add this-&gt; to all class members. We recommend that you avoid doing so, as it tends to make your code less readable for little benefit. Using the m_ prefix is a more readable way to differentiate member variables from non-member (local) variables.</p><br><h3>Chaining member functions</h3><p>Second, it can sometimes be useful to have a class member function return the object it was working with as a return value. The primary reason to do this is to allow a series of member functions to be “chained” together, so several member functions can be called on the same object! You’ve actually been doing this for a long time. Consider this common example where you’re outputting more than one bit of text using std::cout:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; "Hello, " &lt;&lt; userName;</code></pre><p>In this case, std::cout is an object, and operator&lt;&lt; is a member function that operates on that object. The compiler evaluates the above snippet like this:</p><pre class="language-cpp line-numbers"><code>(std::cout &lt;&lt; "Hello, ") &lt;&lt; userName;</code></pre><p>First, operator&lt;&lt; uses std::cout and the string literal “Hello, ” to print “Hello, ” to the console. However, since this is part of an expression, operator&lt;&lt; also needs to return a value (or void). If operator&lt;&lt; returned void, you’d end up with this:</p><pre class="language-cpp line-numbers"><code>(void) &lt;&lt; userName;</code></pre><p>which clearly doesn’t make any sense (and the compiler would throw an error). Instead, operator&lt;&lt; returns *this, which in this context is the std::cout object. That way, after the first operator&lt;&lt; has been evaluated, we get:</p><pre class="language-cpp line-numbers"><code>(std::cout) &lt;&lt; userName;</code></pre><p>which then prints the user’s name.</p><p>In this way, we only need to specify the object (in this case, std::cout) once, and each function call passes it on to the next function to work with, allowing us to chain multiple commands together.</p><p>We can implement this kind of behavior ourselves. Consider the following class:</p><pre class="language-cpp line-numbers"><code>class Calc</code><code>{</code><code>private:</code><code>    int m_value{0};</code><code></code><code>public:</code><code></code><code>    void add(int value) { m_value += value; }</code><code>    void sub(int value) { m_value -= value; }</code><code>    void mult(int value) { m_value *= value; }</code><code></code><code>    int getValue() { return m_value; }</code><code>};</code></pre><p>If you wanted to add 5, subtract 3, and multiply by 4, you’d have to do this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    Calc calc{};</code><code>    calc.add(5); // returns void</code><code>    calc.sub(3); // returns void</code><code>    calc.mult(4); // returns void</code><code></code><code>    std::cout &lt;&lt; calc.getValue() &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>However, if we make each function return *this, we can chain the calls together. Here is the new version of Calc with “chainable” functions:</p><pre class="language-cpp line-numbers"><code>class Calc</code><code>{</code><code>private:</code><code>    int m_value{};</code><code></code><code>public:</code><code>    Calc&amp; add(int value) { m_value += value; return *this; }</code><code>    Calc&amp; sub(int value) { m_value -= value; return *this; }</code><code>    Calc&amp; mult(int value) { m_value *= value; return *this; }</code><code></code><code>    int getValue() { return m_value; }</code><code>};</code></pre><p>Note that add(), sub() and mult() are now returning *this. Consequently, this allows us to do the following:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    Calc calc{};</code><code>    calc.add(5).sub(3).mult(4);</code><code></code><code>    std::cout &lt;&lt; calc.getValue() &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>We have effectively condensed three lines into one expression! Let’s take a closer look at how this works.</p><p>First, calc.add(5) is called, which adds 5 to our m_value. add() then returns *this, which is just a reference to calc, so calc will be the object used in the subsequent evaluation. Next calc.sub(3) evaluates, which subtracts 3 from m_value and again returns calc. Finally, calc.mult(4) multiplies m_value by 4 and returns calc, which isn’t used further, and is thus ignored.</p><p>Since each function modified calc as it was executed, calc’s m_value now contains the value (((0 + 5) - 3) * 4), which is 8.</p><br><h3>Summary</h3><p>The “this” pointer is a hidden parameter implicitly added to any non-static member function. Most of the time, you will not need to access it directly, but you can if needed. It’s worth noting that “this” is a const pointer -- you can change the value of the underlying object it points to, but you can not make it point to something else!</p><p>By having functions that would otherwise return void return *this instead, you can make those functions chainable. This is most often used when overloading operators for your classes (something we’ll talk about more in <a href="https://www.learncpp.com#Chapter14">chapter 14</a>).</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">13.11 — Class code and header files</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>Defining member functions outside the class definition</strong></p><p>All of the classes that we have written so far have been simple enough that we have been able to implement the member functions directly inside the class definition itself. For example, here’s our ubiquitous Date class:</p><pre class="language-cpp line-numbers"><code>class Date</code><code>{</code><code>private:</code><code>    int m_year;</code><code>    int m_month;</code><code>    int m_day;</code><code> </code><code>public:</code><code>    Date(int year, int month, int day)</code><code>    {</code><code>        setDate(year, month, day);</code><code>    }</code><code></code><code>    void setDate(int year, int month, int day)</code><code>    {</code><code>        m_year = year;</code><code>        m_month = month;</code><code>        m_day = day;</code><code>    }</code><code></code><code>    int getYear() { return m_year; }</code><code>    int getMonth() { return m_month; }</code><code>    int getDay()  { return m_day; }</code><code>};</code></pre><p>However, as classes get longer and more complicated, having all the member function definitions inside the class can make the class harder to manage and work with. Using an already-written class only requires understanding its public interface (the public member functions), not how the class works underneath the hood. The member function implementation details just get in the way.</p><p>Fortunately, C++ provides a way to separate the “declaration” portion of the class from the “implementation” portion. This is done by defining the class member functions outside of the class definition. To do so, simply define the member functions of the class as if they were normal functions, but prefix the class name to the function using the scope resolution operator (::) (same as for a namespace).</p><p>Here is our Date class with the Date constructor and setDate() function defined outside of the class definition. Note that the prototypes for these functions still exist inside the class definition, but the actual implementation has been moved outside:</p><pre class="language-cpp line-numbers"><code>class Date</code><code>{</code><code>private:</code><code>    int m_year;</code><code>    int m_month;</code><code>    int m_day;</code><code> </code><code>public:</code><code>    Date(int year, int month, int day);</code><code></code><code>    void SetDate(int year, int month, int day);</code><code></code><code>    int getYear() { return m_year; }</code><code>    int getMonth() { return m_month; }</code><code>    int getDay()  { return m_day; }</code><code>};</code><code></code><code>// Date constructor</code><code>Date::Date(int year, int month, int day)</code><code>{</code><code>    SetDate(year, month, day);</code><code>}</code><code></code><code>// Date member function</code><code>void Date::SetDate(int year, int month, int day)</code><code>{</code><code>    m_month = month;</code><code>    m_day = day;</code><code>    m_year = year;</code><code>}</code></pre><p>This is pretty straightforward. Because access functions are often only one line, they are typically left in the class definition, even though they could be moved outside.</p><p>Here is another example that includes an externally defined constructor with a member initialization list:</p><pre class="language-cpp line-numbers"><code>class Calc</code><code>{</code><code>private:</code><code>    int m_value = 0;</code><code> </code><code>public:</code><code>    Calc(int value=0): m_value{value} {}</code><code></code><code>    Calc&amp; add(int value) { m_value  += value;  return *this; }</code><code>    Calc&amp; sub(int value) { m_value -= value;  return *this; }</code><code>    Calc&amp; mult(int value) { m_value *= value;  return *this; }</code><code> </code><code>    int getValue() { return m_value ; }</code><code>};</code></pre><p>becomes:</p><pre class="language-cpp line-numbers"><code>class Calc</code><code>{</code><code>private:</code><code>    int m_value = 0;</code><code> </code><code>public:</code><code>    Calc(int value=0);</code><code></code><code>    Calc&amp; add(int value);</code><code>    Calc&amp; sub(int value);</code><code>    Calc&amp; mult(int value);</code><code> </code><code>    int getValue() { return m_value; }</code><code>};</code><code></code><code>Calc::Calc(int value): m_value{value}</code><code>{</code><code>}</code><code></code><code>Calc&amp; Calc::add(int value)</code><code>{</code><code>    m_value += value;</code><code>    return *this;</code><code>}</code><code></code><code>Calc&amp; Calc::sub(int value) </code><code>{</code><code>    m_value -= value;</code><code>    return *this;</code><code>}</code><code></code><code>Calc&amp; Calc::mult(int value)</code><code>{</code><code>    m_value *= value;</code><code>    return *this;</code><code>}</code></pre><p><strong>Putting class definitions in a header file</strong></p><p>In the lesson on <a href="https://www.learncpp.com/cpp-tutorial/19-header-files/">header files</a>, you learned that you can put function declarations inside header files in order to use those functions in multiple files or even multiple projects. Classes are no different. Class definitions can be put in header files in order to facilitate reuse in multiple files or multiple projects. Traditionally, the class definition is put in a header file of the same name as the class, and the member functions defined outside of the class are put in a .cpp file of the same name as the class.</p><p>Here’s our Date class again, broken into a .cpp and .h file:</p><p>Date.h:</p><pre class="language-cpp line-numbers"><code>#ifndef DATE_H</code><code>#define DATE_H</code><code></code><code>class Date</code><code>{</code><code>private:</code><code>    int m_year;</code><code>    int m_month;</code><code>    int m_day;</code><code> </code><code>public:</code><code>    Date(int year, int month, int day);</code><code></code><code>    void SetDate(int year, int month, int day);</code><code></code><code>    int getYear() { return m_year; }</code><code>    int getMonth() { return m_month; }</code><code>    int getDay()  { return m_day; }</code><code>};</code><code></code><code>#endif</code></pre><p>Date.cpp:</p><pre class="language-cpp line-numbers"><code>#include "Date.h"</code><code></code><code>// Date constructor</code><code>Date::Date(int year, int month, int day)</code><code>{</code><code>    SetDate(year, month, day);</code><code>}</code><code></code><code>// Date member function</code><code>void Date::SetDate(int year, int month, int day)</code><code>{</code><code>    m_month = month;</code><code>    m_day = day;</code><code>    m_year = year;</code><code>}</code></pre><p>Now any other header or code file that wants to use the Date class can simply <code>#include "Date.h"</code>. Note that Date.cpp also needs to be compiled into any project that uses Date.h so the linker knows how Date is implemented.</p><p><strong>Doesn’t defining a class in a header file violate the one-definition rule?</strong></p><p>It shouldn’t. If your header file has proper header guards, it shouldn’t be possible to include the class definition more than once into the same file.</p><p>Types (which include classes), are exempt from the part of the one-definition rule that says you can only have one definition per program. Therefore, there isn’t an issue #including class definitions into multiple code files (if there was, classes wouldn’t be of much use).</p><p><strong>Doesn’t defining member functions in the header violate the one-definition rule?</strong></p><p>It depends. Member functions defined inside the class definition are considered implicitly inline. Inline functions are exempt from the one definition per program part of the one-definition rule. This means there is no problem defining trivial member functions (such as access functions) inside the class definition itself.</p><p>Member functions defined outside the class definition are treated like normal functions, and are subject to the one definition per program part of the one-definition rule. Therefore, those functions should be defined in a code file, not inside the header. One exception is for template functions, which are also implicitly inline.</p><p><strong>So what should I define in the header file vs the cpp file, and what inside the class definition vs outside?</strong></p><p>You might be tempted to put all of your member function definitions into the header file, inside the class. While this will compile, there are a couple of downsides to doing so. First, as mentioned above, this clutters up your class definition. Second, if you change anything about the code in the header, then you’ll need to recompile every file that includes that header. This can have a ripple effect, where one minor change causes the entire program to need to recompile (which can be slow). If you change the code in a .cpp file, only that .cpp file needs to be recompiled!</p><p>Therefore, we recommend the following:</p><ul><li>For classes used in only one file that aren’t generally reusable, define them directly in the single .cpp file they’re used in.</li><li>For classes used in multiple files, or intended for general reuse, define them in a .h file that has the same name as the class.</li><li>Trivial member functions (trivial constructors or destructors, access functions, etc…) can be defined inside the class.</li><li>Non-trivial member functions should be defined in a .cpp file that has the same name as the class.</li></ul><p>In future lessons, most of our classes will be defined in the .cpp file, with all the functions implemented directly in the class definition. This is just for convenience and to keep the examples short. In real projects, it is much more common for classes to be put in their own code and header files, and you should get used to doing so.</p><p><strong>Default parameters</strong></p><p>Default parameters for member functions should be declared in the class definition (in the header file), where they can be seen by whomever #includes the header.</p><p><strong>Libraries</strong></p><p>Separating the class definition and class implementation is very common for libraries that you can use to extend your program. Throughout your programs, you’ve #included headers that belong to the standard library, such as iostream, string, vector, array, and other. Notice that you haven’t needed to add iostream.cpp, string.cpp, vector.cpp, or array.cpp into your projects. Your program needs the declarations from the header files in order for the compiler to validate you’re writing programs that are syntactically correct. However, the implementations for the classes that belong to the C++ standard library are contained in a precompiled file that is linked in at the link stage. You never see the code.</p><p>Outside of some open source software (where both .h and .cpp files are provided), most 3rd party libraries provide only header files, along with a precompiled library file. There are several reasons for this: 1) It’s faster to link a precompiled library than to recompile it every time you need it, 2) a single copy of a precompiled library can be shared by many applications, whereas compiled code gets compiled into every executable that uses it (inflating file sizes), and 3) intellectual property reasons (you don’t want people stealing your code).</p><p>Having your own files separated into declaration (header) and implementation (code file) is not only good form, it also makes creating your own custom libraries easier. Creating your own libraries is beyond the scope of these tutorials, but separating your declaration and implementation is a prerequisite to doing so.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">13.12 — Const class objects and member functions</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/const-variables-and-symbolic-constants/">4.13 -- Const variables and symbolic constants</a>, you learned that fundamental data types (int, double, char, etc…) can be made const via the const keyword, and that all const variables must be initialized at time of creation.</p><p>In the case of const fundamental data types, initialization can be done through copy, direct, or uniform initialization:</p><pre class="language-cpp line-numbers"><code>const int value1 = 5; // copy initialization</code><code>const int value2(7); // direct initialization</code><code>const int value3 { 9 }; // uniform initialization (C++11)</code></pre><br><h3>Const classes</h3><p>Similarly, instantiated class objects can also be made const by using the const keyword. Initialization is done via class constructors:</p><pre class="language-cpp line-numbers"><code>const Date date1; // initialize using default constructor</code><code>const Date date2(2020, 10, 16); // initialize using parameterized constructor</code><code>const Date date3 { 2020, 10, 16 }; // initialize using parameterized constructor (C++11)</code></pre><p>Once a const class object has been initialized via constructor, any attempt to modify the member variables of the object is disallowed, as it would violate the const-ness of the object. This includes both changing member variables directly (if they are public), or calling member functions that set the value of member variables. Consider the following class:</p><pre class="language-cpp line-numbers"><code>class Something</code><code>{</code><code>public:</code><code>    int m_value {};</code><code></code><code>    Something(): m_value{0} { }</code><code></code><code>    void setValue(int value) { m_value = value; }</code><code>    int getValue() { return m_value ; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    const Something something{}; // calls default constructor</code><code></code><code>    something.m_value = 5; // compiler error: violates const</code><code>    something.setValue(5); // compiler error: violates const</code><code></code><code>    return 0;</code><code>}</code></pre><p>Both of the above lines involving variable something are illegal because they violate the constness of something by either attempting to change a member variable directly, or by calling a member function that attempts to change a member variable.</p><p>Just like with normal variables, you’ll generally want to make your class objects const when you need to ensure they aren’t modified after creation.</p><br><h3>Const member functions</h3><p>Now, consider the following line of code:</p><pre class="language-cpp line-numbers"><code>   std::cout &lt;&lt; something.getValue();</code></pre><p>Perhaps surprisingly, this will also cause a compile error, even though getValue() doesn’t do anything to change a member variable! It turns out that const class objects can only explicitly call <em>const</em> member functions, and getValue() has not been marked as a const member function.</p><p>A <strong>const member function</strong> is a member function that guarantees it will not modify the object or call any non-const member functions (as they may modify the object).</p><p>To make getValue() a const member function, we simply append the const keyword to the function prototype, after the parameter list, but before the function body:</p><pre class="language-cpp line-numbers"><code>class Something</code><code>{</code><code>public:</code><code>    int m_value {};</code><code></code><code>    Something(): m_value{0} { }</code><code></code><code>    void resetValue() { m_value = 0; }</code><code>    void setValue(int value) { m_value = value; }</code><code></code><code>    int getValue() const { return m_value; } // note addition of const keyword after parameter list, but before function body</code><code>};</code></pre><p>Now getValue() has been made a const member function, which means we can call it on any const objects.</p><p>For member functions defined outside of the class definition, the const keyword must be used on both the function prototype in the class definition and on the function definition:</p><pre class="language-cpp line-numbers"><code>class Something</code><code>{</code><code>public:</code><code>    int m_value {};</code><code></code><code>    Something(): m_value{0} { }</code><code></code><code>    void resetValue() { m_value = 0; }</code><code>    void setValue(int value) { m_value = value; }</code><code></code><code>    int getValue() const; // note addition of const keyword here</code><code>};</code><code></code><code>int Something::getValue() const // and here</code><code>{</code><code>    return m_value;</code><code>}</code></pre><p>Futhermore, any const member function that attempts to change a member variable or call a non-const member function will cause a compiler error to occur. For example:</p><pre class="language-cpp line-numbers"><code>class Something</code><code>{</code><code>public:</code><code>    int m_value {};</code><code></code><code>    void resetValue() const { m_value = 0; } // compile error, const functions can't change member variables.</code><code>};</code></pre><p>In this example, resetValue() has been marked as a const member function, but it attempts to change m_value. This will cause a compiler error.</p><p>Note that constructors cannot be marked as const. This is because constructors need to be able to initialize their member variables, and a const constructor would not be able to do so. Consequently, the language disallows const constructors.</p><p>Const member functions can also be called by non-const objects.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Make any member function that does not modify the state of the class object const, so that it can be called by const objects.</p></div><br><h3>Const objects via pass by const reference</h3><p>Although instantiating const class objects is one way to create const objects, a more common way to get a const object is by passing an object to a function by const reference.</p><p>In the lesson <a href="https://www.learncpp.com/cpp-tutorial/pass-by-lvalue-reference/">9.5 -- Pass by lvalue reference</a>, we covered the merits of passing class arguments by const reference instead of by value. To recap, passing a class argument by value causes a copy of the class to be made (which is slow) -- most of the time, we don’t need a copy, a reference to the original argument works just fine, and is more performant because it avoids the needless copy. We typically make the reference const in order to ensure the function does not inadvertently change the argument, and to allow the function to work with R-values (e.g. literals), which can be passed as const references, but not non-const references.</p><p>Can you figure out what’s wrong with the following code?</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Date</code><code>{</code><code>private:</code><code>    int m_year {};</code><code>    int m_month {};</code><code>    int m_day {};</code><code></code><code>public:</code><code>    Date(int year, int month, int day)</code><code>    {</code><code>        setDate(year, month, day);</code><code>    }</code><code> </code><code>    void setDate(int year, int month, int day)</code><code>    {</code><code>        m_year = year;</code><code>        m_month = month;</code><code>        m_day = day;</code><code>    }</code><code> </code><code>    int getYear() { return m_year; }</code><code>    int getMonth() { return m_month; }</code><code>    int getDay() { return m_day; }</code><code>};</code><code></code><code>// note: We're passing date by const reference here to avoid making a copy of date</code><code>void printDate(const Date&amp; date)</code><code>{</code><code>    std::cout &lt;&lt; date.getYear() &lt;&lt; '/' &lt;&lt; date.getMonth() &lt;&lt; '/' &lt;&lt; date.getDay() &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Date date{2016, 10, 16};</code><code>    printDate(date);</code><code></code><code>    return 0;</code><code>}</code></pre><p>The answer is that inside of the printDate function, date is treated as a const object. And with that const date, we’re calling functions getYear(), getMonth(), and getDay(), which are all non-const. Since we can’t call non-const member functions on const objects, this will cause a compile error.</p><p>The fix is simple: make getYear(), getMonth(), and getDay() const:</p><pre class="language-cpp line-numbers"><code>class Date</code><code>{</code><code>private:</code><code>    int m_year {};</code><code>    int m_month {};</code><code>    int m_day {};</code><code></code><code>public:</code><code>    Date(int year, int month, int day)</code><code>    {</code><code>        setDate(year, month, day);</code><code>    }</code><code> </code><code>    // setDate() cannot be const, modifies member variables</code><code>    void setDate(int year, int month, int day)</code><code>    {</code><code>        m_year = year;</code><code>        m_month = month;</code><code>        m_day = day;</code><code>    }</code><code> </code><code>    // The following getters can all be made const</code><code>    int getYear() const { return m_year; }</code><code>    int getMonth() const { return m_month; }</code><code>    int getDay() const { return m_day; }</code><code>};</code></pre><p>Now in function printDate(), const date will be able to successfully call getYear(), getMonth(), and getDay().</p><br><h3>Const members can not return non-const references to members</h3><p>When a member function is const, the hidden *this pointer is also const, which means all members are treated as const within that function. Therefore, a const member function can not return a non-const reference to a member, as that would allow the caller to have non-const access to that const member. Const member functions can return const references to members.</p><p>We’ll see an example of this in the next section.</p><br><h3>Overloading const and non-const function</h3><p>Finally, although it is not done very often, it is possible to overload a function in such a way to have a const and non-const version of the same function. This works because the const qualifier is considered part of the function’s signature, so two functions which differ only in their const-ness are considered distinct.</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>class Something</code><code>{</code><code>private:</code><code>    std::string m_value {};</code><code></code><code>public:</code><code>    Something(const std::string&amp; value=""): m_value{ value } {}</code><code></code><code>    const std::string&amp; getValue() const { return m_value; } // getValue() for const objects (returns const reference)</code><code>    std::string&amp; getValue() { return m_value; } // getValue() for non-const objects (returns non-const reference)</code><code>};</code></pre><p>The const version of the function will be called on any const objects, and the non-const version will be called on any non-const objects:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	Something something;</code><code>	something.getValue() = "Hi"; // calls non-const getValue();</code><code></code><code>	const Something something2;</code><code>	something2.getValue(); // calls const getValue();</code><code></code><code>	return 0;</code><code>}</code></pre><p>Overloading a function with a const and non-const version is typically done when the return value needs to differ in constness. In the example above, the non-const version of getValue() will only work with non-const objects, but is more flexible in that we can use it to both read and write m_value (which we do by assigning the string “Hi”).</p><p>The const version of getValue() will work with either const or non-const objects, but returns a const reference, to ensure we can’t modify the const object’s data.</p><br><h3>Summary</h3><p>Because passing objects by const reference is common, your classes should be const-friendly. That means making any member function that does not modify the state of the class object const!</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">13.13 — Static member variables</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>Review of static keyword uses</strong></p><p>In the lesson on <a href="https://www.learncpp.com/cpp-tutorial/43-file-scope-and-the-static-keyword/">file scope and the static keyword</a>, you learned that static variables keep their values and are not destroyed even after they go out of scope. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int generateID()</code><code>{</code><code>    static int s_id{ 0 };</code><code>    return ++s_id;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; generateID() &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; generateID() &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; generateID() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>1
2
3
</pre><p>Note that s_id has kept its value across multiple function calls.</p><p>The static keyword has another meaning when applied to global variables -- it gives them internal linkage (which restricts them from being seen/used outside of the file they are defined in). Because global variables are typically avoided, the static keyword is not often used in this capacity.</p><p><strong>Static member variables</strong></p><p>C++ introduces two more uses for the static keyword when applied to classes: static member variables, and static member functions. Fortunately, these uses are fairly straightforward. We’ll talk about static member variables in this lesson, and static member functions in the next.</p><p>Before we go into the static keyword as applied to member variables, first consider the following class:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Something</code><code>{</code><code>public:</code><code>    int m_value{ 1 };</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Something first;</code><code>    Something second;</code><code>    </code><code>    first.m_value = 2;</code><code></code><code>    std::cout &lt;&lt; first.m_value &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; second.m_value &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>When we instantiate a class object, each object gets its own copy of all normal member variables. In this case, because we have declared two Something class objects, we end up with two copies of m_value: first.m_value, and second.m_value. first.m_value is distinct from second.m_value. Consequently, the program above prints:</p><pre>2
1
</pre><p>Member variables of a class can be made static by using the static keyword. Unlike normal member variables, static member variables are shared by all objects of the class. Consider the following program, similar to the above:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Something</code><code>{</code><code>public:</code><code>    static int s_value;</code><code>};</code><code></code><code>int Something::s_value{ 1 };</code><code></code><code>int main()</code><code>{</code><code>    Something first;</code><code>    Something second;</code><code></code><code>    first.s_value = 2;</code><code></code><code>    std::cout &lt;&lt; first.s_value &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; second.s_value &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>This program produces the following output:</p><pre>2
2
</pre><p>Because s_value is a static member variable, s_value is shared between all objects of the class. Consequently, first.s_value is the same variable as second.s_value. The above program shows that the value we set using first can be accessed using second!</p><p><strong>Static members are not associated with class objects</strong></p><p>Although you can access static members through objects of the class (as shown with first.s_value and second.s_value in the example above), it turns out that static members exist even if no objects of the class have been instantiated! Much like global variables, they are created when the program starts, and destroyed when the program ends.</p><p>Consequently, it is better to think of static members as belonging to the class itself, not to the objects of the class. Because s_value exists independently of any class objects, it can be accessed directly using the class name and the scope resolution operator (in this case, Something::s_value):</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Something</code><code>{</code><code>public:</code><code>    static int s_value; // declares the static member variable</code><code>};</code><code></code><code>int Something::s_value{ 1 }; // defines the static member variable (we'll discuss this section below)</code><code></code><code>int main()</code><code>{</code><code>    // note: we're not instantiating any objects of type Something</code><code></code><code>    Something::s_value = 2;</code><code>    std::cout &lt;&lt; Something::s_value &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>In the above snippet, s_value is referenced by class name rather than through an object. Note that we have not even instantiated an object of type Something, but we are still able to access and use Something::s_value. This is the preferred method for accessing static members.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Access static members by class name (using the scope resolution operator) rather than through an object of the class (using the member selection operator).</p></div><p><strong>Defining and initializing static member variables</strong></p><p>When we declare a static member variable inside a class, we’re telling the compiler about the existence of a static member variable, but not actually defining it (much like a forward declaration). Because static member variables are not part of the individual class objects (they are treated similarly to global variables, and get initialized when the program starts), you must explicitly define the static member outside of the class, in the global scope.</p><p>In the example above, we do so via this line:</p><pre class="language-cpp line-numbers"><code>int Something::s_value{ 1 }; // defines the static member variable</code></pre><p>This line serves two purposes: it instantiates the static member variable (just like a global variable), and optionally initializes it. In this case, we’re providing the initialization value 1. If no initializer is provided, C++ initializes the value to 0.</p><p>Note that this static member definition is not subject to access controls: you can define and initialize the variable even if it’s declared as private (or protected) in the class.</p><p>If the class is defined in a .h file, the static member definition is usually placed in the associated code file for the class (e.g. Something.cpp). If the class is defined in a .cpp file, the static member definition is usually placed directly underneath the class. Do not put the static member definition in a header file (much like a global variable, if that header file gets included more than once, you’ll end up with multiple definitions, which will cause a linker error).</p><p><strong>Inline initialization of static member variables</strong></p><p>There are a few shortcuts to the above. First, when the static member is a const integral type (which includes char and bool) or a const enum, the static member can be initialized inside the class definition:</p><pre class="language-cpp line-numbers"><code>class Whatever</code><code>{</code><code>public:</code><code>    static const int s_value{ 4 }; // a static const int can be declared and initialized directly</code><code>};</code></pre><p>In the above example, because the static member variable is a const int, no explicit definition line is needed.</p><p>Second, static constexpr members can be initialized inside the class definition:</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code></code><code>class Whatever</code><code>{</code><code>public:</code><code>    static constexpr double s_value{ 2.2 }; // ok</code><code>    static constexpr std::array<int, 3=""> s_array{ 1, 2, 3 }; // this even works for classes that support constexpr initialization</int,></code><code>};</code></pre><p>Finally, as of C++17, we can also initialize non-const static members in the class definition by declaring them inline:</p><pre class="language-cpp line-numbers"><code>class Whatever</code><code>{</code><code>public:</code><code>    static inline int s_value{ 4 }; // a static inline int can be declared and initialized directly (C++17)</code><code>};</code></pre><p><strong>An example of static member variables</strong></p><p>Why use static variables inside classes? One useful example is to assign a unique ID to every instance of the class. Here’s an example of that:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Something</code><code>{</code><code>private:</code><code>    static inline int s_idGenerator { 1 }; // C++17</code><code>//  static int s_idGenerator;              // Use this instead for C++14 or older</code><code>    int m_id { };</code><code></code><code>public:</code><code>    Something()</code><code>    : m_id { s_idGenerator++ } // grab the next value from the id generator</code><code>    {}</code><code></code><code>    int getID() const { return m_id; }</code><code>};</code><code></code><code>// For C++14 or older, we have to initialize the non-const static member outside the class definition</code><code>// Note that we're defining and initializing s_idGenerator even though it is declared as private above.</code><code>// This is okay since the definition isn't subject to access controls.</code><code>// int Something::s_idGenerator { 1 }; // start our ID generator with value 1 (uncomment for C++14 or older)</code><code></code><code>int main()</code><code>{</code><code>    Something first;</code><code>    Something second;</code><code>    Something third;</code><code></code><code>    std::cout &lt;&lt; first.getID() &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; second.getID() &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; third.getID() &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>1
2
3
</pre><p>Because s_idGenerator is shared by all Something objects, when a new Something object is created, the constructor grabs the current value out of s_idGenerator and then increments the value for the next object. This guarantees that each instantiated Something object receives a unique id (incremented in the order of creation). This can really help when debugging multiple items in an array, as it provides a way to tell multiple objects of the same class type apart!</p><p>Static member variables can also be useful when the class needs to utilize an internal lookup table (e.g. an array used to store a set of pre-calculated values). By making the lookup table static, only one copy exists for all objects, rather than making a copy for each object instantiated. This can save substantial amounts of memory.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">13.14 — Static member functions</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Static member functions</h3><p>In the previous lesson on <a href="https://www.learncpp.com/cpp-tutorial/static-member-variables/">13.13 -- Static member variables</a>, you learned that static member variables are member variables that belong to the class rather than objects of the class. If the static member variables are public, we can access them directly using the class name and the scope resolution operator. But what if the static member variables are private? Consider the following example:</p><pre class="language-cpp line-numbers"><code>class Something</code><code>{</code><code>private:</code><code>    static int s_value;</code><code></code><code>};</code><code></code><code>int Something::s_value{ 1 }; // initializer, this is okay even though s_value is private since it's a definition</code><code></code><code>int main()</code><code>{</code><code>    // how do we access Something::s_value since it is private?</code><code>}</code></pre><p>In this case, we can’t access Something::s_value directly from main(), because it is private. Normally we access private members through public member functions. While we could create a normal public member function to access s_value, we’d then need to instantiate an object of the class type to use the function! We can do better. It turns out that we can also make functions static.</p><p>Like static member variables, static member functions are not attached to any particular object. Here is the above example with a static member function accessor:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Something</code><code>{</code><code>private:</code><code>    static int s_value;</code><code>public:</code><code>    static int getValue() { return s_value; } // static member function</code><code>};</code><code></code><code>int Something::s_value{ 1 }; // initializer</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; Something::getValue() &lt;&lt; '\n';</code><code>}</code></pre><p>Because static member functions are not attached to a particular object, they can be called directly by using the class name and the scope resolution operator. Like static member variables, they can also be called through objects of the class type, though this is not recommended.</p><br><h3>Static member functions have no *this pointer</h3><p>Static member functions have two interesting quirks worth noting. First, because static member functions are not attached to an object, they have no <em>this</em> pointer! This makes sense when you think about it -- the <em>this</em> pointer always points to the object that the member function is working on. Static member functions do not work on an object, so the <em>this</em> pointer is not needed.</p><p>Second, static member functions can directly access other static members (variables or functions), but not non-static members. This is because non-static members must belong to a class object, and static member functions have no class object to work with!</p><br><h3>Another example</h3><p>Static member functions can also be defined outside of the class declaration. This works the same way as for normal member functions.</p><p>Here’s an example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class IDGenerator</code><code>{</code><code>private:</code><code>    static int s_nextID; // Here's the declaration for a static member</code><code></code><code>public:</code><code>     static int getNextID(); // Here's the declaration for a static function</code><code>};</code><code></code><code>// Here's the definition of the static member outside the class.  Note we don't use the static keyword here.</code><code>// We'll start generating IDs at 1</code><code>int IDGenerator::s_nextID{ 1 };</code><code></code><code>// Here's the definition of the static function outside of the class.  Note we don't use the static keyword here.</code><code>int IDGenerator::getNextID() { return s_nextID++; } </code><code></code><code>int main()</code><code>{</code><code>    for (int count{ 0 }; count &lt; 5; ++count)</code><code>        std::cout &lt;&lt; "The next ID is: " &lt;&lt; IDGenerator::getNextID() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>The next ID is: 1
The next ID is: 2
The next ID is: 3
The next ID is: 4
The next ID is: 5
</pre><p>Note that because all the data and functions in this class are static, we don’t need to instantiate an object of the class to make use of its functionality! This class utilizes a static member variable to hold the value of the next ID to be assigned, and provides a static member function to return that ID and increment it.</p><br><h3>A word of warning about classes with all static members</h3><p>Be careful when writing classes with all static members. Although such “pure static classes” (also called “monostates”) can be useful, they also come with some potential downsides.</p><p>First, because all static members are instantiated only once, there is no way to have multiple copies of a pure static class (without cloning the class and renaming it). For example, if you needed two independent IDGenerator objects, this would not be possible with a single pure static class.</p><p>Second, in the lesson on global variables, you learned that global variables are dangerous because any piece of code can change the value of the global variable and end up breaking another piece of seemingly unrelated code. The same holds true for pure static classes. Because all of the members belong to the class (instead of object of the class), and class declarations usually have global scope, a pure static class is essentially the equivalent of declaring functions and global variables in a globally accessible namespace, with all the requisite downsides that global variables have.</p><br><h3>C++ does not support static constructors</h3><p>If you can initialize normal member variables via a constructor, then by extension it makes sense that you should be able to initialize static member variables via a static constructor. And while some modern languages do support static constructors for precisely this purpose, C++ is unfortunately not one of them.</p><p>If your static variable can be directly initialized, no constructor is needed: you can initialize the static member variable at the point of definition (even if it is private). We do this in the IDGenerator example above. Here’s another example:</p><pre class="language-cpp line-numbers"><code>class MyClass</code><code>{</code><code>public:</code><code>	static std::vector<char> s_mychars;</char></code><code>};</code><code></code><code>std::vector<char> MyClass::s_mychars{ 'a', 'e', 'i', 'o', 'u' }; // initialize static variable at point of definition</char></code></pre><p>If initializing your static member variable requires executing code (e.g. a loop), there are many different, somewhat obtuse ways of doing this. One way that works with all variables, static or not, is to use a lambda and call it immediately.</p><pre class="language-cpp line-numbers"><code>class MyClass</code><code>{</code><code>public:</code><code>    static std::vector<char> s_mychars;</char></code><code>};</code><code></code><code>std::vector<char> MyClass::s_mychars{</char></code><code>  []{ // The parameter list of lambdas without parameters can be omitted.</code><code>      // Inside the lambda we can declare another vector and use a loop.</code><code>      std::vector<char> v{};</char></code><code>      </code><code>      for (char ch{ 'a' }; ch &lt;= 'z'; ++ch)</code><code>      {</code><code>          v.push_back(ch);</code><code>      }</code><code>      </code><code>      return v;</code><code>  }() // Call the lambda right away</code><code>};</code></pre><p>The following code presents a method that behaves more like a regular constructor. However, it is a little tricky, and you’ll probably never need it, so feel free to skip the remainder of this section if you desire.</p><pre class="language-cpp line-numbers"><code>class MyClass</code><code>{</code><code>public:</code><code>	static std::vector<char> s_mychars;</char></code><code></code><code>	class init_static // we're defining a nested class named init_static</code><code>	{</code><code>	public:</code><code>		init_static() // the init constructor will initialize our static variable</code><code>		{</code><code>			for (char ch{ 'a' }; ch &lt;= 'z'; ++ch)</code><code>			{</code><code>				s_mychars.push_back(ch);</code><code>			}</code><code>		}</code><code>	} ;</code><code></code><code>private:</code><code>	static init_static s_initializer; // we'll use this static object to ensure the init_static constructor is called</code><code>};</code><code></code><code>std::vector<char> MyClass::s_mychars{}; // define our static member variable</char></code><code>MyClass::init_static MyClass::s_initializer{}; // define our static initializer, which will call the init_static constructor, which will initialize s_mychars</code></pre><p>When static member s_initializer is defined, the init_static() default constructor will be called (because s_initializer is of type init_static). We can use this constructor to initialize any static member variables. The nice thing about this solution is that all of the initialization code is kept hidden inside the original class with the static member.</p><br><h3>Summary</h3><p>Static member functions can be used to work with static member variables in the class. An object of the class is not required to call them.</p><p>Classes can be created with all static member variables and static functions. However, such classes are essentially the equivalent of declaring functions and global variables in a globally accessible namespace, and should generally be avoided unless you have a particularly good reason to use them.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">13.15 — Friend functions and classes</h1></header><div class="entry-content" itemprop="articleBody"><p>For much of this chapter, we’ve been preaching the virtues of keeping your data private. However, you may occasionally find situations where you will find you have classes and functions outside of those classes that need to work very closely together. For example, you might have a class that stores data, and a function (or another class) that displays the data on the screen. Although the storage class and display code have been separated for easier maintenance, the display code is really intimately tied to the details of the storage class. Consequently, there isn’t much to gain by hiding the details of the storage class from the display code.</p><p>In situations like this, there are two options:</p><ol start="1"><li>Have the display code use the publicly exposed functions of the storage class. However, this has several potential downsides. First, these public member functions have to be defined, which takes time, and can clutter up the interface of the storage class. Second, the storage class may have to expose functions for the display code that it doesn’t really want accessible to anybody else. There is no way to say “this function is meant to be used by the display class only”.</li><li>Alternatively, using friend classes and friend functions, you can give your display code access to the private details of the storage class. This lets the display code directly access all the private members and functions of the storage class, while keeping everyone else out! In this lesson, we’ll take a closer look at how this is done.</li></ol><p><strong>Friend functions</strong></p><p>A <strong>friend function</strong> is a function that can access the private members of a class as though it was a member of that class. In all other regards, the friend function is just like a normal function. A friend function may be either a normal function, or a member function of another class. To declare a friend function, simply use the <em>friend</em> keyword in front of the prototype of the function you wish to be a friend of the class. It does not matter whether you declare the friend function in the private or public section of the class.</p><p>Here’s an example of using a friend function:</p><pre class="language-cpp line-numbers"><code>class Accumulator</code><code>{</code><code>private:</code><code>    int m_value { 0 };</code><code></code><code>public:</code><code>    void add(int value) { m_value += value; }</code><code></code><code>    // Make the reset() function a friend of this class</code><code>    friend void reset(Accumulator&amp; accumulator);</code><code>};</code><code></code><code>// reset() is now a friend of the Accumulator class</code><code>void reset(Accumulator&amp; accumulator)</code><code>{</code><code>    // And can access the private data of Accumulator objects</code><code>    accumulator.m_value = 0;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Accumulator acc;</code><code>    acc.add(5); // add 5 to the accumulator</code><code>    reset(acc); // reset the accumulator to 0</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this example, we’ve declared a function named reset() that takes an object of class Accumulator, and sets the value of m_value to 0. Because reset() is not a member of the Accumulator class, normally reset() would not be able to access the private members of Accumulator. However, because Accumulator has specifically declared this reset() function to be a friend of the class, the reset() function is given access to the private members of Accumulator.</p><p>Note that we have to pass an Accumulator object to reset(). This is because reset() is not a member function. It does not have a *this pointer, nor does it have an Accumulator object to work with, unless given one.</p><p>Here’s another example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Value</code><code>{</code><code>private:</code><code>    int m_value{};</code><code></code><code>public:</code><code>    Value(int value)</code><code>        : m_value{ value }</code><code>    {</code><code>    }</code><code></code><code>    friend bool isEqual(const Value&amp; value1, const Value&amp; value2);</code><code>};</code><code></code><code>bool isEqual(const Value&amp; value1, const Value&amp; value2)</code><code>{</code><code>    return (value1.m_value == value2.m_value);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Value v1{ 5 };</code><code>    Value v2{ 6 };</code><code>    std::cout &lt;&lt; std::boolalpha &lt;&lt; isEqual(v1, v2);</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this example, we declare the isEqual() function to be a friend of the Value class. isEqual() takes two Value objects as parameters. Because isEqual() is a friend of the Value class, it can access the private members of all Value objects. In this case, it uses that access to do a comparison on the two objects, and returns true if they are equal.</p><p>While both of the above examples are fairly contrived, the latter example is very similar to cases we’ll encounter later when we discuss operator overloading!</p><p><strong>Multiple friends</strong></p><p>A function can be a friend of more than one class at the same time. For example, consider the following example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Humidity;</code><code></code><code>class Temperature</code><code>{</code><code>private:</code><code>    int m_temp {};</code><code></code><code>public:</code><code>    Temperature(int temp=0)</code><code>        : m_temp { temp }</code><code>    {</code><code>    }</code><code></code><code>    friend void printWeather(const Temperature&amp; temperature, const Humidity&amp; humidity);</code><code>};</code><code></code><code>class Humidity</code><code>{</code><code>private:</code><code>    int m_humidity {};</code><code></code><code>public:</code><code>    Humidity(int humidity=0)</code><code>        : m_humidity { humidity }</code><code>    {</code><code>    }</code><code></code><code>    friend void printWeather(const Temperature&amp; temperature, const Humidity&amp; humidity);</code><code>};</code><code></code><code>void printWeather(const Temperature&amp; temperature, const Humidity&amp; humidity)</code><code>{</code><code>    std::cout &lt;&lt; "The temperature is " &lt;&lt; temperature.m_temp &lt;&lt;</code><code>       " and the humidity is " &lt;&lt; humidity.m_humidity &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Humidity hum{10};</code><code>    Temperature temp{12};</code><code></code><code>    printWeather(temp, hum);</code><code></code><code>    return 0;</code><code>}</code></pre><p>There are two things worth noting about this example. First, because printWeather is a friend of both classes, it can access the private data from objects of both classes. Second, note the following line at the top of the example:</p><pre class="language-cpp line-numbers"><code>class Humidity;</code></pre><p>This is a class prototype that tells the compiler that we are going to define a class called Humidity in the future. Without this line, the compiler would tell us it doesn’t know what a Humidity is when parsing the prototype for printWeather() inside the Temperature class. Class prototypes serve the same role as function prototypes -- they tell the compiler what something looks like so it can be used now and defined later. However, unlike functions, classes have no return types or parameters, so class prototypes are always simply <code>class ClassName</code>, where ClassName is the name of the class.</p><p><strong>Friend classes</strong></p><p>It is also possible to make an entire class a friend of another class. This gives all of the members of the friend class access to the private members of the other class. Here is an example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Storage</code><code>{</code><code>private:</code><code>    int m_nValue {};</code><code>    double m_dValue {};</code><code>public:</code><code>    Storage(int nValue, double dValue)</code><code>       : m_nValue { nValue }, m_dValue { dValue }</code><code>    {</code><code>    }</code><code></code><code>    // Make the Display class a friend of Storage</code><code>    friend class Display;</code><code>};</code><code></code><code>class Display</code><code>{</code><code>private:</code><code>    bool m_displayIntFirst;</code><code></code><code>public:</code><code>    Display(bool displayIntFirst)</code><code>         : m_displayIntFirst { displayIntFirst }</code><code>    {</code><code>    }</code><code></code><code>    void displayItem(const Storage&amp; storage)</code><code>    {</code><code>        if (m_displayIntFirst)</code><code>            std::cout &lt;&lt; storage.m_nValue &lt;&lt; ' ' &lt;&lt; storage.m_dValue &lt;&lt; '\n';</code><code>        else // display double first</code><code>            std::cout &lt;&lt; storage.m_dValue &lt;&lt; ' ' &lt;&lt; storage.m_nValue &lt;&lt; '\n';</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Storage storage{5, 6.7};</code><code>    Display display{false};</code><code></code><code>    display.displayItem(storage);</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because the Display class is a friend of Storage, any of Display’s members that use a Storage class object can access the private members of Storage directly. This program produces the following result:</p><pre>6.7 5
</pre><p>A few additional notes on friend classes. First, even though Display is a friend of Storage, Display has no direct access to the *this pointer of Storage objects. Second, just because Display is a friend of Storage, that does not mean Storage is also a friend of Display. If you want two classes to be friends of each other, both must declare the other as a friend. Finally, if class A is a friend of B, and B is a friend of C, that does not mean A is a friend of C.</p><p>Be careful when using friend functions and classes, because it allows the friend function or class to violate encapsulation. If the details of the class change, the details of the friend will also be forced to change. Consequently, limit your use of friend functions and classes to a minimum.</p><p><strong>Friend member functions</strong></p><p>Instead of making an entire class a friend, you can make a single member function a friend. This is done similarly to making a normal function a friend, except using the name of the member function with the className:: prefix included (e.g. Display::displayItem).</p><p>However, in actuality, this can be a little trickier than expected. Let’s convert the previous example to make Display::displayItem a friend member function. You might try something like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Display; // forward declaration for class Display</code><code></code><code>class Storage</code><code>{</code><code>private:</code><code>	int m_nValue {};</code><code>	double m_dValue {};</code><code>public:</code><code>	Storage(int nValue, double dValue)</code><code>		: m_nValue { nValue }, m_dValue { dValue }</code><code>	{</code><code>	}</code><code></code><code>	// Make the Display::displayItem member function a friend of the Storage class</code><code>	friend void Display::displayItem(const Storage&amp; storage); // error: Storage hasn't seen the full definition of class Display</code><code>};</code><code></code><code>class Display</code><code>{</code><code>private:</code><code>	bool m_displayIntFirst {};</code><code></code><code>public:</code><code>	Display(bool displayIntFirst)</code><code>		: m_displayIntFirst { displayIntFirst }</code><code>	{</code><code>	}</code><code></code><code>	void displayItem(const Storage&amp; storage)</code><code>	{</code><code>		if (m_displayIntFirst)</code><code>			std::cout &lt;&lt; storage.m_nValue &lt;&lt; ' ' &lt;&lt; storage.m_dValue &lt;&lt; '\n';</code><code>		else // display double first</code><code>			std::cout &lt;&lt; storage.m_dValue &lt;&lt; ' ' &lt;&lt; storage.m_nValue &lt;&lt; '\n';</code><code>	}</code><code>};</code></pre><p>However, it turns out this won’t work. In order to make a member function a friend, the compiler has to have seen the full definition for the class of the friend member function (not just a forward declaration). Since class Storage hasn’t seen the full definition for class Display yet, the compiler will error at the point where we try to make the member function a friend.</p><p>Fortunately, this is easily resolved simply by moving the definition of class Display before the definition of class Storage.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Display</code><code>{</code><code>private:</code><code>	bool m_displayIntFirst {};</code><code></code><code>public:</code><code>	Display(bool displayIntFirst)</code><code>		: m_displayIntFirst { displayIntFirst }</code><code>	{</code><code>	}</code><code></code><code>	void displayItem(const Storage&amp; storage) // error: compiler doesn't know what a Storage is</code><code>	{</code><code>		if (m_displayIntFirst)</code><code>			std::cout &lt;&lt; storage.m_nValue &lt;&lt; ' ' &lt;&lt; storage.m_dValue &lt;&lt; '\n';</code><code>		else // display double first</code><code>			std::cout &lt;&lt; storage.m_dValue &lt;&lt; ' ' &lt;&lt; storage.m_nValue &lt;&lt; '\n';</code><code>	}</code><code>};</code><code></code><code>class Storage</code><code>{</code><code>private:</code><code>	int m_nValue {};</code><code>	double m_dValue {};</code><code>public:</code><code>	Storage(int nValue, double dValue)</code><code>		: m_nValue { nValue }, m_dValue { dValue }</code><code>	{</code><code>	}</code><code></code><code>	// Make the Display::displayItem member function a friend of the Storage class</code><code>	friend void Display::displayItem(const Storage&amp; storage); // okay now</code><code>};</code></pre><p>However, we now have another problem. Because member function Display::displayItem() uses Storage as a reference parameter, and we just moved the definition of Storage below the definition of Display, the compiler will complain it doesn’t know what a Storage is. We can’t fix this one by rearranging the definition order, because then we’ll undo our previous fix.</p><p>Fortunately, this is also fixable in a couple of simple steps. First, we can add class Storage as a forward declaration. Second, we can move the definition of Display::displayItem() out of the class, after the full definition of Storage class.</p><p>Here’s what this looks like:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Storage; // forward declaration for class Storage</code><code></code><code>class Display</code><code>{</code><code>private:</code><code>	bool m_displayIntFirst {};</code><code></code><code>public:</code><code>	Display(bool displayIntFirst)</code><code>		: m_displayIntFirst { displayIntFirst }</code><code>	{</code><code>	}</code><code>	</code><code>	void displayItem(const Storage&amp; storage); // forward declaration above needed for this declaration line</code><code>};</code><code></code><code>class Storage // full definition of Storage class</code><code>{</code><code>private:</code><code>	int m_nValue {};</code><code>	double m_dValue {};</code><code>public:</code><code>	Storage(int nValue, double dValue)</code><code>		: m_nValue { nValue }, m_dValue { dValue }</code><code>	{</code><code>	}</code><code></code><code>	// Make the Display::displayItem member function a friend of the Storage class (requires seeing the full definition of class Display, as above)</code><code>	friend void Display::displayItem(const Storage&amp; storage);</code><code>};</code><code></code><code>// Now we can define Display::displayItem, which needs to have seen the full definition of class Storage</code><code>void Display::displayItem(const Storage&amp; storage)</code><code>{</code><code>	if (m_displayIntFirst)</code><code>		std::cout &lt;&lt; storage.m_nValue &lt;&lt; ' ' &lt;&lt; storage.m_dValue &lt;&lt; '\n';</code><code>	else // display double first</code><code>		std::cout &lt;&lt; storage.m_dValue &lt;&lt; ' ' &lt;&lt; storage.m_nValue &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Storage storage(5, 6.7);</code><code>    Display display(false);</code><code></code><code>    display.displayItem(storage);</code><code></code><code>    return 0;</code><code>}</code></pre><p>Now everything will compile properly: the forward declaration of class Storage is enough to satisfy the declaration of Display::displayItem(), the full definition of Display satisfies declaring Display::displayItem() as a friend of Storage, and the full definition of class Storage is enough to satisfy the definition of member function Display::displayItem(). If that’s a bit confusing, see the comments in the program above.</p><p>If this seems like a pain -- it is. Fortunately, this dance is only necessary because we’re trying to do everything in a single file. A better solution is to put each class definition in a separate header file, with the member function definitions in corresponding .cpp files. That way, all of the class definitions would have been visible immediately in the .cpp files, and no rearranging of classes or functions is necessary!</p><p><strong>Summary</strong></p><p>A friend function or class is a function or class that can access the private members of another class as though it was a member of that class. This allows the friend function or friend class to work intimately with the other class, without making the other class expose its private members (e.g. via access functions).</p><p>Friending is commonly used when defining overloaded operators (which we’ll cover in the next chapter), or less commonly, when two or more classes need to work together in an intimate way.</p><p>Note that making a specific member function a friend requires the full definition for the class of the member function to have been seen first.</p><p><strong>Quiz time</strong></p><ol start="1"><li>In geometry, a point is a position in space. We can define a point in 3d-space as the set of coordinates x, y, and z. For example, the Point(2.0, 1.0, 0.0) would be the point at coordinate space x=2.0, y=1.0, and z=0.0.</li></ol><p>In physics, a vector is a quantity that has a magnitude (length) and a direction (but no position). We can define a vector in 3d-space as an x, y, and z value representing the direction of the vector along the x, y, and z axis (the length can be derived from these). For example, the Vector(2.0, 0.0, 0.0) would be a vector representing a direction along the positive x-axis (only), with length 2.0.</p><p>A Vector can be applied to a Point to move the Point to a new position. This is done by adding the vector’s direction to the point’s position to yield a new position. For example, Point(2.0, 1.0, 0.0) + Vector(2.0, 0.0, 0.0) would yield the point (4.0, 1.0, 0.0).</p><p>Points and Vectors are often used in computer graphics (the point to represent vertices of shape, and vectors represent movement of the shape).</p><p>Given the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Vector3d</code><code>{</code><code>private:</code><code>	double m_x{};</code><code>	double m_y{};</code><code>	double m_z{};</code><code></code><code>public:</code><code>	Vector3d(double x = 0.0, double y = 0.0, double z = 0.0)</code><code>		: m_x{x}, m_y{y}, m_z{z}</code><code>	{</code><code></code><code>	}</code><code></code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; "Vector(" &lt;&lt; m_x &lt;&lt; " , " &lt;&lt; m_y &lt;&lt; " , " &lt;&lt; m_z &lt;&lt; ")\n";</code><code>	}</code><code>};</code><code></code><code>class Point3d</code><code>{</code><code>private:</code><code>	double m_x{};</code><code>	double m_y{};</code><code>	double m_z{};</code><code></code><code>public:</code><code>	Point3d(double x = 0.0, double y = 0.0, double z = 0.0)</code><code>		: m_x{x}, m_y{y}, m_z{z}</code><code>	{</code><code></code><code>	}</code><code></code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; "Point(" &lt;&lt; m_x &lt;&lt; " , " &lt;&lt; m_y &lt;&lt; " , " &lt;&lt; m_z &lt;&lt; ")\n";</code><code>	}</code><code></code><code>	void moveByVector(const Vector3d&amp; v)</code><code>	{</code><code>		// implement this function as a friend of class Vector3d</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Point3d p{1.0, 2.0, 3.0};</code><code>	Vector3d v{2.0, 2.0, -3.0};</code><code></code><code>	p.print();</code><code>	p.moveByVector(v);</code><code>	p.print();</code><code></code><code>	return 0;</code><code>}</code></pre><p>1a) Make Point3d a friend class of Vector3d, and implement function Point3d::moveByVector()</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Vector3d</code><code>{</code><code>private:</code><code>	double m_x{};</code><code>	double m_y{};</code><code>	double m_z{};</code><code>    </code><code>public:</code><code>	Vector3d(double x = 0.0, double y = 0.0, double z = 0.0)</code><code>		: m_x{x}, m_y{y}, m_z{z}</code><code>	{</code><code></code><code>	}</code><code></code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; "Vector(" &lt;&lt; m_x &lt;&lt; " , " &lt;&lt; m_y &lt;&lt; " , " &lt;&lt; m_z &lt;&lt; ")\n";</code><code>	}</code><code></code><code>	friend class Point3d; // Point3d is now a friend of class Vector3d</code><code>};</code><code></code><code></code><code>class Point3d</code><code>{</code><code>private:</code><code>	double m_x{};</code><code>	double m_y{};</code><code>	double m_z{};</code><code></code><code>public:</code><code>	Point3d(double x = 0.0, double y = 0.0, double z = 0.0)</code><code>		: m_x{x}, m_y{y}, m_z{z}</code><code>	{</code><code></code><code>	}</code><code></code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; "Point(" &lt;&lt; m_x &lt;&lt; " , " &lt;&lt; m_y &lt;&lt; " , " &lt;&lt; m_z &lt;&lt; ")\n";</code><code>	}</code><code></code><code></code><code>	void moveByVector(const Vector3d&amp; v)</code><code>	{</code><code>		m_x += v.m_x;</code><code>		m_y += v.m_y;</code><code>		m_z += v.m_z;</code><code>	}</code><code>};</code><code></code><code></code><code>int main()</code><code>{</code><code>	Point3d p{1.0, 2.0, 3.0};</code><code>	Vector3d v{2.0, 2.0, -3.0};</code><code></code><code>	p.print();</code><code>	p.moveByVector(v);</code><code>	p.print();</code><code></code><code>	return 0;</code><code>}</code></pre></div><p>1b) Instead of making class Point3d a friend of class Vector3d, make member function Point3d::moveByVector a friend of class Vector3d.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Vector3d; // first, we need to tell the compiler that a class named Vector3d exists</code><code></code><code>class Point3d</code><code>{</code><code>private:</code><code>	double m_x{};</code><code>	double m_y{};</code><code>	double m_z{};</code><code></code><code>public:</code><code>	Point3d(double x = 0.0, double y = 0.0, double z = 0.0)</code><code>		: m_x{x}, m_y{y}, m_z{z}</code><code>	{</code><code></code><code>	}</code><code></code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; "Point(" &lt;&lt; m_x &lt;&lt; " , " &lt;&lt; m_y &lt;&lt; " , " &lt;&lt; m_z &lt;&lt; ")\n";</code><code>	}</code><code></code><code>	void moveByVector(const Vector3d&amp; v); // so we can use Vector3d here</code><code>       // note: we can't define this function here, because Vector3d hasn't been declared yet (just forward declared)</code><code>};</code><code></code><code>class Vector3d</code><code>{</code><code>private:</code><code>	double m_x{};</code><code>	double m_y{};</code><code>	double m_z{};</code><code></code><code>public:</code><code>	Vector3d(double x = 0.0, double y = 0.0, double z = 0.0)</code><code>		: m_x{x}, m_y{y}, m_z{z}</code><code>	{</code><code></code><code>	}</code><code></code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; "Vector(" &lt;&lt; m_x &lt;&lt; " , " &lt;&lt; m_y &lt;&lt; " , " &lt;&lt; m_z &lt;&lt; ")\n";</code><code>	}</code><code></code><code>	friend void Point3d::moveByVector(const Vector3d&amp; v); // Point3d::moveByVector() is now a friend of class Vector3d</code><code>};</code><code></code><code>// Now that Vector3d has been declared, we can define the function Point3d::moveByVector()</code><code>void Point3d::moveByVector(const Vector3d&amp; v)</code><code>{</code><code>	m_x += v.m_x;</code><code>	m_y += v.m_y;</code><code>	m_z += v.m_z;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Point3d p{1.0, 2.0, 3.0};</code><code>	Vector3d v{2.0, 2.0, -3.0};</code><code></code><code>	p.print();</code><code>	p.moveByVector(v);</code><code>	p.print();</code><code></code><code>	return 0;</code><code>}</code></pre></div><p>1c) Reimplement the solution to quiz question 1b using 5 separate files: Point3d.h, Point3d.cpp, Vector3d.h, Vector3d.cpp, and main.cpp.</p><p>Thanks to reader Shiva for the suggestion and solution.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>Point3d.h:</p><pre class="language-cpp line-numbers"><code>// Header file that defines the Point3d class</code><code></code><code>#ifndef POINT3D_H</code><code>#define POINT3D_H</code><code></code><code>class Vector3d; // forward declaration for class Vector3d for function moveByVector()</code><code></code><code>class Point3d</code><code>{</code><code>    private:</code><code>    	double m_x{};</code><code>        double m_y{};</code><code>        double m_z{};</code><code>        </code><code>    public:</code><code>        Point3d(double x = 0.0, double y = 0.0, double z = 0.0);</code><code></code><code>        void print() const;</code><code>        void moveByVector(const Vector3d&amp; v); // forward declaration above needed for this line</code><code>};</code><code></code><code>#endif</code></pre><p>Point3d.cpp:</p><pre class="language-cpp line-numbers"><code>// Member functions of the Point3d class defined here</code><code></code><code>#include "Point3d.h" // Point3d class declared in this</code><code>#include "Vector3d.h" // for the parameter of the function moveByVector()</code><code></code><code>#include <iostream></iostream></code><code></code><code>Point3d::Point3d(double x, double y, double z) </code><code>  : m_x{x}, m_y{y}, m_z{z}</code><code>{}</code><code>        </code><code>void Point3d::moveByVector(const Vector3d&amp; v)</code><code>{</code><code>    // Add the vector components to the corresponding point coordinates</code><code>    m_x += v.m_x;</code><code>    m_y += v.m_y;</code><code>    m_z += v.m_z;</code><code>}</code><code></code><code>void Point3d::print() const</code><code>{</code><code>    std::cout &lt;&lt; "Point(" &lt;&lt; m_x &lt;&lt; " , " &lt;&lt; m_y &lt;&lt; " , " &lt;&lt; m_z &lt;&lt; ")\n";</code><code>}</code></pre><p>Vector3d.h:</p><pre class="language-cpp line-numbers"><code>// Header file that defines the Vector3d class</code><code></code><code>#ifndef VECTOR3D_H</code><code>#define VECTOR3D_H</code><code></code><code>#include "Point3d.h" // for declaring Point3d::moveByVector() as a friend</code><code></code><code>class Vector3d</code><code>{</code><code>    private:</code><code>	double m_x{};</code><code>	double m_y{};</code><code>	double m_z{};</code><code></code><code>    public:</code><code>	Vector3d(double x = 0.0, double y = 0.0, double z = 0.0);</code><code></code><code>	void print() const;</code><code>	friend void Point3d::moveByVector(const Vector3d&amp; v);</code><code>};</code><code></code><code>#endif</code></pre><p>Vector3d.cpp:</p><pre class="language-cpp line-numbers"><code>// Member functions of the Vector3d class defined here</code><code></code><code>#include "Vector3d.h" // Vector3d class declared in this file</code><code></code><code>#include <iostream></iostream></code><code></code><code>Vector3d::Vector3d(double x, double y, double z) </code><code>  : m_x{x}, m_y{y}, m_z{z}</code><code>{}</code><code></code><code>void Vector3d::print() const</code><code>{</code><code>    std::cout &lt;&lt; "Vector(" &lt;&lt; m_x &lt;&lt; " , " &lt;&lt; m_y &lt;&lt; " , " &lt;&lt; m_z &lt;&lt; ")\n";</code><code>}</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include "Vector3d.h" // for creating Vector3d object</code><code>#include "Point3d.h" // for creating Point3d object</code><code></code><code>int main()</code><code>{</code><code>    Point3d p{1.0, 2.0, 3.0};</code><code>    Vector3d v{2.0, 2.0, -3.0};</code><code></code><code>    p.print();</code><code>    p.moveByVector(v);</code><code>    p.print();</code><code></code><code>    return 0;</code><code>}</code></pre></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">13.16 — Anonymous objects</h1></header><div class="entry-content" itemprop="articleBody"><p>In certain cases, we need a variable only temporarily. For example, consider the following situation:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y)</code><code>{</code><code>    int sum{ x + y };</code><code>    return sum;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; add(5, 3) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the add() function, note that the sum variable is really only used as a temporary placeholder variable. It doesn’t contribute much -- rather, its only function is to transfer the result of the expression to the return value.</p><p>There is actually an easier way to write the add() function using an anonymous object. An <strong>anonymous object</strong> is essentially a value that has no name. Because they have no name, there’s no way to refer to them beyond the point where they are created. Consequently, they have “expression scope”, meaning they are created, evaluated, and destroyed all within a single expression.</p><p>Here is the add() function rewritten using an anonymous object:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y)</code><code>{</code><code>    return x + y; // an anonymous object is created to hold and return the result of x + y</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; add(5, 3) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>When the expression <code>x + y</code> is evaluated, the result is placed in an anonymous object. A copy of the anonymous object is then returned to the caller by value, and the anonymous object is destroyed.</p><p>This works not only with return values, but also with function parameters. For example, instead of this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printValue(int value)</code><code>{</code><code>    std::cout &lt;&lt; value;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int sum{ 5 + 3 };</code><code>    printValue(sum);</code><code></code><code>    return 0;</code><code>}</code></pre><p>We can write this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printValue(int value)</code><code>{</code><code>    std::cout &lt;&lt; value;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printValue(5 + 3);</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this case, the expression 5 + 3 is evaluated to produce the result 8, which is placed in an anonymous object. A copy of this anonymous object is then passed to the printValue() function, (which prints the value 8) and then is destroyed.</p><p>Note how much cleaner this keeps our code -- we don’t have to litter the code with temporary variables that are only used once.</p><p><strong>Anonymous class objects</strong></p><p>Although our prior examples have been with built-in data types, it is possible to construct anonymous objects of our own class types as well. This is done by creating objects like normal, but omitting the variable name.</p><pre class="language-cpp line-numbers"><code>Cents cents{ 5 }; // normal variable</code><code>Cents{ 7 }; // anonymous object</code></pre><p>In the above code, <code>Cents{ 7 }</code> will create an anonymous Cents object, initialize it with the value 7, and then destroy it. In this context, that isn’t going to do us much good. So let’s take a look at an example where it can be put to good use:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>    int m_cents{};</code><code></code><code>public:</code><code>    Cents(int cents)</code><code>        : m_cents { cents }</code><code>    {}</code><code></code><code>    int getCents() const { return m_cents; }</code><code>};</code><code></code><code>void print(const Cents&amp; cents)</code><code>{</code><code>   std::cout &lt;&lt; cents.getCents() &lt;&lt; " cents\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Cents cents{ 6 };</code><code>    print(cents);</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note that this example is very similar to the prior one using integers. In this case, our main() function is passing a Cents object (named cents) to function print().</p><p>We can simplify this program by using anonymous objects:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>    int m_cents{};</code><code></code><code>public:</code><code>    Cents(int cents)</code><code>        : m_cents { cents }</code><code>    {}</code><code></code><code>    int getCents() const { return m_cents; }</code><code>};</code><code></code><code>void print(const Cents&amp; cents)</code><code>{</code><code>   std::cout &lt;&lt; cents.getCents() &lt;&lt; " cents\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    print(Cents{ 6 }); // Note: Now we're passing an anonymous Cents value</code><code></code><code>    return 0;</code><code>}</code></pre><p>As you’d expect, this prints:</p><pre>6 cents
</pre><p>Now let’s take a look at a slightly more complex example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>    int m_cents{};</code><code></code><code>public:</code><code>    Cents(int cents)</code><code>        : m_cents { cents }</code><code>    {}</code><code></code><code>    int getCents() const { return m_cents; }</code><code>};</code><code></code><code>Cents add(const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>    Cents sum{ c1.getCents() + c2.getCents() };</code><code>    return sum;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Cents cents1{ 6 };</code><code>    Cents cents2{ 8 };</code><code>    Cents sum{ add(cents1, cents2) };</code><code>    std::cout &lt;&lt; "I have " &lt;&lt; sum.getCents() &lt;&lt; " cents.\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, we’re using quite a few named Cents values. In the add() function, we have a Cents value named sum that we’re using as an intermediary value to hold the sum before we return it. And in function main(), we have another Cents value named sum also used as an intermediary value.</p><p>We can make our program simpler by using anonymous values:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>    int m_cents{};</code><code></code><code>public:</code><code>    Cents(int cents)</code><code>        : m_cents { cents }</code><code>    {}</code><code></code><code>    int getCents() const { return m_cents; }</code><code>};</code><code></code><code>Cents add(const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>    // List initialization looks at the return type of the function</code><code>    // and creates the correct object accordingly.</code><code>    return { c1.getCents() + c2.getCents() }; // return anonymous Cents value</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Cents cents1{ 6 };</code><code>    Cents cents2{ 8 };</code><code>    std::cout &lt;&lt; "I have " &lt;&lt; add(cents1, cents2).getCents() &lt;&lt; " cents.\n"; // print anonymous Cents value</code><code></code><code>    return 0;</code><code>}</code></pre><p>This version of add() functions identically to the one above, except it uses an anonymous Cents value instead of a named variable. Also note that in main(), we no longer use a named “sum” variable as temporary storage. Instead, we use the return value of add() anonymously!</p><p>As a result, our program is shorter, cleaner, and generally easier to follow (once you understand the concept).</p><p>In fact, because cents1 and cents2 are only used in one place, we can anonymize this even further:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>    int m_cents{};</code><code></code><code>public:</code><code>    Cents(int cents)</code><code>        : m_cents { cents }</code><code>    {}</code><code></code><code>    int getCents() const { return m_cents; }</code><code>};</code><code></code><code>Cents add(const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>    return { c1.getCents() + c2.getCents() }; // return anonymous Cents value</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "I have " &lt;&lt; add(Cents{ 6 }, Cents{ 8 }).getCents() &lt;&lt; " cents.\n"; // print anonymous Cents value</code><code></code><code>    return 0;</code><code>}</code></pre><p><strong>Summary</strong></p><p>In C++, anonymous objects are primarily used either to pass or return values without having to create lots of temporary variables to do so. Memory allocated dynamically is also done so anonymously (which is why its address must be assigned to a pointer, otherwise we’d have no way to refer to it).</p><p>It is also worth noting that because anonymous objects have expression scope, they can only be used once (unless bound to a constant l-value reference, which will extend the lifetime of the temporary object to match the lifetime of the reference). If you need to reference a value in multiple expressions, you should use a named variable instead.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">13.17 — Nested types in classes</h1></header><div class="entry-content" itemprop="articleBody"><p>Consider the following short program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>enum class FruitType</code><code>{</code><code>	apple,</code><code>	banana,</code><code>	cherry</code><code>};</code><code></code><code>class Fruit</code><code>{</code><code>private:</code><code>	FruitType m_type {};</code><code>	int m_percentageEaten { 0 };</code><code></code><code>public:</code><code>	Fruit(FruitType type) :</code><code>		m_type { type }</code><code>	{</code><code>	}</code><code></code><code>	FruitType getType() const { return m_type; }</code><code>	int getPercentageEaten() const { return m_percentageEaten; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Fruit apple { FruitType::apple };</code><code>	</code><code>	if (apple.getType() == FruitType::apple)</code><code>		std::cout &lt;&lt; "I am an apple";</code><code>	else</code><code>		std::cout &lt;&lt; "I am not an apple";</code><code>	</code><code>	return 0;</code><code>}</code></pre><p>There’s nothing wrong with this program. But because enum FruitType is meant to be used in conjunction with the Fruit class, it’s a little weird to have it exist independently from the class itself.</p><p><strong>Nesting types</strong></p><p>Much like functions and data can be members of a class, in C++, types can also be defined (nested) inside of a class. To do this, you simply define the type inside the class, under the appropriate access specifier.</p><p>Here’s the same program as above, with FruitType defined inside the class:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Fruit</code><code>{</code><code>public:</code><code>	// Note: we've moved FruitType inside the class, under the public access specifier</code><code>	// We've also changed it from an enum class to an enum</code><code>	enum FruitType</code><code>	{</code><code>		apple,</code><code>		banana,</code><code>		cherry</code><code>	};</code><code></code><code>private:</code><code>	FruitType m_type {};</code><code>	int m_percentageEaten { 0 };</code><code></code><code>public:</code><code>	Fruit(FruitType type) :</code><code>		m_type { type }</code><code>	{</code><code>	}</code><code></code><code>	FruitType getType() const { return m_type; }</code><code>	int getPercentageEaten() const { return m_percentageEaten; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	// Note: we access the FruitType via Fruit now</code><code>	Fruit apple { Fruit::apple };</code><code>	</code><code>	if (apple.getType() == Fruit::apple)</code><code>		std::cout &lt;&lt; "I am an apple";</code><code>	else</code><code>		std::cout &lt;&lt; "I am not an apple";</code><code>	</code><code>	return 0;</code><code>}</code></pre><p>First, note that FruitType is now defined inside the class. Second, note that we’ve defined it under the public access specifier, so the type definition can be accessed from outside the class.</p><p>Classes essentially act as a namespace for any nested types, much as enum classes do. In the prior example, because we used an enum class, we had to qualify our enumerators with the FruitType:: scope qualifier. In this example, because FruitType is a normal enum that is part of the class, we access our enumerators using the Fruit:: scope qualifier.</p><p>Note that because enum classes also act like namespaces, if we’d nested FruitType inside Fruit as an enum class instead of an enum, we’d access the enumeration via a Fruit::FruitType:: scope qualifier. This double-scoping is unnecessary, so we’ve used a normal enum.</p><p><strong>Other types can be nested too</strong></p><p>Although enumerations are probably the most common type that is nested inside a class, C++ will let you define other types within a class, such as typedefs, type aliases, and even other classes!</p><p>Like any normal member of a class, nested classes have the same access to members of the enclosing class that the enclosing class does. However, the nested class does not have any special access to the “this” pointer of the enclosing class.</p><p>One other limitation of nested types -- they can’t be forward declared. However, this is rarely a problem in practice since the entire class definition (including the nested type) can generally be #included where needed.</p><p>Defining nested classes isn’t very common, but the C++ standard library does do so in some cases, such as with iterator classes.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">13.18 — Timing your code</h1></header><div class="entry-content" itemprop="articleBody"><p>When writing your code, sometimes you’ll run across cases where you’re not sure whether one method or another will be more performant. So how do you tell?</p><p>One easy way is to time your code to see how long it takes to run. C++11 comes with some functionality in the chrono library to do just that. However, using the chrono library is a bit arcane. The good news is that we can easily encapsulate all the timing functionality we need into a class that we can then use in our own programs.</p><p>Here’s the class:</p><pre class="language-cpp line-numbers"><code>#include <chrono> // for std::chrono functions</chrono></code><code></code><code>class Timer</code><code>{</code><code>private:</code><code>	// Type aliases to make accessing nested type easier</code><code>	using Clock = std::chrono::steady_clock;</code><code>	using Second = std::chrono::duration<double, std::ratio<1=""> &gt;;</double,></code><code>	</code><code>	std::chrono::time_point<clock> m_beg { Clock::now() };</clock></code><code></code><code>public:</code><code>	void reset()</code><code>	{</code><code>		m_beg = Clock::now();</code><code>	}</code><code>	</code><code>	double elapsed() const</code><code>	{</code><code>		return std::chrono::duration_cast<second>(Clock::now() - m_beg).count();</second></code><code>	}</code><code>};</code></pre><p>That’s it! To use it, we instantiate a Timer object at the top of our main function (or wherever we want to start timing), and then call the elapsed() member function whenever we want to know how long the program took to run to that point.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    Timer t;</code><code></code><code>    // Code to time goes here</code><code></code><code>    std::cout &lt;&lt; "Time elapsed: " &lt;&lt; t.elapsed() &lt;&lt; " seconds\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>Now, let’s use this in an actual example where we sort an array of 10000 elements. First, let’s use the selection sort algorithm we developed in a previous chapter:</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <chrono> // for std::chrono functions</chrono></code><code>#include <cstddef> // for std::size_t</cstddef></code><code>#include <iostream></iostream></code><code>#include <numeric> // for std::iota</numeric></code><code></code><code>const int g_arrayElements { 10000 };</code><code></code><code>class Timer</code><code>{</code><code>private:</code><code>    // Type aliases to make accessing nested type easier</code><code>    using Clock = std::chrono::steady_clock;</code><code>    using Second = std::chrono::duration<double, std::ratio<1=""> &gt;;</double,></code><code></code><code>    std::chrono::time_point<clock> m_beg{ Clock::now() };</clock></code><code></code><code>public:</code><code></code><code>    void reset()</code><code>    {</code><code>        m_beg = Clock::now();</code><code>    }</code><code></code><code>    double elapsed() const</code><code>    {</code><code>        return std::chrono::duration_cast<second>(Clock::now() - m_beg).count();</second></code><code>    }</code><code>};</code><code></code><code>void sortArray(std::array<int, g_arrayelements="">&amp; array)</int,></code><code>{</code><code></code><code>    // Step through each element of the array</code><code>    // (except the last one, which will already be sorted by the time we get there)</code><code>    for (std::size_t startIndex{ 0 }; startIndex &lt; (g_arrayElements - 1); ++startIndex)</code><code>    {</code><code>        // smallestIndex is the index of the smallest element we’ve encountered this iteration</code><code>        // Start by assuming the smallest element is the first element of this iteration</code><code>        std::size_t smallestIndex{ startIndex };</code><code></code><code>        // Then look for a smaller element in the rest of the array</code><code>        for (std::size_t currentIndex{ startIndex + 1 }; currentIndex &lt; g_arrayElements; ++currentIndex)</code><code>        {</code><code>            // If we've found an element that is smaller than our previously found smallest</code><code>            if (array[currentIndex] &lt; array[smallestIndex])</code><code>            {</code><code>                // then keep track of it</code><code>                smallestIndex = currentIndex;</code><code>            }</code><code>        }</code><code></code><code>        // smallestIndex is now the smallest element in the remaining array</code><code>        // swap our start element with our smallest element (this sorts it into the correct place)</code><code>        std::swap(array[startIndex], array[smallestIndex]);</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::array<int, g_arrayelements=""> array;</int,></code><code>    std::iota(array.rbegin(), array.rend(), 1); // fill the array with values 10000 to 1</code><code></code><code>    Timer t;</code><code></code><code>    sortArray(array);</code><code></code><code>    std::cout &lt;&lt; "Time taken: " &lt;&lt; t.elapsed() &lt;&lt; " seconds\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>On the author’s machine, three runs produced timings of 0.0507, 0.0506, and 0.0498. So we can say around 0.05 seconds.</p><p>Now, let’s do the same test using std::sort from the standard library.</p><pre class="language-cpp line-numbers"><code>#include <algorithm> // for std::sort</algorithm></code><code>#include <array></array></code><code>#include <chrono> // for std::chrono functions</chrono></code><code>#include <cstddef> // for std::size_t</cstddef></code><code>#include <iostream></iostream></code><code>#include <numeric> // for std::iota</numeric></code><code></code><code>const int g_arrayElements { 10000 };</code><code></code><code>class Timer</code><code>{</code><code>private:</code><code>    // Type aliases to make accessing nested type easier</code><code>    using Clock = std::chrono::steady_clock;</code><code>    using Second = std::chrono::duration<double, std::ratio<1=""> &gt;;</double,></code><code></code><code>    std::chrono::time_point<clock> m_beg{ Clock::now() };</clock></code><code></code><code>public:</code><code></code><code>    void reset()</code><code>    {</code><code>        m_beg = Clock::now();</code><code>    }</code><code></code><code>    double elapsed() const</code><code>    {</code><code>        return std::chrono::duration_cast<second>(Clock::now() - m_beg).count();</second></code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    std::array<int, g_arrayelements=""> array;</int,></code><code>    std::iota(array.rbegin(), array.rend(), 1); // fill the array with values 10000 to 1</code><code></code><code>    Timer t;</code><code></code><code>    std::ranges::sort(array); // Since C++20</code><code>    // If your compiler isn't C++20-capable</code><code>    // std::sort(array.begin(), array.end());</code><code></code><code>    std::cout &lt;&lt; "Time taken: " &lt;&lt; t.elapsed() &lt;&lt; " seconds\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>On the author’s machine, this produced results of: 0.000693, 0.000692, and 0.000699. So basically right around 0.0007.</p><p>In other words, in this case, std::sort is 100 times faster than the selection sort we wrote ourselves!</p><p><strong>A few caveats about timing</strong></p><p>Timing is straightforward, but your results can be significantly impacted by a number of things, and it’s important to be aware of what those things are.</p><p>First, make sure you’re using a release build target, not a debug build target. Debug build targets typically turn optimization off, and that optimization can have a significant impact on the results. For example, using a debug build target, running the above std::sort example on the author’s machine took 0.0235 seconds -- 33 times as long!</p><p>Second, your timing results will be influenced by other things your system may be doing in the background. For best results, make sure your system isn’t doing anything CPU or memory intensive (e.g. playing a game) or hard drive intensive (e.g. searching for a file or running an antivirus scan).</p><p>Then measure at least 3 times. If the results are all similar, take the average. If one or two results are different, run the program a few more times until you get a better sense of which ones are outliers. Note that seemingly innocent things, like web browsers, can temporarily spike your CPU to 100% utilization when the site you have sitting in the background rotates in a new ad banner and has to parse a bunch of javascript. Running multiple times helps identify whether your initial run may have been impacted by such an event.</p><p>Third, when doing comparisons between two sets of code, be wary of what may change between runs that could impact timing. Your system may have kicked off an antivirus scan in the background, or maybe you’re streaming music now when you weren’t previously. Randomization can also impact timing. If we’d sorted an array filled with random numbers, the results could have been impacted by the randomization. Randomization can still be used, but ensure you use a fixed seed (e.g. don’t use the system clock) so the randomization is identical each run. Also, make sure you’re not timing waiting for user input, as how long the user takes to input something should not be part of your timing considerations.</p><p>Finally, note that results are only valid for your machine’s architecture, OS, compiler, and system specs. You may get different results on other systems that have different strengths and weaknesses.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">13.x — Chapter 13 comprehensive quiz</h1></header><div class="entry-content" itemprop="articleBody"><p>In this chapter, we explored the meat of C++ -- object-oriented programming! This is the most important chapter in the tutorial series.</p><br><h3>Chapter Review</h3><p>Classes allow you to create your own data types that bundle both data and functions that work on that data. Data and functions inside the class are called members. Members of the class are selected by using the . operator (or -&gt; if you’re accessing the member through a pointer).</p><p>Access specifiers allow you to specify who can access the members of a class. Public members can be accessed directly by anybody. Private members can only be accessed by other members of the class. We’ll cover protected members later, when we get to inheritance. By default, all members of a class are private and all members of a struct are public.</p><p>Encapsulation is the process of making all of your member data private, so it can not be accessed directly. This helps protect your class from misuse.</p><p>Constructors are a special type of member function that allow you to initialize objects of your class. A constructor that takes no parameters (or has all default parameters) is called a default constructor. The default constructor is used if no initialization values are provided by the user. You should always provide at least one constructor for your classes.</p><p>Member initializer lists allows you to initialize your member variables from within a constructor (rather than assigning the member variables values).</p><p>Non-static member initialization allows you to directly specify default values for member variables when they are declared.</p><p>Constructors are allowed to call other constructors (called delegating constructors, or constructor chaining).</p><p>Destructors are another type of special member function that allow your class to clean up after itself. Any kind of deallocation or shutdown routines should be executed from here.</p><p>All member functions have a hidden *this pointer that points at the class object being modified. Most of the time you will not need to access this pointer directly. But you can if you need to.</p><p>It is good programming style to put your class definitions in a header file of the same name as the class, and define your class functions in a .cpp file of the same name as the class. This also helps avoid circular dependencies.</p><p>Member functions can (and should) be made const if they do not modify the state of the class. Const class objects can only call const member functions.</p><p>Static member variables are shared among all objects of the class. Although they can be accessed from a class object, they can also be accessed directly via the scope resolution operator.</p><p>Similarly, static member functions are member functions that have no *this pointer. They can only access static member variables.</p><p>Friend functions are functions that are treated like member functions of the class (and thus can access a class’s private data directly). Friend classes are classes where all members of the class are considered friend functions.</p><p>It’s possible to create anonymous class objects for the purpose of evaluation in an expression, or passing or returning a value.</p><p>You can also nest types within a class. This is often used with enums related to the class, but can be done with other types (including other classes) if desired.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>a) Write a class named Point2d. Point2d should contain two member variables of type double: m_x, and m_y, both defaulted to 0.0. Provide a constructor and a print function.</p><p>The following program should run:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    Point2d first{};</code><code>    Point2d second{ 3.0, 4.0 };</code><code>    first.print();</code><code>    second.print();</code><code></code><code>    return 0;</code><code>}</code></pre><p>This should print:</p><pre>Point2d(0, 0)
Point2d(3, 4)
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Point2d</code><code>{</code><code>private:</code><code>	double m_x{};</code><code>	double m_y{};</code><code></code><code>public:</code><code>	Point2d(double x = 0.0, double y = 0.0)</code><code>		: m_x{ x }, m_y{ y }</code><code>	{</code><code>	}</code><code></code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; "Point2d(" &lt;&lt; m_x &lt;&lt; ", " &lt;&lt; m_y &lt;&lt; ")\n";</code><code>	}</code><code>};</code><code></code><code></code><code>int main()</code><code>{</code><code>   Point2d first{};</code><code>   Point2d second{ 3.0, 4.0 };</code><code>   first.print();</code><code>   second.print();</code><code></code><code>    return 0;</code><code>}</code></pre></div><p>b) Now add a member function named distanceTo that takes another Point2d as a parameter, and calculates the distance between them. Given two points (x1, y1) and (x2, y2), the distance between them can be calculated as std::sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)). The std::sqrt function lives in header cmath.</p><p>The following program should run:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    Point2d first{};</code><code>    Point2d second{ 3.0, 4.0 };</code><code>    first.print();</code><code>    second.print();</code><code>    std::cout &lt;&lt; "Distance between two points: " &lt;&lt; first.distanceTo(second) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This should print:</p><pre>Point2d(0, 0)
Point2d(3, 4)
Distance between two points: 5
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <cmath></cmath></code><code>#include <iostream></iostream></code><code></code><code>class Point2d</code><code>{</code><code>private:</code><code>	double m_x{};</code><code>	double m_y{};</code><code></code><code>public:</code><code>	Point2d(double x = 0.0, double y = 0.0)</code><code>		: m_x{ x }, m_y{ y }</code><code>	{</code><code>	}</code><code></code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; "Point2d(" &lt;&lt; m_x &lt;&lt; " , " &lt;&lt; m_y &lt;&lt; ")\n";</code><code>	}</code><code></code><code>	double distanceTo(const Point2d&amp; other) const</code><code>	{</code><code>		return std::sqrt((m_x - other.m_x) * (m_x - other.m_x) + (m_y - other.m_y) * (m_y - other.m_y));</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Point2d first{};</code><code>	Point2d second{ 3.0, 4.0 };</code><code>	first.print();</code><code>	second.print();</code><code>	std::cout &lt;&lt; "Distance between two points: " &lt;&lt; first.distanceTo(second) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre></div><p>c) Change function distanceTo from a member function to a non-member friend function that takes two Points as parameters. Also rename it “distanceFrom”.</p><p>The following program should run:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    Point2d first{};</code><code>    Point2d second{ 3.0, 4.0 };</code><code>    first.print();</code><code>    second.print();</code><code>    std::cout &lt;&lt; "Distance between two points: " &lt;&lt; distanceFrom(first, second) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This should print:</p><pre>Point2d(0, 0)
Point2d(3, 4)
Distance between two points: 5
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><pre class="language-cpp line-numbers"><code>#include <cmath></cmath></code><code>#include <iostream></iostream></code><code></code><code>class Point2d</code><code>{</code><code>private:</code><code>	double m_x{};</code><code>	double m_y{};</code><code></code><code>public:</code><code>	Point2d(double x = 0.0, double y = 0.0)</code><code>		: m_x{ x }, m_y{ y }</code><code>	{</code><code>	}</code><code></code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; "Point2d(" &lt;&lt; m_x &lt;&lt; " , " &lt;&lt; m_y &lt;&lt; ")\n";</code><code>	}</code><code></code><code>	friend double distanceFrom(const Point2d&amp; x, const Point2d&amp; y);</code><code></code><code>};</code><code></code><code>double distanceFrom(const Point2d&amp; a, const Point2d&amp; b)</code><code>{</code><code>	return std::sqrt((a.m_x - b.m_x) * (a.m_x - b.m_x) + (a.m_y - b.m_y) * (a.m_y - b.m_y));</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Point2d first{};</code><code>	Point2d second{ 3.0, 4.0 };</code><code>	first.print();</code><code>	second.print();</code><code>	std::cout &lt;&lt; "Distance between two points: " &lt;&lt; distanceFrom(first, second) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>Write a destructor for this class:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class HelloWorld</code><code>{</code><code>private:</code><code>	char* m_data{};</code><code></code><code>public:</code><code>	HelloWorld()</code><code>	{</code><code>		m_data = new char[14];</code><code>		const char* init{ "Hello, World!" };</code><code>		for (int i = 0; i &lt; 14; ++i)</code><code>			m_data[i] = init[i];</code><code>	}</code><code></code><code>	~HelloWorld()</code><code>	{</code><code>        // replace this comment with your destructor implementation</code><code>	}</code><code></code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; m_data &lt;&lt; '\n';</code><code>	}</code><code></code><code>};</code><code></code><code>int main()</code><code>{</code><code>	HelloWorld hello{};</code><code>	hello.print();</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class HelloWorld</code><code>{</code><code>private:</code><code>	char* m_data{};</code><code></code><code>public:</code><code>	HelloWorld()</code><code>	{</code><code>		m_data = new char[14];</code><code>		const char* init{ "Hello, World!" };</code><code>		for (int i = 0; i &lt; 14; ++i)</code><code>			m_data[i] = init[i];</code><code>	}</code><code></code><code>	~HelloWorld()</code><code>	{</code><code>		delete[] m_data;</code><code>	}</code><code></code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; m_data &lt;&lt; '\n';</code><code>	}</code><code></code><code>};</code><code></code><code>int main()</code><code>{</code><code>	HelloWorld hello{};</code><code>	hello.print();</code><code></code><code>    return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>Let’s create a random monster generator. This one should be fun.</p><p>a) First, let’s create an enumeration of monster types named MonsterType. Include the following monster types: Dragon, Goblin, Ogre, Orc, Skeleton, Troll, Vampire, and Zombie. Add an additional max_monster_types enum so we can count how many enumerators there are.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><pre class="language-cpp line-numbers"><code>enum class MonsterType</code><code>{</code><code>	dragon,</code><code>	goblin,</code><code>	ogre,</code><code>	orc,</code><code>	skeleton,</code><code>	troll,</code><code>	vampire,</code><code>	zombie,</code><code>	max_monster_types</code><code>};</code></pre></div><p>b) Now, let’s create our Monster class. Our Monster will have 4 attributes (member variables): a type (MonsterType), a name (std::string), a roar (std::string), and the number of hit points (int). Create a Monster class that has these 4 member variables.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>enum class MonsterType</code><code>{</code><code>	dragon,</code><code>	goblin,</code><code>	ogre,</code><code>	orc,</code><code>	skeleton,</code><code>	troll,</code><code>	vampire,</code><code>	zombie,</code><code>	max_monster_types</code><code>};</code><code></code><code>class Monster</code><code>{</code><code>private:</code><code>	MonsterType m_type{};</code><code>	std::string m_name{};</code><code>	std::string m_roar{};</code><code>	int m_hitPoints{};</code><code>};</code></pre></div><p>c) enum MonsterType is specific to Monster, so move the enum inside the class as a public declaration. When the enum is inside the class, “MonsterType” can be renamed “Type” since the context is already Monster.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none"><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>class Monster</code><code>{</code><code>public:</code><code>	enum class Type</code><code>	{</code><code>		dragon,</code><code>		goblin,</code><code>		ogre,</code><code>		orc,</code><code>		skeleton,</code><code>		troll,</code><code>		vampire,</code><code>		zombie,</code><code>		max_monster_types</code><code>	};</code><code></code><code>private:</code><code></code><code>	Type m_type{};</code><code>	std::string m_name{};</code><code>	std::string m_roar{};</code><code>	int m_hitPoints{};</code><code>};</code></pre></div><p>d) Create a constructor that allows you to initialize all of the member variables.</p><p>The following program should compile:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	Monster skeleton{ Monster::Type::skeleton, "Bones", "*rattle*", 4 };</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_7'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_7" style="display:none"><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>class Monster</code><code>{</code><code>public:</code><code>	enum class Type</code><code>	{</code><code>		dragon,</code><code>		goblin,</code><code>		ogre,</code><code>		orc,</code><code>		skeleton,</code><code>		troll,</code><code>		vampire,</code><code>		zombie,</code><code>		max_monster_types</code><code>	};</code><code></code><code>private:</code><code></code><code>	Type m_type{};</code><code>	std::string m_name{};</code><code>	std::string m_roar{};</code><code>	int m_hitPoints{};</code><code></code><code>public:</code><code>	Monster(Type type, const std::string&amp; name, const std::string&amp; roar, int hitPoints)</code><code>		: m_type{ type }, m_name{ name }, m_roar{ roar }, m_hitPoints{ hitPoints }</code><code>	{</code><code></code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Monster skeleton{ Monster::Type::skeleton, "Bones", "*rattle*", 4 };</code><code></code><code>	return 0;</code><code>}</code></pre></div><p>e) Now we want to be able to print our monster so we can validate it’s correct. To do that, we’re going to need to write a function that converts a Monster::Type into a string. Write that function (called getTypeString()), as well as a print() member function.</p><p>The following program should compile:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	Monster skeleton{ Monster::Type::skeleton, "Bones", "*rattle*", 4 };</code><code>	skeleton.print();</code><code></code><code>	return 0;</code><code>}</code></pre><p>and print:</p><pre>Bones the skeleton has 4 hit points and says *rattle*
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_8'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_8" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class Monster</code><code>{</code><code>public:</code><code>	enum class Type</code><code>	{</code><code>		dragon,</code><code>		goblin,</code><code>		ogre,</code><code>		orc,</code><code>		skeleton,</code><code>		troll,</code><code>		vampire,</code><code>		zombie,</code><code>		max_monster_types</code><code>	};</code><code></code><code>private:</code><code></code><code>	Type m_type{};</code><code>	std::string m_name{};</code><code>	std::string m_roar{};</code><code>	int m_hitPoints{};</code><code></code><code>public:</code><code>	Monster(Type type, const std::string&amp; name, const std::string&amp; roar, int hitPoints)</code><code>		: m_type{ type }, m_name{ name }, m_roar{ roar }, m_hitPoints{ hitPoints }</code><code>	{</code><code></code><code>	}</code><code></code><code>	// We're returning strings that are known at compile-time. Returning std::string</code><code>        // could add a considerable run-time cost.</code><code>	std::string_view getTypeString() const</code><code>	{</code><code>		switch (m_type)</code><code>		{</code><code>		case Type::dragon: return "dragon";</code><code>		case Type::goblin: return "goblin";</code><code>		case Type::ogre: return "ogre";</code><code>		case Type::orc: return "orc";</code><code>		case Type::skeleton: return "skeleton";</code><code>		case Type::troll: return "troll";</code><code>		case Type::vampire: return "vampire";</code><code>		case Type::zombie: return "zombie";</code><code>		default: return "???";</code><code>		}</code><code>	}</code><code></code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; m_name &lt;&lt; " the " &lt;&lt; getTypeString() &lt;&lt; " has " &lt;&lt; m_hitPoints &lt;&lt; " hit points and says " &lt;&lt; m_roar &lt;&lt; '\n';</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Monster skeleton{ Monster::Type::skeleton, "Bones", "*rattle*", 4 };</code><code>	skeleton.print();</code><code></code><code>	return 0;</code><code>}</code></pre></div><p>f) Now we can create a random monster generator. Let’s consider how our MonsterGenerator class will work. Ideally, we’ll ask it to give us a Monster, and it will create a random one for us. We don’t need more than one MonsterGenerator. This is a good candidate for a static class (one in which all functions are static). Create a static MonsterGenerator class. Create a static function named generateMonster(). This should return a Monster. For now, make it return anonymous <code>Monster(Monster::Type::skeleton, "Bones", "*rattle*", 4);</code></p><p>The following program should compile:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	Monster m{ MonsterGenerator::generateMonster() };</code><code>	m.print();</code><code></code><code>	return 0;</code><code>}</code></pre><p>and print:</p><pre>Bones the skeleton has 4 hit points and says *rattle*
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_9'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_9" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class Monster</code><code>{</code><code>public:</code><code>	enum class Type</code><code>	{</code><code>		dragon,</code><code>		goblin,</code><code>		ogre,</code><code>		orc,</code><code>		skeleton,</code><code>		troll,</code><code>		vampire,</code><code>		zombie,</code><code>		max_monster_types</code><code>	};</code><code></code><code>private:</code><code></code><code>	Type m_type{};</code><code>	std::string m_name{};</code><code>	std::string m_roar{};</code><code>	int m_hitPoints{};</code><code></code><code>public:</code><code>	Monster(Type type, const std::string&amp; name, const std::string&amp; roar, int hitPoints)</code><code>		: m_type{ type }, m_name{ name }, m_roar{ roar }, m_hitPoints{ hitPoints }</code><code>	{</code><code></code><code>	}</code><code></code><code>	std::string_view getTypeString() const</code><code>	{</code><code>		switch (m_type)</code><code>		{</code><code>		case Type::dragon: return "dragon";</code><code>		case Type::goblin: return "goblin";</code><code>		case Type::ogre: return "ogre";</code><code>		case Type::orc: return "orc";</code><code>		case Type::skeleton: return "skeleton";</code><code>		case Type::troll: return "troll";</code><code>		case Type::vampire: return "vampire";</code><code>		case Type::zombie: return "zombie";</code><code>		default: return "???";</code><code>		}</code><code>	}</code><code></code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; m_name &lt;&lt; " the " &lt;&lt; getTypeString() &lt;&lt; " has " &lt;&lt; m_hitPoints &lt;&lt; " hit points and says " &lt;&lt; m_roar &lt;&lt; '\n';</code><code>	}</code><code>};</code><code></code><code>class MonsterGenerator</code><code>{</code><code>public:</code><code>	static Monster generateMonster()</code><code>	{</code><code>		return { Monster::Type::skeleton, "Bones", "*rattle*", 4 };</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Monster m{ MonsterGenerator::generateMonster() };</code><code>	m.print();</code><code></code><code>	return 0;</code><code>}</code></pre></div><p>g) Now, MonsterGenerator needs to generate some random attributes. To do that, we’ll need to make use of this handy function:</p><pre class="language-cpp line-numbers"><code>	// Generate a random number between min and max (inclusive)</code><code>	// Assumes srand() has already been called</code><code>	static int getRandomNumber(int min, int max)</code><code>	{</code><code>		static constexpr double fraction{ 1.0 / (static_cast<double>(RAND_MAX) + 1.0) };  // static used for efficiency, so we only calculate this value once</double></code><code>		// evenly distribute the random number across our range</code><code>		return static_cast<int>(std::rand() * fraction * (max - min + 1) + min);</int></code><code>	}</code></pre><p>However, because MonsterGenerator relies directly on this function, let’s put it inside the class, as a static function.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_10'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_10" style="display:none"><pre class="language-cpp line-numbers"><code>class MonsterGenerator</code><code>{</code><code>public:</code><code></code><code>	// Generate a random number between min and max (inclusive)</code><code>	// Assumes std::srand() has already been called</code><code>	// Assumes max - min &lt;= RAND_MAX</code><code>	static int getRandomNumber(int min, int max)</code><code>	{</code><code>		static constexpr double fraction { 1.0 / (RAND_MAX + 1.0) };  // static used for efficiency, so we only calculate this value once</code><code>		// evenly distribute the random number across our range</code><code>		return min + static_cast<int>((max - min + 1) * (std::rand() * fraction));</int></code><code>	}</code><code></code><code>	static Monster generateMonster()</code><code>	{</code><code>		return { Monster::Type::skeleton, "Bones", "*rattle*", 4 };</code><code>	}</code><code>};</code></pre></div><p>h) Now edit function generateMonster() to generate a random Monster::Type (between 0 and Monster::Type::max_monster_types-1) and a random hit points (between 1 and 100). This should be fairly straightforward. Once you’ve done that, define two static fixed arrays of size 6 inside the function (named s_names and s_roars) and initialize them with 6 names and 6 sounds of your choice. Pick a random name and roar from these arrays.</p><p>The following program should compile:</p><pre class="language-cpp line-numbers"><code>#include <ctime> // for time()</ctime></code><code>#include <cstdlib> // for rand() and srand()</cstdlib></code><code></code><code>int main()</code><code>{</code><code>	std::srand(static_cast<unsigned int="">(std::time(nullptr))); // set initial seed value to system clock</unsigned></code><code>	std::rand(); // If using Visual Studio, discard first random value</code><code></code><code>	Monster m{ MonsterGenerator::generateMonster() };</code><code>	m.print();</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_11'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_11" style="display:none"><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <ctime> // for time()</ctime></code><code>#include <cstdlib> // for rand() and srand()</cstdlib></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class Monster</code><code>{</code><code>public:</code><code>	enum class Type</code><code>	{</code><code>		dragon,</code><code>		goblin,</code><code>		ogre,</code><code>		orc,</code><code>		skeleton,</code><code>		troll,</code><code>		vampire,</code><code>		zombie,</code><code>		max_monster_types</code><code>	};</code><code></code><code>private:</code><code></code><code>	Type m_type{};</code><code>	std::string m_name{};</code><code>	std::string m_roar{};</code><code>	int m_hitPoints{};</code><code></code><code>public:</code><code>	Monster(Type type, const std::string&amp; name, const std::string&amp; roar, int hitPoints)</code><code>		: m_type{ type }, m_name{ name }, m_roar{ roar }, m_hitPoints{ hitPoints }</code><code>	{</code><code></code><code>	}</code><code></code><code>	std::string_view getTypeString() const</code><code>	{</code><code>		switch (m_type)</code><code>		{</code><code>		case Type::dragon: return "dragon";</code><code>		case Type::goblin: return "goblin";</code><code>		case Type::ogre: return "ogre";</code><code>		case Type::orc: return "orc";</code><code>		case Type::skeleton: return "skeleton";</code><code>		case Type::troll: return "troll";</code><code>		case Type::vampire: return "vampire";</code><code>		case Type::zombie: return "zombie";</code><code>		default: return "???";</code><code>		}</code><code>	}</code><code></code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; m_name &lt;&lt; " the " &lt;&lt; getTypeString() &lt;&lt; " has " &lt;&lt; m_hitPoints &lt;&lt; " hit points and says " &lt;&lt; m_roar &lt;&lt; '\n';</code><code>	}</code><code>};</code><code></code><code>class MonsterGenerator</code><code>{</code><code>public:</code><code>	// Generate a random number between min and max (inclusive)</code><code>	// Assumes std::srand() has already been called</code><code>	// Assumes max - min &lt;= RAND_MAX</code><code>	static int getRandomNumber(int min, int max)</code><code>	{</code><code>		static constexpr double fraction { 1.0 / (RAND_MAX + 1.0) };  // static used for efficiency, so we only calculate this value once</code><code>		// evenly distribute the random number across our range</code><code>		return min + static_cast<int>((max - min + 1) * (std::rand() * fraction));</int></code><code>	}</code><code></code><code>	static Monster generateMonster()</code><code>	{</code><code>		auto type{ static_cast<monster::type>(getRandomNumber(0, static_cast<int>(Monster::Type::max_monster_types) - 1)) };</int></monster::type></code><code>		int hitPoints{ getRandomNumber(1, 100) };</code><code></code><code>		// If your compiler is not C++17 capable, use std::array<const 6="" char*,=""> instead.</const></code><code>		static constexpr std::array s_names{ "Blarg", "Moog", "Pksh", "Tyrn", "Mort", "Hans" };</code><code>		static constexpr std::array s_roars{ "*ROAR*", "*peep*", "*squeal*", "*whine*", "*hum*", "*burp*"};</code><code></code><code>		// Without the cast, compilers with a high warning level complain about</code><code>		// an implicit cast from a signed to an unsigned integer.</code><code>		auto name{ s_names[getRandomNumber(0, static_cast<int>(s_names.size()-1))] };</int></code><code>		auto roar{ s_roars[getRandomNumber(0, static_cast<int>(s_roars.size()-1))] };</int></code><code></code><code>		return { type, name, roar, hitPoints };</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	std::srand(static_cast<unsigned int="">(std::time(nullptr))); // set initial seed value to system clock</unsigned></code><code>	std::rand(); // If using Visual Studio, discard first random value</code><code></code><code>	Monster m{ MonsterGenerator::generateMonster() };</code><code>	m.print();</code><code></code><code>	return 0;</code><code>}</code></pre></div><p>i) Why did we declare variables s_names and s_roars as static?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_12'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_12" style="display:none"><p>Making s_names and s_roars static causes them to be initialized only once. Otherwise, they would get reinitialized every time generateMonster() was called.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #4</p><p>Okay, time for that game face again. This one is going to be a challenge. Let’s rewrite the Blackjack game we wrote in a previous lesson (<a href="https://www.learncpp.com/cpp-tutorial/chapter-11-comprehensive-quiz/">11.x -- Chapter 11 comprehensive quiz</a>) using classes! Here’s the full code without classes:</p><pre class="language-cpp line-numbers"><code>#include <algorithm> // std::shuffle</algorithm></code><code>#include <array></array></code><code>#include <cassert></cassert></code><code>#include <ctime> // std::time</ctime></code><code>#include <iostream></iostream></code><code>#include <random> // std::mt19937</random></code><code></code><code>enum class CardSuit</code><code>{</code><code>    club,</code><code>    diamond,</code><code>    heart,</code><code>    spade,</code><code></code><code>    max_suits</code><code>};</code><code></code><code>enum class CardRank</code><code>{</code><code>    rank_2,</code><code>    rank_3,</code><code>    rank_4,</code><code>    rank_5,</code><code>    rank_6,</code><code>    rank_7,</code><code>    rank_8,</code><code>    rank_9,</code><code>    rank_10,</code><code>    rank_jack,</code><code>    rank_queen,</code><code>    rank_king,</code><code>    rank_ace,</code><code></code><code>    max_ranks</code><code>};</code><code></code><code>struct Card</code><code>{</code><code>    CardRank rank{};</code><code>    CardSuit suit{};</code><code>};</code><code></code><code>struct Player</code><code>{</code><code>    int score{};</code><code>};</code><code></code><code>using Deck = std::array<card, 52="">;</card,></code><code>using Index = Deck::size_type;</code><code></code><code>// Maximum score before losing.</code><code>constexpr int g_maximumScore{ 21 };</code><code></code><code>// Minimum score that the dealer has to have.</code><code>constexpr int g_minimumDealerScore{ 17 };</code><code></code><code>void printCard(const Card&amp; card)</code><code>{</code><code>    switch (card.rank)</code><code>    {</code><code>    case CardRank::rank_2:      std::cout &lt;&lt; '2';   break;</code><code>    case CardRank::rank_3:      std::cout &lt;&lt; '3';   break;</code><code>    case CardRank::rank_4:      std::cout &lt;&lt; '4';   break;</code><code>    case CardRank::rank_5:      std::cout &lt;&lt; '5';   break;</code><code>    case CardRank::rank_6:      std::cout &lt;&lt; '6';   break;</code><code>    case CardRank::rank_7:      std::cout &lt;&lt; '7';   break;</code><code>    case CardRank::rank_8:      std::cout &lt;&lt; '8';   break;</code><code>    case CardRank::rank_9:      std::cout &lt;&lt; '9';   break;</code><code>    case CardRank::rank_10:     std::cout &lt;&lt; 'T';   break;</code><code>    case CardRank::rank_jack:   std::cout &lt;&lt; 'J';   break;</code><code>    case CardRank::rank_queen:  std::cout &lt;&lt; 'Q';   break;</code><code>    case CardRank::rank_king:   std::cout &lt;&lt; 'K';   break;</code><code>    case CardRank::rank_ace:    std::cout &lt;&lt; 'A';   break;</code><code>    default:</code><code>        std::cout &lt;&lt; '?';</code><code>        break;</code><code>    }</code><code></code><code>    switch (card.suit)</code><code>    {</code><code>    case CardSuit::club:       std::cout &lt;&lt; 'C';   break;</code><code>    case CardSuit::diamond:    std::cout &lt;&lt; 'D';   break;</code><code>    case CardSuit::heart:      std::cout &lt;&lt; 'H';   break;</code><code>    case CardSuit::spade:      std::cout &lt;&lt; 'S';   break;</code><code>    default:</code><code>        std::cout &lt;&lt; '?';</code><code>        break;</code><code>    }</code><code>}</code><code></code><code>int getCardValue(const Card&amp; card)</code><code>{</code><code>    switch (card.rank)</code><code>    {</code><code>    case CardRank::rank_2:        return 2;</code><code>    case CardRank::rank_3:        return 3;</code><code>    case CardRank::rank_4:        return 4;</code><code>    case CardRank::rank_5:        return 5;</code><code>    case CardRank::rank_6:        return 6;</code><code>    case CardRank::rank_7:        return 7;</code><code>    case CardRank::rank_8:        return 8;</code><code>    case CardRank::rank_9:        return 9;</code><code>    case CardRank::rank_10:       return 10;</code><code>    case CardRank::rank_jack:     return 10;</code><code>    case CardRank::rank_queen:    return 10;</code><code>    case CardRank::rank_king:     return 10;</code><code>    case CardRank::rank_ace:      return 11;</code><code>    default:</code><code>        assert(false &amp;&amp; "should never happen");</code><code>        return 0;</code><code>    }</code><code>}</code><code></code><code>void printDeck(const Deck&amp; deck)</code><code>{</code><code>    for (const auto&amp; card : deck)</code><code>    {</code><code>        printCard(card);</code><code>        std::cout &lt;&lt; ' ';</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code>}</code><code></code><code>Deck createDeck()</code><code>{</code><code>    Deck deck{};</code><code></code><code>    // We could initialize each card individually, but that would be a pain.  Let's use a loop.</code><code></code><code>    Index index{ 0 };</code><code></code><code>    for (int suit{ 0 }; suit &lt; static_cast<int>(CardSuit::max_suits); ++suit)</int></code><code>    {</code><code>        for (int rank{ 0 }; rank &lt; static_cast<int>(CardRank::max_ranks); ++rank)</int></code><code>        {</code><code>            deck[index].suit = static_cast<cardsuit>(suit);</cardsuit></code><code>            deck[index].rank = static_cast<cardrank>(rank);</cardrank></code><code>            ++index;</code><code>        }</code><code>    }</code><code></code><code>    return deck;</code><code>}</code><code></code><code>void shuffleDeck(Deck&amp; deck)</code><code>{</code><code>    static std::mt19937 mt{ static_cast<std::mt19937::result_type>(std::time(nullptr)) };</std::mt19937::result_type></code><code></code><code>    std::shuffle(deck.begin(), deck.end(), mt);</code><code>}</code><code></code><code>bool playerWantsHit()</code><code>{</code><code>    while (true)</code><code>    {</code><code>        std::cout &lt;&lt; "(h) to hit, or (s) to stand: ";</code><code></code><code>        char ch{};</code><code>        std::cin &gt;&gt; ch;</code><code></code><code>        switch (ch)</code><code>        {</code><code>        case 'h':</code><code>            return true;</code><code>        case 's':</code><code>            return false;</code><code>        }</code><code>    }</code><code>}</code><code></code><code>// Returns true if the player went bust. False otherwise.</code><code>bool playerTurn(const Deck&amp; deck, Index&amp; nextCardIndex, Player&amp; player)</code><code>{</code><code>    while (true)</code><code>    {</code><code>        if (player.score &gt; g_maximumScore)</code><code>        {</code><code>            // This can happen even before the player had a choice if they drew 2</code><code>            // aces.</code><code>            std::cout &lt;&lt; "You busted!\n";</code><code>            return true;</code><code>        }</code><code>        else</code><code>        {</code><code>            if (playerWantsHit())</code><code>            {</code><code>                int cardValue{ getCardValue(deck.at(nextCardIndex++)) };</code><code>                player.score += cardValue;</code><code>                std::cout &lt;&lt; "You were dealt a " &lt;&lt; cardValue &lt;&lt; " and now have " &lt;&lt; player.score &lt;&lt; '\n';</code><code>            }</code><code>            else</code><code>            {</code><code>                // The player didn't go bust.</code><code>                return false;</code><code>            }</code><code>        }</code><code>    }</code><code>}</code><code></code><code>// Returns true if the dealer went bust. False otherwise.</code><code>bool dealerTurn(const Deck&amp; deck, Index&amp; nextCardIndex, Player&amp; dealer)</code><code>{</code><code>    // Draw cards until we reach the minimum value.</code><code>    while (dealer.score &lt; g_minimumDealerScore)</code><code>    {</code><code>        int cardValue{ getCardValue(deck.at(nextCardIndex++)) };</code><code>        dealer.score += cardValue;</code><code>        std::cout &lt;&lt; "The dealer turned up a " &lt;&lt; cardValue &lt;&lt; " and now has " &lt;&lt; dealer.score &lt;&lt; '\n';</code><code></code><code>    }</code><code></code><code>    // If the dealer's score is too high, they went bust.</code><code>    if (dealer.score &gt; g_maximumScore)</code><code>    {</code><code>        std::cout &lt;&lt; "The dealer busted!\n";</code><code>        return true;</code><code>    }</code><code></code><code>    return false;</code><code>}</code><code></code><code>bool playBlackjack(const Deck&amp; deck)</code><code>{</code><code>    // Index of the card that will be drawn next. This cannot overrun</code><code>    // the array, because a player will lose before all cards are used up.</code><code>    Index nextCardIndex{ 0 };</code><code></code><code>    // Create the dealer and give them 1 card.</code><code>    Player dealer{ getCardValue(deck.at(nextCardIndex++)) };</code><code></code><code>    // The dealer's card is face up, the player can see it.</code><code>    std::cout &lt;&lt; "The dealer is showing: " &lt;&lt; dealer.score &lt;&lt; '\n';</code><code></code><code>    // Create the player and give them 2 cards.</code><code>    Player player{ getCardValue(deck.at(nextCardIndex)) + getCardValue(deck.at(nextCardIndex + 1)) };</code><code>    nextCardIndex += 2;</code><code></code><code>    std::cout &lt;&lt; "You have: " &lt;&lt; player.score &lt;&lt; '\n';</code><code></code><code>    if (playerTurn(deck, nextCardIndex, player))</code><code>    {</code><code>        // The player went bust.</code><code>        return false;</code><code>    }</code><code></code><code>    if (dealerTurn(deck, nextCardIndex, dealer))</code><code>    {</code><code>        // The dealer went bust, the player wins.</code><code>        return true;</code><code>    }</code><code></code><code>    return (player.score &gt; dealer.score);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    auto deck{ createDeck() };</code><code></code><code>    shuffleDeck(deck);</code><code></code><code>    if (playBlackjack(deck))</code><code>    {</code><code>        std::cout &lt;&lt; "You win!\n";</code><code>    }</code><code>    else</code><code>    {</code><code>        std::cout &lt;&lt; "You lose!\n";</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>Holy moly! Where do we even begin? Don’t worry, we can do this, but we’ll need a strategy here. This Blackjack program is really composed of four parts: the logic that deals with cards, the logic that deals with the deck of cards, the logic that deals with dealing cards from the deck, and the game logic. Our strategy will be to work on each of these pieces individually, testing each part with a small test program as we go. That way, instead of trying to convert the entire program in one go, we can do it in 4 testable parts.</p><p>Start by copying the original program into your IDE, and then commenting out everything except the #include lines.</p><p>a) Let’s start by making <code>Card</code> a <code>class</code> instead of a <code>struct</code>. The good news is that the <code>Card</code> <code>class</code> is pretty similar to the <code>Monster</code> <code>class</code> from the previous quiz question. First, create private members to hold the rank and suit (name them <code>m_rank</code> and <code>m_suit</code> accordingly). Second, create a public constructor for the <code>Card</code> class so we can initialize Cards. Third, make the <code>class</code> default constructible, either by adding a default constructor or by adding default arguments to the current constructor. Fourth, because <code>CardSuit</code> and <code>CardRank</code> are tied to cards, move those into the <code>Card</code> class as standard enums named <code>Suit</code> and <code>Rank</code>. Finally, move the <code>printCard()</code> and <code>getCardValue()</code> functions inside the <code>class</code> as public members (remember to make them <code>const</code>!).</p><div class="cpp-note cpp-lightgraybackground"><h4>A reminder</h4><p>When using a <code>std::array</code> (or <code>std::vector</code>) where the elements are a class type, your element’s <code>class</code> must have a default constructor so the elements can be initialized to a reasonable default state. If you do not provide one, you’ll get a cryptic error about attempting to reference a deleted function.</p></div><p>The following test program should compile:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// ...</code><code></code><code>int main()</code><code>{</code><code>  const Card cardQueenHearts{ Card::rank_queen, Card::heart };</code><code>  cardQueenHearts.print();</code><code>  std::cout &lt;&lt; " has the value " &lt;&lt; cardQueenHearts.value() &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_13'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_13" style="display:none"><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code>#include <iostream></iostream></code><code></code><code>class Card</code><code>{</code><code>public:</code><code>    enum Suit</code><code>    {</code><code>        club,</code><code>        diamond,</code><code>        heart,</code><code>        spade,</code><code></code><code>        max_suits</code><code>    };</code><code></code><code>    enum Rank</code><code>    {</code><code>        rank_2,</code><code>        rank_3,</code><code>        rank_4,</code><code>        rank_5,</code><code>        rank_6,</code><code>        rank_7,</code><code>        rank_8,</code><code>        rank_9,</code><code>        rank_10,</code><code>        rank_jack,</code><code>        rank_queen,</code><code>        rank_king,</code><code>        rank_ace,</code><code></code><code>        max_ranks</code><code>    };</code><code></code><code>private:</code><code>    Rank m_rank{};</code><code>    Suit m_suit{};</code><code></code><code>public:</code><code>    Card() = default;</code><code></code><code>    Card(Rank rank, Suit suit)</code><code>        : m_rank{ rank }, m_suit{ suit }</code><code>    {</code><code>    }</code><code></code><code>    void print() const</code><code>	{</code><code>		switch (m_rank)</code><code>		{</code><code>		case rank_2:        std::cout &lt;&lt; '2';   break;</code><code>		case rank_3:        std::cout &lt;&lt; '3';   break;</code><code>		case rank_4:        std::cout &lt;&lt; '4';   break;</code><code>		case rank_5:        std::cout &lt;&lt; '5';   break;</code><code>		case rank_6:        std::cout &lt;&lt; '6';   break;</code><code>		case rank_7:        std::cout &lt;&lt; '7';   break;</code><code>		case rank_8:        std::cout &lt;&lt; '8';   break;</code><code>		case rank_9:        std::cout &lt;&lt; '9';   break;</code><code>		case rank_10:       std::cout &lt;&lt; 'T';   break;</code><code>		case rank_jack:     std::cout &lt;&lt; 'J';   break;</code><code>		case rank_queen:    std::cout &lt;&lt; 'Q';   break;</code><code>		case rank_king:     std::cout &lt;&lt; 'K';   break;</code><code>		case rank_ace:      std::cout &lt;&lt; 'A';   break;</code><code>		default:</code><code>            std::cout &lt;&lt; '?';</code><code>            break;</code><code>		}</code><code></code><code>		switch (m_suit)</code><code>		{</code><code>		case club:          std::cout &lt;&lt; 'C';   break;</code><code>		case diamond:       std::cout &lt;&lt; 'D';   break;</code><code>		case heart:         std::cout &lt;&lt; 'H';   break;</code><code>		case spade:         std::cout &lt;&lt; 'S';   break;</code><code>		default:</code><code>            std::cout &lt;&lt; '?';</code><code>            break;</code><code>		}</code><code>	}</code><code></code><code>    int value() const</code><code>    {</code><code>        switch (m_rank)</code><code>        {</code><code>        case rank_2:        return 2;</code><code>        case rank_3:        return 3;</code><code>        case rank_4:        return 4;</code><code>        case rank_5:        return 5;</code><code>        case rank_6:        return 6;</code><code>        case rank_7:        return 7;</code><code>        case rank_8:        return 8;</code><code>        case rank_9:        return 9;</code><code>        case rank_10:       return 10;</code><code>        case rank_jack:     return 10;</code><code>        case rank_queen:    return 10;</code><code>        case rank_king:     return 10;</code><code>        case rank_ace:      return 11;</code><code>        default:</code><code>            assert(false &amp;&amp; "should never happen");</code><code>            return 0;</code><code>        }</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    const Card cardQueenHearts{ Card::rank_queen, Card::heart};</code><code>    cardQueenHearts.print();</code><code>    std::cout &lt;&lt; " has the value " &lt;&lt; cardQueenHearts.value() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre></div><p>b) Okay, now let’s work on a <code>Deck</code> <code>class</code>. The deck needs to hold 52 cards, so use a private <code>std::array</code> member to create a fixed array of 52 cards named <code>m_deck</code>. Second, create a constructor that takes no parameters and initializes/assigns m_deck with one of each card (modify the code from the original <code>createDeck()</code> function). Third, move <code>printDeck</code> into the <code>Deck</code> <code>class</code> as a public member. Fourth, move <code>shuffleDeck</code> into the class as a public member.</p><p>The trickiest part of this step is initializing the deck using the modified code from the original <code>createDeck()</code> function. The following hint shows how to do that.</p><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">Hint:<pre class="language-cpp line-numbers"><code>m_deck[card] = { static_cast<card::rank>(rank), static_cast<card::suit>(suit) };</card::suit></card::rank></code></pre></div><p>The following test program should compile:</p><pre class="language-cpp line-numbers"><code>// ...</code><code></code><code>int main()</code><code>{</code><code>  Deck deck{};</code><code>  deck.print();</code><code>  deck.shuffle();</code><code>  deck.print();</code><code></code><code>  return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_14'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_14" style="display:none"><pre class="language-cpp line-numbers"><code>#include <algorithm> // for std::shuffle</algorithm></code><code>#include <array></array></code><code>#include <cassert></cassert></code><code>#include <ctime></ctime></code><code>#include <iostream></iostream></code><code>#include <random></random></code><code></code><code>class Card</code><code>{</code><code>public:</code><code>    enum Suit</code><code>    {</code><code>        club,</code><code>        diamond,</code><code>        heart,</code><code>        spade,</code><code></code><code>        max_suits</code><code>    };</code><code></code><code>    enum Rank</code><code>    {</code><code>        rank_2,</code><code>        rank_3,</code><code>        rank_4,</code><code>        rank_5,</code><code>        rank_6,</code><code>        rank_7,</code><code>        rank_8,</code><code>        rank_9,</code><code>        rank_10,</code><code>        rank_jack,</code><code>        rank_queen,</code><code>        rank_king,</code><code>        rank_ace,</code><code></code><code>        max_ranks</code><code>    };</code><code></code><code>private:</code><code>    Rank m_rank{};</code><code>    Suit m_suit{};</code><code></code><code>public:</code><code>    Card() = default;</code><code></code><code>    Card(Rank rank, Suit suit)</code><code>        : m_rank{ rank }, m_suit{ suit }</code><code>    {</code><code>    }</code><code>    void print() const</code><code>    {</code><code>        switch (m_rank)</code><code>        {</code><code>        case rank_2:        std::cout &lt;&lt; '2';   break;</code><code>        case rank_3:        std::cout &lt;&lt; '3';   break;</code><code>        case rank_4:        std::cout &lt;&lt; '4';   break;</code><code>        case rank_5:        std::cout &lt;&lt; '5';   break;</code><code>        case rank_6:        std::cout &lt;&lt; '6';   break;</code><code>        case rank_7:        std::cout &lt;&lt; '7';   break;</code><code>        case rank_8:        std::cout &lt;&lt; '8';   break;</code><code>        case rank_9:        std::cout &lt;&lt; '9';   break;</code><code>        case rank_10:       std::cout &lt;&lt; 'T';   break;</code><code>        case rank_jack:     std::cout &lt;&lt; 'J';   break;</code><code>        case rank_queen:    std::cout &lt;&lt; 'Q';   break;</code><code>        case rank_king:     std::cout &lt;&lt; 'K';   break;</code><code>        case rank_ace:      std::cout &lt;&lt; 'A';   break;</code><code>        default:</code><code>            std::cout &lt;&lt; '?';</code><code>            break;</code><code>        }</code><code></code><code>        switch (m_suit)</code><code>        {</code><code>        case club:          std::cout &lt;&lt; 'C';   break;</code><code>        case diamond:       std::cout &lt;&lt; 'D';   break;</code><code>        case heart:         std::cout &lt;&lt; 'H';   break;</code><code>        case spade:         std::cout &lt;&lt; 'S';   break;</code><code>        default:</code><code>            std::cout &lt;&lt; '?';</code><code>            break;</code><code>        }</code><code>    }</code><code></code><code>    int value() const</code><code>    {</code><code>        switch (m_rank)</code><code>        {</code><code>        case rank_2:        return 2;</code><code>        case rank_3:        return 3;</code><code>        case rank_4:        return 4;</code><code>        case rank_5:        return 5;</code><code>        case rank_6:        return 6;</code><code>        case rank_7:        return 7;</code><code>        case rank_8:        return 8;</code><code>        case rank_9:        return 9;</code><code>        case rank_10:       return 10;</code><code>        case rank_jack:     return 10;</code><code>        case rank_queen:    return 10;</code><code>        case rank_king:     return 10;</code><code>        case rank_ace:      return 11;</code><code>        default:</code><code>            assert(false &amp;&amp; "should never happen");</code><code>            return 0;</code><code>        }</code><code>    }</code><code>};</code><code></code><code>class Deck</code><code>{</code><code>public:</code><code>    using DeckType = std::array<card, 52="">;</card,></code><code>    using Index = DeckType::size_type;</code><code></code><code>private:</code><code>    DeckType m_deck{};</code><code></code><code>public:</code><code>    Deck()</code><code>    {</code><code>        Index index{ 0 };</code><code></code><code>        for (int suit{ 0 }; suit &lt; Card::max_suits; ++suit)</code><code>        {</code><code>            for (int rank{ 0 }; rank &lt; Card::max_ranks; ++rank)</code><code>            {</code><code>                m_deck[index] = { static_cast<card::rank>(rank), static_cast<card::suit>(suit) };</card::suit></card::rank></code><code>                ++index;</code><code>            }</code><code>        }</code><code>    }</code><code>    void print() const</code><code>    {</code><code>        for (const auto&amp; card : m_deck)</code><code>        {</code><code>            card.print();</code><code>            std::cout &lt;&lt; ' ';</code><code>        }</code><code></code><code>        std::cout &lt;&lt; '\n';</code><code>    }</code><code></code><code>    void shuffle()</code><code>    {</code><code>        static std::mt19937 mt{ static_cast<std::mt19937::result_type>(std::time(nullptr)) };</std::mt19937::result_type></code><code></code><code>        std::shuffle(m_deck.begin(), m_deck.end(), mt);</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Deck deck;</code><code>    deck.print();</code><code>    deck.shuffle();</code><code>    deck.print();</code><code></code><code>    return 0;</code><code>}</code></pre></div><p>c) Now we need a way to keep track of which card is next to be dealt (in the original program, this is what <code>nextCardIndex</code> was for). First, add a member named <code>m_cardIndex</code> to <code>Deck</code> and initialize it to 0. Create a public member function named <code>dealCard()</code>, which should return a const reference to the current card and advance <code>m_cardIndex</code> to the next index. <code>shuffle()</code> should also be updated to reset <code>m_cardIndex</code> (since if you shuffle the deck, you’ll start dealing from the top of the deck again).</p><p>The following test program should compile:</p><pre class="language-cpp line-numbers"><code>// ...</code><code></code><code>int main()</code><code>{</code><code>  Deck deck{};</code><code>  </code><code>  deck.shuffle();</code><code>  deck.print();</code><code>  </code><code>  std::cout &lt;&lt; "The first card has value: " &lt;&lt; deck.dealCard().value() &lt;&lt; '\n';</code><code>  std::cout &lt;&lt; "The second card has value: " &lt;&lt; deck.dealCard().value() &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_15'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_15" style="display:none"><pre class="language-cpp line-numbers"><code>#include <algorithm> // for std::shuffle</algorithm></code><code>#include <array></array></code><code>#include <cassert></cassert></code><code>#include <ctime></ctime></code><code>#include <iostream></iostream></code><code>#include <random></random></code><code></code><code>class Card</code><code>{</code><code>public:</code><code>    enum Suit</code><code>    {</code><code>        club,</code><code>        diamond,</code><code>        heart,</code><code>        spade,</code><code></code><code>        max_suits</code><code>    };</code><code></code><code>    enum Rank</code><code>    {</code><code>        rank_2,</code><code>        rank_3,</code><code>        rank_4,</code><code>        rank_5,</code><code>        rank_6,</code><code>        rank_7,</code><code>        rank_8,</code><code>        rank_9,</code><code>        rank_10,</code><code>        rank_jack,</code><code>        rank_queen,</code><code>        rank_king,</code><code>        rank_ace,</code><code></code><code>        max_ranks</code><code>    };</code><code></code><code>private:</code><code>    Rank m_rank{};</code><code>    Suit m_suit{};</code><code></code><code>public:</code><code>    Card() = default;</code><code></code><code>    Card(Rank rank, Suit suit)</code><code>        : m_rank{ rank }, m_suit{ suit }</code><code>    {</code><code>    }</code><code></code><code>    void print() const</code><code>    {</code><code>        switch (m_rank)</code><code>        {</code><code>        case rank_2:        std::cout &lt;&lt; '2';   break;</code><code>        case rank_3:        std::cout &lt;&lt; '3';   break;</code><code>        case rank_4:        std::cout &lt;&lt; '4';   break;</code><code>        case rank_5:        std::cout &lt;&lt; '5';   break;</code><code>        case rank_6:        std::cout &lt;&lt; '6';   break;</code><code>        case rank_7:        std::cout &lt;&lt; '7';   break;</code><code>        case rank_8:        std::cout &lt;&lt; '8';   break;</code><code>        case rank_9:        std::cout &lt;&lt; '9';   break;</code><code>        case rank_10:       std::cout &lt;&lt; 'T';   break;</code><code>        case rank_jack:     std::cout &lt;&lt; 'J';   break;</code><code>        case rank_queen:    std::cout &lt;&lt; 'Q';   break;</code><code>        case rank_king:     std::cout &lt;&lt; 'K';   break;</code><code>        case rank_ace:      std::cout &lt;&lt; 'A';   break;</code><code>        default:</code><code>            std::cout &lt;&lt; '?';</code><code>            break;</code><code>        }</code><code></code><code>        switch (m_suit)</code><code>        {</code><code>        case club:          std::cout &lt;&lt; 'C';   break;</code><code>        case diamond:       std::cout &lt;&lt; 'D';   break;</code><code>        case heart:         std::cout &lt;&lt; 'H';   break;</code><code>        case spade:         std::cout &lt;&lt; 'S';   break;</code><code>        default:</code><code>            std::cout &lt;&lt; '?';</code><code>            break;</code><code>        }</code><code>    }</code><code></code><code>    int value() const</code><code>    {</code><code>        switch (m_rank)</code><code>        {</code><code>        case rank_2:        return 2;</code><code>        case rank_3:        return 3;</code><code>        case rank_4:        return 4;</code><code>        case rank_5:        return 5;</code><code>        case rank_6:        return 6;</code><code>        case rank_7:        return 7;</code><code>        case rank_8:        return 8;</code><code>        case rank_9:        return 9;</code><code>        case rank_10:       return 10;</code><code>        case rank_jack:     return 10;</code><code>        case rank_queen:    return 10;</code><code>        case rank_king:     return 10;</code><code>        case rank_ace:      return 11;</code><code>        default:</code><code>            assert(false &amp;&amp; "should never happen");</code><code>            return 0;</code><code>        }</code><code>    }</code><code>};</code><code></code><code>class Deck</code><code>{</code><code>public:</code><code>    using DeckType = std::array<card, 52="">;</card,></code><code>    using Index = DeckType::size_type;</code><code></code><code>private:</code><code>    DeckType m_deck{};</code><code>    Index m_cardIndex{ 0 };</code><code></code><code>public:</code><code>    Deck()</code><code>    {</code><code>        Index index{ 0 };</code><code></code><code>        for (int suit{ 0 }; suit &lt; Card::max_suits; ++suit)</code><code>        {</code><code>            for (int rank{ 0 }; rank &lt; Card::max_ranks; ++rank)</code><code>            {</code><code>                m_deck[index] = { static_cast<card::rank>(rank), static_cast<card::suit>(suit) };</card::suit></card::rank></code><code>                ++index;</code><code>            }</code><code>        }</code><code>    }</code><code></code><code>    void print() const</code><code>    {</code><code>        for (const auto&amp; card : m_deck)</code><code>        {</code><code>            card.print();</code><code>            std::cout &lt;&lt; ' ';</code><code>        }</code><code></code><code>        std::cout &lt;&lt; '\n';</code><code>    }</code><code></code><code>    void shuffle()</code><code>    {</code><code>        static std::mt19937 mt{ static_cast<std::mt19937::result_type>(std::time(nullptr)) };</std::mt19937::result_type></code><code></code><code>        std::shuffle(m_deck.begin(), m_deck.end(), mt);</code><code>        </code><code>        m_cardIndex = 0;</code><code>    }</code><code></code><code>    const Card&amp; dealCard()</code><code>    {</code><code>        assert(m_cardIndex &lt; m_deck.size());</code><code></code><code>        return m_deck[m_cardIndex++];</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Deck deck{};</code><code></code><code>    deck.shuffle();</code><code>    deck.print();</code><code></code><code>    std::cout &lt;&lt; "The first card has value: " &lt;&lt; deck.dealCard().value() &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "The second card has value: " &lt;&lt; deck.dealCard().value() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre></div><p>d) Next up is the <code>Player</code>. Because <code>playerTurn</code> and <code>dealerTurn</code> are very different from each other, we’ll keep them as non-member functions. Make <code>Player</code> a <code>class</code> and add a <code>drawCard</code> member function that deals the player one card from the deck, increasing the player’s score. We’ll also need a member function to access the <code>Player</code>‘s score. For convenience, add a member function named <code>isBust()</code> that returns <code>true</code> if the player’s score exceeds the maximum (<code>g_maximumScore</code>). The following code should compile:</p><pre class="language-cpp line-numbers"><code>// ...</code><code></code><code>int main()</code><code>{</code><code>    Deck deck{};</code><code></code><code>    deck.shuffle();</code><code>    deck.print();</code><code></code><code>    Player player{};</code><code>    Player dealer{};</code><code></code><code>    int playerCard { player.drawCard(deck) };</code><code>    std::cout &lt;&lt; "The player drew a card with value " &lt;&lt; playerCard &lt;&lt; " and now has score " &lt;&lt; player.score() &lt;&lt; '\n';</code><code></code><code>    int dealerCard { dealer.drawCard(deck) };</code><code>    std::cout &lt;&lt; "The dealer drew a card with value " &lt;&lt; dealerCard &lt;&lt; " and now has score " &lt;&lt; dealer.score() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_16'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_16" style="display:none"><pre class="language-cpp line-numbers"><code>#include <algorithm> // for std::shuffle</algorithm></code><code>#include <array></array></code><code>#include <cassert></cassert></code><code>#include <ctime></ctime></code><code>#include <iostream></iostream></code><code>#include <random></random></code><code></code><code>// Maximum score before losing.</code><code>constexpr int g_maximumScore{ 21 };</code><code></code><code>// Minimum score that the dealer has to have.</code><code>constexpr int g_minimumDealerScore{ 17 };</code><code></code><code>class Card</code><code>{</code><code>public:</code><code>    enum Suit</code><code>    {</code><code>        club,</code><code>        diamond,</code><code>        heart,</code><code>        spade,</code><code></code><code>        max_suits</code><code>    };</code><code></code><code>    enum Rank</code><code>    {</code><code>        rank_2,</code><code>        rank_3,</code><code>        rank_4,</code><code>        rank_5,</code><code>        rank_6,</code><code>        rank_7,</code><code>        rank_8,</code><code>        rank_9,</code><code>        rank_10,</code><code>        rank_jack,</code><code>        rank_queen,</code><code>        rank_king,</code><code>        rank_ace,</code><code></code><code>        max_ranks</code><code>    };</code><code></code><code>private:</code><code>    Rank m_rank{};</code><code>    Suit m_suit{};</code><code></code><code>public:</code><code>    Card() = default;</code><code></code><code>    Card(Rank rank, Suit suit)</code><code>        : m_rank{ rank }, m_suit{ suit }</code><code>    {</code><code>    }</code><code></code><code>    void print() const</code><code>    {</code><code>        switch (m_rank)</code><code>        {</code><code>        case rank_2:        std::cout &lt;&lt; '2';   break;</code><code>        case rank_3:        std::cout &lt;&lt; '3';   break;</code><code>        case rank_4:        std::cout &lt;&lt; '4';   break;</code><code>        case rank_5:        std::cout &lt;&lt; '5';   break;</code><code>        case rank_6:        std::cout &lt;&lt; '6';   break;</code><code>        case rank_7:        std::cout &lt;&lt; '7';   break;</code><code>        case rank_8:        std::cout &lt;&lt; '8';   break;</code><code>        case rank_9:        std::cout &lt;&lt; '9';   break;</code><code>        case rank_10:       std::cout &lt;&lt; 'T';   break;</code><code>        case rank_jack:     std::cout &lt;&lt; 'J';   break;</code><code>        case rank_queen:    std::cout &lt;&lt; 'Q';   break;</code><code>        case rank_king:     std::cout &lt;&lt; 'K';   break;</code><code>        case rank_ace:      std::cout &lt;&lt; 'A';   break;</code><code>        default:</code><code>            std::cout &lt;&lt; '?';</code><code>            break;</code><code>        }</code><code></code><code>        switch (m_suit)</code><code>        {</code><code>        case club:          std::cout &lt;&lt; 'C';   break;</code><code>        case diamond:       std::cout &lt;&lt; 'D';   break;</code><code>        case heart:         std::cout &lt;&lt; 'H';   break;</code><code>        case spade:         std::cout &lt;&lt; 'S';   break;</code><code>        default:</code><code>            std::cout &lt;&lt; '?';</code><code>            break;</code><code>        }</code><code>    }</code><code></code><code>    int value() const</code><code>    {</code><code>        switch (m_rank)</code><code>        {</code><code>        case rank_2:        return 2;</code><code>        case rank_3:        return 3;</code><code>        case rank_4:        return 4;</code><code>        case rank_5:        return 5;</code><code>        case rank_6:        return 6;</code><code>        case rank_7:        return 7;</code><code>        case rank_8:        return 8;</code><code>        case rank_9:        return 9;</code><code>        case rank_10:       return 10;</code><code>        case rank_jack:     return 10;</code><code>        case rank_queen:    return 10;</code><code>        case rank_king:     return 10;</code><code>        case rank_ace:      return 11;</code><code>        default:</code><code>            assert(false &amp;&amp; "should never happen");</code><code>            return 0;</code><code>        }</code><code>    }</code><code>};</code><code></code><code>class Deck</code><code>{</code><code>public:</code><code>    using DeckType = std::array<card, 52="">;</card,></code><code>    using Index = DeckType::size_type;</code><code></code><code>private:</code><code>    DeckType m_deck{};</code><code>    Index m_cardIndex{ 0 };</code><code></code><code>public:</code><code>    Deck()</code><code>    {</code><code>        Index index{ 0 };</code><code></code><code>        for (int suit{ 0 }; suit &lt; Card::max_suits; ++suit)</code><code>        {</code><code>            for (int rank{ 0 }; rank &lt; Card::max_ranks; ++rank)</code><code>            {</code><code>                m_deck[index] = { static_cast<card::rank>(rank), static_cast<card::suit>(suit) };</card::suit></card::rank></code><code>                ++index;</code><code>            }</code><code>        }</code><code>    }</code><code></code><code>    void print() const</code><code>    {</code><code>        for (const auto&amp; card : m_deck)</code><code>        {</code><code>            card.print();</code><code>            std::cout &lt;&lt; ' ';</code><code>        }</code><code></code><code>        std::cout &lt;&lt; '\n';</code><code>    }</code><code></code><code>    void shuffle()</code><code>    {</code><code>        static std::mt19937 mt{ static_cast<std::mt19937::result_type>(std::time(nullptr)) };</std::mt19937::result_type></code><code></code><code>        std::shuffle(m_deck.begin(), m_deck.end(), mt);</code><code>        </code><code>        m_cardIndex = 0;</code><code>    }</code><code></code><code>    const Card&amp; dealCard()</code><code>    {</code><code>        assert(m_cardIndex &lt; m_deck.size());</code><code></code><code>        return m_deck[m_cardIndex++];</code><code>    }</code><code>};</code><code></code><code>class Player</code><code>{</code><code>private:</code><code>    int m_score{};</code><code></code><code>public:</code><code>    int drawCard(Deck&amp; deck)</code><code>    {</code><code>        int value = deck.dealCard().value();</code><code>        m_score += value;</code><code>        return value;</code><code>    }</code><code></code><code>    int score() const</code><code>    {</code><code>        return m_score;</code><code>    }</code><code></code><code>    bool isBust() const</code><code>    {</code><code>        return (m_score &gt; g_maximumScore);</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Deck deck{};</code><code></code><code>    deck.shuffle();</code><code>    deck.print();</code><code></code><code>    Player player{};</code><code>    Player dealer{};</code><code></code><code>    int playerCard { player.drawCard(deck) };</code><code>    std::cout &lt;&lt; "The player drew a card with value " &lt;&lt; playerCard &lt;&lt; " and now has score " &lt;&lt; player.score() &lt;&lt; '\n';</code><code></code><code>    int dealerCard { dealer.drawCard(deck) };</code><code>    std::cout &lt;&lt; "The dealer drew a card with value " &lt;&lt; dealerCard &lt;&lt; " and now has score " &lt;&lt; dealer.score() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre></div><p>e) Why did we write the following statement like this:</p><pre class="language-cpp line-numbers"><code>    int playerCard { player.drawCard(deck) };</code><code>    std::cout &lt;&lt; "The player drew a card with value " &lt;&lt; playerCard &lt;&lt; " and now has score " &lt;&lt; player.score() &lt;&lt; '\n';</code></pre><p>Instead of like this?</p><pre class="language-cpp line-numbers"><code>    std::cout &lt;&lt; "The player drew a card with value " &lt;&lt; player.drawCard(deck) &lt;&lt; " and now has score " &lt;&lt; player.score() &lt;&lt; '\n';</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_17'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_17" style="display:none"><p>C++ does not have many guarantees on the order in which expressions evaluate (see <a href="https://www.learncpp.com/cpp-tutorial/operator-precedence-and-associativity/">5.1 -- Operator precedence and associativity</a> for a reminder). In the latter snippet, either player.drawCard() or player.score() could evaluate first. Normally this wouldn’t matter, but player.drawCard() has the side effect of modifying the score that player.score() returns. If player.score() evaluates first, it will return the player’s score before the card is drawn, which isn’t what we want. In the former snippet, we put the card draw as a separate statement in order to guarantee it executes first, so that player.score() will return the score after the card draw.</p></div><p>f) Almost there! Now, just fix up the remaining program to use the classes you wrote above. Since most of the functions have been moved into the classes, you can jettison them.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_18'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_18" style="display:none"><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <array></array></code><code>#include <cassert></cassert></code><code>#include <ctime></ctime></code><code>#include <iostream></iostream></code><code>#include <random></random></code><code></code><code>// Maximum score before losing.</code><code>constexpr int g_maximumScore{ 21 };</code><code></code><code>// Minimum score that the dealer has to have.</code><code>constexpr int g_minimumDealerScore{ 17 };</code><code></code><code>class Card</code><code>{</code><code>public:</code><code>    enum Suit</code><code>    {</code><code>        club,</code><code>        diamond,</code><code>        heart,</code><code>        spade,</code><code></code><code>        max_suits</code><code>    };</code><code></code><code>    enum Rank</code><code>    {</code><code>        rank_2,</code><code>        rank_3,</code><code>        rank_4,</code><code>        rank_5,</code><code>        rank_6,</code><code>        rank_7,</code><code>        rank_8,</code><code>        rank_9,</code><code>        rank_10,</code><code>        rank_jack,</code><code>        rank_queen,</code><code>        rank_king,</code><code>        rank_ace,</code><code></code><code>        max_ranks</code><code>    };</code><code></code><code>private:</code><code>    Rank m_rank{};</code><code>    Suit m_suit{};</code><code></code><code>public:</code><code>    Card() = default;</code><code></code><code>    Card(Rank rank, Suit suit)</code><code>        : m_rank{ rank }, m_suit{ suit }</code><code>    {</code><code>    }</code><code></code><code>    void print() const</code><code>    {</code><code>        switch (m_rank)</code><code>        {</code><code>        case rank_2:        std::cout &lt;&lt; '2';   break;</code><code>        case rank_3:        std::cout &lt;&lt; '3';   break;</code><code>        case rank_4:        std::cout &lt;&lt; '4';   break;</code><code>        case rank_5:        std::cout &lt;&lt; '5';   break;</code><code>        case rank_6:        std::cout &lt;&lt; '6';   break;</code><code>        case rank_7:        std::cout &lt;&lt; '7';   break;</code><code>        case rank_8:        std::cout &lt;&lt; '8';   break;</code><code>        case rank_9:        std::cout &lt;&lt; '9';   break;</code><code>        case rank_10:       std::cout &lt;&lt; 'T';   break;</code><code>        case rank_jack:     std::cout &lt;&lt; 'J';   break;</code><code>        case rank_queen:    std::cout &lt;&lt; 'Q';   break;</code><code>        case rank_king:     std::cout &lt;&lt; 'K';   break;</code><code>        case rank_ace:      std::cout &lt;&lt; 'A';   break;</code><code>        default:</code><code>            std::cout &lt;&lt; '?';</code><code>            break;</code><code>        }</code><code></code><code>        switch (m_suit)</code><code>        {</code><code>        case club:          std::cout &lt;&lt; 'C';   break;</code><code>        case diamond:       std::cout &lt;&lt; 'D';   break;</code><code>        case heart:         std::cout &lt;&lt; 'H';   break;</code><code>        case spade:         std::cout &lt;&lt; 'S';   break;</code><code>        default:</code><code>            std::cout &lt;&lt; '?';</code><code>            break;</code><code>        }</code><code>    }</code><code></code><code>    int value() const</code><code>    {</code><code>        switch (m_rank)</code><code>        {</code><code>        case rank_2:        return 2;</code><code>        case rank_3:        return 3;</code><code>        case rank_4:        return 4;</code><code>        case rank_5:        return 5;</code><code>        case rank_6:        return 6;</code><code>        case rank_7:        return 7;</code><code>        case rank_8:        return 8;</code><code>        case rank_9:        return 9;</code><code>        case rank_10:       return 10;</code><code>        case rank_jack:     return 10;</code><code>        case rank_queen:    return 10;</code><code>        case rank_king:     return 10;</code><code>        case rank_ace:      return 11;</code><code>        default:</code><code>            assert(false &amp;&amp; "should never happen");</code><code>            return 0;</code><code>        }</code><code>    }</code><code>};</code><code></code><code>class Deck</code><code>{</code><code>public:</code><code>    using DeckType = std::array<card, 52="">;</card,></code><code>    using Index = DeckType::size_type;</code><code></code><code>private:</code><code>    DeckType m_deck{};</code><code>    Index m_cardIndex{ 0 };</code><code></code><code>public:</code><code>    Deck()</code><code>    {</code><code>        Index index{ 0 };</code><code></code><code>        for (int suit{ 0 }; suit &lt; Card::max_suits; ++suit)</code><code>        {</code><code>            for (int rank{ 0 }; rank &lt; Card::max_ranks; ++rank)</code><code>            {</code><code>                m_deck[index] = { static_cast<card::rank>(rank), static_cast<card::suit>(suit) };</card::suit></card::rank></code><code>                ++index;</code><code>            }</code><code>        }</code><code>    }</code><code></code><code>    void print() const</code><code>    {</code><code>        for (const auto&amp; card : m_deck)</code><code>        {</code><code>            card.print();</code><code>            std::cout &lt;&lt; ' ';</code><code>        }</code><code></code><code>        std::cout &lt;&lt; '\n';</code><code>    }</code><code></code><code>    void shuffle()</code><code>    {</code><code>        static std::mt19937 mt{ static_cast<std::mt19937::result_type>(std::time(nullptr)) };</std::mt19937::result_type></code><code></code><code>        std::shuffle(m_deck.begin(), m_deck.end(), mt);</code><code></code><code>        m_cardIndex = 0;</code><code>    }</code><code></code><code>    const Card&amp; dealCard()</code><code>    {</code><code>        assert(m_cardIndex &lt; m_deck.size());</code><code></code><code>        return m_deck[m_cardIndex++];</code><code>    }</code><code>};</code><code></code><code>class Player</code><code>{</code><code>private:</code><code>    int m_score{};</code><code></code><code>public:</code><code>    int drawCard(Deck&amp; deck)</code><code>    {</code><code>        int value = deck.dealCard().value();</code><code>        m_score += value;</code><code>        return value;</code><code>    }</code><code></code><code>    int score() const</code><code>    {</code><code>        return m_score;</code><code>    }</code><code></code><code>    bool isBust() const</code><code>    {</code><code>        return (m_score &gt; g_maximumScore);</code><code>    }</code><code></code><code>};</code><code></code><code>bool playerWantsHit()</code><code>{</code><code>    while (true)</code><code>    {</code><code>        std::cout &lt;&lt; "(h) to hit, or (s) to stand: ";</code><code></code><code>        char ch{};</code><code>        std::cin &gt;&gt; ch;</code><code></code><code>        switch (ch)</code><code>        {</code><code>        case 'h':</code><code>            return true;</code><code>        case 's':</code><code>            return false;</code><code>        }</code><code>    }</code><code>}</code><code></code><code>// Returns true if the player went bust. False otherwise.</code><code>bool playerTurn(Deck&amp; deck, Player&amp; player)</code><code>{</code><code>    while (true)</code><code>    {</code><code>        if (player.isBust())</code><code>        {</code><code>            // This can happen even before the player had a choice if they drew 2</code><code>            // aces.</code><code>            std::cout &lt;&lt; "You busted!\n";</code><code>            return true;</code><code>        }</code><code>        else</code><code>        {</code><code>            if (playerWantsHit())</code><code>            {</code><code>                auto playerCard = player.drawCard(deck);</code><code>                std::cout &lt;&lt; "You were dealt a " &lt;&lt; playerCard &lt;&lt; " and now have " &lt;&lt; player.score() &lt;&lt; '\n';</code><code>            }</code><code>            else</code><code>            {</code><code>                // The player didn't go bust.</code><code>                return false;</code><code>            }</code><code>        }</code><code>    }</code><code>    return false;</code><code>}</code><code></code><code>// Returns true if the dealer went bust. False otherwise.</code><code>bool dealerTurn(Deck&amp; deck, Player&amp; dealer)</code><code>{</code><code>    while (dealer.score() &lt; g_minimumDealerScore)</code><code>    {</code><code>        auto dealerCard { dealer.drawCard(deck) };</code><code>        std::cout &lt;&lt; "The dealer turned up a " &lt;&lt; dealerCard &lt;&lt; " and now has " &lt;&lt; dealer.score() &lt;&lt; '\n';</code><code>    }</code><code></code><code>    if (dealer.isBust())</code><code>    {</code><code>        std::cout &lt;&lt; "The dealer busted!\n";</code><code>        return true;</code><code>    }</code><code>    return false;</code><code>}</code><code></code><code>bool playBlackjack(Deck&amp; deck)</code><code>{</code><code>    Player dealer{};</code><code>    dealer.drawCard(deck);</code><code></code><code>    std::cout &lt;&lt; "The dealer is showing: " &lt;&lt; dealer.score() &lt;&lt; '\n';</code><code></code><code>    Player player{};</code><code>    player.drawCard(deck);</code><code>    player.drawCard(deck);</code><code></code><code>    std::cout &lt;&lt; "You have: " &lt;&lt; player.score() &lt;&lt; '\n';</code><code></code><code>    if (playerTurn(deck, player))</code><code>    {</code><code>        return false;</code><code>    }</code><code></code><code>    if (dealerTurn(deck, dealer))</code><code>    {</code><code>        return true;</code><code>    }</code><code></code><code>    return (player.score() &gt; dealer.score());</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Deck deck{};</code><code></code><code>    deck.shuffle();</code><code></code><code>    if (playBlackjack(deck))</code><code>    {</code><code>        std::cout &lt;&lt; "You win!\n";</code><code>    }</code><code>    else</code><code>    {</code><code>        std::cout &lt;&lt; "You lose!\n";</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">14.1 — Introduction to operator overloading</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-function-overloading/">8.9 -- Introduction to function overloading</a>, you learned about function overloading, which provides a mechanism to create and resolve function calls to multiple functions with the same name, so long as each function has a unique function prototype. This allows you to create variations of a function to work with different data types, without having to think up a unique name for each variant.</p><p>In C++, operators are implemented as functions. By using function overloading on the operator functions, you can define your own versions of the operators that work with different data types (including classes that you’ve written). Using function overloading to overload operators is called <strong>operator overloading</strong>.</p><p>In this chapter, we’ll examine topics related to operator overloading.</p><p><strong>Operators as functions</strong></p><p>Consider the following example:</p><pre class="language-cpp line-numbers"><code>int x { 2 };</code><code>int y { 3 };</code><code>std::cout &lt;&lt; x + y &lt;&lt; '\n';</code></pre><p>The compiler comes with a built-in version of the plus operator (+) for integer operands -- this function adds integers x and y together and returns an integer result. When you see the expression <code>x + y</code>, you can translate this in your head to the function call <code>operator+(x, y)</code> (where operator+ is the name of the function).</p><p>Now consider this similar snippet:</p><pre class="language-cpp line-numbers"><code>double z { 2.0 };</code><code>double w { 3.0 };</code><code>std::cout &lt;&lt; w + z &lt;&lt; '\n';</code></pre><p>The compiler also comes with a built-in version of the plus operator (+) for double operands. Expression w + z becomes function call <code>operator+(w, z)</code>, and function overloading is used to determine that the compiler should be calling the double version of this function instead of the integer version.</p><p>Now consider what happens if we try to add two objects of a user-defined class:</p><pre class="language-cpp line-numbers"><code>Mystring string1 { "Hello, " };</code><code>Mystring string2 { "World!" };</code><code>std::cout &lt;&lt; string1 + string2 &lt;&lt; '\n';</code></pre><p>What would you expect to happen in this case? The intuitive expected result is that the string “Hello, World!” would be printed on the screen. However, because Mystring is a user-defined class, the compiler does not have a built-in version of the plus operator that it can use for Mystring operands. So in this case, it will give us an error. In order to make it work like we want, we’d need to write an overloaded function to tell the compiler how the + operator should work with two operands of type Mystring. We’ll look at how to do this in the next lesson.</p><p><strong>Resolving overloaded operators</strong></p><p>When evaluating an expression containing an operator, the compiler uses the following rules:</p><ul><li>If <em>all</em> of the operands are fundamental data types, the compiler will call a built-in routine if one exists. If one does not exist, the compiler will produce a compiler error.</li><li>If <em>any</em> of the operands are user data types (e.g. one of your classes, or an enum type), the compiler looks to see whether the type has a matching overloaded operator function that it can call. If it can’t find one, it will try to convert one or more of the user-defined type operands into fundamental data types so it can use a matching built-in operator (via an overloaded typecast, which we’ll cover later in this chapter). If that fails, then it will produce a compile error.</li></ul><p><strong>What are the limitations on operator overloading?</strong></p><p>First, almost any existing operator in C++ can be overloaded. The exceptions are: conditional (?:), sizeof, scope (::), member selector (.), member pointer selector (.*), typeid, and the casting operators.</p><p>Second, you can only overload the operators that exist. You can not create new operators or rename existing operators. For example, you could not create an operator ** to do exponents.</p><p>Third, at least one of the operands in an overloaded operator must be a user-defined type. This means you can not overload the plus operator to work with one integer and one double. However, you could overload the plus operator to work with an integer and a Mystring.</p><p>Fourth, it is not possible to change the number of operands an operator supports.</p><p>Finally, all operators keep their default precedence and associativity (regardless of what they’re used for) and this can not be changed.</p><p>Some new programmers attempt to overload the bitwise XOR operator (^) to do exponentiation. However, in C++, operator^ has a lower precedence level than the basic arithmetic operators, which causes expressions to evaluate incorrectly.</p><p>In basic mathematics, exponentiation is resolved before basic arithmetic, so 4 + 3 ^ 2 resolves as 4 + (3 ^ 2) =&gt; 4 + 9 =&gt; 13.<br>However, in C++, the arithmetic operators have higher precedence than operator^, so 4 + 3 ^ 2 resolves as (4 + 3) ^ 2 =&gt; 7 ^ 2 =&gt; 49.</p><p>You’d need to explicitly parenthesize the exponent portion (e.g. 4 + (3 ^ 2)) every time you used it for this to work properly, which isn’t intuitive, and is potentially error-prone.</p><p>Because of this precedence issue, it’s generally a good idea to use operators only in an analogous way to their original intent.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>When overloading operators, it’s best to keep the function of the operators as close to the original intent of the operators as possible.</p></div><p>Furthermore, because operators don’t have descriptive names, it’s not always clear what they are intended to do. For example, operator+ might be a reasonable choice for a string class to do concatenation of strings. But what about operator-? What would you expect that to do? It’s unclear.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>If the meaning of an overloaded operator is not clear and intuitive, use a named function instead.</p></div><p>Within those confines, you will still find plenty of useful functionality to overload for your custom classes! You can overload the + operator to concatenate your user-defined string class, or add two Fraction class objects together. You can overload the &lt;&lt; operator to make it easy to print your class to the screen (or a file). You can overload the equality operator (==) to compare two class objects. This makes operator overloading one of the most useful features in C++ -- simply because it allows you to work with your classes in a more intuitive way.</p><p>In the upcoming lessons, we’ll take a deeper look at overloading different kinds of operators.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">14.2 — Overloading the arithmetic operators using friend functions</h1></header><div class="entry-content" itemprop="articleBody"><p>Some of the most commonly used operators in C++ are the arithmetic operators -- that is, the plus operator (+), minus operator (-), multiplication operator (*), and division operator (/). Note that all of the arithmetic operators are binary operators -- meaning they take two operands -- one on each side of the operator. All four of these operators are overloaded in the exact same way.</p><p>It turns out that there are three different ways to overload operators: the member function way, the friend function way, and the normal function way. In this lesson, we’ll cover the friend function way (because it’s more intuitive for most binary operators). Next lesson, we’ll discuss the normal function way. Finally, in a later lesson in this chapter, we’ll cover the member function way. And, of course, we’ll also summarize when to use each in more detail.</p><br><h3>Overloading operators using friend functions</h3><p>Consider the following trivial class:</p><pre class="language-cpp line-numbers"><code>class Cents</code><code>{</code><code>private:</code><code>	int m_cents {};</code><code></code><code>public:</code><code>	Cents(int cents) : m_cents{ cents } { }</code><code>	int getCents() const { return m_cents; }</code><code>};</code></pre><p>The following example shows how to overload operator plus (+) in order to add two “Cents” objects together:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>	int m_cents {};</code><code></code><code>public:</code><code>	Cents(int cents) : m_cents{ cents } { }</code><code></code><code>	// add Cents + Cents using a friend function</code><code>	friend Cents operator+(const Cents&amp; c1, const Cents&amp; c2);</code><code></code><code>	int getCents() const { return m_cents; }</code><code>};</code><code></code><code>// note: this function is not a member function!</code><code>Cents operator+(const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>	// use the Cents constructor and operator+(int, int)</code><code>	// we can access m_cents directly because this is a friend function</code><code>	return Cents{c1.m_cents + c2.m_cents};</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Cents cents1{ 6 };</code><code>	Cents cents2{ 8 };</code><code>	Cents centsSum{ cents1 + cents2 };</code><code>	std::cout &lt;&lt; "I have " &lt;&lt; centsSum.getCents() &lt;&lt; " cents.\n";</code><code></code><code>	return 0;</code><code>}</code></pre><p>This produces the result:</p><pre>I have 14 cents.
</pre><p>Overloading the plus operator (+) is as simple as declaring a function named operator+, giving it two parameters of the type of the operands we want to add, picking an appropriate return type, and then writing the function.</p><p>In the case of our Cents object, implementing our operator+() function is very simple. First, the parameter types: in this version of operator+, we are going to add two Cents objects together, so our function will take two objects of type Cents. Second, the return type: our operator+ is going to return a result of type Cents, so that’s our return type.</p><p>Finally, implementation: to add two Cents objects together, we really need to add the m_cents member from each Cents object. Because our overloaded operator+() function is a friend of the class, we can access the m_cents member of our parameters directly. Also, because m_cents is an integer, and C++ knows how to add integers together using the built-in version of the plus operator that works with integer operands, we can simply use the + operator to do the adding.</p><p>Overloading the subtraction operator (-) is simple as well:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>	int m_cents {};</code><code></code><code>public:</code><code>	Cents(int cents) : m_cents{ cents } { }</code><code></code><code>	// add Cents + Cents using a friend function</code><code>	friend Cents operator+(const Cents&amp; c1, const Cents&amp; c2);</code><code></code><code>	// subtract Cents - Cents using a friend function</code><code>	friend Cents operator-(const Cents&amp; c1, const Cents&amp; c2);</code><code></code><code>	int getCents() const { return m_cents; }</code><code>};</code><code></code><code>// note: this function is not a member function!</code><code>Cents operator+(const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>	// use the Cents constructor and operator+(int, int)</code><code>	// we can access m_cents directly because this is a friend function</code><code>	return Cents{c1.m_cents + c2.m_cents};</code><code>}</code><code></code><code>// note: this function is not a member function!</code><code>Cents operator-(const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>	// use the Cents constructor and operator-(int, int)</code><code>	// we can access m_cents directly because this is a friend function</code><code>	return Cents(c1.m_cents - c2.m_cents);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Cents cents1{ 6 };</code><code>	Cents cents2{ 2 };</code><code>	Cents centsSum{ cents1 - cents2 };</code><code>	std::cout &lt;&lt; "I have " &lt;&lt; centsSum.getCents() &lt;&lt; " cents.\n";</code><code></code><code>	return 0;</code><code>}</code></pre><p>Overloading the multiplication operator (*) and the division operator (/) is as easy as defining functions for operator* and operator/ respectively.</p><br><h3>Friend functions can be defined inside the class</h3><p>Even though friend functions are not members of the class, they can still be defined inside the class if desired:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>	int m_cents {};</code><code></code><code>public:</code><code>	Cents(int cents) : m_cents{ cents } { }</code><code></code><code>	// add Cents + Cents using a friend function</code><code>        // This function is not considered a member of the class, even though the definition is inside the class</code><code>	friend Cents operator+(const Cents&amp; c1, const Cents&amp; c2)</code><code>	{</code><code>		// use the Cents constructor and operator+(int, int)</code><code>		// we can access m_cents directly because this is a friend function</code><code>		return Cents{c1.m_cents + c2.m_cents};</code><code>	}</code><code></code><code>	int getCents() const { return m_cents; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Cents cents1{ 6 };</code><code>	Cents cents2{ 8 };</code><code>	Cents centsSum{ cents1 + cents2 };</code><code>	std::cout &lt;&lt; "I have " &lt;&lt; centsSum.getCents() &lt;&lt; " cents.\n";</code><code></code><code>	return 0;</code><code>}</code></pre><p>We generally don’t recommend this, as non-trivial function definitions are better kept in a separate .cpp file, outside of the class definition. However, we will use this pattern in future tutorials to keep the examples concise.</p><br><h3>Overloading operators for operands of different types</h3><p>Often it is the case that you want your overloaded operators to work with operands that are different types. For example, if we have Cents(4), we may want to add the integer 6 to this to produce the result Cents(10).</p><p>When C++ evaluates the expression <code>x + y</code>, x becomes the first parameter, and y becomes the second parameter. When x and y have the same type, it does not matter if you add x + y or y + x -- either way, the same version of operator+ gets called. However, when the operands have different types, x + y does not call the same function as y + x.</p><p>For example, <code>Cents(4) + 6</code> would call operator+(Cents, int), and <code>6 + Cents(4)</code> would call operator+(int, Cents). Consequently, whenever we overload binary operators for operands of different types, we actually need to write two functions -- one for each case. Here is an example of that:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>	int m_cents {};</code><code></code><code>public:</code><code>	Cents(int cents) : m_cents{ cents } { }</code><code></code><code>	// add Cents + int using a friend function</code><code>	friend Cents operator+(const Cents&amp; c1, int value);</code><code></code><code>	// add int + Cents using a friend function</code><code>	friend Cents operator+(int value, const Cents&amp; c1);</code><code></code><code></code><code>	int getCents() const { return m_cents; }</code><code>};</code><code></code><code>// note: this function is not a member function!</code><code>Cents operator+(const Cents&amp; c1, int value)</code><code>{</code><code>	// use the Cents constructor and operator+(int, int)</code><code>	// we can access m_cents directly because this is a friend function</code><code>	return { c1.m_cents + value };</code><code>}</code><code></code><code>// note: this function is not a member function!</code><code>Cents operator+(int value, const Cents&amp; c1)</code><code>{</code><code>	// use the Cents constructor and operator+(int, int)</code><code>	// we can access m_cents directly because this is a friend function</code><code>	return { c1.m_cents + value };</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Cents c1{ Cents{ 4 } + 6 };</code><code>	Cents c2{ 6 + Cents{ 4 } };</code><code></code><code>	std::cout &lt;&lt; "I have " &lt;&lt; c1.getCents() &lt;&lt; " cents.\n";</code><code>	std::cout &lt;&lt; "I have " &lt;&lt; c2.getCents() &lt;&lt; " cents.\n";</code><code></code><code>	return 0;</code><code>}</code></pre><p>Note that both overloaded functions have the same implementation -- that’s because they do the same thing, they just take their parameters in a different order.</p><br><h3>Another example</h3><p>Let’s take a look at another example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class MinMax</code><code>{</code><code>private:</code><code>	int m_min {}; // The min value seen so far</code><code>	int m_max {}; // The max value seen so far</code><code></code><code>public:</code><code>	MinMax(int min, int max)</code><code>		: m_min { min }, m_max { max }</code><code>	{ }</code><code></code><code>	int getMin() const { return m_min; }</code><code>	int getMax() const { return m_max; }</code><code></code><code>	friend MinMax operator+(const MinMax&amp; m1, const MinMax&amp; m2);</code><code>	friend MinMax operator+(const MinMax&amp; m, int value);</code><code>	friend MinMax operator+(int value, const MinMax&amp; m);</code><code>};</code><code></code><code>MinMax operator+(const MinMax&amp; m1, const MinMax&amp; m2)</code><code>{</code><code>	// Get the minimum value seen in m1 and m2</code><code>	int min{ m1.m_min &lt; m2.m_min ? m1.m_min : m2.m_min };</code><code></code><code>	// Get the maximum value seen in m1 and m2</code><code>	int max{ m1.m_max &gt; m2.m_max ? m1.m_max : m2.m_max };</code><code></code><code>	return { min, max };</code><code>}</code><code></code><code>MinMax operator+(const MinMax&amp; m, int value)</code><code>{</code><code>	// Get the minimum value seen in m and value</code><code>	int min{ m.m_min &lt; value ? m.m_min : value };</code><code></code><code>	// Get the maximum value seen in m and value</code><code>	int max{ m.m_max &gt; value ? m.m_max : value };</code><code></code><code>	return { min, max };</code><code>}</code><code></code><code>MinMax operator+(int value, const MinMax&amp; m)</code><code>{</code><code>	// call operator+(MinMax, int)</code><code>	return { m + value };</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	MinMax m1{ 10, 15 };</code><code>	MinMax m2{ 8, 11 };</code><code>	MinMax m3{ 3, 12 };</code><code></code><code>	MinMax mFinal{ m1 + m2 + 5 + 8 + m3 + 16 };</code><code></code><code>	std::cout &lt;&lt; "Result: (" &lt;&lt; mFinal.getMin() &lt;&lt; ", " &lt;&lt;</code><code>		mFinal.getMax() &lt;&lt; ")\n";</code><code></code><code>	return 0;</code><code>}</code></pre><p>The MinMax class keeps track of the minimum and maximum values that it has seen so far. We have overloaded the + operator 3 times, so that we can add two MinMax objects together, or add integers to MinMax objects.</p><p>This example produces the result:</p><pre>Result: (3, 16)
</pre><p>which you will note is the minimum and maximum values that we added to mFinal.</p><p>Let’s talk a little bit more about how “MinMax mFinal { m1 + m2 + 5 + 8 + m3 + 16 }” evaluates. Remember that operator+ evaluates from left to right, so m1 + m2 evaluates first. This becomes a call to operator+(m1, m2), which produces the return value MinMax(8, 15). Then MinMax(8, 15) + 5 evaluates next. This becomes a call to operator+(MinMax(8, 15), 5), which produces return value MinMax(5, 15). Then MinMax(5, 15) + 8 evaluates in the same way to produce MinMax(5, 15). Then MinMax(5, 15) + m3 evaluates to produce MinMax(3, 15). And finally, MinMax(3, 15) + 16 evaluates to MinMax(3, 16). This final result is then used to initialize mFinal.</p><p>In other words, this expression evaluates as “MinMax mFinal = (((((m1 + m2) + 5) + 8) + m3) + 16)”, with each successive operation returning a MinMax object that becomes the left-hand operand for the following operator.</p><br><h3>Implementing operators using other operators</h3><p>In the above example, note that we defined operator+(int, MinMax) by calling operator+(MinMax, int) (which produces the same result). This allows us to reduce the implementation of operator+(int, MinMax) to a single line, making our code easier to maintain by minimizing redundancy and making the function simpler to understand.</p><p>It is often possible to define overloaded operators by calling other overloaded operators. You should do so if and when doing so produces simpler code. In cases where the implementation is trivial (e.g. a single line) it may or may not be worth doing this.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>a) Write a class named Fraction that has an integer numerator and denominator member. Write a print() function that prints out the fraction.</p><p>The following code should compile:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    Fraction f1{ 1, 4 };</code><code>    f1.print();</code><code></code><code>    Fraction f2{ 1, 2 };</code><code>    f2.print();</code><code></code><code>    return 0;</code><code>}</code></pre><p>This should print:</p><pre>1/4
1/2
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>	int m_numerator { 0 };</code><code>	int m_denominator { 1 };</code><code></code><code>public:</code><code>	Fraction(int numerator, int denominator=1)</code><code>		: m_numerator{numerator}, m_denominator{denominator}</code><code>	{</code><code>	}</code><code></code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; m_numerator &lt;&lt; '/' &lt;&lt; m_denominator &lt;&lt; '\n';</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Fraction f1{1, 4};</code><code>	f1.print();</code><code>	</code><code>	Fraction f2{1, 2};</code><code>	f2.print();</code><code></code><code>	return 0;</code><code>}</code></pre></div><p>b) Add overloaded multiplication operators to handle multiplication between a Fraction and integer, and between two Fractions. Use the friend function method.</p><p>Hint: To multiply two fractions, first multiply the two numerators together, and then multiply the two denominators together. To multiply a fraction and an integer, multiply the numerator of the fraction by the integer and leave the denominator alone.</p><p>The following code should compile:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    Fraction f1{2, 5};</code><code>    f1.print();</code><code></code><code>    Fraction f2{3, 8};</code><code>    f2.print();</code><code></code><code>    Fraction f3{ f1 * f2 };</code><code>    f3.print();</code><code></code><code>    Fraction f4{ f1 * 2 };</code><code>    f4.print();</code><code></code><code>    Fraction f5{ 2 * f2 };</code><code>    f5.print();</code><code></code><code>    Fraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };</code><code>    f6.print();</code><code></code><code>    return 0;</code><code>}</code></pre><p>This should print:</p><pre>2/5
3/8
6/40
4/5
6/8
6/24
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>	int m_numerator { 0 };</code><code>	int m_denominator { 1 };</code><code></code><code>public:</code><code>	Fraction(int numerator, int denominator=1)</code><code>		: m_numerator{numerator}, m_denominator{denominator}</code><code>	{</code><code>	}</code><code></code><code>	// We don't want to pass by value, because copying is slow.</code><code>	// We can't and shouldn't pass by non-const reference, because then</code><code>	// our functions wouldn't work with r-values.</code><code>	friend Fraction operator*(const Fraction&amp; f1, const Fraction&amp; f2);</code><code>	friend Fraction operator*(const Fraction&amp; f1, int value);</code><code>	friend Fraction operator*(int value, const Fraction&amp; f1);</code><code></code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; m_numerator &lt;&lt; '/' &lt;&lt; m_denominator &lt;&lt; '\n';</code><code>	}</code><code>};</code><code></code><code>Fraction operator*(const Fraction&amp; f1, const Fraction&amp; f2)</code><code>{</code><code>	return { f1.m_numerator * f2.m_numerator, f1.m_denominator * f2.m_denominator };</code><code>}</code><code></code><code>Fraction operator*(const Fraction&amp; f1, int value)</code><code>{</code><code>	return { f1.m_numerator * value, f1.m_denominator };</code><code>}</code><code></code><code>Fraction operator*(int value, const Fraction&amp; f1)</code><code>{</code><code>	return { f1 * value };</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Fraction f1{2, 5};</code><code>	f1.print();</code><code></code><code>	Fraction f2{3, 8};</code><code>	f2.print();</code><code></code><code>	Fraction f3{ f1 * f2 };</code><code>	f3.print();</code><code></code><code>	Fraction f4{ f1 * 2 };</code><code>	f4.print();</code><code></code><code>	Fraction f5{ 2 * f2 };</code><code>	f5.print();</code><code></code><code>	Fraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };</code><code>	f6.print();</code><code></code><code>	return 0;</code><code>}</code></pre></div><p>c) Why does the program continue to work correctly if we remove the operators for integer multiplication from the previous solution?</p><pre class="language-cpp line-numbers"><code>// We can remove these operators, and the program continues to work</code><code>Fraction operator*(const Fraction&amp; f1, int value);</code><code>Fraction operator*(int value, const Fraction&amp; f1);</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>We still have</p><pre class="language-cpp line-numbers"><code>Fraction operator*(const Fraction&amp; f1, const Fraction&amp; f2)</code></pre><p>When we multiply a fraction with an integer, for example</p><pre class="language-cpp line-numbers"><code>Fraction f5{ 2 * f2 };</code></pre><p>The <code>Fraction(int, int)</code> constructor will be used to construct a new <code>Fraction</code> from 2. This new <code>Fraction</code> is then multiplied by <code>f2</code> using the <code>Fraction * Fraction</code> operator.</p><p>The additional conversion from 2 to a <code>Fraction</code> slows down the program, making it slower than the implementation with overloaded operators for integer multiplication.</p></div><p>d) If we remove the <code>const</code> from the <code>Fraction * Fraction</code> operator, the following line from the <code>main</code> function no longer works. Why?</p><pre class="language-cpp line-numbers"><code>// The non-const multiplication operator looks like this</code><code>Fraction operator*(Fraction&amp; f1, Fraction&amp; f2)</code><code></code><code>// This doesn't work anymore</code><code>Fraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><p>We’re multiplying temporary <code>Fraction</code> objects, but non-const references cannot bind to temporaries.</p></div><p>e) Extra credit: the fraction 2/4 is the same as 1/2, but 2/4 is not reduced to the lowest terms. We can reduce any given fraction to lowest terms by finding the greatest common divisor (GCD) between the numerator and denominator, and then dividing both the numerator and denominator by the GCD.</p><p>std::gcd was added to the standard library in C++17 (in the &lt;numeric&gt; header).</p><p>If you’re on an older compiler, you can use this function to find the GCD:</p><pre class="language-cpp line-numbers"><code>#include <cmath> // for std::abs</cmath></code><code></code><code>int gcd(int a, int b) {</code><code>    return (b == 0) ? std::abs(a) : gcd(b, a % b);</code><code>}</code></pre><p>Write a member function named reduce() that reduces your fraction. Make sure all fractions are properly reduced.</p><p>The following should compile:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    Fraction f1{2, 5};</code><code>    f1.print();</code><code></code><code>    Fraction f2{3, 8};</code><code>    f2.print();</code><code></code><code>    Fraction f3{ f1 * f2 };</code><code>    f3.print();</code><code></code><code>    Fraction f4{ f1 * 2 };</code><code>    f4.print();</code><code></code><code>    Fraction f5{ 2 * f2 };</code><code>    f5.print();</code><code></code><code>    Fraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };</code><code>    f6.print();</code><code></code><code>    Fraction f7{0, 6};</code><code>    f7.print();</code><code></code><code>    return 0;</code><code>}</code></pre><p>And produce the result:</p><pre>2/5
3/8
3/20
4/5
3/4
1/4
0/1
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <numeric> // for std::gcd</numeric></code><code></code><code>// This version of the Fraction class auto-reduces fractions</code><code>class Fraction</code><code>{</code><code>private:</code><code>	int m_numerator{ 0 };</code><code>	int m_denominator{ 1 };</code><code></code><code>public:</code><code>	Fraction(int numerator, int denominator = 1)</code><code>		: m_numerator{ numerator }, m_denominator{ denominator }</code><code>	{</code><code>		// We put reduce() in the constructor to ensure any fractions we make get reduced!</code><code>		// Since all of the overloaded operators create new Fractions, we can guarantee this will get called here</code><code>		reduce();</code><code>	}</code><code></code><code>	void reduce()</code><code>	{</code><code>		int gcd{ std::gcd(m_numerator, m_denominator) };</code><code>		if (gcd)</code><code>		{</code><code>			m_numerator /= gcd;</code><code>			m_denominator /= gcd;</code><code>		}</code><code>	}</code><code></code><code>	friend Fraction operator*(const Fraction&amp; f1, const Fraction&amp; f2);</code><code>	friend Fraction operator*(const Fraction&amp; f1, int value);</code><code>	friend Fraction operator*(int value, const Fraction&amp; f1);</code><code></code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; m_numerator &lt;&lt; '/' &lt;&lt; m_denominator &lt;&lt; '\n';</code><code>	}</code><code>};</code><code></code><code>Fraction operator*(const Fraction&amp; f1, const Fraction&amp; f2)</code><code>{</code><code>	return { f1.m_numerator * f2.m_numerator, f1.m_denominator * f2.m_denominator };</code><code>}</code><code></code><code>Fraction operator*(const Fraction&amp; f1, int value)</code><code>{</code><code>	return { f1.m_numerator * value, f1.m_denominator };</code><code>}</code><code></code><code>Fraction operator*(int value, const Fraction&amp; f1)</code><code>{</code><code>	return { f1 * value };</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Fraction f1{ 2, 5 };</code><code>	f1.print();</code><code></code><code>	Fraction f2{ 3, 8 };</code><code>	f2.print();</code><code></code><code>	Fraction f3{ f1 * f2 };</code><code>	f3.print();</code><code></code><code>	Fraction f4{ f1 * 2 };</code><code>	f4.print();</code><code></code><code>	Fraction f5{ 2 * f2 };</code><code>	f5.print();</code><code></code><code>	Fraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };</code><code>	f6.print();</code><code></code><code>	Fraction f7{ 0, 6 };</code><code>	f7.print();</code><code></code><code>	return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">14.3 — Overloading operators using normal functions</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson, we overloaded operator+ as a friend function:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code> </code><code>class Cents</code><code>{</code><code>private:</code><code>  int m_cents{};</code><code></code><code>public:</code><code>  Cents(int cents)</code><code>    : m_cents{ cents }</code><code>  {}</code><code></code><code>  // add Cents + Cents using a friend function</code><code>  friend Cents operator+(const Cents&amp; c1, const Cents&amp; c2);</code><code></code><code>  int getCents() const { return m_cents; }</code><code>};</code><code> </code><code>// note: this function is not a member function!</code><code>Cents operator+(const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>  // use the Cents constructor and operator+(int, int)</code><code>  // we can access m_cents directly because this is a friend function</code><code>  return { c1.m_cents + c2.m_cents };</code><code>}</code><code> </code><code>int main()</code><code>{</code><code>  Cents cents1{ 6 };</code><code>  Cents cents2{ 8 };</code><code>  Cents centsSum{ cents1 + cents2 };</code><code>  std::cout &lt;&lt; "I have " &lt;&lt; centsSum.getCents() &lt;&lt; " cents.\n";</code><code></code><code>  return 0;</code><code>}</code></pre><p>Using a friend function to overload an operator is convenient because it gives you direct access to the internal members of the classes you’re operating on. In the initial Cents example above, our friend function version of operator+ accessed member variable m_cents directly.</p><p>However, if you don’t need that access, you can write your overloaded operators as normal functions. Note that the Cents class above contains an access function (getCents()) that allows us to get at m_cents without having to have direct access to private members. Because of this, we can write our overloaded operator+ as a non-friend:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>  int m_cents{};</code><code></code><code>public:</code><code>  Cents(int cents)</code><code>    : m_cents{ cents }</code><code>  {}</code><code></code><code>  int getCents() const { return m_cents; }</code><code>};</code><code></code><code>// note: this function is not a member function nor a friend function!</code><code>Cents operator+(const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>  // use the Cents constructor and operator+(int, int)</code><code>  // we don't need direct access to private members here</code><code>  return Cents{ c1.getCents() + c2.getCents() };</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  Cents cents1{ 6 };</code><code>  Cents cents2{ 8 };</code><code>  Cents centsSum{ cents1 + cents2 };</code><code>  std::cout &lt;&lt; "I have " &lt;&lt; centsSum.getCents() &lt;&lt; " cents.\n";</code><code></code><code>  return 0;</code><code>}</code></pre><p>Because the normal and friend functions work almost identically (they just have different levels of access to private members), we generally won’t differentiate them. The one difference is that the friend function declaration inside the class serves as a prototype as well. With the normal function version, you’ll have to provide your own function prototype.</p><p>Cents.h:</p><pre class="language-cpp line-numbers"><code>#ifndef CENTS_H</code><code>#define CENTS_H</code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>  int m_cents{};</code><code></code><code>public:</code><code>  Cents(int cents)</code><code>    : m_cents{ cents }</code><code>  {}</code><code>  </code><code>  int getCents() const { return m_cents; }</code><code>};</code><code></code><code>// Need to explicitly provide prototype for operator+ so uses of operator+ in other files know this overload exists</code><code>Cents operator+(const Cents&amp; c1, const Cents&amp; c2);</code><code></code><code>#endif</code></pre><p>Cents.cpp:</p><pre class="language-cpp line-numbers"><code>#include "Cents.h"</code><code></code><code>// note: this function is not a member function nor a friend function!</code><code>Cents operator+(const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>  // use the Cents constructor and operator+(int, int)</code><code>  // we don't need direct access to private members here</code><code>  return { c1.getCents() + c2.getCents() };</code><code>}</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include "Cents.h"</code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>  Cents cents1{ 6 };</code><code>  Cents cents2{ 8 };</code><code>  Cents centsSum{ cents1 + cents2 }; // without the prototype in Cents.h, this would fail to compile</code><code>  std::cout &lt;&lt; "I have " &lt;&lt; centsSum.getCents() &lt;&lt; " cents.\n";</code><code></code><code>  return 0;</code><code>}</code></pre><p>In general, a normal function should be preferred over a friend function if it’s possible to do so with the existing member functions available (the less functions touching your classes’s internals, the better). However, don’t add additional access functions just to overload an operator as a normal function instead of a friend function!</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Prefer overloading operators as normal functions instead of friends if it’s possible to do so without adding additional functions.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">14.4 — Overloading the I/O operators</h1></header><div class="entry-content" itemprop="articleBody"><p>For classes that have multiple member variables, printing each of the individual variables on the screen can get tiresome fast. For example, consider the following class:</p><pre class="language-cpp line-numbers"><code>class Point</code><code>{</code><code>private:</code><code>    double m_x{};</code><code>    double m_y{};</code><code>    double m_z{};</code><code></code><code>public:</code><code>    Point(double x=0.0, double y=0.0, double z=0.0)</code><code>      : m_x{x}, m_y{y}, m_z{z}</code><code>    {</code><code>    }</code><code></code><code>    double getX() const { return m_x; }</code><code>    double getY() const { return m_y; }</code><code>    double getZ() const { return m_z; }</code><code>};</code></pre><p>If you wanted to print an instance of this class to the screen, you’d have to do something like this:</p><pre class="language-cpp line-numbers"><code>Point point{5.0, 6.0, 7.0};</code><code></code><code>std::cout &lt;&lt; "Point(" &lt;&lt; point.getX() &lt;&lt; ", " &lt;&lt;</code><code>    point.getY() &lt;&lt; ", " &lt;&lt;</code><code>    point.getZ() &lt;&lt; ')';</code></pre><p>Of course, it makes more sense to do this as a reusable function. And in previous examples, you’ve seen us create print() functions that work like this:</p><pre class="language-cpp line-numbers"><code>class Point</code><code>{</code><code>private:</code><code>    double m_x{};</code><code>    double m_y{};</code><code>    double m_z{};</code><code></code><code>public:</code><code>    Point(double x=0.0, double y=0.0, double z=0.0)</code><code>      : m_x{x}, m_y{y}, m_z{z}</code><code>    {</code><code>    }</code><code></code><code>    double getX() const { return m_x; }</code><code>    double getY() const { return m_y; }</code><code>    double getZ() const { return m_z; }</code><code></code><code>    void print() const</code><code>    {</code><code>        std::cout &lt;&lt; "Point(" &lt;&lt; m_x &lt;&lt; ", " &lt;&lt; m_y &lt;&lt; ", " &lt;&lt; m_z &lt;&lt; ')';</code><code>    }</code><code>};</code></pre><p>While this is much better, it still has some downsides. Because print() returns void, it can’t be called in the middle of an output statement. Instead, you have to do this:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    const Point point{5.0, 6.0, 7.0};</code><code></code><code>    std::cout &lt;&lt; "My point is: ";</code><code>    point.print();</code><code>    std::cout &lt;&lt; " in Cartesian space.\n";</code><code>}</code></pre><p>It would be much easier if you could simply type:</p><pre class="language-cpp line-numbers"><code>Point point{5.0, 6.0, 7.0};</code><code>cout &lt;&lt; "My point is: " &lt;&lt; point &lt;&lt; " in Cartesian space.\n";</code></pre><p>and get the same result. There would be no breaking up output across multiple statements, and no having to remember what you named the print function.</p><p>Fortunately, by overloading the &lt;&lt; operator, you can!</p><p><strong>Overloading operator&lt;&lt;</strong></p><p>Overloading operator&lt;&lt; is similar to overloading operator+ (they are both binary operators), except that the parameter types are different.</p><p>Consider the expression <code>std::cout &lt;&lt; point</code>. If the operator is &lt;&lt;, what are the operands? The left operand is the std::cout object, and the right operand is your Point class object. std::cout is actually an object of type std::ostream. Therefore, our overloaded function will look like this:</p><pre class="language-cpp line-numbers"><code>// std::ostream is the type for object std::cout</code><code>friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point);</code></pre><p>Implementation of operator&lt;&lt; for our Point class is fairly straightforward -- because C++ already knows how to output doubles using operator&lt;&lt;, and our members are all doubles, we can simply use operator&lt;&lt; to output the member variables of our Point. Here is the above Point class with the overloaded operator&lt;&lt;.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Point</code><code>{</code><code>private:</code><code>    double m_x{};</code><code>    double m_y{};</code><code>    double m_z{};</code><code></code><code>public:</code><code>    Point(double x=0.0, double y=0.0, double z=0.0)</code><code>      : m_x{x}, m_y{y}, m_z{z}</code><code>    {</code><code>    }</code><code></code><code>    friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point);</code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point)</code><code>{</code><code>    // Since operator&lt;&lt; is a friend of the Point class, we can access Point's members directly.</code><code>    out &lt;&lt; "Point(" &lt;&lt; point.m_x &lt;&lt; ", " &lt;&lt; point.m_y &lt;&lt; ", " &lt;&lt; point.m_z &lt;&lt; ')'; // actual output done here</code><code></code><code>    return out; // return std::ostream so we can chain calls to operator&lt;&lt;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    const Point point1{2.0, 3.0, 4.0};</code><code></code><code>    std::cout &lt;&lt; point1 &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This is pretty straightforward -- note how similar our output line is to the line in the print() function we wrote previously. The most notable difference is that std::cout has become parameter out (which will be a reference to std::cout when the function is called).</p><p>The trickiest part here is the return type. With the arithmetic operators, we calculated and returned a single answer by value (because we were creating and returning a new result). However, if you try to return std::ostream by value, you’ll get a compiler error. This happens because std::ostream specifically disallows being copied.</p><p>In this case, we return the left hand parameter as a reference. This not only prevents a copy of std::ostream from being made, it also allows us to “chain” output commands together, such as <code>std::cout &lt;&lt; point &lt;&lt; std::endl;</code></p><p>You might have initially thought that since operator&lt;&lt; doesn’t return a value to the caller, we should define the function as returning void. But consider what would happen if our operator&lt;&lt; returned void. When the compiler evaluates <code>std::cout &lt;&lt; point &lt;&lt; '\n'</code>, due to the precedence/associativity rules, it evaluates this expression as <code>(std::cout &lt;&lt; point) &lt;&lt; '\n';</code>. <code>std::cout &lt;&lt; point</code> would call our void-returning overloaded operator&lt;&lt; function, which returns void. Then the partially evaluated expression becomes: <code>void &lt;&lt; '\n';</code>, which makes no sense!</p><p>By returning the out parameter as the return type instead, <code>(std::cout&lt;&lt; point)</code> returns std::cout. Then our partially evaluated expression becomes: <code>std::cout &lt;&lt; '\n';</code>, which then gets evaluated itself!</p><p>Any time we want our overloaded binary operators to be chainable in such a manner, the left operand should be returned (by reference). Returning the left-hand parameter by reference is okay in this case -- since the left-hand parameter was passed in by the calling function, it must still exist when the called function returns. Therefore, we don’t have to worry about referencing something that will go out of scope and get destroyed when the operator returns.</p><p>Just to prove it works, consider the following example, which uses the Point class with the overloaded operator&lt;&lt; we wrote above:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Point</code><code>{</code><code>private:</code><code>    double m_x{};</code><code>    double m_y{};</code><code>    double m_z{};</code><code></code><code>public:</code><code>    Point(double x=0.0, double y=0.0, double z=0.0)</code><code>      : m_x{x}, m_y{y}, m_z{z}</code><code>    {</code><code>    }</code><code></code><code>    friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point);</code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point)</code><code>{</code><code>    // Since operator&lt;&lt; is a friend of the Point class, we can access Point's members directly.</code><code>    out &lt;&lt; "Point(" &lt;&lt; point.m_x &lt;&lt; ", " &lt;&lt; point.m_y &lt;&lt; ", " &lt;&lt; point.m_z &lt;&lt; ')';</code><code></code><code>    return out;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Point point1{2.0, 3.5, 4.0};</code><code>    Point point2{6.0, 7.5, 8.0};</code><code></code><code>    std::cout &lt;&lt; point1 &lt;&lt; ' ' &lt;&lt; point2 &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This produces the following result:</p><pre>Point(2, 3.5, 4) Point(6, 7.5, 8)
</pre><p><strong>Overloading operator&gt;&gt;</strong></p><p>It is also possible to overload the input operator. This is done in a manner analogous to overloading the output operator. The key thing you need to know is that std::cin is an object of type std::istream. Here’s our Point class with an overloaded operator&gt;&gt;:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Point</code><code>{</code><code>private:</code><code>    double m_x{};</code><code>    double m_y{};</code><code>    double m_z{};</code><code></code><code>public:</code><code>    Point(double x=0.0, double y=0.0, double z=0.0)</code><code>      : m_x{x}, m_y{y}, m_z{z}</code><code>    {</code><code>    }</code><code></code><code>    friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point);</code><code>    friend std::istream&amp; operator&gt;&gt; (std::istream&amp; in, Point&amp; point);</code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point)</code><code>{</code><code>    // Since operator&lt;&lt; is a friend of the Point class, we can access Point's members directly.</code><code>    out &lt;&lt; "Point(" &lt;&lt; point.m_x &lt;&lt; ", " &lt;&lt; point.m_y &lt;&lt; ", " &lt;&lt; point.m_z &lt;&lt; ')';</code><code></code><code>    return out;</code><code>}</code><code></code><code>std::istream&amp; operator&gt;&gt; (std::istream&amp; in, Point&amp; point)</code><code>{</code><code>    // Since operator&gt;&gt; is a friend of the Point class, we can access Point's members directly.</code><code>    // note that parameter point must be non-const so we can modify the class members with the input values</code><code>    in &gt;&gt; point.m_x;</code><code>    in &gt;&gt; point.m_y;</code><code>    in &gt;&gt; point.m_z;</code><code></code><code>    return in;</code><code>}</code></pre><p>Here’s a sample program using both the overloaded operator&lt;&lt; and operator&gt;&gt;:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a point: ";</code><code></code><code>    Point point;</code><code>    std::cin &gt;&gt; point;</code><code></code><code>    std::cout &lt;&lt; "You entered: " &lt;&lt; point &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Assuming the user enters <code>3.0 4.5 7.26</code> as input, the program produces the following result:</p><pre>You entered: Point(3, 4.5, 7.26)
</pre><p><strong>Conclusion</strong></p><p>Overloading operator&lt;&lt; and operator&gt;&gt; make it extremely easy to output your class to screen and accept user input from the console.</p><p><strong>Quiz time</strong></p><p>Take the Fraction class we wrote in the previous quiz (listed below) and add an overloaded operator&lt;&lt; and operator&gt;&gt; to it.</p><p>The following program should compile:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	Fraction f1;</code><code>	std::cout &lt;&lt; "Enter fraction 1: ";</code><code>	std::cin &gt;&gt; f1;</code><code></code><code>	Fraction f2;</code><code>	std::cout &lt;&lt; "Enter fraction 2: ";</code><code>	std::cin &gt;&gt; f2;</code><code></code><code>	std::cout &lt;&lt; f1 &lt;&lt; " * " &lt;&lt; f2 &lt;&lt; " is " &lt;&lt; f1 * f2 &lt;&lt; '\n'; // note: The result of f1 * f2 is an r-value</code><code></code><code>	return 0;</code><code>}</code></pre><p>And produce the result:</p><pre>Enter fraction 1: 2/3
Enter fraction 2: 3/8
2/3 * 3/8 is 1/4
</pre><p>Here’s the Fraction class:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <numeric> // for std::gcd</numeric></code><code> </code><code>class Fraction</code><code>{</code><code>private:</code><code>	int m_numerator{};</code><code>	int m_denominator{};</code><code> </code><code>public:</code><code>	Fraction(int numerator=0, int denominator=1):</code><code>		m_numerator{numerator}, m_denominator{denominator}</code><code>	{</code><code>		// We put reduce() in the constructor to ensure any new fractions we make get reduced!</code><code>		// Any fractions that are overwritten will need to be re-reduced</code><code>		reduce();</code><code>	}</code><code></code><code>	void reduce()</code><code>	{</code><code>		int gcd{ std::gcd(m_numerator, m_denominator) };</code><code>		if (gcd)</code><code>		{</code><code>			m_numerator /= gcd;</code><code>			m_denominator /= gcd;</code><code>		}</code><code>	}</code><code> </code><code>	friend Fraction operator*(const Fraction&amp; f1, const Fraction&amp; f2);</code><code>	friend Fraction operator*(const Fraction&amp; f1, int value);</code><code>	friend Fraction operator*(int value, const Fraction&amp; f1);</code><code> </code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; m_numerator &lt;&lt; '/' &lt;&lt; m_denominator &lt;&lt; '\n';</code><code>	}</code><code>};</code><code> </code><code>Fraction operator*(const Fraction&amp; f1, const Fraction&amp; f2)</code><code>{</code><code>	return Fraction(f1.m_numerator * f2.m_numerator, f1.m_denominator * f2.m_denominator);</code><code>}</code><code> </code><code>Fraction operator*(const Fraction&amp; f1, int value)</code><code>{</code><code>	return Fraction(f1.m_numerator * value, f1.m_denominator);</code><code>}</code><code> </code><code>Fraction operator*(int value, const Fraction&amp; f1)</code><code>{</code><code>	return Fraction(f1.m_numerator * value, f1.m_denominator);</code><code>}</code></pre><p>If you’re on a pre-C++17 compiler, you can replace std::gcd with this function:</p><pre class="language-cpp line-numbers"><code>#include <cmath></cmath></code><code> </code><code>int gcd(int a, int b) {</code><code>    return (b == 0) ? std::abs(a) : gcd(b, a % b);</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <limits></limits></code><code>#include <numeric> // for std::gcd</numeric></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>	int m_numerator{ 0 };</code><code>	int m_denominator{ 1 };</code><code></code><code>public:</code><code>	Fraction(int numerator=0, int denominator = 1) :</code><code>		m_numerator{ numerator }, m_denominator{ denominator }</code><code>	{</code><code>		// We put reduce() in the constructor to ensure any new fractions we make get reduced!</code><code>		// Any fractions that are overwritten will need to be re-reduced</code><code>		reduce();</code><code>	}</code><code></code><code>	void reduce()</code><code>	{</code><code>		int gcd{ std::gcd(m_numerator, m_denominator) };</code><code>		if (gcd)</code><code>		{</code><code>			m_numerator /= gcd;</code><code>			m_denominator /= gcd;</code><code>		}</code><code>	}</code><code></code><code>	friend Fraction operator*(const Fraction&amp; f1, const Fraction&amp; f2);</code><code>	friend Fraction operator*(const Fraction&amp; f1, int value);</code><code>	friend Fraction operator*(int value, const Fraction&amp; f1);</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);</code><code>	friend std::istream&amp; operator&gt;&gt;(std::istream&amp; in, Fraction&amp; f1);</code><code></code><code>	void print()</code><code>	{</code><code>		std::cout &lt;&lt; m_numerator &lt;&lt; '/' &lt;&lt; m_denominator &lt;&lt; '\n';</code><code>	}</code><code>};</code><code></code><code>Fraction operator*(const Fraction&amp; f1, const Fraction&amp; f2)</code><code>{</code><code>	return { f1.m_numerator * f2.m_numerator, f1.m_denominator * f2.m_denominator };</code><code>}</code><code></code><code>Fraction operator*(const Fraction&amp; f1, int value)</code><code>{</code><code>	return { f1.m_numerator * value, f1.m_denominator };</code><code>}</code><code></code><code>Fraction operator*(int value, const Fraction&amp; f1)</code><code>{</code><code>	return { f1.m_numerator * value, f1.m_denominator };</code><code>}</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)</code><code>{</code><code>	out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>	return out;</code><code>}</code><code></code><code>std::istream&amp; operator&gt;&gt;(std::istream&amp; in, Fraction&amp; f1)</code><code>{</code><code>	// Overwrite the values of f1</code><code>	in &gt;&gt; f1.m_numerator;</code><code></code><code>	// Ignore the '/' separator</code><code>	in.ignore(std::numeric_limits<std::streamsize>::max(), '/');</std::streamsize></code><code></code><code>	in &gt;&gt; f1.m_denominator;</code><code></code><code>	// Since we overwrite the existing f1, we need to reduce again</code><code>	f1.reduce();</code><code></code><code>	return in;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Fraction f1;</code><code>	std::cout &lt;&lt; "Enter fraction 1: ";</code><code>	std::cin &gt;&gt; f1;</code><code></code><code>	Fraction f2;</code><code>	std::cout &lt;&lt; "Enter fraction 2: ";</code><code>	std::cin &gt;&gt; f2;</code><code></code><code>	std::cout &lt;&lt; f1 &lt;&lt; " * " &lt;&lt; f2 &lt;&lt; " is " &lt;&lt; f1 * f2 &lt;&lt; '\n'; // note: The result of f1 * f2 is an r-value</code><code></code><code>	return 0;</code><code>}</code></pre></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">14.5 — Overloading operators using member functions</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/overloading-the-arithmetic-operators-using-friend-functions/">14.2 -- Overloading the arithmetic operators using friend functions</a>, you learned how to overload the arithmetic operators using friend functions. You also learned you can overload operators as normal functions. Many operators can be overloaded in a different way: as a member function.</p><p>Overloading operators using a member function is very similar to overloading operators using a friend function. When overloading an operator using a member function:</p><ul><li>The overloaded operator must be added as a member function of the left operand.</li><li>The left operand becomes the implicit *this object</li><li>All other operands become function parameters.</li></ul><p>As a reminder, here’s how we overloaded operator+ using a friend function:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>    int m_cents {};</code><code></code><code>public:</code><code>    Cents(int cents)</code><code>        : m_cents { cents } { }</code><code></code><code>    // Overload Cents + int</code><code>    friend Cents operator+(const Cents ¢s, int value);</code><code></code><code>    int getCents() const { return m_cents; }</code><code>};</code><code></code><code>// note: this function is not a member function!</code><code>Cents operator+(const Cents ¢s, int value)</code><code>{</code><code>    return Cents(cents.m_cents + value);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Cents cents1 { 6 };</code><code>	Cents cents2 { cents1 + 2 };</code><code>	std::cout &lt;&lt; "I have " &lt;&lt; cents2.getCents() &lt;&lt; " cents.\n";</code><code> </code><code>	return 0;</code><code>}</code></pre><p>Converting a friend overloaded operator to a member overloaded operator is easy:</p><ol><li>The overloaded operator is defined as a member instead of a friend (Cents::operator+ instead of friend operator+)</li><li>The left parameter is removed, because that parameter now becomes the implicit *this object.</li><li>Inside the function body, all references to the left parameter can be removed (e.g. cents.m_cents becomes m_cents, which implicitly references the *this object).</li></ol><p>Now, the same operator overloaded using the member function method:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>    int m_cents {};</code><code></code><code>public:</code><code>    Cents(int cents)</code><code>        : m_cents { cents } { }</code><code></code><code>    // Overload Cents + int</code><code>    Cents operator+ (int value);</code><code></code><code>    int getCents() const { return m_cents; }</code><code>};</code><code></code><code>// note: this function is a member function!</code><code>// the cents parameter in the friend version is now the implicit *this parameter</code><code>Cents Cents::operator+ (int value)</code><code>{</code><code>    return Cents { m_cents + value };</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Cents cents1 { 6 };</code><code>	Cents cents2 { cents1 + 2 };</code><code>	std::cout &lt;&lt; "I have " &lt;&lt; cents2.getCents() &lt;&lt; " cents.\n";</code><code> </code><code>	return 0;</code><code>}</code></pre><p>Note that the usage of the operator does not change (in both cases, <code>cents1 + 2</code>), we’ve simply defined the function differently. Our two-parameter friend function becomes a one-parameter member function, with the leftmost parameter in the friend version (cents) becoming the implicit *this parameter in the member function version.</p><p>Let’s take a closer look at how the expression <code>cents1 + 2</code> evaluates.</p><p>In the friend function version, the expression <code>cents1 + 2</code> becomes function call operator+(cents1, 2). Note that there are two function parameters. This is straightforward.</p><p>In the member function version, the expression <code>cents1 + 2</code> becomes function call <code>cents1.operator+(2)</code>. Note that there is now only one explicit function parameter, and cents1 has become an object prefix. However, in lesson <a href="https://www.learncpp.com/cpp-tutorial/the-hidden-this-pointer/">13.10 -- The hidden “this” pointer</a>, we mentioned that the compiler implicitly converts an object prefix into a hidden leftmost parameter named *this. So in actuality, <code>cents1.operator+(2)</code> becomes <code>operator+(¢s1, 2)</code>, which is almost identical to the friend version.</p><p>Both cases produce the same result, just in slightly different ways.</p><p>So if we can overload an operator as a friend or a member, which should we use? In order to answer that question, there’s a few more things you’ll need to know.</p><p><strong>Not everything can be overloaded as a friend function</strong></p><p>The assignment (=), subscript ([]), function call (()), and member selection (-&gt;) operators must be overloaded as member functions, because the language requires them to be.</p><p><strong>Not everything can be overloaded as a member function</strong></p><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/overloading-the-io-operators/">14.4 -- Overloading the I/O operators</a>, we overloaded operator&lt;&lt; for our Point class using the friend function method. Here’s a reminder of how we did that:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code> </code><code>class Point</code><code>{</code><code>private:</code><code>    double m_x {}, m_y {}, m_z {};</code><code> </code><code>public:</code><code>    Point(double x=0.0, double y=0.0, double z=0.0)</code><code>        : m_x { x }, m_y { y }, m_z { z }</code><code>    {</code><code>    }</code><code> </code><code>    friend std::ostream&amp; operator&lt;&lt; (std::ostream &amp;out, const Point &amp;point);</code><code>};</code><code> </code><code>std::ostream&amp; operator&lt;&lt; (std::ostream &amp;out, const Point &amp;point)</code><code>{</code><code>    // Since operator&lt;&lt; is a friend of the Point class, we can access Point's members directly.</code><code>    out &lt;&lt; "Point(" &lt;&lt; point.m_x &lt;&lt; ", " &lt;&lt; point.m_y &lt;&lt; ", " &lt;&lt; point.m_z &lt;&lt; ")";</code><code> </code><code>    return out;</code><code>}</code><code> </code><code>int main()</code><code>{</code><code>    Point point1 { 2.0, 3.0, 4.0 };</code><code> </code><code>    std::cout &lt;&lt; point1;</code><code> </code><code>    return 0;</code><code>}</code></pre><p>However, we are not able to overload operator&lt;&lt; as a member function. Why not? Because the overloaded operator must be added as a member of the left operand. In this case, the left operand is an object of type std::ostream. std::ostream is fixed as part of the standard library. We can’t modify the class declaration to add the overload as a member function of std::ostream.</p><p>This necessitates that operator&lt;&lt; be overloaded as a normal function (preferred) or a friend.</p><p>Similarly, although we can overload operator+(Cents, int) as a member function (as we did above), we can’t overload operator+(int, Cents) as a member function, because int isn’t a class we can add members to.</p><p>Typically, we won’t be able to use a member overload if the left operand is either not a class (e.g. int), or it is a class that we can’t modify (e.g. std::ostream).</p><p><strong>When to use a normal, friend, or member function overload</strong></p><p>In most cases, the language leaves it up to you to determine whether you want to use the normal/friend or member function version of the overload. However, one of the two is usually a better choice than the other.</p><p>When dealing with binary operators that don’t modify the left operand (e.g. operator+), the normal or friend function version is typically preferred, because it works for all parameter types (even when the left operand isn’t a class object, or is a class that is not modifiable). The normal or friend function version has the added benefit of “symmetry”, as all operands become explicit parameters (instead of the left operand becoming *this and the right operand becoming an explicit parameter).</p><p>When dealing with binary operators that do modify the left operand (e.g. operator+=), the member function version is typically preferred. In these cases, the leftmost operand will always be a class type, and having the object being modified become the one pointed to by *this is natural. Because the rightmost operand becomes an explicit parameter, there’s no confusion over who is getting modified and who is getting evaluated.</p><p>Unary operators are usually overloaded as member functions as well, since the member version has no parameters.</p><p>The following rules of thumb can help you determine which form is best for a given situation:</p><ul><li>If you’re overloading assignment (=), subscript ([]), function call (()), or member selection (-&gt;), do so as a member function.</li><li>If you’re overloading a unary operator, do so as a member function.</li><li>If you’re overloading a binary operator that does not modify its left operand (e.g. operator+), do so as a normal function (preferred) or friend function.</li><li>If you’re overloading a binary operator that modifies its left operand, but you can’t add members to the class definition of the left operand (e.g. operator&lt;&lt;, which has a left operand of type ostream), do so as a normal function (preferred) or friend function.</li><li>If you’re overloading a binary operator that modifies its left operand (e.g. operator+=), and you can modify the definition of the left operand, do so as a member function.</li></ul></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">14.6 — Overloading unary operators +, -, and !</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>Overloading unary operators</strong></p><p>Unlike the operators you’ve seen so far, the positive (+), negative (-) and logical not (!) operators all are unary operators, which means they only operate on one operand. Because they only operate on the object they are applied to, typically unary operator overloads are implemented as member functions. All three operands are implemented in an identical manner.</p><p>Let’s take a look at how we’d implement operator- on the Cents class we used in a previous example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>    int m_cents {};</code><code> </code><code>public:</code><code>    Cents(int cents): m_cents{cents} {}</code><code> </code><code>    // Overload -Cents as a member function</code><code>    Cents operator-() const;</code><code></code><code>    int getCents() const { return m_cents; }</code><code>};</code><code> </code><code>// note: this function is a member function!</code><code>Cents Cents::operator-() const</code><code>{</code><code>    return -m_cents; // since return type is a Cents, this does an implicit conversion from int to Cents using the Cents(int) constructor</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    const Cents nickle{ 5 };</code><code>    std::cout &lt;&lt; "A nickle of debt is worth " &lt;&lt; (-nickle).getCents() &lt;&lt; " cents\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This should be straightforward. Our overloaded negative operator (-) is a unary operator implemented as a member function, so it takes no parameters (it operates on the *this object). It returns a Cents object that is the negation of the original Cents value. Because operator- does not modify the Cents object, we can (and should) make it a const function (so it can be called on const Cents objects).</p><p>Note that there’s no confusion between the negative operator- and the minus operator- since they have a different number of parameters.</p><p>Here’s another example. The ! operator is the logical negation operator -- if an expression evaluates to “true”, operator! will return false, and vice-versa. We commonly see this applied to boolean variables to test whether they are true or not:</p><pre class="language-cpp line-numbers"><code>if (!isHappy)</code><code>    std::cout &lt;&lt; "I am not happy!\n";</code><code>else</code><code>    std::cout &lt;&lt; "I am so happy!\n";</code></pre><p>For integers, 0 evaluates to false, and anything else to true, so operator! as applied to integers will return true for an integer value of 0 and false otherwise.</p><p>Extending the concept, we can say that operator! should evaluate to true if the state of the object is “false”, “zero”, or whatever the default initialization state is.</p><p>The following example shows an overload of both operator- and operator! for a user-defined Point class:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Point</code><code>{</code><code>private:</code><code>    double m_x {};</code><code>    double m_y {};</code><code>    double m_z {};</code><code> </code><code>public:</code><code>    Point(double x=0.0, double y=0.0, double z=0.0):</code><code>        m_x{x}, m_y{y}, m_z{z}</code><code>    {</code><code>    }</code><code> </code><code>    // Convert a Point into its negative equivalent</code><code>    Point operator- () const;</code><code></code><code>    // Return true if the point is set at the origin</code><code>    bool operator! () const;</code><code> </code><code>    double getX() const { return m_x; }</code><code>    double getY() const { return m_y; }</code><code>    double getZ() const { return m_z; }</code><code>};</code><code></code><code>// Convert a Point into its negative equivalent </code><code>Point Point::operator- () const</code><code>{</code><code>    return { -m_x, -m_y, -m_z };</code><code>}</code><code></code><code>// Return true if the point is set at the origin, false otherwise</code><code>bool Point::operator! () const</code><code>{</code><code>    return (m_x == 0.0 &amp;&amp; m_y == 0.0 &amp;&amp; m_z == 0.0);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Point point{}; // use default constructor to set to (0.0, 0.0, 0.0)</code><code></code><code>    if (!point)</code><code>        std::cout &lt;&lt; "point is set at the origin.\n";</code><code>    else</code><code>        std::cout &lt;&lt; "point is not set at the origin.\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>The overloaded operator! for this class returns the Boolean value “true” if the Point is set to the default value at coordinate (0.0, 0.0, 0.0). Thus, the above code produces the result:</p><pre>point is set at the origin.
</pre><p><strong>Quiz time</strong></p><ol start="1"><li>Implement overloaded operator+ for the Point class.</li></ol><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>Here’s the obvious solution:</p><pre class="language-cpp line-numbers"><code>Point Point::operator+ () const</code><code>{</code><code>    return { m_x, m_y, m_z };</code><code>}</code></pre><p>But because the Point we’re returning is exactly the same one we’re operating on, the following also works:</p><pre class="language-cpp line-numbers"><code>Point Point::operator+ () const</code><code>{</code><code>    return *this;</code><code>}</code></pre><p>Note that we’re returning a copy by value rather than a const reference here. This is because users of this function will probably expect the returned object to be modifiable.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">14.7 — Overloading the comparison operators</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/relational-operators-and-floating-point-comparisons/">5.6 -- Relational operators and floating point comparisons</a>, we discussed the six comparison operators. Overloading these comparison operators is comparatively simple (see what I did there?), as they follow the same patterns as we’ve seen in overloading other operators.</p><p>Because the comparison operators are all binary operators that do not modify their left operands, we will make our overloaded comparison operators friend functions.</p><p>Here’s an example Car class with an overloaded operator== and operator!=.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class Car</code><code>{</code><code>private:</code><code>    std::string m_make;</code><code>    std::string m_model;</code><code></code><code>public:</code><code>    Car(std::string_view make, std::string_view model)</code><code>        : m_make{ make }, m_model{ model }</code><code>    {</code><code>    }</code><code></code><code>    friend bool operator== (const Car&amp; c1, const Car&amp; c2);</code><code>    friend bool operator!= (const Car&amp; c1, const Car&amp; c2);</code><code>};</code><code></code><code>bool operator== (const Car&amp; c1, const Car&amp; c2)</code><code>{</code><code>    return (c1.m_make == c2.m_make &amp;&amp;</code><code>            c1.m_model == c2.m_model);</code><code>}</code><code></code><code>bool operator!= (const Car&amp; c1, const Car&amp; c2)</code><code>{</code><code>    return (c1.m_make != c2.m_make ||</code><code>            c1.m_model != c2.m_model);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Car corolla{ "Toyota", "Corolla" };</code><code>    Car camry{ "Toyota", "Camry" };</code><code></code><code>    if (corolla == camry)</code><code>        std::cout &lt;&lt; "a Corolla and Camry are the same.\n";</code><code></code><code>    if (corolla != camry)</code><code>        std::cout &lt;&lt; "a Corolla and Camry are not the same.\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>The code here should be straightforward.</p><p>What about operator&lt; and operator&gt;? What would it mean for a Car to be greater or less than another Car? We typically don’t think about cars this way. Since the results of operator&lt; and operator&gt; would not be immediately intuitive, it may be better to leave these operators undefined.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Only define overloaded operators that make intuitive sense for your class.</p></div><p>However, there is one common exception to the above recommendation. What if we wanted to sort a list of Cars? In such a case, we might want to overload the comparison operators to return the member (or members) you’re most likely to want to sort on. For example, an overloaded operator&lt; for Cars might sort based on make and model alphabetically.</p><p>Some of the container classes in the standard library (classes that hold sets of other classes) require an overloaded operator&lt; so they can keep the elements sorted.</p><p>Here’s a different example overloading all 6 logical comparison operators:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>    int m_cents;</code><code> </code><code>public:</code><code>    Cents(int cents)</code><code>	: m_cents{ cents }</code><code>	{}</code><code> </code><code>    friend bool operator== (const Cents&amp; c1, const Cents&amp; c2);</code><code>    friend bool operator!= (const Cents&amp; c1, const Cents&amp; c2);</code><code></code><code>    friend bool operator&lt; (const Cents&amp; c1, const Cents&amp; c2);</code><code>    friend bool operator&gt; (const Cents&amp; c1, const Cents&amp; c2);</code><code></code><code>    friend bool operator&lt;= (const Cents&amp; c1, const Cents&amp; c2);</code><code>    friend bool operator&gt;= (const Cents&amp; c1, const Cents&amp; c2);</code><code>};</code><code> </code><code>bool operator== (const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>    return c1.m_cents == c2.m_cents;</code><code>}</code><code></code><code>bool operator!= (const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>    return c1.m_cents != c2.m_cents;</code><code>}</code><code></code><code>bool operator&lt; (const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>    return c1.m_cents &lt; c2.m_cents;</code><code>}</code><code></code><code>bool operator&gt; (const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>    return c1.m_cents &gt; c2.m_cents;</code><code>}</code><code></code><code>bool operator&lt;= (const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>    return c1.m_cents &lt;= c2.m_cents;</code><code>}</code><code></code><code>bool operator&gt;= (const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>    return c1.m_cents &gt;= c2.m_cents;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Cents dime{ 10 };</code><code>    Cents nickel{ 5 };</code><code> </code><code>    if (nickel &gt; dime)</code><code>        std::cout &lt;&lt; "a nickel is greater than a dime.\n";</code><code>    if (nickel &gt;= dime)</code><code>        std::cout &lt;&lt; "a nickel is greater than or equal to a dime.\n";</code><code>    if (nickel &lt; dime)</code><code>        std::cout &lt;&lt; "a dime is greater than a nickel.\n";</code><code>    if (nickel &lt;= dime)</code><code>        std::cout &lt;&lt; "a dime is greater than or equal to a nickel.\n";</code><code>    if (nickel == dime)</code><code>        std::cout &lt;&lt; "a dime is equal to a nickel.\n";</code><code>    if (nickel != dime)</code><code>        std::cout &lt;&lt; "a dime is not equal to a nickel.\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This is also pretty straightforward.</p><br><h3>Minimizing comparative redundancy</h3><p>In the example above, note how similar the implementation of each of the overloaded comparison operators are. Overloaded comparison operators tend to have a high degree of redundancy, and the more complex the implementation, the more redundancy there will be.</p><p>Fortunately, many of the comparison operators can be implemented using the other comparison operators:</p><ul><li>operator!= can be implemented as !(operator==)</li><li>operator&gt; can be implemented as operator&lt; with the order of the parameters flipped</li><li>operator&gt;= can be implemented as !(operator&lt;)</li><li>operator&lt;= can be implemented as !(operator&gt;)</li></ul><p>This means that we only need to implement logic for operator== and operator&lt;, and then the other four comparison operators can be defined in terms of those two! Here’s an updated Cents example illustrating this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>    int m_cents;</code><code></code><code>public:</code><code>    Cents(int cents)</code><code>        : m_cents{ cents }</code><code>    {}</code><code></code><code>    friend bool operator== (const Cents&amp; c1, const Cents&amp; c2);</code><code>    friend bool operator!= (const Cents&amp; c1, const Cents&amp; c2);</code><code></code><code>    friend bool operator&lt; (const Cents&amp; c1, const Cents&amp; c2);</code><code>    friend bool operator&gt; (const Cents&amp; c1, const Cents&amp; c2);</code><code></code><code>    friend bool operator&lt;= (const Cents&amp; c1, const Cents&amp; c2);</code><code>    friend bool operator&gt;= (const Cents&amp; c1, const Cents&amp; c2);</code><code></code><code>};</code><code></code><code>bool operator== (const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>    return c1.m_cents == c2.m_cents;</code><code>}</code><code></code><code>bool operator!= (const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>    return !(operator==(c1, c2));</code><code>}</code><code></code><code>bool operator&lt; (const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>    return c1.m_cents &lt; c2.m_cents;</code><code>}</code><code></code><code>bool operator&gt; (const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>    return operator&lt;(c2, c1);</code><code>}</code><code></code><code>bool operator&lt;= (const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>    return !(operator&gt;(c1, c2));</code><code>}</code><code></code><code>bool operator&gt;= (const Cents&amp; c1, const Cents&amp; c2)</code><code>{</code><code>    return !(operator&lt;(c1, c2));</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Cents dime{ 10 };</code><code>    Cents nickel{ 5 };</code><code></code><code>    if (nickel &gt; dime)</code><code>        std::cout &lt;&lt; "a nickel is greater than a dime.\n";</code><code>    if (nickel &gt;= dime)</code><code>        std::cout &lt;&lt; "a nickel is greater than or equal to a dime.\n";</code><code>    if (nickel &lt; dime)</code><code>        std::cout &lt;&lt; "a dime is greater than a nickel.\n";</code><code>    if (nickel &lt;= dime)</code><code>        std::cout &lt;&lt; "a dime is greater than or equal to a nickel.\n";</code><code>    if (nickel == dime)</code><code>        std::cout &lt;&lt; "a dime is equal to a nickel.\n";</code><code>    if (nickel != dime)</code><code>        std::cout &lt;&lt; "a dime is not equal to a nickel.\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This way, if we ever need to change something, we only need to update operator== and operator&lt; instead of all six comparison operators!</p><p><strong>Quiz time</strong></p><ol start="1"><li>Add the six comparison operators to the Fraction class so that the following program compiles:</li></ol><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <numeric> // for std::gcd</numeric></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>	int m_numerator{};</code><code>	int m_denominator{};</code><code></code><code>public:</code><code>	Fraction(int numerator = 0, int denominator = 1) :</code><code>		m_numerator{ numerator }, m_denominator{ denominator }</code><code>	{</code><code>		// We put reduce() in the constructor to ensure any new fractions we make get reduced!</code><code>		// Any fractions that are overwritten will need to be re-reduced</code><code>		reduce();</code><code>	}</code><code></code><code>	void reduce()</code><code>	{</code><code>		int gcd{ std::gcd(m_numerator, m_denominator) };</code><code>		if (gcd)</code><code>		{</code><code>			m_numerator /= gcd;</code><code>			m_denominator /= gcd;</code><code>		}</code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);</code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)</code><code>{</code><code>	out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>	return out;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Fraction f1{ 3, 2 };</code><code>	Fraction f2{ 5, 8 };</code><code></code><code>	std::cout &lt;&lt; f1 &lt;&lt; ((f1 == f2) ? " == " : " not == ") &lt;&lt; f2 &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; f1 &lt;&lt; ((f1 != f2) ? " != " : " not != ") &lt;&lt; f2 &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; f1 &lt;&lt; ((f1 &lt; f2) ? " &lt; " : " not &lt; ") &lt;&lt; f2 &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; f1 &lt;&lt; ((f1 &gt; f2) ? " &gt; " : " not &gt; ") &lt;&lt; f2 &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; f1 &lt;&lt; ((f1 &lt;= f2) ? " &lt;= " : " not &lt;= ") &lt;&lt; f2 &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; f1 &lt;&lt; ((f1 &gt;= f2) ? " &gt;= " : " not &gt;= ") &lt;&lt; f2 &lt;&lt; '\n';</code><code>	return 0;</code><code>}</code></pre><p>If you’re on a pre-C++17 compiler, you can replace std::gcd with this function:</p><pre class="language-cpp line-numbers"><code>#include <cmath></cmath></code><code> </code><code>int gcd(int a, int b) {</code><code>    return (b == 0) ? std::abs(a) : gcd(b, a % b);</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <numeric> // for std::gcd</numeric></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>	int m_numerator{};</code><code>	int m_denominator{};</code><code></code><code>public:</code><code>	Fraction(int numerator = 0, int denominator = 1) :</code><code>		m_numerator{ numerator }, m_denominator{ denominator }</code><code>	{</code><code>		// We put reduce() in the constructor to ensure any new fractions we make get reduced!</code><code>		// Any fractions that are overwritten will need to be re-reduced</code><code>		reduce();</code><code>	}</code><code></code><code>	void reduce()</code><code>	{</code><code>		int gcd{ std::gcd(m_numerator, m_denominator) };</code><code>		if (gcd)</code><code>		{</code><code>			m_numerator /= gcd;</code><code>			m_denominator /= gcd;</code><code>		}</code><code>	}</code><code></code><code>	friend bool operator== (const Fraction&amp; f1, const Fraction&amp; f2);</code><code>	friend bool operator!= (const Fraction&amp; f1, const Fraction&amp; f2);</code><code></code><code>	friend bool operator&lt; (const Fraction&amp; f1, const Fraction&amp; f2);</code><code>	friend bool operator&gt; (const Fraction&amp; f1, const Fraction&amp; f2);</code><code></code><code>	friend bool operator&lt;= (const Fraction&amp; f1, const Fraction&amp; f2);</code><code>	friend bool operator&gt;= (const Fraction&amp; f1, const Fraction&amp; f2);</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);</code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)</code><code>{</code><code>	out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>	return out;</code><code>}</code><code></code><code>bool operator== (const Fraction&amp; f1, const Fraction&amp; f2)</code><code>{</code><code>	return (f1.m_numerator == f2.m_numerator) &amp;&amp; (f1.m_denominator == f2.m_denominator);</code><code>}</code><code></code><code>bool operator!= (const Fraction&amp; f1, const Fraction&amp; f2)</code><code>{</code><code>	return !(operator==(f1, f2));</code><code>}</code><code></code><code>bool operator&lt; (const Fraction&amp; f1, const Fraction&amp; f2)</code><code>{</code><code>	return (f1.m_numerator * f2.m_denominator &lt; f2.m_numerator * f1.m_denominator);</code><code>}</code><code></code><code>bool operator&gt; (const Fraction&amp; f1, const Fraction&amp; f2)</code><code>{</code><code>	return operator&lt;(f2, f1);</code><code>}</code><code></code><code>bool operator&lt;= (const Fraction&amp; f1, const Fraction&amp; f2)</code><code>{</code><code>	return !(operator&gt;(f1, f2));</code><code>}</code><code></code><code>bool operator&gt;= (const Fraction&amp; f1, const Fraction&amp; f2)</code><code>{</code><code>	return !(operator&lt;(f1, f2));</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Fraction f1{ 3, 2 };</code><code>	Fraction f2{ 5, 8 };</code><code></code><code>	std::cout &lt;&lt; f1 &lt;&lt; ((f1 == f2) ? " == " : " not == ") &lt;&lt; f2 &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; f1 &lt;&lt; ((f1 != f2) ? " != " : " not != ") &lt;&lt; f2 &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; f1 &lt;&lt; ((f1 &lt; f2) ? " &lt; " : " not &lt; ") &lt;&lt; f2 &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; f1 &lt;&lt; ((f1 &gt; f2) ? " &gt; " : " not &gt; ") &lt;&lt; f2 &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; f1 &lt;&lt; ((f1 &lt;= f2) ? " &lt;= " : " not &lt;= ") &lt;&lt; f2 &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; f1 &lt;&lt; ((f1 &gt;= f2) ? " &gt;= " : " not &gt;= ") &lt;&lt; f2 &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre></div><ol start="2"><li>Add an overloaded operator&lt;&lt; and operator&lt; to the Car class at the top of the lesson so that the following program compiles:</li></ol><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <vector></vector></code><code></code><code>int main()</code><code>{</code><code>  std::vector<car> cars{</car></code><code>    { "Toyota", "Corolla" },</code><code>    { "Honda", "Accord" },</code><code>    { "Toyota", "Camry" },</code><code>    { "Honda", "Civic" }</code><code>  };</code><code></code><code>  std::sort(cars.begin(), cars.end()); // requires an overloaded operator&lt;</code><code></code><code>  for (const auto&amp; car : cars)</code><code>    std::cout &lt;&lt; car &lt;&lt; '\n'; // requires an overloaded operator&lt;&lt;</code><code></code><code>  return 0;</code><code>}</code></pre><p>This program should produce the following output:</p><pre>(Honda, Accord)
(Honda, Civic)
(Toyota, Camry)
(Toyota, Corolla)
</pre><p>If you need a refresher on std::sort, we talk about it in lesson <a href="https://www.learncpp.com/cpp-tutorial/sorting-an-array-using-selection-sort/">11.4 -- Sorting an array using selection sort</a>.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code>#include <vector></vector></code><code></code><code>class Car</code><code>{</code><code>private:</code><code>  std::string m_make;</code><code>  std::string m_model;</code><code></code><code>public:</code><code>  Car(std::string_view make, std::string_view model)</code><code>      : m_make{ make }, m_model{ model }</code><code>  {</code><code>  }</code><code></code><code>  friend bool operator==(const Car&amp; c1, const Car&amp; c2);</code><code>  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Car&amp; c)</code><code>  {</code><code>    out &lt;&lt; '(' &lt;&lt; c.m_make &lt;&lt; ", " &lt;&lt; c.m_model &lt;&lt; ')';</code><code>    return out;</code><code>  }</code><code></code><code>  // h/t to reader Olivier for this version of the function</code><code>  friend bool operator&lt;(const Car&amp; c1, const Car&amp; c2)</code><code>  {</code><code>    if (c1.m_make == c2.m_make) // If the car is the same make...</code><code>      return c1.m_model &lt; c2.m_model; // then compare the model</code><code>    else</code><code>      return c1.m_make &lt; c2.m_make; // otherwise compare the makes</code><code>  }</code><code>};</code><code></code><code>bool operator==(const Car&amp; c1, const Car&amp; c2)</code><code>{</code><code>  return (c1.m_make == c2.m_make &amp;&amp;</code><code>          c1.m_model == c2.m_model);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  std::vector<car> cars{</car></code><code>    { "Toyota", "Corolla" },</code><code>    { "Honda", "Accord" },</code><code>    { "Toyota", "Camry" },</code><code>    { "Honda", "Civic" }</code><code>  };</code><code></code><code>  std::sort(cars.begin(), cars.end()); // requires an overloaded Car::operator&lt;</code><code></code><code>  for (const auto&amp; car : cars)</code><code>    std::cout &lt;&lt; car &lt;&lt; '\n'; // requires an overloaded Car::operator&lt;&lt;</code><code></code><code>  return 0;</code><code>}</code></pre></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">14.8 — Overloading the increment and decrement operators</h1></header><div class="entry-content" itemprop="articleBody"><p>Overloading the increment (<code>++</code>) and decrement (<code>--</code>) operators is pretty straightforward, with one small exception. There are actually two versions of the increment and decrement operators: a prefix increment and decrement (e.g. <code>++x; --y;</code>) and a postfix increment and decrement (e.g. <code>x++; y--;</code>).</p><p>Because the increment and decrement operators are both unary operators and they modify their operands, they’re best overloaded as member functions. We’ll tackle the prefix versions first because they’re the most straightforward.</p><p><strong>Overloading prefix increment and decrement</strong></p><p>Prefix increment and decrement are overloaded exactly the same as any normal unary operator. We’ll do this one by example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Digit</code><code>{</code><code>private:</code><code>    int m_digit;</code><code>public:</code><code>    Digit(int digit=0)</code><code>        : m_digit{digit}</code><code>    {</code><code>    }</code><code></code><code>    Digit&amp; operator++();</code><code>    Digit&amp; operator--();</code><code></code><code>    friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Digit&amp; d);</code><code>};</code><code></code><code>Digit&amp; Digit::operator++()</code><code>{</code><code>    // If our number is already at 9, wrap around to 0</code><code>    if (m_digit == 9)</code><code>        m_digit = 0;</code><code>    // otherwise just increment to next number</code><code>    else</code><code>        ++m_digit;</code><code></code><code>    return *this;</code><code>}</code><code></code><code>Digit&amp; Digit::operator--()</code><code>{</code><code>    // If our number is already at 0, wrap around to 9</code><code>    if (m_digit == 0)</code><code>        m_digit = 9;</code><code>    // otherwise just decrement to next number</code><code>    else</code><code>        --m_digit;</code><code></code><code>    return *this;</code><code>}</code><code></code><code>std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Digit&amp; d)</code><code>{</code><code>	out &lt;&lt; d.m_digit;</code><code>	return out;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Digit digit(8);</code><code></code><code>    std::cout &lt;&lt; digit;</code><code>    std::cout &lt;&lt; ++digit;</code><code>    std::cout &lt;&lt; ++digit;</code><code>    std::cout &lt;&lt; --digit;</code><code>    std::cout &lt;&lt; --digit;</code><code></code><code>    return 0;</code><code>}</code></pre><p>Our Digit class holds a number between 0 and 9. We’ve overloaded increment and decrement so they increment/decrement the digit, wrapping around if the digit is incremented/decremented out range.</p><p>This example prints:</p><pre>89098
</pre><p>Note that we return *this. The overloaded increment and decrement operators return the current implicit object so multiple operators can be “chained” together.</p><p><strong>Overloading postfix increment and decrement</strong></p><p>Normally, functions can be overloaded when they have the same name but a different number and/or different type of parameters. However, consider the case of the prefix and postfix increment and decrement operators. Both have the same name (eg. operator++), are unary, and take one parameter of the same type. So how it is possible to differentiate the two when overloading?</p><p>The C++ language specification has a special case that provides the answer: the compiler looks to see if the overloaded operator has an int parameter. If the overloaded operator has an int parameter, the operator is a postfix overload. If the overloaded operator has no parameter, the operator is a prefix overload.</p><p>Here is the above Digit class with both prefix and postfix overloads:</p><pre class="language-cpp line-numbers"><code>class Digit</code><code>{</code><code>private:</code><code>    int m_digit;</code><code>public:</code><code>    Digit(int digit=0)</code><code>        : m_digit{digit}</code><code>    {</code><code>    }</code><code></code><code>    Digit&amp; operator++(); // prefix has no parameter</code><code>    Digit&amp; operator--(); // prefix has no parameter</code><code></code><code>    Digit operator++(int); // postfix has an int parameter</code><code>    Digit operator--(int); // postfix has an int parameter</code><code></code><code>    friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Digit&amp; d);</code><code>};</code><code></code><code>// No parameter means this is prefix operator++</code><code>Digit&amp; Digit::operator++()</code><code>{</code><code>    // If our number is already at 9, wrap around to 0</code><code>    if (m_digit == 9)</code><code>        m_digit = 0;</code><code>    // otherwise just increment to next number</code><code>    else</code><code>        ++m_digit;</code><code></code><code>    return *this;</code><code>}</code><code></code><code>// No parameter means this is prefix operator--</code><code>Digit&amp; Digit::operator--()</code><code>{</code><code>    // If our number is already at 0, wrap around to 9</code><code>    if (m_digit == 0)</code><code>        m_digit = 9;</code><code>    // otherwise just decrement to next number</code><code>    else</code><code>        --m_digit;</code><code></code><code>    return *this;</code><code>}</code><code></code><code>// int parameter means this is postfix operator++</code><code>Digit Digit::operator++(int)</code><code>{</code><code>    // Create a temporary variable with our current digit</code><code>    Digit temp{*this};</code><code></code><code>    // Use prefix operator to increment this digit</code><code>    ++(*this); // apply operator</code><code></code><code>    // return temporary result</code><code>    return temp; // return saved state</code><code>}</code><code></code><code>// int parameter means this is postfix operator--</code><code>Digit Digit::operator--(int)</code><code>{</code><code>    // Create a temporary variable with our current digit</code><code>    Digit temp{*this};</code><code></code><code>    // Use prefix operator to decrement this digit</code><code>    --(*this); // apply operator</code><code></code><code>    // return temporary result</code><code>    return temp; // return saved state</code><code>}</code><code></code><code>std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Digit&amp; d)</code><code>{</code><code>	out &lt;&lt; d.m_digit;</code><code>	return out;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Digit digit(5);</code><code></code><code>    std::cout &lt;&lt; digit;</code><code>    std::cout &lt;&lt; ++digit; // calls Digit::operator++();</code><code>    std::cout &lt;&lt; digit++; // calls Digit::operator++(int);</code><code>    std::cout &lt;&lt; digit;</code><code>    std::cout &lt;&lt; --digit; // calls Digit::operator--();</code><code>    std::cout &lt;&lt; digit--; // calls Digit::operator--(int);</code><code>    std::cout &lt;&lt; digit;</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints</p><pre>5667665
</pre><p>There are a few interesting things going on here. First, note that we’ve distinguished the prefix from the postfix operators by providing an integer dummy parameter on the postfix version. Second, because the dummy parameter is not used in the function implementation, we have not even given it a name. This tells the compiler to treat this variable as a placeholder, which means it won’t warn us that we declared a variable but never used it.</p><p>Third, note that the prefix and postfix operators do the same job -- they both increment or decrement the object. The difference between the two is in the value they return. The overloaded prefix operators return the object after it has been incremented or decremented. Consequently, overloading these is fairly straightforward. We simply increment or decrement our member variables, and then return *this.</p><p>The postfix operators, on the other hand, need to return the state of the object <em>before</em> it is incremented or decremented. This leads to a bit of a conundrum -- if we increment or decrement the object, we won’t be able to return the state of the object before it was incremented or decremented. On the other hand, if we return the state of the object before we increment or decrement it, the increment or decrement will never be called.</p><p>The typical way this problem is solved is to use a temporary variable that holds the value of the object before it is incremented or decremented. Then the object itself can be incremented or decremented. And finally, the temporary variable is returned to the caller. In this way, the caller receives a copy of the object before it was incremented or decremented, but the object itself is incremented or decremented. Note that this means the return value of the overloaded operator must be a non-reference, because we can’t return a reference to a local variable that will be destroyed when the function exits. Also note that this means the postfix operators are typically less efficient than the prefix operators because of the added overhead of instantiating a temporary variable and returning by value instead of reference.</p><p>Finally, note that we’ve written the post-increment and post-decrement in such a way that it calls the pre-increment and pre-decrement to do most of the work. This cuts down on duplicate code, and makes our class easier to modify in the future.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">14.9 — Overloading the subscript operator</h1></header><div class="entry-content" itemprop="articleBody"><p>When working with arrays, we typically use the subscript operator ([]) to index specific elements of an array:</p><pre class="language-cpp line-numbers"><code>myArray[0] = 7; // put the value 7 in the first element of the array</code></pre><p>However, consider the following <code>IntList</code> class, which has a member variable that is an array:</p><pre class="language-cpp line-numbers"><code>class IntList</code><code>{</code><code>private:</code><code>    int m_list[10]{};</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    IntList list{};</code><code>    // how do we access elements from m_list?</code><code>    return 0;</code><code>}</code></pre><p>Because the m_list member variable is private, we can not access it directly from variable list. This means we have no way to directly get or set values in the m_list array. So how do we get or put elements into our list?</p><p>Without operator overloading, the typical method would be to create access functions:</p><pre class="language-cpp line-numbers"><code>class IntList</code><code>{</code><code>private:</code><code>    int m_list[10]{};</code><code></code><code>public:</code><code>    void setItem(int index, int value) { m_list[index] = value; }</code><code>    int getItem(int index) const { return m_list[index]; }</code><code>};</code></pre><p>While this works, it’s not particularly user friendly. Consider the following example:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    IntList list{};</code><code>    list.setItem(2, 3);</code><code></code><code>    return 0;</code><code>}</code></pre><p>Are we setting element 2 to the value 3, or element 3 to the value 2? Without seeing the definition of <code>setItem()</code>, it’s simply not clear.</p><p>You could also just return the entire list and use operator[] to access the element:</p><pre class="language-cpp line-numbers"><code>class IntList</code><code>{</code><code>private:</code><code>    int m_list[10]{};</code><code></code><code>public:</code><code>    int* getList() { return m_list; }</code><code>};</code></pre><p>While this also works, it’s syntactically odd:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    IntList list{};</code><code>    list.getList()[2] = 3;</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>Overloading operator[]</h3><p>However, a better solution in this case is to overload the subscript operator ([]) to allow access to the elements of m_list. The subscript operator is one of the operators that must be overloaded as a member function. An overloaded operator[] function will always take one parameter: the subscript that the user places between the hard braces. In our IntList case, we expect the user to pass in an integer index, and we’ll return an integer value back as a result.</p><pre class="language-cpp line-numbers"><code>class IntList</code><code>{</code><code>private:</code><code>    int m_list[10]{};</code><code></code><code>public:</code><code>    int&amp; operator[] (int index);</code><code>};</code><code></code><code>int&amp; IntList::operator[] (int index)</code><code>{</code><code>    return m_list[index];</code><code>}</code></pre><p>Now, whenever we use the subscript operator ([]) on an object of our class, the compiler will return the corresponding element from the m_list member variable! This allows us to both get and set values of m_list directly:</p><pre class="language-cpp line-numbers"><code>    IntList list{};</code><code>    list[2] = 3; // set a value</code><code>    std::cout &lt;&lt; list[2] &lt;&lt; '\n'; // get a value</code><code></code><code>    return 0;</code></pre><p>This is both easy syntactically and from a comprehension standpoint. When <code>list[2]</code> evaluates, the compiler first checks to see if there’s an overloaded operator[] function. If so, it passes the value inside the hard braces (in this case, 2) as an argument to the function.</p><p>Note that although you can provide a default value for the function parameter, actually using operator[] without a subscript inside is not considered a valid syntax, so there’s no point.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>C++23 will add support for overloading operator[] with multiple subscripts.</p></div><br><h3>Why operator[] returns a reference</h3><p>Let’s take a closer look at how <code>list[2] = 3</code> evaluates. Because the subscript operator has a higher precedence than the assignment operator, <code>list[2]</code> evaluates first. <code>list[2]</code> calls operator[], which we’ve defined to return a reference to <code>list.m_list[2]</code>. Because operator[] is returning a reference, it returns the actual <code>list.m_list[2]</code> array element. Our partially evaluated expression becomes <code>list.m_list[2] = 3</code>, which is a straightforward integer assignment.</p><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/value-categories-lvalues-and-rvalues/">9.2 -- Value categories (lvalues and rvalues)</a>, you learned that any value on the left hand side of an assignment statement must be an l-value (which is a variable that has an actual memory address). Because the result of operator[] can be used on the left hand side of an assignment (e.g. <code>list[2] = 3</code>), the return value of operator[] must be an l-value. As it turns out, references are always l-values, because you can only take a reference of variables that have memory addresses. So by returning a reference, the compiler is satisfied that we are returning an l-value.</p><p>Consider what would happen if operator[] returned an integer by value instead of by reference. <code>list[2]</code> would call operator[], which would return the <em>value of</em> list.m_list[2]. For example, if m_list[2] had the value of 6, operator[] would return the value 6. <code>list[2] = 3</code> would partially evaluate to <code>6 = 3</code>, which makes no sense! If you try to do this, the C++ compiler will complain:</p><pre>C:VCProjectsTest.cpp(386) : error C2106: '=' : left operand must be l-value
</pre><br><h3>Dealing with const objects</h3><p>In the above IntList example, operator[] is non-const, and we can use it as an l-value to change the state of non-const objects. However, what if our IntList object was const? In this case, we wouldn’t be able to call the non-const version of operator[] because that would allow us to potentially change the state of a const object.</p><p>The good news is that we can define a non-const and a const version of operator[] separately. The non-const version will be used with non-const objects, and the const version with const-objects.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class IntList</code><code>{</code><code>private:</code><code>    int m_list[10]{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; // give this class some initial state for this example</code><code></code><code>public:</code><code>    int&amp; operator[] (int index);</code><code>    int operator[] (int index) const; // could also return const int&amp; if returning a non-fundamental type</code><code>};</code><code></code><code>int&amp; IntList::operator[] (int index) // for non-const objects: can be used for assignment</code><code>{</code><code>    return m_list[index];</code><code>}</code><code></code><code>int IntList::operator[] (int index) const // for const objects: can only be used for access</code><code>{</code><code>    return m_list[index];</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    IntList list{};</code><code>    list[2] = 3; // okay: calls non-const version of operator[]</code><code>    std::cout &lt;&lt; list[2] &lt;&lt; '\n';</code><code></code><code>    const IntList clist{};</code><code>    clist[2] = 3; // compile error: calls const version of operator[], which returns by value.  Cannot assign to this because it is an rvalue.</code><code>    std::cout &lt;&lt; clist[2] &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>If we comment out the line <code>clist[2] = 3</code>, the above program compiles and executes as expected.</p><br><h3>Error checking</h3><p>One other advantage of overloading the subscript operator is that we can make it safer than accessing arrays directly. Normally, when accessing arrays, the subscript operator does not check whether the index is valid. For example, the compiler will not complain about the following code:</p><pre class="language-cpp line-numbers"><code>int list[5]{};</code><code>list[7] = 3; // index 7 is out of bounds!</code></pre><p>However, if we know the size of our array, we can make our overloaded subscript operator check to ensure the index is within bounds:</p><pre class="language-cpp line-numbers"><code>#include <cassert> // for assert()</cassert></code><code>#include <iterator> // for std::size()</iterator></code><code></code><code>class IntList</code><code>{</code><code>private:</code><code>    int m_list[10]{};</code><code></code><code>public:</code><code>    int&amp; operator[] (int index);</code><code>};</code><code></code><code>int&amp; IntList::operator[] (int index)</code><code>{</code><code>    assert(index &gt;= 0 &amp;&amp; index &lt; std::size(m_list));</code><code></code><code>    return m_list[index];</code><code>}</code></pre><p>In the above example, we have used the assert() function (included in the cassert header) to make sure our index is valid. If the expression inside the assert evaluates to false (which means the user passed in an invalid index), the program will terminate with an error message, which is much better than the alternative (corrupting memory). This is probably the most common method of doing error checking of this sort.</p><br><h3>Pointers to objects and overloaded operator[] don’t mix</h3><p>If you try to call operator[] on a pointer to an object, C++ will assume you’re trying to index an array of objects of that type.</p><p>Consider the following example:</p><pre class="language-cpp line-numbers"><code>#include <cassert> // for assert()</cassert></code><code>#include <iterator> // for std::size()</iterator></code><code></code><code>class IntList</code><code>{</code><code>private:</code><code>    int m_list[10]{};</code><code></code><code>public:</code><code>    int&amp; operator[] (int index);</code><code>};</code><code></code><code>int&amp; IntList::operator[] (int index)</code><code>{</code><code>    assert(index &gt;= 0 &amp;&amp; index &lt; std::size(m_list));</code><code></code><code>    return m_list[index];</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    IntList* list{ new IntList{} };</code><code>    list [2] = 3; // error: this will assume we're accessing index 2 of an array of IntLists</code><code>    delete list;</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because we can’t assign an integer to an IntList, this won’t compile. However, if assigning an integer was valid, this would compile and run, with undefined results.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Rule</h4><p>Make sure you’re not trying to call an overloaded operator[] on a pointer to an object.</p></div><p>The proper syntax would be to dereference the pointer first (making sure to use parenthesis since operator[] has higher precedence than operator*), then call operator[]:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    IntList* list{ new IntList{} };</code><code>    (*list)[2] = 3; // get our IntList object, then call overloaded operator[]</code><code>    delete list;</code><code></code><code>    return 0;</code><code>}</code></pre><p>This is ugly and error prone. Better yet, don’t set pointers to your objects if you don’t have to.</p><br><h3>The function parameter does not need to be an integer</h3><p>As mentioned above, C++ passes what the user types between the hard braces as an argument to the overloaded function. In most cases, this will be an integer value. However, this is not required -- and in fact, you can define that your overloaded operator[] take a value of any type you desire. You could define your overloaded operator[] to take a double, a std::string, or whatever else you like.</p><p>As a ridiculous example, just so you can see that it works:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view> // C++17</string_view></code><code></code><code>class Stupid</code><code>{</code><code>private:</code><code></code><code>public:</code><code>	void operator[] (std::string_view index);</code><code>};</code><code></code><code>// It doesn't make sense to overload operator[] to print something</code><code>// but it is the easiest way to show that the function parameter can be a non-integer</code><code>void Stupid::operator[] (std::string_view index)</code><code>{</code><code>	std::cout &lt;&lt; index;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Stupid stupid{};</code><code>	stupid["Hello, world!"];</code><code></code><code>	return 0;</code><code>}</code></pre><p>As you would expect, this prints:</p><pre>Hello, world!
</pre><p>Overloading operator[] to take a std::string parameter can be useful when writing certain kinds of classes, such as those that use words as indices.</p><br><h3>Conclusion</h3><p>The subscript operator is typically overloaded to provide direct access to individual elements from an array (or other similar structure) contained within a class. Because strings are often implemented as arrays of characters, operator[] is often implemented in string classes to allow the user to access a single character of the string.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>A map is a class that stores elements as a key-value pair. The key must be unique, and is used to access the associated pair. In this quiz, we’re going to write an application that lets us assign grades to students by name, using a simple map class. The student’s name will be the key, and the grade (as a char) will be the value.</p><p>a) First, write a struct named <code>StudentGrade</code> that contains the student’s name (as a <code>std::string</code>) and grade (as a <code>char</code>).</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>struct StudentGrade</code><code>{</code><code>    std::string name{};</code><code>    char grade{};</code><code>};</code></pre></div><p>b) Add a class named <code>GradeMap</code> that contains a <code>std::vector</code> of <code>StudentGrade</code> named <code>m_map</code>.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <string></string></code><code>#include <vector></vector></code><code></code><code>struct StudentGrade</code><code>{</code><code>	std::string name{};</code><code>	char grade{};</code><code>};</code><code></code><code>class GradeMap</code><code>{</code><code>private:</code><code>	std::vector<studentgrade> m_map{};</studentgrade></code><code>};</code></pre></div><p>c) Write an overloaded <code>operator[]</code> for this class. This function should take a <code>std::string</code> parameter, and return a reference to a char. In the body of the function, first see if the student’s name already exists (You can use <code>std::find_if</code> from &lt;algorithm&gt;). If the student exists, return a reference to the grade and you’re done. Otherwise, use the <code>std::vector::push_back()</code> function to add a <code>StudentGrade</code> for this new student. When you do this, <code>std::vector</code> will add a copy of your <code>StudentGrade</code> to itself (resizing if needed, invalidating all previously returned references). Finally, we need to return a reference to the grade for the student we just added to the <code>std::vector</code>. We can access the student we just added using the <code>std::vector::back()</code> function.</p><p>The following program should run:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// ...</code><code></code><code>int main()</code><code>{</code><code>	GradeMap grades{};</code><code></code><code>	grades["Joe"] = 'A';</code><code>	grades["Frank"] = 'B';</code><code></code><code>	std::cout &lt;&lt; "Joe has a grade of " &lt;&lt; grades["Joe"] &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; "Frank has a grade of " &lt;&lt; grades["Frank"] &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view> // C++17</string_view></code><code>#include <vector></vector></code><code></code><code>struct StudentGrade</code><code>{</code><code>	std::string name{};</code><code>	char grade{};</code><code>};</code><code></code><code>class GradeMap</code><code>{</code><code>private:</code><code>	std::vector<studentgrade> m_map{};</studentgrade></code><code></code><code>public:</code><code>	char&amp; operator[](std::string_view name);</code><code>};</code><code></code><code>char&amp; GradeMap::operator[](std::string_view name)</code><code>{</code><code>	auto found{ std::find_if(m_map.begin(), m_map.end(),</code><code>				[&amp;](const auto&amp; student) { // this is a lambda</code><code>					return (student.name == name);</code><code>				}) };</code><code></code><code>	if (found != m_map.end())</code><code>	{</code><code>		return found-&gt;grade;</code><code>	}</code><code></code><code>	// otherwise create a new StudentGrade for this student and add</code><code>	// it to the end of our vector.</code><code>	m_map.push_back({ std::string{name} });</code><code></code><code>	// and return the element</code><code>	return m_map.back().grade;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	GradeMap grades{};</code><code></code><code>	grades["Joe"] = 'A';</code><code>	grades["Frank"] = 'B';</code><code></code><code>	std::cout &lt;&lt; "Joe has a grade of " &lt;&lt; grades["Joe"] &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; "Frank has a grade of " &lt;&lt; grades["Frank"] &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>A reminder</h4><p>See <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-lambdas-anonymous-functions/">12.7 -- Introduction to lambdas (anonymous functions)</a> for more information on lambdas.</p></div><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>Since maps are common, the standard library offers <a href="https://en.cppreference.com/w/cpp/container/map"><code>std::map</code></a>, which is not currently covered on learncpp. Using <code>std::map</code>, we can simplify our code to</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <map> // std::map</map></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>	// std::map can be initialized</code><code>	std::map<std::string, char=""> grades{</std::string,></code><code>		{ "Joe", 'A' },</code><code>		{ "Frank", 'B' }</code><code>	};</code><code></code><code>	// and assigned</code><code>	grades["Susan"] = 'C';</code><code>	grades["Tom"] = 'D';</code><code></code><code>	std::cout &lt;&lt; "Joe has a grade of " &lt;&lt; grades["Joe"] &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; "Frank has a grade of " &lt;&lt; grades["Frank"] &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>Prefer using <code>std::map</code> over writing your own implementation.</p></div></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>Extra credit #1: The <code>GradeMap</code> class and sample program we wrote is inefficient for many reasons. Describe one way that the <code>GradeMap</code> class could be improved.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><p><code>std::vector</code> is unsorted by nature. This means every time we call <code>operator[]</code>, we’re potentially traversing the entire <code>std::vector</code> to find our element. With a few elements, this isn’t a problem, but as we continue to add names, this will become increasingly slow. We could optimize this by keeping our <code>m_map</code> sorted and using a binary search, so we minimize the number of elements we have to look through to find the ones we’re interested in.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>Extra credit #2: Why does this program potentially not work as expected?</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	GradeMap grades{};</code><code></code><code>	char&amp; gradeJoe{ grades["Joe"] }; // does a push_back</code><code>	gradeJoe = 'A';</code><code></code><code>	char&amp; gradeFrank{ grades["Frank"] }; // does a push_back</code><code>	gradeFrank = 'B';</code><code></code><code>	std::cout &lt;&lt; "Joe has a grade of " &lt;&lt; gradeJoe &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; "Frank has a grade of " &lt;&lt; gradeFrank &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><p>When Frank is added, the <code>std::vector</code> may need to grow to hold it. This requires dynamically allocating a new block of memory, copying the elements in the array to that new block, and deleting the old block. When this happens, any references to existing elements in the std::vector are invalidated (meaning they are left as dangling references to deleted memory).</p><p>In other words, after we <code>push_back("Frank")</code>, if the std::vector had to grow to make room for Frank, the <code>gradeJoe</code> reference would be invalidated. Accessing <code>gradeJoe</code> to print Joe’s grade would then lead to undefined results.</p><p>How a std::vector grows is a compiler-specific detail, so we can expect the above program to work fine when compiled with some compilers and not others.</p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">14.10 — Overloading the parenthesis operator</h1></header><div class="entry-content" itemprop="articleBody"><p>All of the overloaded operators you have seen so far let you define the type of the operator’s parameters, but not the number of parameters (which is fixed based on the type of the operator). For example, operator== always takes two parameters, whereas operator! always takes one. The parenthesis operator (operator()) is a particularly interesting operator in that it allows you to vary both the type AND number of parameters it takes.</p><p>There are two things to keep in mind: first, the parenthesis operator must be implemented as a member function. Second, in non-object-oriented C++, the () operator is used to call functions. In the case of classes, operator() is just a normal operator that calls a function (named operator()) like any other overloaded operator.</p><br><h3>An example</h3><p>Let’s take a look at an example that lends itself to overloading this operator:</p><pre class="language-cpp line-numbers"><code>class Matrix</code><code>{</code><code>private:</code><code>    double data[4][4]{};</code><code>};</code></pre><p>Matrices are a key component of linear algebra, and are often used to do geometric modeling and 3D computer graphics work. In this case, all you need to recognize is that the Matrix class is a 4 by 4 two-dimensional array of doubles.</p><p>In the lesson on <a href="https://www.learncpp.com/cpp-tutorial/98-overloading-the-subscript-operator/">overloading the subscript operator</a>, you learned that we could overload operator[] to provide direct access to a private one-dimensional array. However, in this case, we want access to a private two-dimensional array. Because operator[] is limited to a single parameter, it is not sufficient to let us index a two-dimensional array.</p><p>However, because the () operator can take as many parameters as we want it to have, we can declare a version of operator() that takes two integer index parameters, and use it to access our two-dimensional array. Here is an example of this:</p><pre class="language-cpp line-numbers"><code>#include <cassert> // for assert()</cassert></code><code></code><code>class Matrix</code><code>{</code><code>private:</code><code>    double m_data[4][4]{};</code><code></code><code>public:</code><code>    double&amp; operator()(int row, int col);</code><code>    double operator()(int row, int col) const; // for const objects</code><code>};</code><code></code><code>double&amp; Matrix::operator()(int row, int col)</code><code>{</code><code>    assert(col &gt;= 0 &amp;&amp; col &lt; 4);</code><code>    assert(row &gt;= 0 &amp;&amp; row &lt; 4);</code><code></code><code>    return m_data[row][col];</code><code>}</code><code></code><code>double Matrix::operator()(int row, int col) const</code><code>{</code><code>    assert(col &gt;= 0 &amp;&amp; col &lt; 4);</code><code>    assert(row &gt;= 0 &amp;&amp; row &lt; 4);</code><code></code><code>    return m_data[row][col];</code><code>}</code></pre><p>Now we can declare a Matrix and access its elements like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    Matrix matrix;</code><code>    matrix(1, 2) = 4.5;</code><code>    std::cout &lt;&lt; matrix(1, 2) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>which produces the result:</p><pre>4.5
</pre><p>Now, let’s overload the () operator again, this time in a way that takes no parameters at all:</p><pre class="language-cpp line-numbers"><code>#include <cassert> // for assert()</cassert></code><code>class Matrix</code><code>{</code><code>private:</code><code>    double m_data[4][4]{};</code><code></code><code>public:</code><code>    double&amp; operator()(int row, int col);</code><code>    double operator()(int row, int col) const;</code><code>    void operator()();</code><code>};</code><code></code><code>double&amp; Matrix::operator()(int row, int col)</code><code>{</code><code>    assert(col &gt;= 0 &amp;&amp; col &lt; 4);</code><code>    assert(row &gt;= 0 &amp;&amp; row &lt; 4);</code><code></code><code>    return m_data[row][col];</code><code>}</code><code></code><code>double Matrix::operator()(int row, int col) const</code><code>{</code><code>    assert(col &gt;= 0 &amp;&amp; col &lt; 4);</code><code>    assert(row &gt;= 0 &amp;&amp; row &lt; 4);</code><code></code><code>    return m_data[row][col];</code><code>}</code><code></code><code>void Matrix::operator()()</code><code>{</code><code>    // reset all elements of the matrix to 0.0</code><code>    for (int row{ 0 }; row &lt; 4; ++row)</code><code>    {</code><code>        for (int col{ 0 }; col &lt; 4; ++col)</code><code>        {</code><code>            m_data[row][col] = 0.0;</code><code>        }</code><code>    }</code><code>}</code></pre><p>And here’s our new example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    Matrix matrix{};</code><code>    matrix(1, 2) = 4.5;</code><code>    matrix(); // erase matrix</code><code>    std::cout &lt;&lt; matrix(1, 2) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>which produces the result:</p><pre>0
</pre><p>Because the () operator is so flexible, it can be tempting to use it for many different purposes. However, this is strongly discouraged, since the () symbol does not really give any indication of what the operator is doing. In our example above, it would be better to have written the erase functionality as a function called clear() or erase(), as <code>matrix.erase()</code> is easier to understand than <code>matrix()</code> (which could do anything!).</p><br><h3>Having fun with functors</h3><p>Operator() is also commonly overloaded to implement <strong>functors</strong> (or <strong>function object</strong>), which are classes that operate like functions. The advantage of a functor over a normal function is that functors can store data in member variables (since they are classes).</p><p>Here’s a simple functor:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Accumulator</code><code>{</code><code>private:</code><code>    int m_counter{ 0 };</code><code></code><code>public:</code><code>    int operator() (int i) { return (m_counter += i); }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Accumulator acc{};</code><code>    std::cout &lt;&lt; acc(10) &lt;&lt; '\n'; // prints 10</code><code>    std::cout &lt;&lt; acc(20) &lt;&lt; '\n'; // prints 30</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note that using our Accumulator looks just like making a normal function call, but our Accumulator object is storing an accumulated value.</p><p>You may wonder why we couldn’t do the same thing with a normal function and a static local variable to preserve data between function calls. We could, but because functions only have one global instance, we’d be limited to using it for one thing at a time. With functors, we can instantiate as many separate functor objects as we need and use them all simultaneously.</p><br><h3>Conclusion</h3><p>Operator() is sometimes overloaded with two parameters to index multidimensional arrays, or to retrieve a subset of a one dimensional array (with the two parameters defining the subset to return). Anything else is probably better written as a member function with a more descriptive name.</p><p>Operator() is also often overloaded to create functors. Although simple functors (such as the example above) are fairly easily understood, functors are typically used in more advanced programming topics, and deserve their own lesson.</p><br><h3>Quiz time</h3><p class="cpp-quiz-question" style="clear:both">Question #1</p><p>Write a class named MyString that holds a <code>std::string</code>. Overload <code>operator&lt;&lt;</code> to output the string. Overload <code>operator()</code> to return the substring that starts at the index of the first parameter (as a <code>MyString</code>). The length of the substring should be defined by the second parameter.</p><p>The following code should run:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    MyString s { "Hello, world!" };</code><code>    std::cout &lt;&lt; s(7, 5) &lt;&lt; '\n'; // start at index 7 and return 5 characters</code><code></code><code>    return 0;</code><code>}</code></pre><p>This should print</p><pre>world
</pre><p>Hint: You can use <a href="https://en.cppreference.com/w/cpp/string/basic_string/substr"><code>std::string::substr</code></a> to get a substring of a std::string.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>class MyString</code><code>{</code><code>private:</code><code>	std::string m_string{};</code><code></code><code>public:</code><code>	MyString(const std::string&amp; string = {})</code><code>		:m_string{ string }</code><code>	{</code><code>	}</code><code></code><code>	MyString operator()(int start, int length)</code><code>	{</code><code>		assert(start &gt;= 0);</code><code>		assert(start + length &lt;= static_cast<int>(m_string.length()) &amp;&amp; "MyString::operator(int, int): Substring is out of range");</int></code><code></code><code>		return m_string.substr(start, length);</code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyString&amp; s)</code><code>	{</code><code>		out &lt;&lt; s.m_string;</code><code></code><code>		return out;</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	MyString s { "Hello, world!" };</code><code>	std::cout &lt;&lt; s(7, 5) &lt;&lt; '\n'; // start at index 7 and return 5 characters</code><code></code><code>	return 0;</code><code>}</code></pre></div><p class="cpp-quiz-question cpp-topline" style="clear:both">Question #2</p><p>Extra credit: Why is the above inefficient if we need the substring only temporarily (assume you used <code>std::string::substr</code> to implement the substring)?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p><code>std::string::substr</code> returns a <code>std::string</code>, which means when we call it, we’re making a copy of part of the source string. Our overloaded <code>operator()</code> uses this to construct a new <code>MyString</code>, which contains a <code>std::string</code> member, which makes another copy. We then return this <code>MyString</code> to the caller, which makes a third copy.</p><p>Note: The compiler will probably optimize some of these copies out of existence, but at least one <code>std::string</code> (containing the resulting substring) must be kept.</p></div><p class="cpp-quiz-question cpp-topline" style="clear:both">Question #3</p><p>Extra credit: Implement a member function named <code>substr</code> that returns the same substring as a <code>std::string_view</code>.</p><p>The following code should run and produce the same result as above:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    MyString s { "Hello, world!" };</code><code>    std::cout &lt;&lt; s.substr(7, 5) &lt;&lt; '\n'; // start at index 7 and return 5 characters</code><code></code><code>    return 0;</code><code>}</code></pre><p>Hint: <code>std::string::substr</code> returns a <code>std::string</code>. <code>std::string_view::substr</code> returns a <code>std::string_view</code>. Be very careful not to return a dangling <code>std::string_view!</code>.</p><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">Hint: Don’t create any <code>std::string</code> temporaries, as these will be destroyed at the end of the function, and any <code>std::string_view</code> of those <code>std::string</code> will be left dangling.</div><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_1'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_1" style="display:none;margin-bottom:1em">Hint: Creating <code>std::string_view</code> temporaries is okay, as long as they are views of <code>m_string</code>.</div><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class MyString</code><code>{</code><code>private:</code><code>	std::string m_string{};</code><code></code><code>public:</code><code>	MyString(const std::string&amp; string = {})</code><code>		:m_string{ string }</code><code>	{</code><code>	}</code><code></code><code>	MyString operator()(int start, int length)</code><code>	{</code><code>		assert(start &gt;= 0);</code><code>		assert(start + length &lt;= static_cast<int>(m_string.length()) &amp;&amp; "MyString::operator(int, int): Substring is out of range");</int></code><code></code><code>		return m_string.substr(start, length);</code><code>	}</code><code></code><code>	std::string_view substr(int start, int length)</code><code>	{</code><code>		assert(start &gt;= 0);</code><code>		assert(start + length &lt;= static_cast<int>(m_string.length()) &amp;&amp; "MyString::substr(int, int): Substring is out of range");</int></code><code></code><code>		return std::string_view{ m_string }.substr(start, length);</code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyString&amp; s)</code><code>	{</code><code>		out &lt;&lt; s.m_string;</code><code></code><code>		return out;</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	MyString s { "Hello, world!" };</code><code>	std::cout &lt;&lt; s.substr(7, 5) &lt;&lt; '\n'; // start at index 7 and return 5 characters</code><code></code><code>	return 0;</code><code>}</code></pre><p>Let’s explore <code>return std::string_view{ m_string }.substr(start, length);</code> further. First, we’re creating a temporary <code>std::string_view</code> of <code>m_string</code>, which is inexpensive and lets us access <code>std::string_view</code> member functions. Next, we call <code>std::string_view::substr</code> on this temporary to get our substring (as a non-null-terminated view of <code>m_string</code>). We then return this view to the caller. Since the <code>std::string_view</code> we return to the caller is still a view of <code>m_string</code>, it is not dangling.</p><p>The end result is we create 3 <code>std::string_view</code> instead of 3 <code>std::string</code>, which is more efficient.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">14.11 — Overloading typecasts</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/explicit-type-conversion-casting-and-static-cast/">8.5 -- Explicit type conversion (casting) and static_cast</a>, you learned that C++ allows you to convert one data type to another. The following example shows an int being converted into a double:</p><pre class="language-cpp line-numbers"><code>int n{ 5 };</code><code>auto d{ static_cast<double>(n) }; // int cast to a double</double></code></pre><p>C++ already knows how to convert between the built-in data types. However, it does not know how to convert any of our user-defined classes. That’s where overloading the typecast operators comes into play.</p><p><strong>User-defined conversions</strong> allow us to convert our class into another data type. Take a look at the following class:</p><pre class="language-cpp line-numbers"><code>class Cents</code><code>{</code><code>private:</code><code>    int m_cents;</code><code>public:</code><code>    Cents(int cents=0)</code><code>        : m_cents{ cents }</code><code>    {</code><code>    }</code><code></code><code>    int getCents() const { return m_cents; }</code><code>    void setCents(int cents) { m_cents = cents; }</code><code>};</code></pre><p>This class is pretty simple: it holds some number of cents as an integer, and provides access functions to get and set the number of cents. It also provides a constructor for converting an int into a Cents.</p><p>If we can convert an int into a Cents, then doesn’t it also make sense for us to be able to convert a Cents back into an int? In some cases, this might not be true, but in this case, it does make sense.</p><p>In the following example, we have to use getCents() to convert our Cents variable back into an integer so we can print it using printInt():</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printInt(int value)</code><code>{</code><code>    std::cout &lt;&lt; value;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Cents cents{ 7 };</code><code>    printInt(cents.getCents()); // print 7</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>If we have already written a lot of functions that take integers as parameters, our code will be littered with calls to getCents(), which makes it more messy than it needs to be.</p><p>To make things easier, we can provide a user-defined conversion by overloading the int typecast. This will allow us to cast our Cents class directly into an int. The following example shows how this is done:</p><pre class="language-cpp line-numbers"><code>class Cents</code><code>{</code><code>private:</code><code>    int m_cents;</code><code>public:</code><code>    Cents(int cents=0)</code><code>        : m_cents{ cents }</code><code>    {</code><code>    }</code><code></code><code>    // Overloaded int cast</code><code>    operator int() const { return m_cents; }</code><code></code><code>    int getCents() const { return m_cents; }</code><code>    void setCents(int cents) { m_cents = cents; }</code><code>};</code></pre><p>There are three things to note:</p><ol><li>To overload the function that casts our class to an int, we write a new function in our class called operator int(). Note that there is a space between the word operator and the type we are casting to.</li><li>User-defined conversions do not take parameters, as there is no way to pass arguments to them.</li><li>User-defined conversions do not have a return type. C++ assumes you will be returning the correct type.</li></ol><p>Now in our example, we can call printInt() like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    Cents cents{ 7 };</code><code>    printInt(cents); // print 7</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>The compiler will first note that function printInt takes an integer parameter. Then it will note that variable cents is not an int. Finally, it will look to see if we’ve provided a way to convert a Cents into an int. Since we have, it will call our operator int() function, which returns an int, and the returned int will be passed to printInt().</p><p>We can now also explicitly cast our Cents variable to an int:</p><pre class="language-cpp line-numbers"><code>Cents cents{ 7 };</code><code>int c{ static_cast<int>(cents) };</int></code></pre><p>You can provide user-defined conversions for any data type you wish, including your own user-defined data types!</p><p>Here’s a new class called Dollars that provides an overloaded Cents conversion:</p><pre class="language-cpp line-numbers"><code>class Dollars</code><code>{</code><code>private:</code><code>    int m_dollars;</code><code>public:</code><code>    Dollars(int dollars=0)</code><code>        : m_dollars{ dollars }</code><code>    {</code><code>    }</code><code></code><code>     // Allow us to convert Dollars into Cents</code><code>     operator Cents() const { return Cents{ m_dollars * 100 }; }</code><code>};</code></pre><p>This allows us to convert a Dollars object directly into a Cents object! This allows you to do something like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>    int m_cents;</code><code>public:</code><code>    Cents(int cents=0)</code><code>        : m_cents{ cents }</code><code>    {</code><code>    }</code><code></code><code>    // Overloaded int cast</code><code>    operator int() const { return m_cents; }</code><code></code><code>    int getCents() const { return m_cents; }</code><code>    void setCents(int cents) { m_cents = cents; }</code><code>};</code><code></code><code>class Dollars</code><code>{</code><code>private:</code><code>    int m_dollars;</code><code>public:</code><code>    Dollars(int dollars=0)</code><code>        : m_dollars{ dollars }</code><code>    {</code><code>    }</code><code></code><code>    // Allow us to convert Dollars into Cents</code><code>    operator Cents() const { return Cents { m_dollars * 100 }; }</code><code>};</code><code></code><code>void printCents(Cents cents)</code><code>{</code><code>    std::cout &lt;&lt; cents; // cents will be implicitly cast to an int here</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Dollars dollars{ 9 };</code><code>    printCents(dollars); // dollars will be implicitly cast to a Cents here</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Consequently, this program will print the value:</p><pre>900
</pre><p>which makes sense, since 9 dollars is 900 cents!</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">14.12 — The copy constructor</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>Recapping the types of initialization</strong></p><p>Since we’re going to talk a lot about initialization in the next few lessons, let’s first recap the types of initialization that C++ supports: direct (parenthesis) initialization, uniform (brace) initialization or copy (equals) initialization.</p><p>Here are examples of all of those, using our Fraction class:</p><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code>#include <iostream></iostream></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>    int m_numerator{};</code><code>    int m_denominator{};</code><code> </code><code>public:</code><code>    // Default constructor</code><code>    Fraction(int numerator=0, int denominator=1)</code><code>        : m_numerator{numerator}, m_denominator{denominator}</code><code>    {</code><code>        assert(denominator != 0);</code><code>    }</code><code> </code><code>    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);</code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)</code><code>{</code><code>	out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>	return out;</code><code>}</code></pre><p>We can do a direct initialization:</p><pre class="language-cpp line-numbers"><code>int x(5); // Direct initialize an integer</code><code>Fraction fiveThirds(5, 3); // Direct initialize a Fraction, calls Fraction(int, int) constructor</code></pre><p>In C++11, we can do a uniform initialization:</p><pre class="language-cpp line-numbers"><code>int x { 5 }; // Uniform initialization of an integer</code><code>Fraction fiveThirds {5, 3}; // Uniform initialization of a Fraction, calls Fraction(int, int) constructor</code></pre><p>And finally, we can do a copy initialization:</p><pre class="language-cpp line-numbers"><code>int x = 6; // Copy initialize an integer</code><code>Fraction six = Fraction(6); // Copy initialize a Fraction, will call Fraction(6, 1)</code><code>Fraction seven = 7; // Copy initialize a Fraction.  The compiler will try to find a way to convert 7 to a Fraction, which will invoke the Fraction(7, 1) constructor.</code></pre><p>With direct and uniform initialization, the object being created is directly initialized. However, copy initialization is a little more complicated. We’ll explore copy initialization in more detail in the next lesson. But in order to do that effectively, we need to take a short detour.</p><p><strong>The copy constructor</strong></p><p>Now consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code>#include <iostream></iostream></code><code> </code><code>class Fraction</code><code>{</code><code>private:</code><code>    int m_numerator{};</code><code>    int m_denominator{};</code><code> </code><code>public:</code><code>    // Default constructor</code><code>    Fraction(int numerator=0, int denominator=1)</code><code>        : m_numerator{numerator}, m_denominator{denominator}</code><code>    {</code><code>        assert(denominator != 0);</code><code>    }</code><code></code><code>    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);</code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)</code><code>{</code><code>	out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>	return out;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Fraction fiveThirds { 5, 3 }; // Brace initialize a Fraction, calls Fraction(int, int) constructor</code><code>	Fraction fCopy { fiveThirds }; // Brace initialize a Fraction -- with what constructor?</code><code>	std::cout &lt;&lt; fCopy &lt;&lt; '\n';</code><code>}</code></pre><p>If you compile this program, you’ll see that it compiles just fine, and produces the result:</p><pre class="language-cpp line-numbers"><code>5/3</code></pre><p>Let’s take a closer look at how this program works.</p><p>The initialization of variable fiveThirds is just a standard brace initialization that calls the Fraction(int, int) constructor. No surprises there. But what about the next line? The initialization of variable fCopy is also clearly an initialization, and you know that constructor functions are used to initialize classes. So what constructor is this line calling?</p><p>The answer is that this line is calling Fraction’s copy constructor. A <strong>copy constructor</strong> is a special type of constructor used to create a new object as a copy of an existing object (of the same type). And much like a default constructor, if you do not provide a copy constructor for your classes, C++ will create a public copy constructor for you. Because the compiler does not know much about your class, by default, the created copy constructor utilizes a method of initialization called memberwise initialization. <strong>Memberwise initialization</strong> simply means that each member of the copy is initialized directly from the member of the class being copied. In the above example, fCopy.m_numerator would be initialized from fiveThirds.m_numerator, etc…</p><p>Just like we can explicitly define a default constructor, we can also explicitly define a copy constructor. The copy constructor looks just like you’d expect it to:</p><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code>#include <iostream></iostream></code><code> </code><code>class Fraction</code><code>{</code><code>private:</code><code>    int m_numerator{};</code><code>    int m_denominator{};</code><code> </code><code>public:</code><code>    // Default constructor</code><code>    Fraction(int numerator=0, int denominator=1)</code><code>        : m_numerator{numerator}, m_denominator{denominator}</code><code>    {</code><code>        assert(denominator != 0);</code><code>    }</code><code></code><code>    // Copy constructor</code><code>    Fraction(const Fraction&amp; fraction)</code><code>        : m_numerator{fraction.m_numerator}, m_denominator{fraction.m_denominator}</code><code>        // Note: We can access the members of parameter fraction directly, because we're inside the Fraction class</code><code>    {</code><code>        // no need to check for a denominator of 0 here since fraction must already be a valid Fraction</code><code>        std::cout &lt;&lt; "Copy constructor called\n"; // just to prove it works</code><code>    }</code><code></code><code>    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);</code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)</code><code>{</code><code>	out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>	return out;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Fraction fiveThirds { 5, 3 }; // Direct initialize a Fraction, calls Fraction(int, int) constructor</code><code>	Fraction fCopy { fiveThirds }; // Direct initialize -- with Fraction copy constructor</code><code>	std::cout &lt;&lt; fCopy &lt;&lt; '\n';</code><code>}</code></pre><p>When this program is run, you get:</p><pre>Copy constructor called
5/3
</pre><p>The copy constructor we defined in the example above uses memberwise initialization, and is functionally equivalent to the one we’d get by default, except we’ve added an output statement to prove the copy constructor is being called.</p><p>Unlike with default constructors, it’s fine to use the default copy constructor if it meets your needs.</p><p>One interesting note: You’ve already seen a few examples of overloaded operator&lt;&lt;, where we’re able to access the private members of parameter f1 because the function is a friend of the Fraction class. Similarly, member functions of a class can access the private members of parameters of the same class type. Since our Fraction copy constructor takes a parameter of the class type (to make a copy of), we’re able to access the members of parameter fraction directly, even though it’s not the implicit object.</p><br><h3>The copy constructor’s parameter must be a reference</h3><p>It is a requirement that the parameter of a copy constructor be a (const) reference. This makes sense: if the argument were passed by value, then we’d need the copy constructor to copy the argument into the parameter of the copy constructor (which would result in an infinite recursion).</p><p><strong>Preventing copies</strong></p><p>We can prevent copies of our classes from being made by making the copy constructor private:</p><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code>#include <iostream></iostream></code><code> </code><code>class Fraction</code><code>{</code><code>private:</code><code>    int m_numerator{};</code><code>    int m_denominator{};</code><code> </code><code>    // Copy constructor (private)</code><code>    Fraction(const Fraction&amp; fraction)</code><code>        : m_numerator{fraction.m_numerator}, m_denominator{fraction.m_denominator}</code><code>    {</code><code>        // no need to check for a denominator of 0 here since fraction must already be a valid Fraction</code><code>        std::cout &lt;&lt; "Copy constructor called\n"; // just to prove it works</code><code>    }</code><code></code><code>public:</code><code>    // Default constructor</code><code>    Fraction(int numerator=0, int denominator=1)</code><code>        : m_numerator{numerator}, m_denominator{denominator}</code><code>    {</code><code>        assert(denominator != 0);</code><code>    }</code><code></code><code>    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);</code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)</code><code>{</code><code>	out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>	return out;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Fraction fiveThirds { 5, 3 }; // Direct initialize a Fraction, calls Fraction(int, int) constructor</code><code>	Fraction fCopy { fiveThirds }; // Copy constructor is private, compile error on this line</code><code>	std::cout &lt;&lt; fCopy &lt;&lt; '\n';</code><code>}</code></pre><p>Now when we try to compile our program, we’ll get a compile error since fCopy needs to use the copy constructor, but can not see it since the copy constructor has been declared as private.</p><p><strong>The copy constructor may be elided</strong></p><p>Now consider the following example:</p><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code>#include <iostream></iostream></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>	int m_numerator{};</code><code>	int m_denominator{};</code><code></code><code>public:</code><code>    // Default constructor</code><code>    Fraction(int numerator=0, int denominator=1)</code><code>        : m_numerator{numerator}, m_denominator{denominator}</code><code>    {</code><code>        assert(denominator != 0);</code><code>    }</code><code></code><code>        // Copy constructor</code><code>	Fraction(const Fraction &amp;fraction)</code><code>		: m_numerator{fraction.m_numerator}, m_denominator{fraction.m_denominator}</code><code>	{</code><code>		// no need to check for a denominator of 0 here since fraction must already be a valid Fraction</code><code>		std::cout &lt;&lt; "Copy constructor called\n"; // just to prove it works</code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);</code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)</code><code>{</code><code>	out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>	return out;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Fraction fiveThirds { Fraction { 5, 3 } };</code><code>	std::cout &lt;&lt; fiveThirds;</code><code>	return 0;</code><code>}</code></pre><p>Consider how this program works. First, we direct initialize an anonymous Fraction object, using the Fraction(int, int) constructor. Then we use that anonymous Fraction object as an initializer for Fraction fiveThirds. Since the anonymous object is a Fraction, as is fiveThirds, this should call the copy constructor, right?</p><p>Run this and compile it for yourself. You’d probably expect to get this result (and you may):</p><pre>copy constructor called
5/3
</pre><p>But in actuality, you’re more likely to get this result:</p><pre>5/3
</pre><p>Why didn’t our copy constructor get called?</p><p>Note that initializing an anonymous object and then using that object to direct initialize our defined object takes two steps (one to create the anonymous object, one to call the copy constructor). However, the end result is essentially identical to just doing a direct initialization, which only takes one step.</p><p>For this reason, in such cases, the compiler is allowed to opt out of calling the copy constructor and just do a direct initialization instead. The process of omitting certain copy (or move) steps for performance purposes is called <strong>elision</strong>.</p><p>So although you wrote:</p><pre class="language-cpp line-numbers"><code>	Fraction fiveThirds { Fraction{ 5, 3 } };</code></pre><p>The compiler may change this to:</p><pre class="language-cpp line-numbers"><code>	Fraction fiveThirds{ 5, 3 };</code></pre><p>which only requires one constructor call (to Fraction(int, int)). Note that in cases where elision is used, any statements in the body of the copy constructor are not executed, even if they would have produced side effects (like printing to the screen)!</p><p>Prior to C++17, compilers are permitted (but not required) to perform copy elision in certain cases. In such cases, a copy constructor must be accessible (e.g. non-private), even if the actual copy is elided.</p><p>As of C++17, some cases of copy elision (including the example above) have been made mandatory. In these mandatory elision cases, the copy constructor does not need to be accessible (or even present) since it is guaranteed not to be needed!</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">14.13 — Copy initialization</h1></header><div class="entry-content" itemprop="articleBody"><p>Consider the following line of code:</p><pre class="language-cpp line-numbers"><code>int x = 5;</code></pre><p>This statement uses copy initialization to initialize newly created integer variable x to the value of 5.</p><p>However, classes are a little more complicated, since they use constructors for initialization. This lesson will examine topics related to copy initialization for classes.</p><p><strong>Copy initialization for classes</strong></p><p>Given our Fraction class:</p><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code>#include <iostream></iostream></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>    int m_numerator;</code><code>    int m_denominator;</code><code> </code><code>public:</code><code>    // Default constructor</code><code>    Fraction(int numerator=0, int denominator=1)</code><code>        : m_numerator(numerator), m_denominator(denominator)</code><code>    {</code><code>        assert(denominator != 0);</code><code>    }</code><code> </code><code>    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);</code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)</code><code>{</code><code>	out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>	return out;</code><code>}</code></pre><p>Consider the following:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Fraction six = Fraction(6); </code><code>    std::cout &lt;&lt; six;</code><code>    return 0;</code><code>}</code></pre><p>If you were to compile and run this, you’d see that it produces the expected output:</p><pre>6/1
</pre><p>This form of copy initialization is evaluated the same way as the following:</p><pre class="language-cpp line-numbers"><code>	Fraction six(Fraction(6));</code></pre><p>And as you learned in the previous lesson, this can potentially make calls to both Fraction(int, int) and the Fraction copy constructor (which may be elided for performance reasons). However, because eliding isn’t guaranteed (prior to C++17, where elision in this particular case is now mandatory), it’s better to avoid copy initialization for classes, and use uniform initialization instead.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Avoid using copy initialization, and use uniform initialization instead.</p></div><p><strong>Other places copy initialization is used</strong></p><p>There are a few other places copy initialization is used, but two of them are worth mentioning explicitly. When you pass or return a class by value, that process uses copy initialization.</p><p>Consider:</p><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code>#include <iostream></iostream></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>	int m_numerator;</code><code>	int m_denominator;</code><code></code><code>public:</code><code>    // Default constructor</code><code>    Fraction(int numerator=0, int denominator=1)</code><code>        : m_numerator(numerator), m_denominator(denominator)</code><code>    {</code><code>        assert(denominator != 0);</code><code>    }</code><code></code><code>        // Copy constructor</code><code>	Fraction(const Fraction&amp; copy) :</code><code>		m_numerator(copy.m_numerator), m_denominator(copy.m_denominator)</code><code>	{</code><code>		// no need to check for a denominator of 0 here since copy must already be a valid Fraction</code><code>		std::cout &lt;&lt; "Copy constructor called\n"; // just to prove it works</code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);</code><code>	int getNumerator() { return m_numerator; }</code><code>	void setNumerator(int numerator) { m_numerator = numerator; }</code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)</code><code>{</code><code>	out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>	return out;</code><code>}</code><code></code><code>Fraction makeNegative(Fraction f) // ideally we should do this by const reference</code><code>{</code><code>    f.setNumerator(-f.getNumerator());</code><code>    return f;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Fraction fiveThirds(5, 3);</code><code>    std::cout &lt;&lt; makeNegative(fiveThirds);</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above program, function makeNegative takes a Fraction by value and also returns a Fraction by value. When we run this program, we get:</p><pre>Copy constructor called
Copy constructor called
-5/3
</pre><p>The first copy constructor call happens when fiveThirds is passed as an argument into makeNegative() parameter f. The second call happens when the return value from makeNegative() is passed back to main().</p><p>In the above case, both the argument passed by value and the return value can not be elided. However, in other cases, if the argument or return value meet specific criteria, the compiler may opt to elide the copy constructor. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>class Something</code><code>{</code><code>public:</code><code>	Something() = default;</code><code>	Something(const Something&amp;)</code><code>	{</code><code>		std::cout &lt;&lt; "Copy constructor called\n";</code><code>	}</code><code>};</code><code></code><code>Something foo()</code><code>{</code><code>	return Something(); // copy constructor normally called here</code><code>}</code><code>Something goo()</code><code>{</code><code>	Something s;</code><code>	return s; // copy constructor normally called here</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Initializing s1\n";</code><code>	Something s1 = foo(); // copy constructor normally called here</code><code></code><code>	std::cout &lt;&lt; "Initializing s2\n";</code><code>	Something s2 = goo(); // copy constructor normally called here</code><code>}</code></pre><p>The above program would normally call the copy constructor 4 times -- however, due to copy elision, it’s likely that your compiler will elide most or all of the cases. Visual Studio 2019 elides 3 (it doesn’t elide the case where goo() is returned), and GCC elides all 4.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">14.14 — Converting constructors, explicit, and delete</h1></header><div class="entry-content" itemprop="articleBody"><p>By default, C++ will treat any constructor as an implicit conversion operator. Consider the following case:</p><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code>#include <iostream></iostream></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>	int m_numerator;</code><code>	int m_denominator;</code><code></code><code>public:</code><code>	// Default constructor</code><code>	Fraction(int numerator = 0, int denominator = 1)</code><code>		 : m_numerator(numerator), m_denominator(denominator)</code><code>	{</code><code>		assert(denominator != 0);</code><code>	}</code><code></code><code>	// Copy constructor</code><code>	Fraction(const Fraction&amp; copy)</code><code>		: m_numerator(copy.m_numerator), m_denominator(copy.m_denominator)</code><code>	{</code><code>		// no need to check for a denominator of 0 here since copy must already be a valid Fraction</code><code>		std::cout &lt;&lt; "Copy constructor called\n"; // just to prove it works</code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);</code><code>	int getNumerator() { return m_numerator; }</code><code>	void setNumerator(int numerator) { m_numerator = numerator; }</code><code>};</code><code></code><code>void printFraction(const Fraction&amp; f)</code><code>{</code><code>	std::cout &lt;&lt; f;</code><code>}</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)</code><code>{</code><code>	out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>	return out;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	printFraction(6);</code><code></code><code>	return 0;</code><code>}</code></pre><p>Although function printFraction() is expecting a Fraction, we’ve given it the integer literal 6 instead. Because Fraction has a constructor willing to take a single integer, the compiler will implicitly convert the literal 6 into a Fraction object. It does this by initializing printFraction() parameter f using the Fraction(int, int) constructor.</p><p>Consequently, the above program prints:</p><pre>6/1
</pre><p>This implicit conversion works for all kinds of initialization (direct, uniform, and copy).</p><p>Constructors eligible to be used for implicit conversions are called <strong>converting constructors</strong> (or conversion constructors).</p><p><strong>The explicit keyword</strong></p><p>While doing implicit conversions makes sense in the Fraction case, in other cases, this may be undesirable, or lead to unexpected behaviors:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code>#include <iostream></iostream></code><code></code><code>class MyString</code><code>{</code><code>private:</code><code>	std::string m_string;</code><code>public:</code><code>	MyString(int x) // allocate string of size x</code><code>	{</code><code>		m_string.resize(x);</code><code>	}</code><code></code><code>	MyString(const char* string) // allocate string to hold string value</code><code>	{</code><code>		m_string = string;</code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyString&amp; s);</code><code></code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyString&amp; s)</code><code>{</code><code>	out &lt;&lt; s.m_string;</code><code>	return out;</code><code>}</code><code></code><code>void printString(const MyString&amp; s)</code><code>{</code><code>	std::cout &lt;&lt; s;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	MyString mine = 'x'; // Will compile and use MyString(int)</code><code>	std::cout &lt;&lt; mine &lt;&lt; '\n';</code><code></code><code>	printString('x'); // Will compile and use MyString(int)</code><code>	return 0;</code><code>}</code></pre><p>In the above example, the user is trying to initialize a string with a char. Because chars are part of the integer family, the compiler will use the converting constructor MyString(int) constructor to implicitly convert the char to a MyString. The program will then print this MyString, to unexpected results. Similarly, a call to printString(‘x’) causes an implicit conversion that results in the same issue.</p><p>One way to address this issue is to make constructors (and conversion functions) explicit via the explicit keyword, which is placed in front of the function’s name. Constructors and conversion functions made explicit will not be used for <em>implicit</em> conversions or copy initialization:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code>#include <iostream></iostream></code><code></code><code>class MyString</code><code>{</code><code>private:</code><code>	std::string m_string;</code><code>public:</code><code>	// explicit keyword makes this constructor ineligible for implicit conversions</code><code>	explicit MyString(int x) // allocate string of size x</code><code>	{</code><code>		m_string.resize(x);</code><code>	}</code><code></code><code>	MyString(const char* string) // allocate string to hold string value</code><code>	{</code><code>		m_string = string;</code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyString&amp; s);</code><code></code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyString&amp; s)</code><code>{</code><code>	out &lt;&lt; s.m_string;</code><code>	return out;</code><code>}</code><code></code><code>void printString(const MyString&amp; s)</code><code>{</code><code>	std::cout &lt;&lt; s;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	MyString mine = 'x'; // compile error, since MyString(int) is now explicit and nothing will match this</code><code>	std::cout &lt;&lt; mine;</code><code></code><code>	printString('x'); // compile error, since MyString(int) can't be used for implicit conversions</code><code></code><code>	return 0;</code><code>}</code></pre><p>The above program will not compile, since MyString(int) was made explicit, and an appropriate converting constructor could not be found to implicitly convert ‘x’ to a MyString.</p><p>However, note that making a constructor explicit only prevents <em>implicit</em> conversions. Explicit conversions (via casting) are still allowed:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; static_cast<mystring>(5); // Allowed: explicit cast of 5 to MyString(int)</mystring></code></pre><p>Direct or uniform initialization will also still convert parameters to match (uniform initialization will not do narrowing conversions, but it will happily do other types of conversions).</p><pre class="language-cpp line-numbers"><code>MyString str{'x'}; // Allowed: initialization parameters may still be implicitly converted to match</code></pre><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Consider making your constructors and user-defined conversion member functions explicit to prevent implicit conversion errors.</p></div><p><strong>The delete keyword</strong></p><p>In our MyString case, we really want to completely disallow ‘x’ from being converted to a MyString (whether implicit or explicit, since the results aren’t going to be intuitive). One way to partially do this is to add a MyString(char) constructor, and make it private:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code>#include <iostream></iostream></code><code></code><code>class MyString</code><code>{</code><code>private:</code><code>	std::string m_string;</code><code></code><code>	MyString(char) // objects of type MyString(char) can't be constructed from outside the class</code><code>	{</code><code>	}</code><code></code><code>public:</code><code>	// explicit keyword makes this constructor ineligible for implicit conversions</code><code>	explicit MyString(int x) // allocate string of size x</code><code>	{</code><code>		m_string.resize(x);</code><code>	}</code><code></code><code>	MyString(const char* string) // allocate string to hold string value</code><code>	{</code><code>		m_string = string;</code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyString&amp; s);</code><code></code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyString&amp; s)</code><code>{</code><code>	out &lt;&lt; s.m_string;</code><code>	return out;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	MyString mine('x'); // compile error, since MyString(char) is private</code><code>	std::cout &lt;&lt; mine;</code><code>	return 0;</code><code>}</code></pre><p>However, this constructor can still be used from inside the class (private access only prevents non-members from calling this function).</p><p>A better way to resolve the issue is to use the “delete” keyword to delete the function:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code>#include <iostream></iostream></code><code></code><code>class MyString</code><code>{</code><code>private:</code><code>	std::string m_string;</code><code></code><code>public:</code><code>	MyString(char) = delete; // any use of this constructor is an error</code><code></code><code>	// explicit keyword makes this constructor ineligible for implicit conversions</code><code>	explicit MyString(int x) // allocate string of size x /</code><code>	{</code><code>		m_string.resize(x);</code><code>	}</code><code></code><code>	MyString(const char* string) // allocate string to hold string value</code><code>	{</code><code>		m_string = string;</code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyString&amp; s);</code><code></code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyString&amp; s)</code><code>{</code><code>	out &lt;&lt; s.m_string;</code><code>	return out;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	MyString mine('x'); // compile error, since MyString(char) is deleted</code><code>	std::cout &lt;&lt; mine;</code><code>	return 0;</code><code>}</code></pre><p>When a function has been deleted, any use of that function is considered a compile error.</p><p>Note that the copy constructor and overloaded operators may also be deleted in order to prevent those functions from being used.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">14.15 — Overloading the assignment operator</h1></header><div class="entry-content" itemprop="articleBody"><p>The <strong>assignment operator</strong> (operator=) is used to copy values from one object to another <em>already existing object</em>.</p><p><strong>Assignment vs Copy constructor</strong></p><p>The purpose of the copy constructor and the assignment operator are almost equivalent -- both copy one object to another. However, the copy constructor initializes new objects, whereas the assignment operator replaces the contents of existing objects.</p><p>The difference between the copy constructor and the assignment operator causes a lot of confusion for new programmers, but it’s really not all that difficult. Summarizing:</p><ul><li>If a new object has to be created before the copying can occur, the copy constructor is used (note: this includes passing or returning objects by value).</li><li>If a new object does not have to be created before the copying can occur, the assignment operator is used.</li></ul><p><strong>Overloading the assignment operator</strong></p><p>Overloading the assignment operator (operator=) is fairly straightforward, with one specific caveat that we’ll get to. The assignment operator must be overloaded as a member function.</p><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code>#include <iostream></iostream></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>	int m_numerator { 0 };</code><code>	int m_denominator { 1 };</code><code></code><code>public:</code><code>	// Default constructor</code><code>	Fraction(int numerator = 0, int denominator = 1 )</code><code>		: m_numerator { numerator }, m_denominator { denominator }</code><code>	{</code><code>		assert(denominator != 0);</code><code>	}</code><code></code><code>	// Copy constructor</code><code>	Fraction(const Fraction&amp; copy)</code><code>		: m_numerator { copy.m_numerator }, m_denominator { copy.m_denominator }</code><code>	{</code><code>		// no need to check for a denominator of 0 here since copy must already be a valid Fraction</code><code>		std::cout &lt;&lt; "Copy constructor called\n"; // just to prove it works</code><code>	}</code><code></code><code>	// Overloaded assignment</code><code>	Fraction&amp; operator= (const Fraction&amp; fraction);</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);</code><code>        </code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)</code><code>{</code><code>	out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>	return out;</code><code>}</code><code></code><code>// A simplistic implementation of operator= (see better implementation below)</code><code>Fraction&amp; Fraction::operator= (const Fraction&amp; fraction)</code><code>{</code><code>    // do the copy</code><code>    m_numerator = fraction.m_numerator;</code><code>    m_denominator = fraction.m_denominator;</code><code></code><code>    // return the existing object so we can chain this operator</code><code>    return *this;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Fraction fiveThirds { 5, 3 };</code><code>    Fraction f;</code><code>    f = fiveThirds; // calls overloaded assignment</code><code>    std::cout &lt;&lt; f;</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>5/3
</pre><p>This should all be pretty straightforward by now. Our overloaded operator= returns *this, so that we can chain multiple assignments together:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Fraction f1 { 5, 3 };</code><code>    Fraction f2 { 7, 2 };</code><code>    Fraction f3 { 9, 5 };</code><code></code><code>    f1 = f2 = f3; // chained assignment</code><code></code><code>    return 0;</code><code>}</code></pre><p><strong>Issues due to self-assignment</strong></p><p>Here’s where things start to get a little more interesting. C++ allows self-assignment:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Fraction f1 { 5, 3 };</code><code>    f1 = f1; // self assignment</code><code></code><code>    return 0;</code><code>}</code></pre><p>This will call f1.operator=(f1), and under the simplistic implementation above, all of the members will be assigned to themselves. In this particular example, the self-assignment causes each member to be assigned to itself, which has no overall impact, other than wasting time. In most cases, a self-assignment doesn’t need to do anything at all!</p><p>However, in cases where an assignment operator needs to dynamically assign memory, self-assignment can actually be dangerous:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class MyString</code><code>{</code><code>private:</code><code>	char* m_data {};</code><code>	int m_length {};</code><code></code><code>public:</code><code>	MyString(const char* data = nullptr, int length = 0 )</code><code>		: m_length { length }</code><code>	{</code><code>		if (length)</code><code>		{</code><code>			m_data = new char[length];</code><code></code><code>			for (int i { 0 }; i &lt; length; ++i)</code><code>				m_data[i] = data[i];</code><code>		}</code><code>	}</code><code>	~MyString()</code><code>	{</code><code>		delete[] m_data;</code><code>	}</code><code></code><code>	// Overloaded assignment</code><code>	MyString&amp; operator= (const MyString&amp; str);</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyString&amp; s);</code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyString&amp; s)</code><code>{</code><code>	out &lt;&lt; s.m_data;</code><code>	return out;</code><code>}</code><code></code><code>// A simplistic implementation of operator= (do not use)</code><code>MyString&amp; MyString::operator= (const MyString&amp; str)</code><code>{</code><code>	// if data exists in the current string, delete it</code><code>	if (m_data) delete[] m_data;</code><code></code><code>	m_length = str.m_length;</code><code></code><code>	// copy the data from str to the implicit object</code><code>	m_data = new char[str.m_length];</code><code></code><code>	for (int i { 0 }; i &lt; str.m_length; ++i)</code><code>		m_data[i] = str.m_data[i];</code><code></code><code>	// return the existing object so we can chain this operator</code><code>	return *this;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	MyString alex("Alex", 5); // Meet Alex</code><code>	MyString employee;</code><code>	employee = alex; // Alex is our newest employee</code><code>	std::cout &lt;&lt; employee; // Say your name, employee</code><code></code><code>	return 0;</code><code>}</code></pre><p>First, run the program as it is. You’ll see that the program prints “Alex” as it should.</p><p>Now run the following program:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    MyString alex { "Alex", 5 }; // Meet Alex</code><code>    alex = alex; // Alex is himself</code><code>    std::cout &lt;&lt; alex; // Say your name, Alex</code><code></code><code>    return 0;</code><code>}</code></pre><p>You’ll probably get garbage output. What happened?</p><p>Consider what happens in the overloaded operator= when the implicit object AND the passed in parameter (str) are both variable alex. In this case, m_data is the same as str.m_data. The first thing that happens is that the function checks to see if the implicit object already has a string. If so, it needs to delete it, so we don’t end up with a memory leak. In this case, m_data is allocated, so the function deletes m_data. But because str is the same as *this, the string that we wanted to copy has been deleted and m_data (and str.m_data) are dangling.</p><p>Later on, we allocate new memory to m_data (and str.m_data). So when we subsequently copy the data from str.m_data into m_data, we’re copying garbage, because str.m_data was never initialized.</p><p><strong>Detecting and handling self-assignment</strong></p><p>Fortunately, we can detect when self-assignment occurs. Here’s an updated implementation of our overloaded operator= for the MyString class:</p><pre class="language-cpp line-numbers"><code>MyString&amp; MyString::operator= (const MyString&amp; str)</code><code>{</code><code>	// self-assignment check</code><code>	if (this == &amp;str)</code><code>		return *this;</code><code></code><code>	// if data exists in the current string, delete it</code><code>	if (m_data) delete[] m_data;</code><code></code><code>	m_length = str.m_length;</code><code></code><code>	// copy the data from str to the implicit object</code><code>	m_data = new char[str.m_length];</code><code></code><code>	for (int i { 0 }; i &lt; str.m_length; ++i)</code><code>		m_data[i] = str.m_data[i];</code><code></code><code>	// return the existing object so we can chain this operator</code><code>	return *this;</code><code>}</code></pre><p>By checking if the address of our implicit object is the same as the address of the object being passed in as a parameter, we can have our assignment operator just return immediately without doing any other work.</p><p>Because this is just a pointer comparison, it should be fast, and does not require operator== to be overloaded.</p><p><strong>When not to handle self-assignment</strong></p><p>Typically the self-assignment check is skipped for copy constructors. Because the object being copy constructed is newly created, the only case where the newly created object can be equal to the object being copied is when you try to initialize a newly defined object with itself:</p><pre class="language-cpp line-numbers"><code>someClass c { c };</code></pre><p>In such cases, your compiler should warn you that <code>c</code> is an uninitialized variable.</p><p>Second, the self-assignment check may be omitted in classes that can naturally handle self-assignment. Consider this Fraction class assignment operator that has a self-assignment guard:</p><pre class="language-cpp line-numbers"><code>// A better implementation of operator=</code><code>Fraction&amp; Fraction::operator= (const Fraction&amp; fraction)</code><code>{</code><code>    // self-assignment guard</code><code>    if (this == &amp;fraction)</code><code>        return *this;</code><code></code><code>    // do the copy</code><code>    m_numerator = fraction.m_numerator; // can handle self-assignment</code><code>    m_denominator = fraction.m_denominator; // can handle self-assignment</code><code></code><code>    // return the existing object so we can chain this operator</code><code>    return *this;</code><code>}</code></pre><p>If the self-assignment guard did not exist, this function would still operate correctly during a self-assignment (because all of the operations done by the function can handle self-assignment properly).</p><p>Because self-assignment is a rare event, some prominent C++ gurus recommend omitting the self-assignment guard even in classes that would benefit from it. We do not recommend this, as we believe it’s a better practice to code defensively and then selectively optimize later.</p><p><strong>The copy and swap idiom</strong></p><p>A better way to handle self-assignment issues is via what’s called the copy and swap idiom. There’s a great writeup of how this idiom works <a href="https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom">on Stack Overflow</a>.</p><p><strong>Default assignment operator</strong></p><p>Unlike other operators, the compiler will provide a default public assignment operator for your class if you do not provide one. This assignment operator does memberwise assignment (which is essentially the same as the memberwise initialization that default copy constructors do).</p><p>Just like other constructors and operators, you can prevent assignments from being made by making your assignment operator private or using the delete keyword:</p><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code>#include <iostream></iostream></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>	int m_numerator { 0 };</code><code>	int m_denominator { 1 };</code><code></code><code>public:</code><code>    // Default constructor</code><code>    Fraction(int numerator = 0, int denominator = 1)</code><code>        : m_numerator { numerator }, m_denominator { denominator }</code><code>    {</code><code>        assert(denominator != 0);</code><code>    }</code><code></code><code>	// Copy constructor</code><code>	Fraction(const Fraction ©) = delete;</code><code></code><code>	// Overloaded assignment</code><code>	Fraction&amp; operator= (const Fraction&amp; fraction) = delete; // no copies through assignment!</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);</code><code>        </code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)</code><code>{</code><code>	out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>	return out;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Fraction fiveThirds { 5, 3 };</code><code>    Fraction f;</code><code>    f = fiveThirds; // compile error, operator= has been deleted</code><code>    std::cout &lt;&lt; f;</code><code></code><code>    return 0;</code><code>}</code></pre></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">14.16 — Shallow vs. deep copying</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>Shallow copying</strong></p><p>Because C++ does not know much about your class, the default copy constructor and default assignment operators it provides use a copying method known as a memberwise copy (also known as a <strong>shallow copy</strong>). This means that C++ copies each member of the class individually (using the assignment operator for overloaded operator=, and direct initialization for the copy constructor). When classes are simple (e.g. do not contain any dynamically allocated memory), this works very well.</p><p>For example, let’s take a look at our Fraction class:</p><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code>#include <iostream></iostream></code><code> </code><code>class Fraction</code><code>{</code><code>private:</code><code>    int m_numerator { 0 };</code><code>    int m_denominator { 1 };</code><code> </code><code>public:</code><code>    // Default constructor</code><code>    Fraction(int numerator = 0, int denominator = 1)</code><code>        : m_numerator{ numerator }</code><code>        , m_denominator{ denominator }</code><code>    {</code><code>        assert(denominator != 0);</code><code>    }</code><code> </code><code>    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);</code><code>};</code><code> </code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)</code><code>{</code><code>	out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>	return out;</code><code>}</code></pre><p>The default copy constructor and default assignment operator provided by the compiler for this class look something like this:</p><pre class="language-cpp line-numbers"><code>#include <cassert></cassert></code><code>#include <iostream></iostream></code><code> </code><code>class Fraction</code><code>{</code><code>private:</code><code>    int m_numerator { 0 };</code><code>    int m_denominator { 1 };</code><code> </code><code>public:</code><code>    // Default constructor</code><code>    Fraction(int numerator = 0, int denominator = 1)</code><code>        : m_numerator{ numerator }</code><code>        , m_denominator{ denominator }</code><code>    {</code><code>        assert(denominator != 0);</code><code>    }</code><code> </code><code>    // Possible implementation of implicit copy constructor</code><code>    Fraction(const Fraction&amp; f)</code><code>        : m_numerator{ f.m_numerator }</code><code>        , m_denominator{ f.m_denominator }</code><code>    {</code><code>    }</code><code></code><code>    // Possible implementation of implicit assignment operator</code><code>    Fraction&amp; operator= (const Fraction&amp; fraction)</code><code>    {</code><code>        // self-assignment guard</code><code>        if (this == &amp;fraction)</code><code>            return *this;</code><code> </code><code>        // do the copy</code><code>        m_numerator = fraction.m_numerator;</code><code>        m_denominator = fraction.m_denominator;</code><code> </code><code>        // return the existing object so we can chain this operator</code><code>        return *this;</code><code>    }</code><code></code><code>    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)</code><code>    {</code><code>	out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>	return out;</code><code>    }</code><code>};</code></pre><p>Note that because these default versions work just fine for copying this class, there’s really no reason to write our own version of these functions in this case.</p><p>However, when designing classes that handle dynamically allocated memory, memberwise (shallow) copying can get us in a lot of trouble! This is because shallow copies of a pointer just copy the address of the pointer -- it does not allocate any memory or copy the contents being pointed to!</p><p>Let’s take a look at an example of this:</p><pre class="language-cpp line-numbers"><code>#include <cstring> // for strlen()</cstring></code><code>#include <cassert> // for assert()</cassert></code><code></code><code>class MyString</code><code>{</code><code>private:</code><code>    char* m_data{};</code><code>    int m_length{};</code><code> </code><code>public:</code><code>    MyString(const char* source = "" )</code><code>    {</code><code>        assert(source); // make sure source isn't a null string</code><code></code><code>        // Find the length of the string</code><code>        // Plus one character for a terminator</code><code>        m_length = std::strlen(source) + 1;</code><code>        </code><code>        // Allocate a buffer equal to this length</code><code>        m_data = new char[m_length];</code><code>        </code><code>        // Copy the parameter string into our internal buffer</code><code>        for (int i{ 0 }; i &lt; m_length; ++i)</code><code>            m_data[i] = source[i];</code><code>    }</code><code> </code><code>    ~MyString() // destructor</code><code>    {</code><code>        // We need to deallocate our string</code><code>        delete[] m_data;</code><code>    }</code><code> </code><code>    char* getString() { return m_data; }</code><code>    int getLength() { return m_length; }</code><code>};</code></pre><p>The above is a simple string class that allocates memory to hold a string that we pass in. Note that we have not defined a copy constructor or overloaded assignment operator. Consequently, C++ will provide a default copy constructor and default assignment operator that do a shallow copy. The copy constructor will look something like this:</p><pre class="language-cpp line-numbers"><code>MyString::MyString(const MyString&amp; source)</code><code>    : m_length { source.m_length }</code><code>    , m_data { source.m_data }</code><code>{</code><code>}</code></pre><p>Note that m_data is just a shallow pointer copy of source.m_data, meaning they now both point to the same thing.</p><p>Now, consider the following snippet of code:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    MyString hello{ "Hello, world!" };</code><code>    {</code><code>        MyString copy{ hello }; // use default copy constructor</code><code>    } // copy is a local variable, so it gets destroyed here.  The destructor deletes copy's string, which leaves hello with a dangling pointer</code><code></code><code>    std::cout &lt;&lt; hello.getString() &lt;&lt; '\n'; // this will have undefined behavior</code><code></code><code>    return 0;</code><code>}</code></pre><p>While this code looks harmless enough, it contains an insidious problem that will cause the program to exhibit undefined behavior!</p><p>Let’s break down this example line by line:</p><pre class="language-cpp line-numbers"><code>    MyString hello{ "Hello, world!" };</code></pre><p>This line is harmless enough. This calls the MyString constructor, which allocates some memory, sets hello.m_data to point to it, and then copies the string “Hello, world!” into it.</p><pre class="language-cpp line-numbers"><code>    MyString copy{ hello }; // use default copy constructor</code></pre><p>This line seems harmless enough as well, but it’s actually the source of our problem! When this line is evaluated, C++ will use the default copy constructor (because we haven’t provided our own). This copy constructor will do a shallow copy, initializing copy.m_data to the same address of hello.m_data. As a result, copy.m_data and hello.m_data are now both pointing to the same piece of memory!</p><pre class="language-cpp line-numbers"><code>} // copy gets destroyed here</code></pre><p>When copy goes out of scope, the MyString destructor is called on copy. The destructor deletes the dynamically allocated memory that both copy.m_data and hello.m_data are pointing to! Consequently, by deleting copy, we’ve also (inadvertently) affected hello. Variable copy then gets destroyed, but hello.m_data is left pointing to the deleted (invalid) memory!</p><pre class="language-cpp line-numbers"><code>    std::cout &lt;&lt; hello.getString() &lt;&lt; '\n'; // this will have undefined behavior</code></pre><p>Now you can see why this program has undefined behavior. We deleted the string that hello was pointing to, and now we are trying to print the value of memory that is no longer allocated.</p><p>The root of this problem is the shallow copy done by the copy constructor -- doing a shallow copy on pointer values in a copy constructor or overloaded assignment operator is almost always asking for trouble.</p><p><strong>Deep copying</strong></p><p>One answer to this problem is to do a deep copy on any non-null pointers being copied. A <strong>deep copy</strong> allocates memory for the copy and then copies the actual value, so that the copy lives in distinct memory from the source. This way, the copy and source are distinct and will not affect each other in any way. Doing deep copies requires that we write our own copy constructors and overloaded assignment operators.</p><p>Let’s go ahead and show how this is done for our MyString class:</p><pre class="language-cpp line-numbers"><code>// assumes m_data is initialized</code><code>void MyString::deepCopy(const MyString&amp; source)</code><code>{</code><code>    // first we need to deallocate any value that this string is holding!</code><code>    delete[] m_data;</code><code></code><code>    // because m_length is not a pointer, we can shallow copy it</code><code>    m_length = source.m_length;</code><code></code><code>    // m_data is a pointer, so we need to deep copy it if it is non-null</code><code>    if (source.m_data)</code><code>    {</code><code>        // allocate memory for our copy</code><code>        m_data = new char[m_length];</code><code></code><code>        // do the copy</code><code>        for (int i{ 0 }; i &lt; m_length; ++i)</code><code>            m_data[i] = source.m_data[i];</code><code>    }</code><code>    else</code><code>        m_data = nullptr;</code><code>}</code><code></code><code>// Copy constructor</code><code>MyString::MyString(const MyString&amp; source)</code><code>{</code><code>    deepCopy(source);</code><code>}</code></pre><p>As you can see, this is quite a bit more involved than a simple shallow copy! First, we have to check to make sure source even has a string (line 11). If it does, then we allocate enough memory to hold a copy of that string (line 14). Finally, we have to manually copy the string (lines 17 and 18).</p><p>Now let’s do the overloaded assignment operator. The overloaded assignment operator is slightly trickier:</p><pre class="language-cpp line-numbers"><code>// Assignment operator</code><code>MyString&amp; MyString::operator=(const MyString&amp; source)</code><code>{</code><code>    // check for self-assignment</code><code>    if (this != &amp;source)</code><code>    {</code><code>        // now do the deep copy</code><code>        deepCopy(source);</code><code>    }</code><code></code><code>    return *this;</code><code>}</code></pre><p>Note that our assignment operator is very similar to our copy constructor, but there are three major differences:</p><ul><li>We added a self-assignment check.</li><li>We return *this so we can chain the assignment operator.</li><li>We need to explicitly deallocate any value that the string is already holding (so we don’t have a memory leak when m_data is reallocated later). This is handled inside deepCopy().</li></ul><p>When the overloaded assignment operator is called, the item being assigned to may already contain a previous value, which we need to make sure we clean up before we assign memory for new values. For non-dynamically allocated variables (which are a fixed size), we don’t have to bother because the new value just overwrites the old one. However, for dynamically allocated variables, we need to explicitly deallocate any old memory before we allocate any new memory. If we don’t, the code will not crash, but we will have a memory leak that will eat away our free memory every time we do an assignment!</p><p><strong>A better solution</strong></p><p>Classes in the standard library that deal with dynamic memory, such as std::string and std::vector, handle all of their memory management, and have overloaded copy constructors and assignment operators that do proper deep copying. So instead of doing your own memory management, you can just initialize or assign them like normal fundamental variables! That makes these classes simpler to use, less error-prone, and you don’t have to spend time writing your own overloaded functions!</p><p><strong>Summary</strong></p><ul><li>The default copy constructor and default assignment operators do shallow copies, which is fine for classes that contain no dynamically allocated variables.</li><li>Classes with dynamically allocated variables need to have a copy constructor and assignment operator that do a deep copy.</li><li>Favor using classes in the standard library over doing your own memory management.</li></ul></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">14.17 — Overloading operators and function templates</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/function-template-instantiation/">8.14 -- Function template instantiation</a>, we discussed how the compiler will use function templates to instantiate functions, which are then compiled. We also noted that these functions may not compile, if the code in the function template tries to perform some operation that the actual type doesn’t support (such as adding integer value <code>1</code> to a <code>std::string</code>).</p><p>In this lesson, we’ll take a look at a few examples where our instantiated functions won’t compile because our actual class types don’t support those operators, and show how we can define those operators so that the instantiated functions will then compile.</p><br><h3>Operators, function calls, and function templates</h3><p>First, let’s create a simple class:</p><pre class="language-cpp line-numbers"><code>class Cents</code><code>{</code><code>private:</code><code>    int m_cents{};</code><code>public:</code><code>    Cents(int cents)</code><code>        : m_cents { cents }</code><code>    {</code><code>    }</code><code></code><code>    friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; ostr, const Cents&amp; c)</code><code>    {</code><code>        ostr &lt;&lt; c.m_cents;</code><code>        return ostr;</code><code>    }</code><code>};</code></pre><p>and define a <code>max</code> function template:</p><pre class="language-cpp line-numbers"><code>template <typename t=""></typename></code><code>const T&amp; max(T x, T y)</code><code>{</code><code>    return (x &lt; y) ? y : x;</code><code>}</code></pre><p>Now, let’s see what happens when we try to call <code>max()</code> with object of type <code>Cents</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>    int m_cents{};</code><code>public:</code><code>    Cents(int cents)</code><code>        : m_cents { cents }</code><code>    {</code><code>    }</code><code></code><code>    friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; ostr, const Cents&amp; c)</code><code>    {</code><code>        ostr &lt;&lt; c.m_cents;</code><code>        return ostr;</code><code>    }</code><code>};</code><code></code><code>template <typename t=""></typename></code><code>const T&amp; max(const T&amp; x, const T&amp; y)</code><code>{</code><code>    return (x &lt; y) ? y : x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Cents nickel{ 5 };</code><code>    Cents dime{ 10 };</code><code></code><code>    Cents bigger = max(nickel, dime);</code><code>    std::cout &lt;&lt; bigger &lt;&lt; " is bigger\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>C++ will create a template instance for max() that looks like this:</p><pre class="language-cpp line-numbers"><code>template &lt;&gt;</code><code>const Cents&amp; max(const Cents&amp; x, const Cents&amp; y)</code><code>{</code><code>    return (x &lt; y) ? y : x;</code><code>}</code></pre><p>And then it will try to compile this function. See the problem here? C++ has no idea how to evaluate <code>x &lt; y</code> when <code>x</code> and <code>y</code> are of type <code>Cents</code>! Consequently, this will produce a compile error.</p><p>To get around this problem, simply overload <code>operator&lt;</code> for any class we wish to use <code>max</code> with:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>    int m_cents {};</code><code>public:</code><code>    Cents(int cents)</code><code>        : m_cents { cents }</code><code>    {</code><code>    }</code><code>    </code><code>    friend bool operator&lt; (const Cents&amp; c1, const Cents&amp; c2)</code><code>    {</code><code>        return (c1.m_cents &lt; c2.m_cents);</code><code>    }</code><code></code><code>    friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; ostr, const Cents&amp; c)</code><code>    {</code><code>        ostr &lt;&lt; c.m_cents;</code><code>        return ostr;</code><code>    }</code><code>};</code><code></code><code>template <typename t=""></typename></code><code>const T&amp; max(const T&amp; x, const T&amp; y)</code><code>{</code><code>    return (x &lt; y) ? y : x;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Cents nickel{ 5 };</code><code>    Cents dime { 10 };</code><code></code><code>    Cents bigger = max(nickel, dime);</code><code>    std::cout &lt;&lt; bigger &lt;&lt; " is bigger\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This works as expected, and prints:</p><pre>10 is bigger
</pre><br><h3>Another example</h3><p>Let’s do one more example of a function template not working because of missing overloaded operators.</p><p>The following function template will calculate the average of a number of objects in an array:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>T average(const T* myArray, int numValues)</code><code>{</code><code>    T sum { 0 };</code><code>    for (int count { 0 }; count &lt; numValues; ++count)</code><code>        sum += myArray[count];</code><code></code><code>    sum /= numValues;</code><code>    return sum;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int intArray[] { 5, 3, 2, 1, 4 };</code><code>    std::cout &lt;&lt; average(intArray, 5) &lt;&lt; '\n';</code><code></code><code>    double doubleArray[] { 3.12, 3.45, 9.23, 6.34 };</code><code>    std::cout &lt;&lt; average(doubleArray, 4) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This produces the values:</p><pre>3
5.535
</pre><p>As you can see, it works great for built-in types!</p><p>Now let’s see what happens when we call this function on our <code>Cents</code> class:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>T average(const T* myArray, int numValues)</code><code>{</code><code>    T sum { 0 };</code><code>    for (int count { 0 }; count &lt; numValues; ++count)</code><code>        sum += myArray[count];</code><code></code><code>    sum /= numValues;</code><code>    return sum;</code><code>}</code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>    int m_cents {};</code><code>public:</code><code>    Cents(int cents)</code><code>        : m_cents { cents }</code><code>    {</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Cents centsArray[] { Cents { 5 }, Cents { 10 }, Cents { 15 }, Cents { 14 } };</code><code>    std::cout &lt;&lt; average(centsArray, 4) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>The compiler goes berserk and produces a ton of error messages! The first error message will be something like this:</p><pre>error C2679: binary &lt;&lt; : no operator found which takes a right-hand operand of type Cents (or there is no acceptable conversion)
</pre><p>Remember that <code>average()</code> returns a <code>Cents</code> object, and we are trying to stream that object to <code>std::cout</code> using <code>operator&lt;&lt;</code>. However, we haven’t defined the <code>operator&lt;&lt;</code> for our <code>Cents</code> class yet. Let’s do that:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>T average(const T* myArray, int numValues)</code><code>{</code><code>    T sum { 0 };</code><code>    for (int count { 0 }; count &lt; numValues; ++count)</code><code>        sum += myArray[count];</code><code></code><code>    sum /= numValues;</code><code>    return sum;</code><code>}</code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>    int m_cents {};</code><code>public:</code><code>    Cents(int cents)</code><code>        : m_cents { cents }</code><code>    {</code><code>    }</code><code></code><code>    friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Cents&amp; cents)</code><code>    {</code><code>        out &lt;&lt; cents.m_cents &lt;&lt; " cents ";</code><code>        return out;</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Cents centsArray[] { Cents { 5 }, Cents { 10 }, Cents { 15 }, Cents { 14 } };</code><code>    std::cout &lt;&lt; average(centsArray, 4) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>If we compile again, we will get another error:</p><pre>error C2676: binary += : Cents does not define this operator or a conversion to a type acceptable to the predefined operator</pre><p>This error is actually being caused by the function template instance created when we call <code>average(const Cents*, int)</code>. Remember that when we call a templated function, the compiler “stencils” out a copy of the function where the template type parameters (the placeholder types) have been replaced with the actual types in the function call. Here is the function template instance for <code>average()</code> when <code>T</code> is a <code>Cents</code> object:</p><pre class="language-cpp line-numbers"><code>template &lt;&gt;</code><code>Cents average(const Cents* myArray, int numValues)</code><code>{</code><code>    Cents sum { 0 };</code><code>    for (int count { 0 }; count &lt; numValues; ++count)</code><code>        sum += myArray[count];</code><code></code><code>    sum /= numValues;</code><code>    return sum;</code><code>}</code></pre><p>The reason we are getting an error message is because of the following line:</p><pre class="language-cpp line-numbers"><code>        sum += myArray[count];</code></pre><p>In this case, <code>sum</code> is a <code>Cents</code> object, but we have not defined <code>operator+=</code> for <code>Cents</code> objects! We will need to define this function in order for <code>average()</code> to be able to work with <code>Cents</code>. Looking forward, we can see that <code>average()</code> also uses the <code>operator/=</code>, so we will go ahead and define that as well:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>T average(const T* myArray, int numValues)</code><code>{</code><code>    T sum { 0 };</code><code>    for (int count { 0 }; count &lt; numValues; ++count)</code><code>        sum += myArray[count];</code><code></code><code>    sum /= numValues;</code><code>    return sum;</code><code>}</code><code></code><code>class Cents</code><code>{</code><code>private:</code><code>    int m_cents {};</code><code>public:</code><code>    Cents(int cents)</code><code>        : m_cents { cents }</code><code>    {</code><code>    }</code><code></code><code>    friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Cents&amp; cents)</code><code>    {</code><code>        out &lt;&lt; cents.m_cents &lt;&lt; " cents ";</code><code>        return out;</code><code>    }</code><code></code><code>    Cents&amp; operator+= (const Cents ¢s)</code><code>    {</code><code>        m_cents += cents.m_cents;</code><code>        return *this;</code><code>    }</code><code></code><code>    Cents&amp; operator/= (int x)</code><code>    {</code><code>        m_cents /= x;</code><code>        return *this;</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Cents centsArray[] { Cents { 5 }, Cents { 10 }, Cents { 15 }, Cents { 14 } };</code><code>    std::cout &lt;&lt; average(centsArray, 4) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Finally, our code will compile and run! Here is the result:</p><pre>11 cents
</pre><p>Note that we didn’t have to modify <code>average()</code> at all to make it work with objects of type <code>Cents</code>. We simply had to define the operators used to implement <code>average()</code> for the <code>Cents</code> class, and the compiler took care of the rest!</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">14.x — Chapter 14 comprehensive quiz</h1></header><div class="entry-content" itemprop="articleBody"><p>In this chapter, we explored topics related to operator overloading, as well as overloaded typecasts, and topics related to the copy constructor.</p><p><strong>Summary</strong></p><p>Operator overloading is a variant of function overloading that lets you overload operators for your classes. When operators are overloaded, the intent of the operators should be kept as close to the original intent of the operators as possible. If the meaning of an operator when applied to a custom class is not clear and intuitive, use a named function instead.</p><p>Operators can be overloaded as a normal function, a friend function, or a member function. The following rules of thumb can help you determine which form is best for a given situation:</p><ul><li>If you’re overloading assignment (=), subscript ([]), function call (()), or member selection (-&gt;), do so as a member function.</li><li>If you’re overloading a unary operator, do so as a member function.</li><li>If you’re overloading a binary operator that modifies its left operand (e.g. operator+=), do so as a member function if you can.</li><li>If you’re overloading a binary operator that does not modify its left operand (e.g. operator+), do so as a normal function or friend function.</li></ul><p>Typecasts can be overloaded to provide conversion functions, which can be used to explicitly or implicitly convert your class into another type.</p><p>A copy constructor is a special type of constructor used to initialize an object from another object of the same type. Copy constructors are used for direct/uniform initialization from an object of the same type, copy initialization (Fraction f = Fraction(5,3)), and when passing or returning a parameter by value.</p><p>If you do not supply a copy constructor, the compiler will create one for you. Compiler-provided copy constructors will use memberwise initialization, meaning each member of the copy is initialized from the original member. The copy constructor may be elided for optimization purposes, even if it has side-effects, so do not rely on your copy constructor actually executing.</p><p>Constructors are considered converting constructors by default, meaning that the compiler will use them to implicitly convert objects of other types into objects of your class. You can avoid this by using the explicit keyword in front of your constructor. You can also delete functions within your class, including the copy constructor and overloaded assignment operator if desired. This will cause a compiler error if a deleted function would be called.</p><p>The assignment operator can be overloaded to allow assignment to your class. If you do not provide an overloaded assignment operator, the compiler will create one for you. Overloaded assignment operators should always include a self-assignment check (unless it’s handled naturally, or you’re using the copy and swap idiom).</p><p>New programmers often mix up when the assignment operator vs copy constructor are used, but it’s fairly straightforward:</p><ul><li>If a new object has to be created before the copying can occur, the copy constructor is used (note: this includes passing or returning objects by value).</li><li>If a new object does not have to be created before the copying can occur, the assignment operator is used.</li></ul><p>By default, the copy constructor and assignment operators provided by the compiler do a memberwise initialization or assignment, which is a shallow copy. If your class dynamically allocates memory, this will likely lead to problems, as multiple objects will end up pointing to the same allocated memory. In this case, you’ll need to explicitly define these in order to do a deep copy. Even better, avoid doing your own memory management if you can and use classes from the standard library.</p><p><strong>Quiz Time</strong></p><ol start="1"><li>Assuming Point is a class and point is an instance of that class, should you use a normal/friend or member function overload for the following operators?</li></ol><p>1a) point + point<br>1b) -point<br>1c) std::cout &lt;&lt; point<br>1d) point = 5;</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>1a) binary operator+ is best implemented as a normal/friend function.<br>1b) unary operator- is best implemented as a member function.<br>1c) operator&lt;&lt; must be implemented as a normal/friend function.<br>1d) operator= must be implemented as a member function.</p></div><ol start="2"><li>Write a class named Average that will keep track of the average of all integers passed to it. Use two members: The first one should be type <code>std::int_least32_t</code>, and used to keep track of the sum of all the numbers you’ve seen so far. The second should be of type <code>std::int_least8_t</code>, and used to keep track of how many numbers you’ve seen so far. You can divide them to find your average.</li></ol><p>2a) Write all of the functions necessary for the following program to run:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	Average avg{};</code><code>	</code><code>	avg += 4;</code><code>	std::cout &lt;&lt; avg &lt;&lt; '\n'; // 4 / 1 = 4</code><code>	</code><code>	avg += 8;</code><code>	std::cout &lt;&lt; avg &lt;&lt; '\n'; // (4 + 8) / 2 = 6</code><code></code><code>	avg += 24;</code><code>	std::cout &lt;&lt; avg &lt;&lt; '\n'; // (4 + 8 + 24) / 3 = 12</code><code></code><code>	avg += -10;</code><code>	std::cout &lt;&lt; avg &lt;&lt; '\n'; // (4 + 8 + 24 - 10) / 4 = 6.5</code><code></code><code>	(avg += 6) += 10; // 2 calls chained together</code><code>	std::cout &lt;&lt; avg &lt;&lt; '\n'; // (4 + 8 + 24 - 10 + 6 + 10) / 6 = 7</code><code></code><code>	Average copy{ avg };</code><code>	std::cout &lt;&lt; copy &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>and produce the result:</p><pre>4
6
12
6.5
7
7
</pre><p>Hint: Remember that 8 bit integers are usually <code>char</code>s, so <code>std::cout</code> treats them accordingly.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cstdint> // for fixed width integers</cstdint></code><code></code><code>class Average</code><code>{</code><code>private:</code><code>	std::int_least32_t m_total{ 0 }; // the sum of all numbers we've seen so far</code><code>	std::int_least8_t m_numbers{ 0 }; // the count of numbers we've seen so far</code><code></code><code>public:</code><code>	Average()</code><code>	{</code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Average&amp; average)</code><code>	{</code><code>		// Our average is the sum of the numbers we've seen divided by the count of the numbers we've seen</code><code>		// We need to remember to do a floating point division here, not an integer division</code><code>		out &lt;&lt; static_cast<double>(average.m_total) / average.m_numbers;</double></code><code></code><code>		return out;</code><code>	}</code><code></code><code>	// Because operator+= modifies its left operand, we'll write it as a member</code><code>	Average&amp; operator+=(int num)</code><code>	{</code><code>		// Increment our total by the new number</code><code>		m_total += num;</code><code>		// And increase the count by 1</code><code>		++m_numbers;</code><code></code><code>		// return *this in case someone wants to chain +='s together</code><code>		return *this;</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Average avg{};</code><code>	</code><code>	avg += 4;</code><code>	std::cout &lt;&lt; avg &lt;&lt; '\n';</code><code>	</code><code>	avg += 8;</code><code>	std::cout &lt;&lt; avg &lt;&lt; '\n';</code><code></code><code>	avg += 24;</code><code>	std::cout &lt;&lt; avg &lt;&lt; '\n';</code><code></code><code>	avg += -10;</code><code>	std::cout &lt;&lt; avg &lt;&lt; '\n';</code><code></code><code>	(avg += 6) += 10; // 2 calls chained together</code><code>	std::cout &lt;&lt; avg &lt;&lt; '\n';</code><code></code><code>	Average copy{ avg };</code><code>	std::cout &lt;&lt; copy &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre></div><p>2b) Does this class need an explicit copy constructor or assignment operator?</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>No. Because using memberwise initialization/copy is fine here, using the compiler provided defaults is acceptable.</p></div><ol start="3"><li>Write your own integer array class named IntArray from scratch (do not use std::array or std::vector). Users should pass in the size of the array when it is created, and the array should be dynamically allocated. Use assert statements to guard against bad data. Create any constructors or overloaded operators needed to make the following program operate correctly:</li></ol><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>IntArray fillArray()</code><code>{</code><code>	IntArray a(5);</code><code></code><code>	a[0] = 5;</code><code>	a[1] = 8;</code><code>	a[2] = 2;</code><code>	a[3] = 3;</code><code>	a[4] = 6;</code><code></code><code>	return a;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	IntArray a{ fillArray() };</code><code>	std::cout &lt;&lt; a &lt;&lt; '\n';</code><code></code><code>	auto&amp; ref{ a }; // we're using this reference to avoid compiler self-assignment errors</code><code>	a = ref;</code><code></code><code>	IntArray b(1);</code><code>	b = a;</code><code></code><code>	std::cout &lt;&lt; b &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This program should print:</p><pre>5 8 2 3 6
5 8 2 3 6
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cassert> // for assert</cassert></code><code></code><code>class IntArray</code><code>{</code><code>private:</code><code>	int m_length{ 0 };</code><code>	int* m_array{ nullptr };</code><code></code><code>public:</code><code>	IntArray(int length)</code><code>		: m_length{ length }</code><code>	{</code><code>		assert(length &gt; 0 &amp;&amp; "IntArray length should be a positive integer");</code><code></code><code>		m_array = new int[m_length]{};</code><code>	}</code><code></code><code>	// Copy constructor that does a deep copy</code><code>	IntArray(const IntArray&amp; array)</code><code>		: m_length{ array.m_length }</code><code>	{</code><code>		// Allocate a new array</code><code>		m_array = new int[m_length];</code><code></code><code>		// Copy elements from original array to new array</code><code>		for (int count{ 0 }; count &lt; array.m_length; ++count)</code><code>			m_array[count] = array.m_array[count];</code><code>	}</code><code></code><code>	~IntArray()</code><code>	{</code><code>		delete[] m_array;</code><code>	}</code><code>	</code><code>	// If you're getting crazy values here you probably forgot to do a deep copy in your copy constructor</code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const IntArray&amp; array)</code><code>	{</code><code>		for (int count{ 0 }; count &lt; array.m_length; ++count)</code><code>		{</code><code>			out &lt;&lt; array.m_array[count] &lt;&lt; ' ';</code><code>		}</code><code>		return out;</code><code>	}</code><code></code><code>	int&amp; operator[] (const int index)</code><code>	{</code><code>		assert(index &gt;= 0);</code><code>		assert(index &lt; m_length);</code><code>		return m_array[index];</code><code>    }</code><code>	</code><code>	// Assignment operator that does a deep copy</code><code>	IntArray&amp; operator= (const IntArray&amp; array)</code><code>	{</code><code>		// self-assignment guard</code><code>		if (this == &amp;array)</code><code>			return *this;</code><code></code><code>		// If this array already exists, delete it so we don't leak memory</code><code>		delete[] m_array;</code><code></code><code>		m_length = array.m_length;</code><code></code><code>		// Allocate a new array</code><code>		m_array = new int[m_length];</code><code></code><code>		// Copy elements from original array to new array</code><code>		for (int count{ 0 }; count &lt; array.m_length; ++count)</code><code>			m_array[count] = array.m_array[count];</code><code></code><code>		return *this;</code><code>	}</code><code></code><code>};</code><code></code><code>IntArray fillArray()</code><code>{</code><code>	IntArray a(5);</code><code>	a[0] = 5;</code><code>	a[1] = 8;</code><code>	a[2] = 2;</code><code>	a[3] = 3;</code><code>	a[4] = 6;</code><code></code><code>	return a;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	IntArray a{ fillArray() };</code><code></code><code>	// If you're getting crazy values here you probably forgot to do a deep copy in your copy constructor</code><code>	std::cout &lt;&lt; a &lt;&lt; '\n';</code><code></code><code>	auto&amp; ref{ a }; // we're using this reference to avoid compiler self-assignment errors</code><code>	a = ref;</code><code></code><code>	IntArray b(1);</code><code>	b = a;</code><code></code><code>	// If you're getting crazy values here you probably forgot to do a deep copy in your assignment operator</code><code>	// or you forgot your self-assignment check</code><code>	std::cout &lt;&lt; b &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre></div><ol start="4"><li>Extra credit: This one is a little more tricky. A floating point number is a number with a decimal where the number of digits after the decimal can be variable. A fixed point number is a number with a fractional component where the number of digits in the fractional portion is fixed.</li></ol><p>In this quiz, we’re going to write a class to implement a fixed point number with two fractional digits (e.g. 12.34, 3.00, or 1278.99). Assume that the range of the class should be -32768.99 to 32767.99, that the fractional component should hold any two digits, that we don’t want precision errors, and that we want to conserve space.</p><p>4a) What type of member variable(s) do you think we should use to implement our fixed point number with 2 digits after the decimal? (Make sure you read the answer before proceeding with the next questions)</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><p>There are many different ways to implement a fixed point number. Because a fixed point number is essentially a subcase of a floating point number (where the number of digits after the decimal is fixed instead of variable), using a floating point number might seem like an obvious choice. But floating point numbers have precision issues. With a fixed number of decimal digits, we can reasonably enumerate all the possible fractional values (in our case, .00 to .99), so using a data type that has precision issues isn’t the best choice.</p><p>A better solution would be to use a 16-bit signed integer to hold the non-fractional part of the number, and an 8-bit signed integer to hold the fractional component.</p></div><p>4b) Write a class named FixedPoint2 that implements the recommended solution from the previous question. If either (or both) of the non-fractional and fractional part of the number are negative, the number should be treated as negative. Provide the overloaded operators and constructors required for the following program to run:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	FixedPoint2 a{ 34, 56 };</code><code>	std::cout &lt;&lt; a &lt;&lt; '\n';</code><code></code><code>	FixedPoint2 b{ -2, 8 };</code><code>	std::cout &lt;&lt; b &lt;&lt; '\n';</code><code></code><code>	FixedPoint2 c{ 2, -8 };</code><code>	std::cout &lt;&lt; c &lt;&lt; '\n';</code><code></code><code>	FixedPoint2 d{ -2, -8 };</code><code>	std::cout &lt;&lt; d &lt;&lt; '\n';</code><code></code><code>	FixedPoint2 e{ 0, -5 };</code><code>	std::cout &lt;&lt; e &lt;&lt; '\n';</code><code></code><code>	std::cout &lt;&lt; static_cast<double>(e) &lt;&lt; '\n';</double></code><code></code><code>	return 0;</code><code>}</code></pre><p>This program should produce the result:</p><pre>34.56
-2.08
-2.08
-2.08
-0.05
-0.05
</pre><p>Hint: To output your number, first cast it to a double.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cstdint> // for fixed width integers</cstdint></code><code></code><code>class FixedPoint2</code><code>{</code><code>private:</code><code>	std::int_least16_t m_base{}; // here's our non-fractional part</code><code>	std::int_least8_t m_decimal{}; // here's our factional part</code><code></code><code>public:</code><code>	FixedPoint2(std::int_least16_t base = 0, std::int_least8_t decimal = 0)</code><code>		: m_base{ base }, m_decimal{ decimal }</code><code>	{</code><code>		// We should handle the case where decimal is &gt; 99 or &lt; -99 here</code><code>		// but will leave as an exercise for the reader</code><code></code><code>		// If either (or both) of the non-fractional and fractional part of the number are negative, the number should be treated as negative</code><code>		if (m_base &lt; 0 || m_decimal &lt; 0)</code><code>		{</code><code>			// Make sure base is negative</code><code>			if (m_base &gt; 0)</code><code>				m_base = -m_base;</code><code>			// Make sure decimal is negative</code><code>			if (m_decimal &gt; 0)</code><code>				m_decimal = -m_decimal;</code><code>		}</code><code>	}</code><code></code><code>	operator double() const</code><code>	{</code><code>		return m_base + (static_cast<double>(m_decimal) / 100);</double></code><code>	}</code><code>};</code><code></code><code>// This doesn't require access to the internals of the class, so it can be defined outside the class</code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const FixedPoint2&amp; fp)</code><code>{</code><code>	out &lt;&lt; static_cast<double>(fp);</double></code><code>	return out;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	FixedPoint2 a{ 34, 56 };</code><code>	std::cout &lt;&lt; a &lt;&lt; '\n';</code><code></code><code>	FixedPoint2 b{ -2, 8 };</code><code>	std::cout &lt;&lt; b &lt;&lt; '\n';</code><code></code><code>	FixedPoint2 c{ 2, -8 };</code><code>	std::cout &lt;&lt; c &lt;&lt; '\n';</code><code></code><code>	FixedPoint2 d{ -2, -8 };</code><code>	std::cout &lt;&lt; d &lt;&lt; '\n';</code><code></code><code>	FixedPoint2 e{ 0, -5 };</code><code>	std::cout &lt;&lt; e &lt;&lt; '\n';</code><code></code><code>	std::cout &lt;&lt; static_cast<double>(e) &lt;&lt; '\n';</double></code><code></code><code>	return 0;</code><code>}</code></pre></div><p>4c) Now add a constructor that takes a double. The follow program should run:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	// Handle cases where the argument is representable directly</code><code>	FixedPoint2 a{ 0.01 };</code><code>	std::cout &lt;&lt; a &lt;&lt; '\n';</code><code></code><code>	FixedPoint2 b{ -0.01 };</code><code>	std::cout &lt;&lt; b &lt;&lt; '\n';</code><code></code><code>	// Handle cases where the argument has some rounding error</code><code>	FixedPoint2 c{ 5.01 }; // stored as 5.0099999... so we'll need to round this</code><code>	std::cout &lt;&lt; c &lt;&lt; '\n';</code><code></code><code>	FixedPoint2 d{ -5.01 }; // stored as -5.0099999... so we'll need to round this</code><code>	std::cout &lt;&lt; d &lt;&lt; '\n';</code><code></code><code>	// Handle case where the argument's decimal rounds to 100 (need to increase base by 1)</code><code>	FixedPoint2 e{ 106.9978 }; // should be stored with base 107 and decimal 0</code><code>	std::cout &lt;&lt; e &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This program should produce the result</p><pre>0.01
-0.01
5.01
-5.01
107
</pre><p>Recommendation: This one will be a bit tricky. Do this one in three steps. First, solve for the cases where the double parameter is representable directly (cases a &amp; b above). Then, update your code to handle the cases where the double parameter has a rounding error (cases c &amp; d). Lastly, handle the edge case where the decimal rounds up to 100 (case e).</p><p>For all cases: <a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">Hint: You can move a digit from the right of the decimal to the left of the decimal by multiplying by 10. Multiply by 100 to move two places.</div><p>For cases a &amp; b: <a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_1'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_1" style="display:none;margin-bottom:1em">Hint: You can get the non-fractional part of a double by static casting the double to an integer. To get the fractional part, you can subtract out the base part.</div><p>For cases c &amp; d: <a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_2'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_2" style="display:none;margin-bottom:1em">Hint: You can round a number (on the left of the decimal) by using the std::round() function (included in header cmath).</div><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cstdint> // for fixed width integers</cstdint></code><code>#include <cmath> // for std::round()</cmath></code><code></code><code>class FixedPoint2</code><code>{</code><code>private:</code><code>	std::int_least16_t m_base{}; // here's our non-fractional part</code><code>	std::int_least8_t m_decimal{}; // here's our factional part</code><code></code><code>public:</code><code>	FixedPoint2(std::int_least16_t base = 0, std::int_least8_t decimal = 0)</code><code>		: m_base{ base }, m_decimal{ decimal }</code><code>	{</code><code>		// We should handle the case where decimal is &gt; 99 or &lt; -99 here</code><code>		// but will leave as an exercise for the reader</code><code></code><code>		// If either (or both) of the non-fractional and fractional part of the number are negative, the number should be treated as negative</code><code>		if (m_base &lt; 0 || m_decimal &lt; 0)</code><code>		{</code><code>			// Make sure base is negative</code><code>			if (m_base &gt; 0)</code><code>				m_base = -m_base;</code><code>			// Make sure decimal is negative</code><code>			if (m_decimal &gt; 0)</code><code>				m_decimal = -m_decimal;</code><code>		}</code><code>	}</code><code></code><code>	FixedPoint2(double d) :</code><code>		m_base{ static_cast<std::int_least16_t>(std::round(d)) },</std::int_least16_t></code><code>		m_decimal{ static_cast<std::int_least8_t>(std::round(d * 100) - m_base * 100) }</std::int_least8_t></code><code>	{</code><code>	}</code><code></code><code></code><code>	operator double() const</code><code>	{</code><code>		return m_base + (static_cast<double>(m_decimal) / 100);</double></code><code>	}</code><code>};</code><code></code><code>// This doesn't require access to the internals of the class, so it can be defined outside the class</code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const FixedPoint2&amp; fp)</code><code>{</code><code>	out &lt;&lt; static_cast<double>(fp);</double></code><code>	return out;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	FixedPoint2 a{ 0.01 };</code><code>	std::cout &lt;&lt; a &lt;&lt; '\n';</code><code></code><code>	FixedPoint2 b{ -0.01 };</code><code>	std::cout &lt;&lt; b &lt;&lt; '\n';</code><code></code><code>	FixedPoint2 c{ 5.01 }; // stored as 5.0099999... so we'll need to round this</code><code>	std::cout &lt;&lt; c &lt;&lt; '\n';</code><code></code><code>	FixedPoint2 d{ -5.01 }; // stored as -5.0099999... so we'll need to round this</code><code>	std::cout &lt;&lt; d &lt;&lt; '\n';</code><code></code><code>	// Handle case where the argument's decimal rounds to 100 (need to increase base by 1)</code><code>	FixedPoint2 e{ 106.9978 }; // should be stored with base 107 and decimal 0</code><code>	std::cout &lt;&lt; e &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre></div><p>4d) Overload operator==, operator&gt;&gt;, operator- (unary), and operator+ (binary).</p><p>The following program should run:</p><pre class="language-cpp line-numbers"><code>void testAddition()</code><code>{</code><code>	// h/t to reader Sharjeel Safdar for this function</code><code>	std::cout &lt;&lt; std::boolalpha;</code><code>	std::cout &lt;&lt; (FixedPoint2{ 0.75 } + FixedPoint2{ 1.23 } == FixedPoint2{ 1.98 }) &lt;&lt; '\n'; // both positive, no decimal overflow</code><code>	std::cout &lt;&lt; (FixedPoint2{ 0.75 } + FixedPoint2{ 1.50 } == FixedPoint2{ 2.25 }) &lt;&lt; '\n'; // both positive, with decimal overflow</code><code>	std::cout &lt;&lt; (FixedPoint2{ -0.75 } + FixedPoint2{ -1.23 } == FixedPoint2{ -1.98 }) &lt;&lt; '\n'; // both negative, no decimal overflow</code><code>	std::cout &lt;&lt; (FixedPoint2{ -0.75 } + FixedPoint2{ -1.50 } == FixedPoint2{ -2.25 }) &lt;&lt; '\n'; // both negative, with decimal overflow</code><code>	std::cout &lt;&lt; (FixedPoint2{ 0.75 } + FixedPoint2{ -1.23 } == FixedPoint2{ -0.48 }) &lt;&lt; '\n'; // second negative, no decimal overflow</code><code>	std::cout &lt;&lt; (FixedPoint2{ 0.75 } + FixedPoint2{ -1.50 } == FixedPoint2{ -0.75 }) &lt;&lt; '\n'; // second negative, possible decimal overflow</code><code>	std::cout &lt;&lt; (FixedPoint2{ -0.75 } + FixedPoint2{ 1.23 } == FixedPoint2{ 0.48 }) &lt;&lt; '\n'; // first negative, no decimal overflow</code><code>	std::cout &lt;&lt; (FixedPoint2{ -0.75 } + FixedPoint2{ 1.50 } == FixedPoint2{ 0.75 }) &lt;&lt; '\n'; // first negative, possible decimal overflow</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	testAddition();</code><code></code><code>	FixedPoint2 a{ -0.48 };</code><code>	std::cout &lt;&lt; a &lt;&lt; '\n';</code><code></code><code>	std::cout &lt;&lt; -a &lt;&lt; '\n';</code><code></code><code>	std::cout &lt;&lt; "Enter a number: "; // enter 5.678</code><code>	std::cin &gt;&gt; a;</code><code>	</code><code>	std::cout &lt;&lt; "You entered: " &lt;&lt; a &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>And produce the output:</p><pre>true
true
true
true
true
true
true
true
-0.48
0.48
Enter a number: 5.678
You entered: 5.68
</pre><p>Hint: Add your two FixedPoint2 together by leveraging the double cast, adding the results, and converting back to a FixedPoint2.<br>Hint: For operator&gt;&gt;, use your double constructor to create an anonymous object of type FixedPoint2, and assign it to your FixedPoint2 function parameter</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_7'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_7" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cstdint> // for fixed width integers</cstdint></code><code>#include <cmath> // for std::round()</cmath></code><code></code><code>class FixedPoint2</code><code>{</code><code>private:</code><code>	std::int_least16_t m_base{}; // here's our non-fractional part</code><code>	std::int_least8_t m_decimal{}; // here's our factional part</code><code></code><code>public:</code><code>	FixedPoint2(std::int_least16_t base = 0, std::int_least8_t decimal = 0)</code><code>		: m_base{ base }, m_decimal{ decimal }</code><code>	{</code><code>		// We should handle the case where decimal is &gt; 99 or &lt; -99 here</code><code>		// but will leave as an exercise for the reader</code><code></code><code>		// If either (or both) of the non-fractional and fractional part of the number are negative, the number should be treated as negative</code><code>		if (m_base &lt; 0 || m_decimal &lt; 0)</code><code>		{</code><code>			// Make sure base is negative</code><code>			if (m_base &gt; 0)</code><code>				m_base = -m_base;</code><code>			// Make sure decimal is negative</code><code>			if (m_decimal &gt; 0)</code><code>				m_decimal = -m_decimal;</code><code>		}</code><code>	}</code><code></code><code>	FixedPoint2(double d):</code><code>		m_base{ static_cast<std::int_least16_t>(std::round(d)) },</std::int_least16_t></code><code>		m_decimal{ static_cast<std::int_least8_t>(std::round(d * 100) - m_base * 100) }</std::int_least8_t></code><code>	{</code><code>	}</code><code></code><code>	operator double() const</code><code>	{</code><code>		return m_base + (static_cast<double>(m_decimal) / 100);</double></code><code>	}</code><code></code><code>	friend bool operator==(const FixedPoint2&amp; fp1, const FixedPoint2&amp; fp2)</code><code>	{</code><code>		return (fp1.m_base == fp2.m_base &amp;&amp; fp1.m_decimal == fp2.m_decimal);</code><code>	}</code><code></code><code>	FixedPoint2 operator-() const</code><code>	{</code><code>		// We need to cast, because the negative sign (-) converts our</code><code>		// narrow integers types to int.</code><code>		return {</code><code>			static_cast<std::int_least16_t>(-m_base),</std::int_least16_t></code><code>			static_cast<std::int_least8_t>(-m_decimal)</std::int_least8_t></code><code>		};</code><code>	}</code><code>};</code><code></code><code>// These don't require access to the internals of the class, so they can be defined outside the class</code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const FixedPoint2&amp; fp)</code><code>{</code><code>	out &lt;&lt; static_cast<double>(fp);</double></code><code>	return out;</code><code>}</code><code></code><code>std::istream&amp; operator&gt;&gt;(std::istream&amp; in, FixedPoint2&amp; fp)</code><code>{</code><code>	double d{};</code><code>	in &gt;&gt; d;</code><code>	fp = FixedPoint2{ d };</code><code></code><code>	return in;</code><code>}</code><code></code><code>FixedPoint2 operator+(const FixedPoint2&amp; fp1, const FixedPoint2&amp; fp2)</code><code>{</code><code>	return { static_cast<double>(fp1) + static_cast<double>(fp2) };</double></double></code><code>}</code><code></code><code>void testAddition()</code><code>{</code><code>	// h/t to reader Sharjeel Safdar for this function</code><code>	std::cout &lt;&lt; std::boolalpha;</code><code>	std::cout &lt;&lt; (FixedPoint2{ 0.75 } + FixedPoint2{ 1.23 } == FixedPoint2{ 1.98 }) &lt;&lt; '\n'; // both positive, no decimal overflow</code><code>	std::cout &lt;&lt; (FixedPoint2{ 0.75 } + FixedPoint2{ 1.50 } == FixedPoint2{ 2.25 }) &lt;&lt; '\n'; // both positive, with decimal overflow</code><code>	std::cout &lt;&lt; (FixedPoint2{ -0.75 } + FixedPoint2{ -1.23 } == FixedPoint2{ -1.98 }) &lt;&lt; '\n'; // both negative, no decimal overflow</code><code>	std::cout &lt;&lt; (FixedPoint2{ -0.75 } + FixedPoint2{ -1.50 } == FixedPoint2{ -2.25 }) &lt;&lt; '\n'; // both negative, with decimal overflow</code><code>	std::cout &lt;&lt; (FixedPoint2{ 0.75 } + FixedPoint2{ -1.23 } == FixedPoint2{ -0.48 }) &lt;&lt; '\n'; // second negative, no decimal overflow</code><code>	std::cout &lt;&lt; (FixedPoint2{ 0.75 } + FixedPoint2{ -1.50 } == FixedPoint2{ -0.75 }) &lt;&lt; '\n'; // second negative, possible decimal overflow</code><code>	std::cout &lt;&lt; (FixedPoint2{ -0.75 } + FixedPoint2{ 1.23 } == FixedPoint2{ 0.48 }) &lt;&lt; '\n'; // first negative, no decimal overflow</code><code>	std::cout &lt;&lt; (FixedPoint2{ -0.75 } + FixedPoint2{ 1.50 } == FixedPoint2{ 0.75 }) &lt;&lt; '\n'; // first negative, possible decimal overflow</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	testAddition();</code><code></code><code>	FixedPoint2 a{ -0.48 };</code><code>	std::cout &lt;&lt; a &lt;&lt; '\n';</code><code></code><code>	std::cout &lt;&lt; -a &lt;&lt; '\n';</code><code></code><code>	std::cout &lt;&lt; "Enter a number: "; // enter 5.678</code><code>	std::cin &gt;&gt; a;</code><code>	</code><code>	std::cout &lt;&lt; "You entered: " &lt;&lt; a &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">16.1 — Object relationships</h1></header><div class="entry-content" itemprop="articleBody"><p>Life is full of recurring patterns, relationships, and hierarchies between objects. By exploring and understanding these, we can gain insight into how real-life objects behave, enhancing our understanding of those objects.</p><p>For example, let’s say one day you’re walking down the street, and you see a bright yellow object attached to a green shrubby object. You’d probably recognize that the bright yellow thing is a flower, and the green shrubby thing is a plant. Even though you’d never seen this particular type of plant before, you’d know that the green things are leaves, collecting sunlight. You’d know that the flower helps the plant propagate itself. You’d also know that if you killed the plant, the flower would die too.</p><p>But how can you know all of this without ever encountering a plant of this type before? You know this because you understand the abstract concept of plants, and recognize that this plant is an instantiation of that abstraction. You know that most plants are composed (in part) of leaves, and some have flowers. You know that the leaves interact with the sunlight (even if you don’t know how, exactly), and that the flower’s existence depends on the plant. Because you know all of these things about plants in general, you can infer a lot about this plant.</p><p>Similarly, programming is also full of recurring patterns, relationships and hierarchies. Particularly when it comes to programming objects, the same patterns that govern real-life objects are applicable to the programming objects we create ourselves. By examining these in more detail, we can better understand how to improve code reusability and write classes that are more extensible.</p><p>In previous chapters, we’ve already explored some ideas around recurring patterns: we’ve created loops and functions to allow us to do a particular task many times. Additionally, we’ve created our own enums, structs, and classes to allow us to instantiate objects of a given type.</p><p>We’ve also explored some primitive forms of hierarchy, such as arrays (which allow us to group elements into a larger structure) and recursion, where a function calls a derivative version of itself.</p><p>However, we haven’t yet focused much on the relationship between objects, particularly as it relates to programming.</p><p><strong>Relationships between objects</strong></p><p>There are many different kinds of relationships two objects may have in real-life, and we use specific “relation type” words to describe these relationships. For example: a square “is-a” shape. A car “has-a” steering wheel. A computer programmer “uses-a” keyboard. A flower “depends-on” a bee for pollination. A student is a “member-of” a class. And your brain exists as “part-of” you (at least, we can reasonably assume so if you’ve gotten this far).</p><p>All of these relation types have useful analogies in C++.</p><p>In this chapter, we’ll explore the nuances of the relation types “part-of”, “has-a”, “uses-a”, “depends-on”, and “member-of”, and show how they can be useful in the context of C++ classes. We’ll also explore a couple of related topics that don’t fit nicely anywhere else.</p><p>Then we’ll devote the following two chapters to exploring “is-a” relationships, via C++’s inheritance model and virtual functions. Yup, it’s a biggie.</p><p>Alright, enough context setting. Let’s get to it.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">16.2 — Composition</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Object composition</h3><p>In real-life, complex objects are often built from smaller, simpler objects. For example, a car is built using a metal frame, an engine, some tires, a transmission, a steering wheel, and a large number of other parts. A personal computer is built from a CPU, a motherboard, some memory, etc… Even you are built from smaller parts: you have a head, a body, some legs, arms, and so on. This process of building complex objects from simpler ones is called <strong>object composition</strong>.</p><p>Broadly speaking, object composition models a “has-a” relationship between two objects. A car “has-a” transmission. Your computer “has-a” CPU. You “have-a” heart. The complex object is sometimes called the whole, or the parent. The simpler object is often called the part, child, or component.</p><p>In C++, you’ve already seen that structs and classes can have data members of various types (such as fundamental types or other classes). When we build classes with data members, we’re essentially constructing a complex object from simpler parts, which is object composition. For this reason, structs and classes are sometimes referred to as <strong>composite types</strong>.</p><p>Object Composition is useful in a C++ context because it allows us to create complex classes by combining simpler, more easily manageable parts. This reduces complexity, and allows us to write code faster and with less errors because we can reuse code that has already been written, tested, and verified as working.</p><br><h3>Types of object composition</h3><p>There are two basic subtypes of object composition: composition and aggregation. We’ll examine composition in this lesson, and aggregation in the next.</p><p>A note on terminology: the term “composition” is often used to refer to both composition and aggregation, not just to the composition subtype. In this tutorial, we’ll use the term “object composition” when we’re referring to both, and “composition” when we’re referring specifically to the composition subtype.</p><br><h3>Composition</h3><p>To qualify as a <strong>composition</strong>, an object and a part must have the following relationship:</p><ul><li>The part (member) is part of the object (class)</li><li>The part (member) can only belong to one object (class) at a time</li><li>The part (member) has its existence managed by the object (class)</li><li>The part (member) does not know about the existence of the object (class)</li></ul><p>A good real-life example of a composition is the relationship between a person’s body and a heart. Let’s examine these in more detail.</p><p>Composition relationships are part-whole relationships where the part must constitute part of the whole object. For example, a heart is a part of a person’s body. The part in a composition can only be part of one object at a time. A heart that is part of one person’s body can not be part of someone else’s body at the same time.</p><p>In a composition relationship, the object is responsible for the existence of the parts. Most often, this means the part is created when the object is created, and destroyed when the object is destroyed. But more broadly, it means the object manages the part’s lifetime in such a way that the user of the object does not need to get involved. For example, when a body is created, the heart is created too. When a person’s body is destroyed, their heart is destroyed too. Because of this, composition is sometimes called a “death relationship”.</p><p>And finally, the part doesn’t know about the existence of the whole. Your heart operates blissfully unaware that it is part of a larger structure. We call this a <strong>unidirectional</strong> relationship, because the body knows about the heart, but not the other way around.</p><p>Note that composition has nothing to say about the transferability of parts. A heart can be transplanted from one body to another. However, even after being transplanted, it still meets the requirements for a composition (the heart is now owned by the recipient, and can only be part of the recipient object unless transferred again).</p><p>Our ubiquitous Fraction class is a great example of a composition:</p><pre class="language-cpp line-numbers"><code>class Fraction</code><code>{</code><code>private:</code><code>	int m_numerator;</code><code>	int m_denominator;</code><code> </code><code>public:</code><code>	Fraction(int numerator=0, int denominator=1)</code><code>		: m_numerator{ numerator }, m_denominator{ denominator }</code><code>	{</code><code>	}</code><code>};</code></pre><p>This class has two data members: a numerator and a denominator. The numerator and denominator are part of the Fraction (contained within it). They can not belong to more than one Fraction at a time. The numerator and denominator don’t know they are part of a Fraction, they just hold integers. When a Fraction instance is created, the numerator and denominator are created. When the fraction instance is destroyed, the numerator and denominator are destroyed as well.</p><p>While object composition models has-a type relationships (a body has-a heart, a fraction has-a denominator), we can be more precise and say that composition models “part-of” relationships (a heart is part-of a body, a numerator is part of a fraction). Composition is often used to model physical relationships, where one object is physically contained inside another.</p><p>The parts of a composition can be singular or multiplicative -- for example, a heart is a singular part of the body, but a body contains 10 fingers (which could be modeled as an array).</p><br><h3>Implementing compositions</h3><p>Compositions are one of the easiest relationship types to implement in C++. They are typically created as structs or classes with normal data members. Because these data members exist directly as part of the struct/class, their lifetimes are bound to that of the class instance itself.</p><p>Compositions that need to do dynamic allocation or deallocation may be implemented using pointer data members. In this case, the composition class should be responsible for doing all necessary memory management itself (not the user of the class).</p><p>In general, if you <em>can</em> design a class using composition, you <em>should</em> design a class using composition. Classes designed using composition are straightforward, flexible, and robust (in that they clean up after themselves nicely).</p><br><h3>More examples</h3><p>Many games and simulations have creatures or objects that move around a board, map, or screen. One thing that all of these creatures/objects have in common is that they all have a location. In this example, we are going to create a creature class that uses a point class to hold the creature’s location.</p><p>First, let’s design the point class. Our creature is going to live in a 2d world, so our point class will have 2 dimensions, X and Y. We will assume the world is made up of discrete squares, so these dimensions will always be integers.</p><p>Point2D.h:</p><pre class="language-cpp line-numbers"><code>#ifndef POINT2D_H</code><code>#define POINT2D_H</code><code></code><code>#include <iostream></iostream></code><code></code><code>class Point2D</code><code>{</code><code>private:</code><code>    int m_x;</code><code>    int m_y;</code><code></code><code>public:</code><code>    // A default constructor</code><code>    Point2D()</code><code>        : m_x{ 0 }, m_y{ 0 }</code><code>    {</code><code>    }</code><code></code><code>    // A specific constructor</code><code>    Point2D(int x, int y)</code><code>        : m_x{ x }, m_y{ y }</code><code>    {</code><code>    }</code><code></code><code>    // An overloaded output operator</code><code>    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Point2D&amp; point)</code><code>    {</code><code>        out &lt;&lt; '(' &lt;&lt; point.m_x &lt;&lt; ", " &lt;&lt; point.m_y &lt;&lt; ')';</code><code>        return out;</code><code>    }</code><code></code><code>    // Access functions</code><code>    void setPoint(int x, int y)</code><code>    {</code><code>        m_x = x;</code><code>        m_y = y;</code><code>    }</code><code></code><code>};</code><code></code><code>#endif</code></pre><p>Note that because we’ve implemented all of our functions in the header file (for the sake of keeping the example concise), there is no Point2D.cpp.</p><p>This Point2d class is a composition of its parts: location values x and y are part-of Point2D, and their lifespan is tied to that of a given Point2D instance.</p><p>Now let’s design our Creature. Our Creature is going to have a few properties: a name, which will be a string, and a location, which will be our Point2D class.</p><p>Creature.h:</p><pre class="language-cpp line-numbers"><code>#ifndef CREATURE_H</code><code>#define CREATURE_H</code><code></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include "Point2D.h"</code><code></code><code>class Creature</code><code>{</code><code>private:</code><code>    std::string m_name;</code><code>    Point2D m_location;</code><code></code><code>public:</code><code>    Creature(const std::string&amp; name, const Point2D&amp; location)</code><code>        : m_name{ name }, m_location{ location }</code><code>    {</code><code>    }</code><code></code><code>    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Creature&amp; creature)</code><code>    {</code><code>        out &lt;&lt; creature.m_name &lt;&lt; " is at " &lt;&lt; creature.m_location;</code><code>        return out;</code><code>    }</code><code></code><code>    void moveTo(int x, int y)</code><code>    {</code><code>        m_location.setPoint(x, y);</code><code>    }</code><code>};</code><code>#endif</code></pre><p>This Creature is also a composition of its parts. The creature’s name and location have one parent, and their lifetime is tied to that of the Creature they are part of.</p><p>And finally, main.cpp:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code>#include <iostream></iostream></code><code>#include "Creature.h"</code><code>#include "Point2D.h"</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a name for your creature: ";</code><code>    std::string name;</code><code>    std::cin &gt;&gt; name;</code><code>    Creature creature{ name, { 4, 7 } };</code><code>	</code><code>    while (true)</code><code>    {</code><code>        // print the creature's name and location</code><code>        std::cout &lt;&lt; creature &lt;&lt; '\n';</code><code></code><code>        std::cout &lt;&lt; "Enter new X location for creature (-1 to quit): ";</code><code>        int x{ 0 };</code><code>        std::cin &gt;&gt; x;</code><code>        if (x == -1)</code><code>            break;</code><code></code><code>        std::cout &lt;&lt; "Enter new Y location for creature (-1 to quit): ";</code><code>        int y{ 0 };</code><code>        std::cin &gt;&gt; y;</code><code>        if (y == -1)</code><code>            break;</code><code>		</code><code>        creature.moveTo(x, y);</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>Here’s a transcript of this code being run:</p><pre>Enter a name for your creature: Marvin
Marvin is at (4, 7)
Enter new X location for creature (-1 to quit): 6
Enter new Y location for creature (-1 to quit): 12
Marvin is at (6, 12)
Enter new X location for creature (-1 to quit): 3
Enter new Y location for creature (-1 to quit): 2
Marvin is at (3, 2)
Enter new X location for creature (-1 to quit): -1
</pre><br><h3>Variants on the composition theme</h3><p>Although most compositions directly create their parts when the composition is created and directly destroy their parts when the composition is destroyed, there are some variations of composition that bend these rules a bit.</p><p>For example:</p><ul><li>A composition may defer creation of some parts until they are needed. For example, a string class may not create a dynamic array of characters until the user assigns the string some data to hold.</li><li>A composition may opt to use a part that has been given to it as input rather than create the part itself.</li><li>A composition may delegate destruction of its parts to some other object (e.g. to a garbage collection routine).</li></ul><p>The key point here is that the composition should manage its parts without the user of the composition needing to manage anything.</p><br><h3>Composition and class members</h3><p>One question that new programmers often ask when it comes to object composition is, “When should I use a class member instead of direct implementation of a feature?”. For example, instead of using the Point2D class to implement the Creature’s location, we could have instead just added 2 integers to the Creature class and written code in the Creature class to handle the positioning. However, making Point2D its own class (and a member of Creature) has a number of benefits:</p><ol><li>Each individual class can be kept relatively simple and straightforward, focused on performing one task well. This makes those classes easier to write and much easier to understand, as they are more focused. For example, Point2D only worries about point-related stuff, which helps keep it simple.</li><li>Each class can be self-contained, which makes them reusable. For example, we could reuse our Point2D class in a completely different application. Or if our creature ever needed another point (for example, a destination it was trying to get to), we can simply add another Point2D member variable.</li><li>The outer class can have the class members do most of the hard work, and instead focus on coordinating the data flow between the members . This helps lower the overall complexity of the outer class, because it can delegate tasks to its members, who already know how to do those tasks. For example, when we move our Creature, it delegates that task to the Point class, which already understands how to set a point. Thus, the Creature class does not have to worry about how such things would be implemented.</li></ol><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>A good rule of thumb is that each class should be built to accomplish a single task. That task should either be the storage and manipulation of some kind of data (e.g. Point2D, std::string), OR the coordination of its members (e.g. Creature). Ideally not both.</p></div><p>In this case of our example, it makes sense that Creature shouldn’t have to worry about how Points are implemented, or how the name is being stored. Creature’s job isn’t to know those intimate details. Creature’s job is to worry about how to coordinate the data flow and ensure that each of the class members knows <i>what</i> it is supposed to do. It’s up to the individual classes to worry about <i>how</i> they will do it.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">16.3 — Aggregation</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson <a href="https://www.learncpp.com/cpp-tutorial/composition/">16.2 -- Composition</a>, we noted that object composition is the process of creating complex objects from simpler ones. We also talked about one type of object composition, called composition. In a composition relationship, the whole object is responsible for the existence of the part.</p><p>In this lesson, we’ll take a look at the other subtype of object composition, called aggregation.</p><br><h3>Aggregation</h3><p>To qualify as an <strong>aggregation</strong>, a whole object and its parts must have the following relationship:</p><ul><li>The part (member) is part of the object (class)</li><li>The part (member) can belong to more than one object (class) at a time</li><li>The part (member) does <em>not</em> have its existence managed by the object (class)</li><li>The part (member) does not know about the existence of the object (class)</li></ul><p>Like a composition, an aggregation is still a part-whole relationship, where the parts are contained within the whole, and it is a unidirectional relationship. However, unlike a composition, parts can belong to more than one object at a time, and the whole object is not responsible for the existence and lifespan of the parts. When an aggregation is created, the aggregation is not responsible for creating the parts. When an aggregation is destroyed, the aggregation is not responsible for destroying the parts.</p><p>For example, consider the relationship between a person and their home address. In this example, for simplicity, we’ll say every person has an address. However, that address can belong to more than one person at a time: for example, to both you and your roommate or significant other. However, that address isn’t managed by the person -- the address probably existed before the person got there, and will exist after the person is gone. Additionally, a person knows what address they live at, but the addresses don’t know what people live there. Therefore, this is an aggregate relationship.</p><p>Alternatively, consider a car and an engine. A car engine is part of the car. And although the engine belongs to the car, it can belong to other things as well, like the person who owns the car. The car is not responsible for the creation or destruction of the engine. And while the car knows it has an engine (it has to in order to get anywhere) the engine doesn’t know it’s part of the car.</p><p>When it comes to modeling physical objects, the use of the term “destroyed” can be a little dicey. One might argue, “If a meteor fell out of the sky and crushed the car, wouldn’t the car parts all be destroyed too?” Yes, of course. But that’s the fault of the meteor. The important point is that the car is not responsible for destruction of its parts (but an external force might be).</p><p>We can say that aggregation models “has-a” relationships (a department has teachers, the car has an engine).</p><p>Similar to a composition, the parts of an aggregation can be singular or multiplicative.</p><br><h3>Implementing aggregations</h3><p>Because aggregations are similar to compositions in that they are both part-whole relationships, they are implemented almost identically, and the difference between them is mostly semantic. In a composition, we typically add our parts to the composition using normal member variables (or pointers where the allocation and deallocation process is handled by the composition class).</p><p>In an aggregation, we also add parts as member variables. However, these member variables are typically either references or pointers that are used to point at objects that have been created outside the scope of the class. Consequently, an aggregation usually either takes the objects it is going to point to as constructor parameters, or it begins empty and the subobjects are added later via access functions or operators.</p><p>Because these parts exist outside of the scope of the class, when the class is destroyed, the pointer or reference member variable will be destroyed (but not deleted). Consequently, the parts themselves will still exist.</p><p>Let’s take a look at a Teacher and Department example in more detail. In this example, we’re going to make a couple of simplifications: First, the department will only hold one teacher. Second, the teacher will be unaware of what department they’re part of.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>class Teacher</code><code>{</code><code>private:</code><code>  std::string m_name{};</code><code></code><code>public:</code><code>  Teacher(const std::string&amp; name)</code><code>      : m_name{ name }</code><code>  {</code><code>  }</code><code></code><code>  const std::string&amp; getName() const { return m_name; }</code><code>};</code><code></code><code>class Department</code><code>{</code><code>private:</code><code>  const Teacher&amp; m_teacher; // This dept holds only one teacher for simplicity, but it could hold many teachers</code><code></code><code>public:</code><code>  Department(const Teacher&amp; teacher)</code><code>      : m_teacher{ teacher }</code><code>  {</code><code>  }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>  // Create a teacher outside the scope of the Department</code><code>  Teacher bob{ "Bob" }; // create a teacher</code><code></code><code>  {</code><code>    // Create a department and use the constructor parameter to pass</code><code>    // the teacher to it.</code><code>    Department department{ bob };</code><code></code><code>  } // department goes out of scope here and is destroyed</code><code></code><code>  // bob still exists here, but the department doesn't</code><code></code><code>  std::cout &lt;&lt; bob.getName() &lt;&lt; " still exists!\n";</code><code></code><code>  return 0;</code><code>}</code></pre><p>In this case, <code>bob</code> is created independently of <code>department</code>, and then passed into <code>department</code>‘s constructor. When <code>department</code> is destroyed, the <code>m_teacher</code> reference is destroyed, but the teacher itself is not destroyed, so it still exists until it is independently destroyed later in <code>main()</code>.</p><br><h3>Pick the right relationship for what you’re modeling</h3><p>Although it might seem a little silly in the above example that the Teachers don’t know what Department they’re working for, that may be totally fine in the context of a given program. When you’re determining what kind of relationship to implement, implement the simplest relationship that meets your needs, not the one that seems like it would fit best in a real-life context.</p><p>For example, if you’re writing a body shop simulator, you may want to implement a car and engine as an aggregation, so the engine can be removed and put on a shelf somewhere for later. However, if you’re writing a racing simulation, you may want to implement a car and an engine as a composition, since the engine will never exist outside of the car in that context.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Implement the simplest relationship type that meets the needs of your program, not what seems right in real-life.</p></div><br><h3>Summarizing composition and aggregation</h3><p>Compositions:</p><ul><li>Typically use normal member variables</li><li>Can use pointer members if the class handles object allocation/deallocation itself</li><li>Responsible for creation/destruction of parts</li></ul><p>Aggregations:</p><ul><li>Typically use pointer or reference members that point to or reference objects that live outside the scope of the aggregate class</li><li>Not responsible for creating/destroying parts</li></ul><p>It is worth noting that the concepts of composition and aggregation can be mixed freely within the same class. It is entirely possible to write a class that is responsible for the creation/destruction of some parts but not others. For example, our Department class could have a name and a Teacher. The name would probably be added to the Department by composition, and would be created and destroyed with the Department. On the other hand, the Teacher would be added to the department by aggregation, and created/destroyed independently.</p><p>While aggregations can be extremely useful, they are also potentially more dangerous, because aggregations do not handle deallocation of their parts. Deallocations are left to an external party to do. If the external party no longer has a pointer or reference to the abandoned parts, or if it simply forgets to do the cleanup (assuming the class will handle that), then memory will be leaked.</p><p>For this reason, compositions should be favored over aggregations.</p><br><h3>A few warnings/errata</h3><p>For a variety of historical and contextual reasons, unlike a composition, the definition of an aggregation is not precise -- so you may see other reference material define it differently from the way we do. That’s fine, just be aware.</p><p>One final note: In the lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-structs-members-and-member-selection/">10.5 -- Introduction to structs, members, and member selection</a>, we defined aggregate data types (such as structs and classes) as data types that group multiple variables together. You may also run across the term <def>aggregate class</def> in your C++ journeys, which is defined as a struct or class that has no provided constructors, destructors, or overloaded assignment, has all public members, and does not use inheritance -- essentially a plain-old-data struct. Despite the similarities in naming, aggregates and aggregation are different and should not be confused.</p><br><h3>std::reference_wrapper</h3><p>In the <code>Department</code>/<code>Teacher</code> example above, we used a reference in the <code>Department</code> to store the <code>Teacher</code>. This works fine if there is only one <code>Teacher</code>, but what if a Department has multiple Teachers? We’d like to store those Teachers in a list of some kind (e.g. a <code>std::vector</code>) but fixed arrays and the various standard library lists can’t hold references (because list elements must be assignable, and references can’t be reassigned).</p><pre class="language-cpp line-numbers"><code>std::vector<const teacher&=""> m_teachers{}; // Illegal</const></code></pre><p>Instead of references, we could use pointers, but that would open the possibility to store or pass null pointers. In the <code>Department</code>/<code>Teacher</code> example, we don’t want to allow null pointers. To solve this, there’s <code>std::reference_wrapper</code>.</p><p>Essentially, <code>std::reference_wrapper</code> is a class that acts like a reference, but also allows assignment and copying, so it’s compatible with lists like <code>std::vector</code>.</p><p>The good news is that you don’t really need to understand how it works to use it. All you need to know are three things:</p><ol start="1"><li><code>std::reference_wrapper</code> lives in the &lt;functional&gt; header.</li><li>When you create your <code>std::reference_wrapper</code> wrapped object, the object can’t be an anonymous object (since anonymous objects have expression scope, and this would leave the reference dangling).</li><li>When you want to get your object back out of <code>std::reference_wrapper</code>, you use the <code>get()</code> member function.</li></ol><p>Here’s an example using <code>std::reference_wrapper</code> in a <code>std::vector</code>:</p><pre class="language-cpp line-numbers"><code>#include <functional> // std::reference_wrapper</functional></code><code>#include <iostream></iostream></code><code>#include <vector></vector></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>  std::string tom{ "Tom" };</code><code>  std::string berta{ "Berta" };</code><code></code><code>  std::vector<std::reference_wrapper<std::string>&gt; names{ tom, berta }; // these strings are stored by reference, not value</std::reference_wrapper<std::string></code><code></code><code>  std::string jim{ "Jim" };</code><code></code><code>  names.push_back(jim);</code><code></code><code>  for (auto name : names)</code><code>  {</code><code>    // Use the get() member function to get the referenced string.</code><code>    name.get() += " Beam";</code><code>  }</code><code></code><code>  std::cout &lt;&lt; jim &lt;&lt; '\n'; // Jim Beam</code><code></code><code>  return 0;</code><code>}</code></pre><p>To create a vector of const references, we’d have to add const before the <code>std::string</code> like so</p><pre class="language-cpp line-numbers"><code>// Vector of const references to std::string</code><code>std::vector<std::reference_wrapper<const std::string="">&gt; names{ tom, berta };</std::reference_wrapper<const></code></pre><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Would you be more likely to implement the following as a composition or an aggregation?<br>a) A ball that has a color<br>b) An employer that is employing multiple people<br>c) The departments in a university<br>d) Your age<br>e) A bag of marbles</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>a) Composition: Color is an intrinsic property of a ball.<br>b) Aggregation: An employer doesn’t start with any employees and hopefully doesn’t destroy all its employees when it goes bankrupt.<br>c) Composition: Departments can’t exist in absence of a university.<br>d) Composition: Your age is an intrinsic property of you.<br>e) Aggregation: The bag and the marbles inside have independent existences.</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>Update the <code>Department</code>/<code>Teacher</code> example so the <code>Department</code> can handle multiple Teachers. The following code should execute:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// ...</code><code></code><code>int main()</code><code>{</code><code>  // Create a teacher outside the scope of the Department</code><code>  Teacher t1{ "Bob" };</code><code>  Teacher t2{ "Frank" };</code><code>  Teacher t3{ "Beth" };</code><code></code><code>  {</code><code>    // Create a department and add some Teachers to it</code><code>    Department department{}; // create an empty Department</code><code></code><code>    department.add(t1);</code><code>    department.add(t2);</code><code>    department.add(t3);</code><code></code><code>    std::cout &lt;&lt; department;</code><code></code><code>  } // department goes out of scope here and is destroyed</code><code></code><code>  std::cout &lt;&lt; t1.getName() &lt;&lt; " still exists!\n";</code><code>  std::cout &lt;&lt; t2.getName() &lt;&lt; " still exists!\n";</code><code>  std::cout &lt;&lt; t3.getName() &lt;&lt; " still exists!\n";</code><code></code><code>  return 0;</code><code>}</code></pre><p>This should print:</p><pre>Department: Bob Frank Beth
Bob still exists!
Frank still exists!
Beth still exists!
</pre><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">Hint: Store the teachers in a <code>std::vector</code><pre class="language-cpp line-numbers"><code>std::vector<std::reference_wrapper<const teacher="">&gt; m_teachers{};</std::reference_wrapper<const></code></pre></div><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <functional> // std::reference_wrapper</functional></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <vector></vector></code><code></code><code>class Teacher</code><code>{</code><code>private:</code><code>  std::string m_name{};</code><code></code><code>public:</code><code>  Teacher(const std::string&amp; name)</code><code>      : m_name{ name }</code><code>  {</code><code>  }</code><code></code><code>  const std::string&amp; getName() const { return m_name; }</code><code>};</code><code></code><code>class Department</code><code>{</code><code>private:</code><code>  std::vector<std::reference_wrapper<const teacher="">&gt; m_teachers{};</std::reference_wrapper<const></code><code></code><code>public:</code><code>  // Pass by regular reference. The user of the Department class shouldn't care</code><code>  // about how it's implemented.</code><code>  void add(const Teacher&amp; teacher)</code><code>  {</code><code>    m_teachers.push_back(teacher);</code><code>  }</code><code></code><code>  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Department&amp; department)</code><code>  {</code><code>    out &lt;&lt; "Department: ";</code><code></code><code>    for (const auto&amp; teacher : department.m_teachers)</code><code>    {</code><code>      out &lt;&lt; teacher.get().getName() &lt;&lt; ' ';</code><code>    }</code><code></code><code>    out &lt;&lt; '\n';</code><code></code><code>    return out;</code><code>  }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>  // Create a teacher outside the scope of the Department</code><code>  Teacher t1{ "Bob" };</code><code>  Teacher t2{ "Frank" };</code><code>  Teacher t3{ "Beth" };</code><code></code><code>  {</code><code>    // Create a department and add some Teachers to it</code><code>    Department department{}; // create an empty Department</code><code></code><code>    department.add(t1);</code><code>    department.add(t2);</code><code>    department.add(t3);</code><code></code><code>    std::cout &lt;&lt; department;</code><code></code><code>  } // department goes out of scope here and is destroyed</code><code></code><code>  std::cout &lt;&lt; t1.getName() &lt;&lt; " still exists!\n";</code><code>  std::cout &lt;&lt; t2.getName() &lt;&lt; " still exists!\n";</code><code>  std::cout &lt;&lt; t3.getName() &lt;&lt; " still exists!\n";</code><code></code><code>  return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">16.4 — Association</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous two lessons, we’ve looked at two types of object composition, composition and aggregation. Object composition is used to model relationships where a complex object is built from one or more simpler objects (parts).</p><p>In this lesson, we’ll take a look at a weaker type of relationship between two otherwise unrelated objects, called an association. Unlike object composition relationships, in an association, there is no implied whole/part relationship.</p><br><h3>Association</h3><p>To qualify as an <strong>association</strong>, an object and another object must have the following relationship:</p><ul><li>The associated object (member) is otherwise unrelated to the object (class)</li><li>The associated object (member) can belong to more than one object (class) at a time</li><li>The associated object (member) does <em>not</em> have its existence managed by the object (class)</li><li>The associated object (member) may or may not know about the existence of the object (class)</li></ul><p>Unlike a composition or aggregation, where the part is a part of the whole object, in an association, the associated object is otherwise unrelated to the object. Just like an aggregation, the associated object can belong to multiple objects simultaneously, and isn’t managed by those objects. However, unlike an aggregation, where the relationship is always unidirectional, in an association, the relationship may be unidirectional or bidirectional (where the two objects are aware of each other).</p><p>The relationship between doctors and patients is a great example of an association. The doctor clearly has a relationship with his patients, but conceptually it’s not a part/whole (object composition) relationship. A doctor can see many patients in a day, and a patient can see many doctors (perhaps they want a second opinion, or they are visiting different types of doctors). Neither of the object’s lifespans are tied to the other.</p><p>We can say that association models as “uses-a” relationship. The doctor “uses” the patient (to earn income). The patient uses the doctor (for whatever health purposes they need).</p><br><h3>Implementing associations</h3><p>Because associations are a broad type of relationship, they can be implemented in many different ways. However, most often, associations are implemented using pointers, where the object points at the associated object.</p><p>In this example, we’ll implement a bi-directional Doctor/Patient relationship, since it makes sense for the Doctors to know who their Patients are, and vice-versa.</p><pre class="language-cpp line-numbers"><code>#include <functional> // reference_wrapper</functional></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <vector></vector></code><code></code><code>// Since Doctor and Patient have a circular dependency, we're going to forward declare Patient</code><code>class Patient;</code><code></code><code>class Doctor</code><code>{</code><code>private:</code><code>	std::string m_name{};</code><code>	std::vector<std::reference_wrapper<const patient="">&gt; m_patient{};</std::reference_wrapper<const></code><code></code><code>public:</code><code>	Doctor(const std::string&amp; name) :</code><code>		m_name{ name }</code><code>	{</code><code>	}</code><code></code><code>	void addPatient(Patient&amp; patient);</code><code>	</code><code>	// We'll implement this function below Patient since we need Patient to be defined at that point</code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Doctor&amp; doctor);</code><code></code><code>	const std::string&amp; getName() const { return m_name; }</code><code>};</code><code></code><code>class Patient</code><code>{</code><code>private:</code><code>	std::string m_name{};</code><code>	std::vector<std::reference_wrapper<const doctor="">&gt; m_doctor{}; // so that we can use it here</std::reference_wrapper<const></code><code></code><code>	// We're going to make addDoctor private because we don't want the public to use it.</code><code>	// They should use Doctor::addPatient() instead, which is publicly exposed</code><code>	void addDoctor(const Doctor&amp; doctor)</code><code>	{</code><code>		m_doctor.push_back(doctor);</code><code>	}</code><code></code><code>public:</code><code>	Patient(const std::string&amp; name)</code><code>		: m_name{ name }</code><code>	{</code><code>	}</code><code></code><code>	// We'll implement this function below to parallel operator&lt;&lt;(std::ostream&amp;, const Doctor&amp;)</code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Patient&amp; patient);</code><code></code><code>	const std::string&amp; getName() const { return m_name; }</code><code></code><code>	// We'll friend Doctor::addPatient() so it can access the private function Patient::addDoctor()</code><code>	friend void Doctor::addPatient(Patient&amp; patient);</code><code>};</code><code></code><code>void Doctor::addPatient(Patient&amp; patient)</code><code>{</code><code>	// Our doctor will add this patient</code><code>	m_patient.push_back(patient);</code><code></code><code>	// and the patient will also add this doctor</code><code>	patient.addDoctor(*this);</code><code>}</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Doctor&amp; doctor)</code><code>{</code><code>	if (doctor.m_patient.empty())</code><code>	{</code><code>		out &lt;&lt; doctor.m_name &lt;&lt; " has no patients right now";</code><code>		return out;</code><code>	}</code><code></code><code>	out &lt;&lt; doctor.m_name &lt;&lt; " is seeing patients: ";</code><code>	for (const auto&amp; patient : doctor.m_patient)</code><code>		out &lt;&lt; patient.get().getName() &lt;&lt; ' ';</code><code></code><code>	return out;</code><code>}</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Patient&amp; patient)</code><code>{</code><code>	if (patient.m_doctor.empty())</code><code>	{</code><code>		out &lt;&lt; patient.getName() &lt;&lt; " has no doctors right now";</code><code>		return out;</code><code>	}</code><code></code><code>	out &lt;&lt; patient.m_name &lt;&lt; " is seeing doctors: ";</code><code>	for (const auto&amp; doctor : patient.m_doctor)</code><code>		out &lt;&lt; doctor.get().getName() &lt;&lt; ' ';</code><code></code><code>	return out;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	// Create a Patient outside the scope of the Doctor</code><code>	Patient dave{ "Dave" };</code><code>	Patient frank{ "Frank" };</code><code>	Patient betsy{ "Betsy" };</code><code></code><code>	Doctor james{ "James" };</code><code>	Doctor scott{ "Scott" };</code><code></code><code>	james.addPatient(dave);</code><code></code><code>	scott.addPatient(dave);</code><code>	scott.addPatient(betsy);</code><code></code><code>	std::cout &lt;&lt; james &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; scott &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; dave &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; frank &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; betsy &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>James is seeing patients: Dave
Scott is seeing patients: Dave Betsy
Dave is seeing doctors: James Scott
Frank has no doctors right now
Betsy is seeing doctors: Scott
</pre><p>In general, you should avoid bidirectional associations if a unidirectional one will do, as they add complexity and tend to be harder to write without making errors.</p><br><h3>Reflexive association</h3><p>Sometimes objects may have a relationship with other objects of the same type. This is called a <strong>reflexive association</strong>. A good example of a reflexive association is the relationship between a university course and its prerequisites (which are also university courses).</p><p>Consider the simplified case where a Course can only have one prerequisite. We can do something like this:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code>class Course</code><code>{</code><code>private:</code><code>    std::string m_name;</code><code>    const Course* m_prerequisite;</code><code></code><code>public:</code><code>    Course(const std::string&amp; name, const Course* prerequisite = nullptr):</code><code>        m_name{ name }, m_prerequisite{ prerequisite }</code><code>    {</code><code>    }</code><code></code><code>};</code></pre><p>This can lead to a chain of associations (a course has a prerequisite, which has a prerequisite, etc…)</p><br><h3>Associations can be indirect</h3><p>In all of the previous cases, we’ve used either pointers or references to directly link objects together. However, in an association, this is not strictly required. Any kind of data that allows you to link two objects together suffices. In the following example, we show how a Driver class can have a unidirectional association with a Car without actually including a Car pointer or reference member:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>class Car</code><code>{</code><code>private:</code><code>	std::string m_name;</code><code>	int m_id;</code><code></code><code>public:</code><code>	Car(const std::string&amp; name, int id)</code><code>		: m_name{ name }, m_id{ id }</code><code>	{</code><code>	}</code><code></code><code>	const std::string&amp; getName() const { return m_name; }</code><code>	int getId() const { return m_id; }</code><code>};</code><code></code><code>// Our CarLot is essentially just a static array of Cars and a lookup function to retrieve them.</code><code>// Because it's static, we don't need to allocate an object of type CarLot to use it</code><code>class CarLot</code><code>{</code><code>private:</code><code>	static Car s_carLot[4];</code><code></code><code>public:</code><code>	CarLot() = delete; // Ensure we don't try to create a CarLot</code><code></code><code>	static Car* getCar(int id)</code><code>	{</code><code>		for (int count{ 0 }; count &lt; 4; ++count)</code><code>		{</code><code>			if (s_carLot[count].getId() == id)</code><code>			{</code><code>				return &amp;(s_carLot[count]);</code><code>			}</code><code>		}</code><code>		</code><code>		return nullptr;</code><code>	}</code><code>};</code><code></code><code>Car CarLot::s_carLot[4]{ { "Prius", 4 }, { "Corolla", 17 }, { "Accord", 84 }, { "Matrix", 62 } };</code><code></code><code>class Driver</code><code>{</code><code>private:</code><code>	std::string m_name;</code><code>	int m_carId; // we're associated with the Car by ID rather than pointer</code><code></code><code>public:</code><code>	Driver(const std::string&amp; name, int carId)</code><code>		: m_name{ name }, m_carId{ carId }</code><code>	{</code><code>	}</code><code></code><code>	const std::string&amp; getName() const { return m_name; }</code><code>	int getCarId() const { return m_carId; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Driver d{ "Franz", 17 }; // Franz is driving the car with ID 17</code><code></code><code>	Car* car{ CarLot::getCar(d.getCarId()) }; // Get that car from the car lot</code><code>	</code><code>	if (car)</code><code>		std::cout &lt;&lt; d.getName() &lt;&lt; " is driving a " &lt;&lt; car-&gt;getName() &lt;&lt; '\n';</code><code>	else</code><code>		std::cout &lt;&lt; d.getName() &lt;&lt; " couldn't find his car\n";</code><code></code><code>	return 0;</code><code>}</code></pre><p>In the above example, we have a CarLot holding our cars. The Driver, who needs a car, doesn’t have a pointer to his Car -- instead, he has the ID of the car, which we can use to get the Car from the CarLot when we need it.</p><p>In this particular example, doing things this way is kind of silly, since getting the Car out of the CarLot requires an inefficient lookup (a pointer connecting the two is much faster). However, there are advantages to referencing things by a unique ID instead of a pointer. For example, you can reference things that are not currently in memory (maybe they’re in a file, or in a database, and can be loaded on demand). Also, pointers can take 4 or 8 bytes -- if space is at a premium and the number of unique objects is fairly low, referencing them by an 8-bit or 16-bit integer can save lots of memory.</p><br><h3>Composition vs aggregation vs association summary</h3><p>Here’s a summary table to help you remember the difference between composition, aggregation, and association:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Property</th><th>Composition</th><th>Aggregation</th><th>Association</th></tr><tr><td>Relationship type</td><td>Whole/part</td><td>Whole/part</td><td>Otherwise unrelated</td></tr><tr><td>Members can belong to multiple classes</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td>Members’ existence managed by class</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>Directionality</td><td>Unidirectional</td><td>Unidirectional</td><td>Unidirectional or bidirectional</td></tr><tr><td>Relationship verb</td><td>Part-of</td><td>Has-a</td><td>Uses-a</td></tr></tbody></table></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">16.5 — Dependencies</h1></header><div class="entry-content" itemprop="articleBody"><p>So far, we’ve explored 3 types of relationships: composition, aggregation, and association. We’ve saved the simplest one for last: dependencies.</p><p>In casual conversation, we use the term dependency to indicate that an object is reliant upon another object for a given task. For example, if you break your foot, you are dependent on crutches to get around (but not otherwise). Flowers are dependent upon bees to pollinate them, in order to grow fruit or propagate (but not otherwise).</p><p>A <strong>dependency</strong> occurs when one object invokes another object’s functionality in order to accomplish some specific task. This is a weaker relationship than an association, but still, any change to object being depended upon may break functionality in the (dependent) caller. A dependency is always a unidirectional relationship.</p><p>A good example of a dependency that you’ve already seen many times is std::ostream. Our classes that use std::ostream use it in order to accomplish the task of printing something to the console, but not otherwise.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code> </code><code>class Point</code><code>{</code><code>private:</code><code>    double m_x{};</code><code>    double m_y{};</code><code>    double m_z{};</code><code> </code><code>public:</code><code>    Point(double x=0.0, double y=0.0, double z=0.0): m_x{x}, m_y{y}, m_z{z}</code><code>    {</code><code>    }</code><code> </code><code>    friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point); // Point has a dependency on std::ostream here</code><code>};</code><code> </code><code>std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point)</code><code>{</code><code>    // Since operator&lt;&lt; is a friend of the Point class, we can access Point's members directly.</code><code>    out &lt;&lt; "Point(" &lt;&lt; point.m_x &lt;&lt; ", " &lt;&lt; point.m_y &lt;&lt; ", " &lt;&lt; point.m_z &lt;&lt; ')';</code><code> </code><code>    return out;</code><code>}</code><code> </code><code>int main()</code><code>{</code><code>    Point point1 { 2.0, 3.0, 4.0 };</code><code> </code><code>    std::cout &lt;&lt; point1; // the program has a dependency on std::cout here</code><code> </code><code>    return 0;</code><code>}</code></pre><p>In the above code, Point isn’t directly related to std::ostream, but it has a dependency on std::ostream since operator&lt;&lt; uses std::ostream to print the Point to the console.</p><p><strong>Dependencies vs Association in C++</strong></p><p>There’s typically some confusion about what differentiates a dependency from an association.</p><p>In C++, associations are a relationship between two classes at the class level. That is, one class keeps a direct or indirect “link” to the associated class as a member. For example, a Doctor class has an array of pointers to its Patients as a member. You can always ask the Doctor who its patients are. The Driver class holds the id of the Car the driver object owns as an integer member. The Driver always knows what Car is associated with it.</p><p>Dependencies typically are not represented at the class level -- that is, the object being depended on is not linked as a member. Rather, the object being depended on is typically instantiated as needed (like opening a file to write data to), or passed into a function as a parameter (like std::ostream in the overloaded operator&lt;&lt; above).</p><p><strong>Humor break</strong></p><p>Dependencies (courtesy of our friends at <a href="https://xkcd.com/754/">xkcd</a>):</p><p><img src="https://www.learncpp.com/ezoimgfmt/imgs.xkcd.com/comics/dependencies.png" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/ezoimgfmt/imgs.xkcd.com/comics/dependencies.png"></p><p>Of course, you and I know that this is actually a reflexive association!</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">16.6 — Container classes</h1></header><div class="entry-content" itemprop="articleBody"><p>In real life, we use containers all the time. Your breakfast cereal comes in a box, the pages in your book come inside a cover and binding, and you might store any number of items in containers in your garage. Without containers, it would be extremely inconvenient to work with many of these objects. Imagine trying to read a book that didn’t have any sort of binding, or eat cereal that didn’t come in a box without using a bowl. It would be a mess. The value the container provides is largely in its ability to help organize and store items that are put inside it.</p><p>Similarly, a <strong>container class</strong> is a class designed to hold and organize multiple instances of another type (either another class, or a fundamental type). There are many different kinds of container classes, each of which has various advantages, disadvantages, and restrictions in their use. By far the most commonly used container in programming is the array, which you have already seen many examples of. Although C++ has built-in array functionality, programmers will often use an array container class (std::array or std::vector) instead because of the additional benefits they provide. Unlike built-in arrays, array container classes generally provide dynamic resizing (when elements are added or removed), remember their size when they are passed to functions, and do bounds-checking. This not only makes array container classes more convenient than normal arrays, but safer too.</p><p>Container classes typically implement a fairly standardized minimal set of functionality. Most well-defined containers will include functions that:</p><ul><li>Create an empty container (via a constructor)</li><li>Insert a new object into the container</li><li>Remove an object from the container</li><li>Report the number of objects currently in the container</li><li>Empty the container of all objects</li><li>Provide access to the stored objects</li><li>Sort the elements (optional)</li></ul><p>Sometimes certain container classes will omit some of this functionality. For example, arrays container classes often omit the insert and remove functions because they are slow and the class designer does not want to encourage their use.</p><p>Container classes implement a member-of relationship. For example, elements of an array are members-of (belong to) the array. Note that we’re using “member-of” in the conventional sense, not the C++ class member sense.</p><p><strong>Types of containers</strong></p><p>Container classes generally come in two different varieties. <strong>Value containers</strong> are <a href="https://www.learncpp.com/cpp-tutorial/102-composition/">compositions</a> that store copies of the objects that they are holding (and thus are responsible for creating and destroying those copies). <strong>Reference containers</strong> are <a href="https://www.learncpp.com/cpp-tutorial/103-aggregation/">aggregations</a> that store pointers or references to other objects (and thus are not responsible for creation or destruction of those objects).</p><p>Unlike in real life, where containers can hold whatever types of objects you put in them, in C++, containers typically only hold one type of data. For example, if you have an array of integers, it will only hold integers. Unlike some other languages, many C++ containers do not allow you to arbitrarily mix types. If you need containers to hold integers and doubles, you will generally have to write two separate containers to do this (or use templates, which is an advanced C++ feature). Despite the restrictions on their use, containers are immensely useful, and they make programming easier, safer, and faster.</p><p><strong>An array container class</strong></p><p>In this example, we are going to write an integer array class from scratch that implements most of the common functionality that containers should have. This array class is going to be a value container, which will hold copies of the elements it’s organizing. As the name suggests, the container will hold an array of integers, similar to <code>std::vector<int></int></code>.</p><p>First, let’s create the IntArray.h file:</p><pre class="language-cpp line-numbers"><code>#ifndef INTARRAY_H</code><code>#define INTARRAY_H</code><code></code><code>class IntArray</code><code>{</code><code>};</code><code></code><code>#endif</code></pre><p>Our IntArray is going to need to keep track of two values: the data itself, and the size of the array. Because we want our array to be able to change in size, we’ll have to do some dynamic allocation, which means we’ll have to use a pointer to store the data.</p><pre class="language-cpp line-numbers"><code>#ifndef INTARRAY_H</code><code>#define INTARRAY_H</code><code></code><code>class IntArray</code><code>{</code><code>private:</code><code>    int m_length{};</code><code>    int* m_data{};</code><code>};</code><code></code><code>#endif</code></pre><p>Now we need to add some constructors that will allow us to create IntArrays. We are going to add two constructors: one that constructs an empty array, and one that will allow us to construct an array of a predetermined size.</p><pre class="language-cpp line-numbers"><code>#ifndef INTARRAY_H</code><code>#define INTARRAY_H</code><code></code><code>#include <cassert> // for assert()</cassert></code><code></code><code>class IntArray</code><code>{</code><code>private:</code><code>    int m_length{};</code><code>    int* m_data{};</code><code></code><code>public:</code><code>    IntArray() = default;</code><code></code><code>    IntArray(int length):</code><code>        m_length{ length }</code><code>    {</code><code>        assert(length &gt;= 0);</code><code></code><code>        if (length &gt; 0)</code><code>            m_data = new int[length]{};</code><code>    }</code><code>};</code><code></code><code>#endif</code></pre><p>We’ll also need some functions to help us clean up IntArrays. First, we’ll write a destructor, which simply deallocates any dynamically allocated data. Second, we’ll write a function called erase(), which will erase the array and set the length to 0.</p><pre class="language-cpp line-numbers"><code>    ~IntArray()</code><code>    {</code><code>        delete[] m_data;</code><code>        // we don't need to set m_data to null or m_length to 0 here, since the object will be destroyed immediately after this function anyway</code><code>    }</code><code></code><code>    void erase()</code><code>    {</code><code>        delete[] m_data;</code><code></code><code>        // We need to make sure we set m_data to nullptr here, otherwise it will</code><code>        // be left pointing at deallocated memory!</code><code>        m_data = nullptr;</code><code>        m_length = 0;</code><code>    }</code></pre><p>Now let’s overload the [] operator so we can access the elements of the array. We should bounds check the index to make sure it’s valid, which is best done using the assert() function. We’ll also add an access function to return the length of the array. Here’s everything so far:</p><pre class="language-cpp line-numbers"><code>#ifndef INTARRAY_H</code><code>#define INTARRAY_H</code><code></code><code>#include <cassert> // for assert()</cassert></code><code></code><code>class IntArray</code><code>{</code><code>private:</code><code>    int m_length{};</code><code>    int* m_data{};</code><code></code><code>public:</code><code>    IntArray() = default;</code><code></code><code>    IntArray(int length):</code><code>        m_length{ length }</code><code>    {</code><code>        assert(length &gt;= 0);</code><code></code><code>        if (length &gt; 0)</code><code>            m_data = new int[length]{};</code><code>    }</code><code></code><code>    ~IntArray()</code><code>    {</code><code>        delete[] m_data;</code><code>        // we don't need to set m_data to null or m_length to 0 here, since the object will be destroyed immediately after this function anyway</code><code>    }</code><code></code><code>    void erase()</code><code>    {</code><code>        delete[] m_data;</code><code>        // We need to make sure we set m_data to nullptr here, otherwise it will</code><code>        // be left pointing at deallocated memory!</code><code>        m_data = nullptr;</code><code>        m_length = 0;</code><code>    }</code><code></code><code>    int&amp; operator[](int index)</code><code>    {</code><code>        assert(index &gt;= 0 &amp;&amp; index &lt; m_length);</code><code>        return m_data[index];</code><code>    }</code><code></code><code>    int getLength() const { return m_length; }</code><code>};</code><code></code><code>#endif</code></pre><p>At this point, we already have an IntArray class that we can use. We can allocate IntArrays of a given size, and we can use the [] operator to retrieve or change the value of the elements.</p><p>However, there are still a few thing we can’t do with our IntArray. We still can’t change its size, still can’t insert or delete elements, and we still can’t sort it.</p><p>First, let’s write some code that will allow us to resize an array. We are going to write two different functions to do this. The first function, reallocate(), will destroy any existing elements in the array when it is resized, but it will be fast. The second function, resize(), will keep any existing elements in the array when it is resized, but it will be slow.</p><pre class="language-cpp line-numbers"><code>    // reallocate resizes the array.  Any existing elements will be destroyed.  This function operates quickly.</code><code>    void reallocate(int newLength)</code><code>    {</code><code>        // First we delete any existing elements</code><code>        erase();</code><code></code><code>        // If our array is going to be empty now, return here</code><code>        if (newLength &lt;= 0)</code><code>            return;</code><code></code><code>        // Then we have to allocate new elements</code><code>        m_data = new int[newLength];</code><code>        m_length = newLength;</code><code>    }</code><code></code><code>    // resize resizes the array.  Any existing elements will be kept.  This function operates slowly.</code><code>    void resize(int newLength)</code><code>    {</code><code>        // if the array is already the right length, we're done</code><code>        if (newLength == m_length)</code><code>            return;</code><code></code><code>        // If we are resizing to an empty array, do that and return</code><code>        if (newLength &lt;= 0)</code><code>        {</code><code>            erase();</code><code>            return;</code><code>        }</code><code></code><code>        // Now we can assume newLength is at least 1 element.  This algorithm</code><code>        // works as follows: First we are going to allocate a new array.  Then we</code><code>        // are going to copy elements from the existing array to the new array.</code><code>        // Once that is done, we can destroy the old array, and make m_data</code><code>        // point to the new array.</code><code></code><code>        // First we have to allocate a new array</code><code>        int* data{ new int[newLength] };</code><code></code><code>        // Then we have to figure out how many elements to copy from the existing</code><code>        // array to the new array.  We want to copy as many elements as there are</code><code>        // in the smaller of the two arrays.</code><code>        if (m_length &gt; 0)</code><code>        {</code><code>            int elementsToCopy{ (newLength &gt; m_length) ? m_length : newLength };</code><code></code><code>            // Now copy the elements one by one</code><code>            for (int index{ 0 }; index &lt; elementsToCopy; ++index)</code><code>                data[index] = m_data[index];</code><code>        }</code><code> </code><code>        // Now we can delete the old array because we don't need it any more</code><code>        delete[] m_data;</code><code></code><code>        // And use the new array instead!  Note that this simply makes m_data point</code><code>        // to the same address as the new array we dynamically allocated.  Because</code><code>        // data was dynamically allocated, it won't be destroyed when it goes out of scope.</code><code>        m_data = data;</code><code>        m_length = newLength;</code><code>    }</code></pre><p>Whew! That was a little tricky!</p><p>Many array container classes would stop here. However, just in case you want to see how insert and delete functionality would be implemented we’ll go ahead and write those too. Both of these algorithms are very similar to resize().</p><pre class="language-cpp line-numbers"><code>    void insertBefore(int value, int index)</code><code>    {</code><code>        // Sanity check our index value</code><code>        assert(index &gt;= 0 &amp;&amp; index &lt;= m_length);</code><code></code><code>        // First create a new array one element larger than the old array</code><code>        int* data{ new int[m_length+1] };</code><code></code><code>        // Copy all of the elements up to the index</code><code>        for (int before{ 0 }; before &lt; index; ++before)</code><code>            data[before] = m_data[before];</code><code></code><code>        // Insert our new element into the new array</code><code>        data[index] = value;</code><code></code><code>        // Copy all of the values after the inserted element</code><code>        for (int after{ index }; after &lt; m_length; ++after)</code><code>            data[after+1] = m_data[after];</code><code></code><code>        // Finally, delete the old array, and use the new array instead</code><code>        delete[] m_data;</code><code>        m_data = data;</code><code>        ++m_length;</code><code>    }</code><code></code><code>    void remove(int index)</code><code>    {</code><code>        // Sanity check our index value</code><code>        assert(index &gt;= 0 &amp;&amp; index &lt; m_length);</code><code></code><code>        // If this is the last remaining element in the array, set the array to empty and bail out</code><code>        if (m_length == 1)</code><code>        {</code><code>            erase();</code><code>            return;</code><code>        }</code><code></code><code>        // First create a new array one element smaller than the old array</code><code>        int* data{ new int[m_length-1] };</code><code></code><code>        // Copy all of the elements up to the index</code><code>        for (int before{ 0 }; before &lt; index; ++before)</code><code>            data[before] = m_data[before];</code><code></code><code>        // Copy all of the values after the removed element</code><code>        for (int after{ index+1 }; after &lt; m_length; ++after)</code><code>            data[after-1] = m_data[after];</code><code></code><code>        // Finally, delete the old array, and use the new array instead</code><code>        delete[] m_data;</code><code>        m_data = data;</code><code>        --m_length;</code><code>    }</code><code></code><code>    // A couple of additional functions just for convenience</code><code>    void insertAtBeginning(int value) { insertBefore(value, 0); }</code><code>    void insertAtEnd(int value) { insertBefore(value, m_length); }</code></pre><p>Here is our IntArray container class in its entirety.</p><p>IntArray.h:</p><pre class="language-cpp line-numbers"><code>#ifndef INTARRAY_H</code><code>#define INTARRAY_H</code><code></code><code>#include <cassert> // for assert()</cassert></code><code></code><code>class IntArray</code><code>{</code><code>private:</code><code>    int m_length{};</code><code>    int* m_data{};</code><code></code><code>public:</code><code>    IntArray() = default;</code><code></code><code>    IntArray(int length):</code><code>        m_length{ length }</code><code>    {</code><code>        assert(length &gt;= 0);</code><code>        if (length &gt; 0)</code><code>            m_data = new int[length]{};</code><code>    }</code><code></code><code>    ~IntArray()</code><code>    {</code><code>        delete[] m_data;</code><code>        // we don't need to set m_data to null or m_length to 0 here, since the object will be destroyed immediately after this function anyway</code><code>    }</code><code></code><code>    void erase()</code><code>    {</code><code>        delete[] m_data;</code><code>        // We need to make sure we set m_data to nullptr here, otherwise it will</code><code>        // be left pointing at deallocated memory!</code><code>        m_data = nullptr;</code><code>        m_length = 0;</code><code>    }</code><code></code><code>    int&amp; operator[](int index)</code><code>    {</code><code>        assert(index &gt;= 0 &amp;&amp; index &lt; m_length);</code><code>        return m_data[index];</code><code>    }</code><code></code><code>    // reallocate resizes the array.  Any existing elements will be destroyed.  This function operates quickly.</code><code>    void reallocate(int newLength)</code><code>    {</code><code>        // First we delete any existing elements</code><code>        erase();</code><code></code><code>        // If our array is going to be empty now, return here</code><code>        if (newLength &lt;= 0)</code><code>            return;</code><code></code><code>        // Then we have to allocate new elements</code><code>        m_data = new int[newLength];</code><code>        m_length = newLength;</code><code>    }</code><code></code><code>    // resize resizes the array.  Any existing elements will be kept.  This function operates slowly.</code><code>    void resize(int newLength)</code><code>    {</code><code>        // if the array is already the right length, we're done</code><code>        if (newLength == m_length)</code><code>            return;</code><code></code><code>        // If we are resizing to an empty array, do that and return</code><code>        if (newLength &lt;= 0)</code><code>        {</code><code>            erase();</code><code>            return;</code><code>        }</code><code></code><code>        // Now we can assume newLength is at least 1 element.  This algorithm</code><code>        // works as follows: First we are going to allocate a new array.  Then we</code><code>        // are going to copy elements from the existing array to the new array.</code><code>        // Once that is done, we can destroy the old array, and make m_data</code><code>        // point to the new array.</code><code></code><code>        // First we have to allocate a new array</code><code>        int* data{ new int[newLength] };</code><code></code><code>        // Then we have to figure out how many elements to copy from the existing</code><code>        // array to the new array.  We want to copy as many elements as there are</code><code>        // in the smaller of the two arrays.</code><code>        if (m_length &gt; 0)</code><code>        {</code><code>            int elementsToCopy{ (newLength &gt; m_length) ? m_length : newLength };</code><code></code><code>            // Now copy the elements one by one</code><code>            for (int index{ 0 }; index &lt; elementsToCopy; ++index)</code><code>                data[index] = m_data[index];</code><code>        }</code><code> </code><code>        // Now we can delete the old array because we don't need it any more</code><code>        delete[] m_data;</code><code></code><code>        // And use the new array instead!  Note that this simply makes m_data point</code><code>        // to the same address as the new array we dynamically allocated.  Because</code><code>        // data was dynamically allocated, it won't be destroyed when it goes out of scope.</code><code>        m_data = data;</code><code>        m_length = newLength;</code><code>    }</code><code></code><code>    void insertBefore(int value, int index)</code><code>    {</code><code>        // Sanity check our index value</code><code>        assert(index &gt;= 0 &amp;&amp; index &lt;= m_length);</code><code></code><code>        // First create a new array one element larger than the old array</code><code>        int* data{ new int[m_length+1] };</code><code></code><code>        // Copy all of the elements up to the index</code><code>        for (int before{ 0 }; before &lt; index; ++before)</code><code>            data[before] = m_data[before];</code><code></code><code>        // Insert our new element into the new array</code><code>        data[index] = value;</code><code></code><code>        // Copy all of the values after the inserted element</code><code>        for (int after{ index }; after &lt; m_length; ++after)</code><code>            data[after+1] = m_data[after];</code><code></code><code>        // Finally, delete the old array, and use the new array instead</code><code>        delete[] m_data;</code><code>        m_data = data;</code><code>        ++m_length;</code><code>    }</code><code></code><code>    void remove(int index)</code><code>    {</code><code>        // Sanity check our index value</code><code>        assert(index &gt;= 0 &amp;&amp; index &lt; m_length);</code><code></code><code>        // If we're removing the last element in the array, we can just erase the array and return early</code><code>        if (m_length == 1)</code><code>        {</code><code>            erase();</code><code>            return;</code><code>        }</code><code></code><code>        // First create a new array one element smaller than the old array</code><code>        int* data{ new int[m_length-1] };</code><code></code><code>        // Copy all of the elements up to the index</code><code>        for (int before{ 0 }; before  &lt; index; ++before)</code><code>            data[before] = m_data[before];</code><code></code><code>        // Copy all of the values after the removed element</code><code>        for (int after{ index+1 }; after &lt; m_length; ++after)</code><code>            data[after-1] = m_data[after];</code><code></code><code>        // Finally, delete the old array, and use the new array instead</code><code>        delete[] m_data;</code><code>        m_data = data;</code><code>        --m_length;</code><code>    }</code><code></code><code>    // A couple of additional functions just for convenience</code><code>    void insertAtBeginning(int value) { insertBefore(value, 0); }</code><code>    void insertAtEnd(int value) { insertBefore(value, m_length); }</code><code></code><code>    int getLength() const { return m_length; }</code><code>};</code><code></code><code>#endif</code></pre><p>Now, let’s test it just to prove it works:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include "IntArray.h"</code><code></code><code>int main()</code><code>{</code><code>    // Declare an array with 10 elements</code><code>    IntArray array(10);</code><code></code><code>    // Fill the array with numbers 1 through 10</code><code>    for (int i{ 0 }; i&lt;10; ++i)</code><code>        array[i] = i+1;</code><code></code><code>    // Resize the array to 8 elements</code><code>    array.resize(8);</code><code></code><code>    // Insert the number 20 before element with index 5</code><code>    array.insertBefore(20, 5);</code><code></code><code>    // Remove the element with index 3</code><code>    array.remove(3);</code><code></code><code>    // Add 30 and 40 to the end and beginning</code><code>    array.insertAtEnd(30);</code><code>    array.insertAtBeginning(40);</code><code></code><code>    // Print out all the numbers</code><code>    for (int i{ 0 }; i<array.getlength(); ++i)<="" code=""></array.getlength();></code><code>        std::cout &lt;&lt; array[i] &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This produces the result:</p><pre>40 1 2 3 5 20 6 7 8 30
</pre><p>Although writing container classes can be pretty complex, the good news is that you only have to write them once. Once the container class is working, you can use and reuse it as often as you like without any additional programming effort required.</p><p>It is also worth explicitly mentioning that even though our sample IntArray container class holds a built-in data type (int), we could have just as easily used a user-defined type (e.g. a Point class).</p><p>One more thing: If a class in the standard library meets your needs, use that instead of creating your own. For example, instead of using IntArray, you’re better off using <code>std::vector<int></int></code>. It’s battle tested, efficient, and plays nicely with the other classes in the standard library. But sometimes you need a specialized container class that doesn’t exist in the standard library, so it’s good to know how to create your own when you need to. We’ll talk more about containers in the standard library once we’ve covered a few more fundamental topics.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">16.7 — std::initializer_list</h1></header><div class="entry-content" itemprop="articleBody"><p>Consider a fixed array of integers in C++:</p><pre class="language-cpp line-numbers"><code>int array[5];</code></pre><p>If we want to initialize this array with values, we can do so directly via the initializer list syntax:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	int array[] { 5, 4, 3, 2, 1 }; // initializer list</code><code>	for (auto i : array)</code><code>		std::cout &lt;&lt; i &lt;&lt; ' ';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>5 4 3 2 1
</pre><p>This also works for dynamically allocated arrays:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	auto* array{ new int[5]{ 5, 4, 3, 2, 1 } }; // initializer list</code><code>	for (int count{ 0 }; count &lt; 5; ++count)</code><code>		std::cout &lt;&lt; array[count] &lt;&lt; ' ';</code><code>	delete[] array;</code><code></code><code>	return 0;</code><code>}</code></pre><p>In the previous lesson, we introduced the concept of container classes, and showed an example of an IntArray class that holds an array of integers:</p><pre class="language-cpp line-numbers"><code>#include <cassert> // for assert()</cassert></code><code>#include <iostream></iostream></code><code> </code><code>class IntArray</code><code>{</code><code>private:</code><code>    int m_length{};</code><code>    int* m_data{};</code><code> </code><code>public:</code><code>    IntArray() = default;</code><code> </code><code>    IntArray(int length)</code><code>        : m_length{ length }</code><code>        , m_data{ new int[length]{} }</code><code>    {</code><code>    }</code><code> </code><code>    ~IntArray()</code><code>    {</code><code>        delete[] m_data;</code><code>        // we don't need to set m_data to null or m_length to 0 here, since the object will be destroyed immediately after this function anyway</code><code>    }</code><code> </code><code>    int&amp; operator[](int index)</code><code>    {</code><code>        assert(index &gt;= 0 &amp;&amp; index &lt; m_length);</code><code>        return m_data[index];</code><code>    }</code><code> </code><code>    int getLength() const { return m_length; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	// What happens if we try to use an initializer list with this container class?</code><code>	IntArray array { 5, 4, 3, 2, 1 }; // this line doesn't compile</code><code>	for (int count{ 0 }; count &lt; 5; ++count)</code><code>		std::cout &lt;&lt; array[count] &lt;&lt; ' ';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This code won’t compile, because the IntArray class doesn’t have a constructor that knows what to do with an initializer list. As a result, we’re left initializing our array elements individually:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	IntArray array(5);</code><code>	array[0] = 5;</code><code>	array[1] = 4;</code><code>	array[2] = 3;</code><code>	array[3] = 2;</code><code>	array[4] = 1;</code><code></code><code>	for (int count{ 0 }; count &lt; 5; ++count)</code><code>		std::cout &lt;&lt; array[count] &lt;&lt; ' ';</code><code></code><code>	return 0;</code><code>}</code></pre><p>That’s not so great.</p><br><h3>Class initialization using std::initializer_list</h3><p>When a compiler sees an initializer list, it automatically converts it into an object of type std::initializer_list. Therefore, if we create a constructor that takes a std::initializer_list parameter, we can create objects using the initializer list as an input.</p><p>std::initializer_list lives in the &lt;initializer_list&gt; header.</p><p>There are a few things to know about std::initializer_list. Much like std::array or std::vector, you have to tell std::initializer_list what type of data the list holds using angled brackets, unless you initialize the std::initializer_list right away. Therefore, you’ll almost never see a plain std::initializer_list. Instead, you’ll see something like std::initializer_list&lt;int&gt; or std::initializer_list&lt;std::string&gt;.</p><p>Second, std::initializer_list has a (misnamed) size() function which returns the number of elements in the list. This is useful when we need to know the length of the list passed in.</p><p>Let’s take a look at updating our IntArray class with a constructor that takes a std::initializer_list.</p><pre class="language-cpp line-numbers"><code>#include <cassert> // for assert()</cassert></code><code>#include <initializer_list> // for std::initializer_list</initializer_list></code><code>#include <iostream></iostream></code><code></code><code>class IntArray</code><code>{</code><code>private:</code><code>	int m_length {};</code><code>	int* m_data {};</code><code></code><code>public:</code><code>	IntArray() = default;</code><code></code><code>	IntArray(int length)</code><code>		: m_length{ length }</code><code>		, m_data{ new int[length]{} }</code><code>	{</code><code></code><code>	}</code><code></code><code>	IntArray(std::initializer_list<int> list) // allow IntArray to be initialized via list initialization</int></code><code>		: IntArray(static_cast<int>(list.size())) // use delegating constructor to set up initial array</int></code><code>	{</code><code>		// Now initialize our array from the list</code><code>		int count{ 0 };</code><code>		for (auto element : list)</code><code>		{</code><code>			m_data[count] = element;</code><code>			++count;</code><code>		}</code><code>	}</code><code></code><code>	~IntArray()</code><code>	{</code><code>		delete[] m_data;</code><code>		// we don't need to set m_data to null or m_length to 0 here, since the object will be destroyed immediately after this function anyway</code><code>	}</code><code></code><code>	IntArray(const IntArray&amp;) = delete; // to avoid shallow copies</code><code>	IntArray&amp; operator=(const IntArray&amp; list) = delete; // to avoid shallow copies</code><code></code><code>	int&amp; operator[](int index)</code><code>	{</code><code>		assert(index &gt;= 0 &amp;&amp; index &lt; m_length);</code><code>		return m_data[index];</code><code>	}</code><code></code><code>	int getLength() const { return m_length; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	IntArray array{ 5, 4, 3, 2, 1 }; // initializer list</code><code>	for (int count{ 0 }; count &lt; array.getLength(); ++count)</code><code>		std::cout &lt;&lt; array[count] &lt;&lt; ' ';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This produces the expected result:</p><pre>5 4 3 2 1
</pre><p>It works! Now, let’s explore this in more detail.</p><p>Here’s our IntArray constructor that takes a std::initializer_list&lt;int&gt;.</p><pre class="language-cpp line-numbers"><code>	IntArray(std::initializer_list<int> list) // allow IntArray to be initialized via list initialization</int></code><code>		: IntArray(static_cast<int>(list.size())) // use delegating constructor to set up initial array</int></code><code>	{</code><code>		// Now initialize our array from the list</code><code>		int count{ 0 };</code><code>		for (int element : list)</code><code>		{</code><code>			m_data[count] = element;</code><code>			++count;</code><code>		}</code><code>	}</code></pre><p>On line 1: As noted above, we have to use angled brackets to denote what type of element we expect inside the list. In this case, because this is an IntArray, we’d expect the list to be filled with int. Note that we don’t pass the list by const reference. Much like std::string_view, std::initializer_list is very lightweight and copies tend to be cheaper than an indirection.</p><p>On line 2: We delegate allocating memory for the IntArray to the other constructor via a delegating constructor (to reduce redundant code). This other constructor needs to know the length of the array, so we pass it list.size(), which contains the number of elements in the list. Note that list.size() returns a size_t (which is unsigned) so we need to cast to a signed int here. We use direct initialization, rather than brace initialization, because brace initialization prefers list constructors. Although the constructor would get resolved correctly, it’s safer to use direct initialization to initialize classes with list constructors if we don’t want to use the list constructor.</p><p>The body of the constructor is reserved for copying the elements from the list into our IntArray class. For some inexplicable reason, std::initializer_list does not provide access to the elements of the list via subscripting (operator[]). The omission has been noted many times to the standards committee and never addressed.</p><p>However, there are easy ways to work around the lack of subscripts. The easiest way is to use a for-each loop here. The ranged-based for loop steps through each element of the initialization list, and we can manually copy the elements into our internal array.</p><p>One caveat: Initializer lists will always favor a matching initializer_list constructor over other potentially matching constructors. Thus, this variable definition:</p><pre class="language-cpp line-numbers"><code>IntArray array { 5 };</code></pre><p>would match to IntArray(std::initializer_list&lt;int&gt;), not IntArray(int). If you want to match to IntArray(int) once a list constructor has been defined, you’ll need to use copy initialization or direct initialization. The same happens to std::vector and other container classes that have both a list constructor and a constructor with a similar type of parameter</p><pre class="language-cpp line-numbers"><code>std::vector<int> array(5); // Calls std::vector::vector(std::vector::size_type), 5 value-initialized elements: 0 0 0 0 0</int></code><code>std::vector<int> array{ 5 }; // Calls std::vector::vector(std::initializer_list<int>), 1 element: 5</int></int></code></pre><br><h3>Class assignment using std::initializer_list</h3><p>You can also use std::initializer_list to assign new values to a class by overloading the assignment operator to take a std::initializer_list parameter. This works analogously to the above. We’ll show an example of how to do this in the quiz solution below.</p><p>Note that if you implement a constructor that takes a std::initializer_list, you should ensure you do at least one of the following:</p><ol><li>Provide an overloaded list assignment operator</li><li>Provide a proper deep-copying copy assignment operator</li></ol><p>Here’s why: consider the above class (which doesn’t have an overloaded list assignment or a copy assignment), along with following statement:</p><pre class="language-cpp line-numbers"><code>	array = { 1, 3, 5, 7, 9, 11 }; // overwrite the elements of array with the elements from the list</code></pre><p>First, the compiler will note that an assignment function taking a std::initializer_list doesn’t exist. Next it will look for other assignment functions it could use, and discover the implicitly provided copy assignment operator. However, this function can only be used if it can convert the initializer list into an IntArray. Because { 1, 3, 5, 7, 9, 11 } is a std::initializer_list, the compiler will use the list constructor to convert the initializer list into a temporary IntArray. Then it will call the implicit assignment operator, which will shallow copy the temporary IntArray into our array object.</p><p>At this point, both the temporary IntArray’s m_data and array-&gt;m_data point to the same address (due to the shallow copy). You can already see where this is going.</p><p>At the end of the assignment statement, the temporary IntArray is destroyed. That calls the destructor, which deletes the temporary IntArray’s m_data. This leaves array-&gt;m_data as a dangling pointer. When you try to use array-&gt;m_data for any purpose (including when array goes out of scope and the destructor goes to delete m_data), you’ll get undefined results (and probably a crash).</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>If you provide list construction, it’s a good idea to provide list assignment as well.</p></div><br><h3>Summary</h3><p>Implementing a constructor that takes a std::initializer_list parameter allows us to use list initialization with our custom classes. We can also use std::initializer_list to implement other functions that need to use an initializer list, such as an assignment operator.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Using the IntArray class above, implement an overloaded assignment operator that takes an initializer list.</p><p>The following code should run:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	IntArray array { 5, 4, 3, 2, 1 }; // initializer list</code><code>	for (int count{ 0 }; count &lt; array.getLength(); ++count)</code><code>		std::cout &lt;&lt; array[count] &lt;&lt; ' ';</code><code></code><code>	std::cout &lt;&lt; '\n';</code><code></code><code>	array = { 1, 3, 5, 7, 9, 11 };</code><code></code><code>	for (int count{ 0 }; count &lt; array.getLength(); ++count)</code><code>		std::cout &lt;&lt; array[count] &lt;&lt; ' ';</code><code></code><code>	std::cout &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This should print:</p><pre>5 4 3 2 1 
1 3 5 7 9 11
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <cassert> // for assert()</cassert></code><code>#include <initializer_list> // for std::initializer_list</initializer_list></code><code>#include <iostream></iostream></code><code></code><code>class IntArray</code><code>{</code><code>private:</code><code>	int m_length {};</code><code>	int* m_data {};</code><code></code><code>public:</code><code>	IntArray() = default;</code><code></code><code>	IntArray(int length)</code><code>		: m_length{ length }</code><code>		, m_data{ new int[length]{} }</code><code>	{</code><code></code><code>	}</code><code></code><code>	IntArray(std::initializer_list<int> list) : // allow IntArray to be initialized via list initialization</int></code><code>		IntArray(static_cast<int>(list.size())) // use delegating constructor to set up initial array</int></code><code>	{</code><code>		// Now initialize our array from the list</code><code>		int count{ 0 };</code><code>		for (auto element : list)</code><code>		{</code><code>			m_data[count] = element;</code><code>			++count;</code><code>		}</code><code>	}</code><code></code><code>	~IntArray()</code><code>	{</code><code>		delete[] m_data;</code><code>		// we don't need to set m_data to null or m_length to 0 here, since the object will be destroyed immediately after this function anyway</code><code>	}</code><code></code><code>	IntArray(const IntArray&amp;) = delete; // to avoid shallow copies</code><code>	IntArray&amp; operator=(const IntArray&amp; list) = delete; // to avoid shallow copies</code><code></code><code>	IntArray&amp; operator=(std::initializer_list<int> list)</int></code><code>	{</code><code>		// If the new list is a different size, reallocate it</code><code>		int length{ static_cast<int>(list.size()) };</int></code><code>		if (length != m_length)</code><code>		{</code><code>			delete[] m_data;</code><code>			m_length = length;</code><code>			m_data = new int[length]{};</code><code>		}</code><code></code><code>		// Now initialize our array from the list</code><code>		int count{ 0 };</code><code>		for (auto element : list)</code><code>		{</code><code>			m_data[count] = element;</code><code>			++count;</code><code>		}</code><code></code><code>		return *this;</code><code>	}</code><code></code><code>	int&amp; operator[](int index)</code><code>	{</code><code>		assert(index &gt;= 0 &amp;&amp; index &lt; m_length);</code><code>		return m_data[index];</code><code>	}</code><code></code><code>	int getLength() const { return m_length; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	IntArray array { 5, 4, 3, 2, 1 }; // initializer list</code><code>	for (int count{ 0 }; count &lt; array.getLength(); ++count)</code><code>		std::cout &lt;&lt; array[count] &lt;&lt; ' ';</code><code></code><code>	std::cout &lt;&lt; '\n';</code><code></code><code>	array = { 1, 3, 5, 7, 9, 11 };</code><code></code><code>	for (int count{ 0 }; count &lt; array.getLength(); ++count)</code><code>		std::cout &lt;&lt; array[count] &lt;&lt; ' ';</code><code></code><code>	std::cout &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">16.x — Chapter 16 comprehensive quiz</h1></header><div class="entry-content" itemprop="articleBody"><p>In this chapter, we learned about some different kinds of relationships between two objects.</p><p><strong>Summary</strong></p><p>The process of building complex objects from simpler ones is called <strong>object composition</strong>. There are two types of object composition: composition, and aggregation.</p><p><strong>Composition</strong> exists when a member of a class has a part-of relationship with the class. In a composition relationship, the class manages the existence of the members. To qualify as a <strong>composition</strong>, an object and a part must have the following relationship:</p><ul><li>The part (member) is part of the object (class)</li><li>The part (member) can only belong to one object (class) at a time</li><li>The part (member) has its existence managed by the object (class)</li><li>The part (member) does not know about the existence of the object (class)</li></ul><p>Compositions are typically implemented via normal member variables, or by pointers where the class manages all the memory allocation and deallocation. If you can implement a class as a composition, you should implement a class as a composition.</p><p><strong>Aggregations</strong> exists when a class has a has-a relationship with the member. In an aggregation relationship, the class does not manage the existence of the members. To qualify as an <strong>aggregation</strong>, an object and its parts must have the following relationship:</p><ul><li>The part (member) is part of the object (class)</li><li>The part (member) can belong to more than one object (class) at a time</li><li>The part (member) does <em>not</em> have its existence managed by the object (class)</li><li>The part (member) does not know about the existence of the object (class)</li></ul><p>Aggregations are typically implemented via pointer or reference.</p><p><strong>Associations</strong> are a looser type of relationship, where the class uses-an otherwise unrelated object. To qualify as an <strong>association</strong>, an object and an associated object must have the following relationship:</p><ul><li>The associated object (member) is otherwise unrelated to the object (class)</li><li>The associated object (member) can belong to more than one object (class) at a time</li><li>The associated object (member) does <em>not</em> have its existence managed by the object (class)</li><li>The associated object (member) may or may not know about the existence of the object (class)</li></ul><p>Associations may be implemented via pointer or reference, or by a more indirect means (such as holding the index or key of the associated object).</p><p>In a <strong>dependency</strong>, one class uses another class to perform a task. The dependent class typically is not a member of the class using it, but rather is temporarily created, used, and then destroyed, or passed into a member function from an external source.</p><p>In a <strong>container class</strong> one class provides a container to hold multiple objects of another type. A <strong>value container</strong> is a composition that stores copies of the objects it is holding. A <strong>reference container</strong> is an aggregation that stores pointers or references to objects that live outside the container.</p><p>std::initializer_list can be used to implement constructors, assignment operators, and other functions that accept a list initialization parameter. std::initailizer_list lives in the &lt;initializer_list&gt; header.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Property\Type</th><th>Composition</th><th>Aggregation</th><th>Association</th><th>Dependency</th></tr><tr><td>Relationship type</td><td>Whole/part</td><td>Whole/part</td><td>Otherwise unrelated</td><td>Otherwise unrelated</td></tr><tr><td>Members can belong to multiple classes</td><td>No</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Members existence managed by class</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>Directionality</td><td>Unidirectional</td><td>Unidirectional</td><td>Unidirectional or bidirectional</td><td>Unidirectional</td></tr><tr><td>Relationship verb</td><td>Part-of</td><td>Has-a</td><td>Uses-a</td><td>Depends-on</td></tr></tbody></table></div><p><strong>Quiz time</strong></p><p>This chapter is pretty straightforward and a little more abstract than the previous ones, so this quiz will be short and to the point.</p><ol start="1"><li>What type of relationship (composition, aggregation, association, or dependency) do the following describe?</li></ol><p>1a) An Animal class that contains an animal type (enum) and name (string).<br><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none">Composition -- The animal type and name don’t have a use outside of the Animal.</div><p>1b) A text editor class with a save() function that takes a File object as an argument. The save() function writes the contents of the editor to disk.<br><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none">Dependency -- The text editor class is using the File object for the task of saving to disk.</div><p>1c) An Adventurer class that can carry various kinds of Items, such as swords, wands, potions, or spellbooks. These Items can be dropped and picked up by other Adventurers.<br><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none">Aggregation -- When the Items are associated with the Adventurer, the Adventurer has-them. A sword being used by an adventurer can’t be used by anybody else at that time. But the Adventurer doesn’t manage the items existences.</div><p>1d) The Player prays at a Shrine to receive a new power.<br><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none">Dependency -- They player depends on the shrine to receive the power, but does not have any long-term association with it.</div><p>1e) A Computer class that contains a CPU class. The CPU can be removed from the Computer and tested on its own.<br><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none">Aggregation -- The computer has a CPU, but does not manage its existence.</div><p>1f) A blacksmith has a specific anvil that he uses to do his work.<br><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none">Association -- The blacksmith uses the anvil, but does not have a whole-part relationship with it.</div><ol start="2"><li>Select one: If you can design a class using (composition, aggregation, association, or dependency), then you should.</li></ol><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none">composition</div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">17.1 — Introduction to inheritance</h1></header><div class="entry-content" itemprop="articleBody"><p>In the last chapter, we discussed object composition, where complex classes are constructed from simpler classes and types. Object composition is perfect for building new objects that have a “has-a” relationship with their parts. However, object composition is just one of the two major ways that C++ lets you construct complex classes. The second way is through inheritance, which models an “is-a” relationship between two objects.</p><p>Unlike object composition, which involves creating new objects by combining and connecting other objects, inheritance involves creating new objects by directly acquiring the attributes and behaviors of other objects and then extending or specializing them. Like object composition, inheritance is everywhere in real life. When you were conceived, you inherited your parents genes, and acquired physical attributes from both of them -- but then you added your own personality on top. Technological products (computers, cell phones, etc…) inherit features from their predecessors (often used for backwards compatibility). For example, the Intel Pentium processor inherited many of the features defined by the Intel 486 processor, which itself inherited features from earlier processors. C++ inherited many features from C, the language upon which it is based, and C inherited many of its features from the programming languages that came before it.</p><p>Consider apples and bananas. Although apples and bananas are different fruits, both have in common that they <em>are</em> fruits. And because apples and bananas are fruits, simple logic tells us that anything that is true of fruits is also true of apples and bananas. For example, all fruits have a name, a color, and a size. Therefore, apples and bananas also have a name, a color, and a size. We can say that apples and bananas inherit (acquire) these all of the properties of fruit because they <em>are</em> fruit. We also know that fruit undergoes a ripening process, by which it becomes edible. Because apples and bananas are fruit, we also know that apples and bananas will inherit the behavior of ripening.</p><p>Put into a diagram, the relationship between apples, bananas, and fruit might look something like this:</p><p><img src="http://learncpp.com/images/CppTutorial/Section11/FruitInheritance.gif"></p><p>This diagram defines a hierarchy.</p><p><strong>Hierarchies</strong></p><p>A hierarchy is a diagram that shows how various objects are related. Most hierarchies either show a progression over time (386 -&gt; 486 -&gt; Pentium), or categorize things in a way that moves from general to specific (fruit -&gt; apple -&gt; red delicious). If you’ve ever taken biology, the famous domain, kingdom, phylum, class, order, family, genus, and species ordering defines a hierarchy (from general to specific).</p><p>Here’s another example of a hierarchy: a square is a rectangle, which is a quadrilateral, which is a shape. A right triangle is a triangle, which is also a shape. Put into a hierarchy diagram, that would look like this:</p><p><img src="http://learncpp.com/images/CppTutorial/Section11/ShapesInheritance.gif"></p><p>This diagram goes from general (top) to specific (bottom), with each item in the hierarchy inheriting the properties and behaviors of the item above it.</p><p><strong>A look ahead</strong></p><p>In this chapter, we’ll explore the basics of how inheritance works in C++.</p><p>Next chapter, we’ll explore how inheritance enables polymorphism (one of object-oriented programming’s big buzzwords) through virtual functions.</p><p>As we progress, we’ll also talk about inheritance’s key benefits, as well as some of the downsides.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">17.2 — Basic inheritance in C++</h1></header><div class="entry-content" itemprop="articleBody"><p>Now that we’ve talked about what inheritance is in an abstract sense, let’s talk about how it’s used within C++.</p><p>Inheritance in C++ takes place between classes. In an inheritance (is-a) relationship, the class being inherited from is called the <strong>parent class</strong>, <strong>base class</strong>, or <strong>superclass</strong>, and the class doing the inheriting is called the <strong>child class</strong>, <strong>derived class</strong>, or <strong>subclass</strong>.</p><p><img src="http://learncpp.com/images/CppTutorial/Section11/FruitInheritance.gif"></p><p>In the above diagram, Fruit is the parent, and both Apple and Banana are children.</p><p><img src="http://learncpp.com/images/CppTutorial/Section11/ShapesInheritance.gif"></p><p>In this diagram, Triangle is both a child (to Shape) and a parent (to Right Triangle).</p><p>A child class inherits both behaviors (member functions) and properties (member variables) from the parent (subject to some access restrictions that we’ll cover in a future lesson).<br>These variables and functions become members of the derived class.</p><p>Because child classes are full-fledged classes, they can (of course) have their own members that are specific to that class. We’ll see an example of this in a moment.</p><p><strong>A Person class</strong></p><p>Here’s a simple class to represent a generic person:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>class Person</code><code>{</code><code>// In this example, we're making our members public for simplicity</code><code>public: </code><code>    std::string m_name{};</code><code>    int m_age{};</code><code></code><code>    Person(const std::string&amp; name = "", int age = 0)</code><code>        : m_name{ name }, m_age{ age }</code><code>    {</code><code>    }</code><code></code><code>    const std::string&amp; getName() const { return m_name; }</code><code>    int getAge() const { return m_age; }</code><code></code><code>};</code></pre><p>Because this Person class is designed to represent a generic person, we’ve only defined members that would be common to any type of person. Every person (regardless of gender, profession, etc…) has a name and age, so those are represented here.</p><p>Note that in this example, we’ve made all of our variables and functions public. This is purely for the sake of keeping these examples simple right now. Normally we would make the variables private. We will talk about access controls and how those interact with inheritance later in this chapter.</p><p><strong>A BaseballPlayer class</strong></p><p>Let’s say we wanted to write a program that keeps track of information about some baseball players. Baseball players need to contain information that is specific to baseball players -- for example, we might want to store a player’s batting average, and the number of home runs they’ve hit.</p><p>Here’s our incomplete Baseball player class:</p><pre class="language-cpp line-numbers"><code>class BaseballPlayer</code><code>{</code><code>// In this example, we're making our members public for simplicity</code><code>public:</code><code>    double m_battingAverage{};</code><code>    int m_homeRuns{};</code><code></code><code>    BaseballPlayer(double battingAverage = 0.0, int homeRuns = 0)</code><code>       : m_battingAverage{battingAverage}, m_homeRuns{homeRuns}</code><code>    {</code><code>    }</code><code>};</code></pre><p>Now, we also want to keep track of a baseball player’s name and age, and we already have that information as part of our Person class.</p><p>We have three choices for how to add name and age to BaseballPlayer:</p><ol start="1"><li>Add name and age to the BaseballPlayer class directly as members. This is probably the worst choice, as we’re duplicating code that already exists in our Person class. Any updates to Person will have to be made in BaseballPlayer too.</li><li>Add Person as a member of BaseballPlayer using composition. But we have to ask ourselves, “does a BaseballPlayer have a Person”? No, it doesn’t. So this isn’t the right paradigm.</li><li>Have BaseballPlayer inherit those attributes from Person. Remember that inheritance represents an is-a relationship. Is a BaseballPlayer a Person? Yes, it is. So inheritance is a good choice here.</li></ol><p><strong>Making BaseballPlayer a derived class</strong></p><p>To have BaseballPlayer inherit from our Person class, the syntax is fairly simple. After the <code>class BaseballPlayer</code> declaration, we use a colon, the word “public”, and the name of the class we wish to inherit. This is called <em>public inheritance</em>. We’ll talk more about what public inheritance means in a future lesson.</p><pre class="language-cpp line-numbers"><code>// BaseballPlayer publicly inheriting Person</code><code>class BaseballPlayer : public Person</code><code>{</code><code>public:</code><code>    double m_battingAverage{};</code><code>    int m_homeRuns{};</code><code></code><code>    BaseballPlayer(double battingAverage = 0.0, int homeRuns = 0)</code><code>       : m_battingAverage{battingAverage}, m_homeRuns{homeRuns}</code><code>    {</code><code>    }</code><code>};</code></pre><p>Using a derivation diagram, our inheritance looks like this:</p><p><img src="https://www.learncpp.com/images/CppTutorial/Section11/BaseballPlayerInheritance.gif" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Section11/BaseballPlayerInheritance.gif"></p><p>When BaseballPlayer inherits from Person, BaseballPlayer acquires the member functions and variables from Person. Additionally, BaseballPlayer defines two members of its own: m_battingAverage and m_homeRuns. This makes sense, since these properties are specific to a BaseballPlayer, not to any Person.</p><p>Thus, BaseballPlayer objects will have 4 member variables: m_battingAverage and m_homeRuns from BaseballPlayer, and m_name and m_age from Person.</p><p>This is easy to prove:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>class Person</code><code>{</code><code>public:</code><code>    std::string m_name{};</code><code>    int m_age{};</code><code></code><code>    Person(const std::string&amp; name = "", int age = 0)</code><code>        : m_name{name}, m_age{age}</code><code>    {</code><code>    }</code><code></code><code>    const std::string&amp; getName() const { return m_name; }</code><code>    int getAge() const { return m_age; }</code><code></code><code>};</code><code></code><code>// BaseballPlayer publicly inheriting Person</code><code>class BaseballPlayer : public Person</code><code>{</code><code>public:</code><code>    double m_battingAverage{};</code><code>    int m_homeRuns{};</code><code></code><code>    BaseballPlayer(double battingAverage = 0.0, int homeRuns = 0)</code><code>       : m_battingAverage{battingAverage}, m_homeRuns{homeRuns}</code><code>    {</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    // Create a new BaseballPlayer object</code><code>    BaseballPlayer joe{};</code><code>    // Assign it a name (we can do this directly because m_name is public)</code><code>    joe.m_name = "Joe";</code><code>    // Print out the name</code><code>    std::cout &lt;&lt; joe.getName() &lt;&lt; '\n'; // use the getName() function we've acquired from the Person base class</code><code></code><code>    return 0;</code><code>}</code></pre><p>Which prints the value:</p><pre>Joe
</pre><p>This compiles and runs because joe is a BaseballPlayer, and all BaseballPlayer objects have a m_name member variable and a getName() member function inherited from the Person class.</p><p><strong>An Employee derived class</strong></p><p>Now let’s write another class that also inherits from Person. This time, we’ll write an Employee class. An employee “is a” person, so using inheritance is appropriate:</p><pre class="language-cpp line-numbers"><code>// Employee publicly inherits from Person</code><code>class Employee: public Person</code><code>{</code><code>public:</code><code>    double m_hourlySalary{};</code><code>    long m_employeeID{};</code><code></code><code>    Employee(double hourlySalary = 0.0, long employeeID = 0)</code><code>        : m_hourlySalary{hourlySalary}, m_employeeID{employeeID}</code><code>    {</code><code>    }</code><code></code><code>    void printNameAndSalary() const</code><code>    {</code><code>        std::cout &lt;&lt; m_name &lt;&lt; ": " &lt;&lt; m_hourlySalary &lt;&lt; '\n';</code><code>    }</code><code>};</code></pre><p>Employee inherits m_name and m_age from Person (as well as the two access functions), and adds two more member variables and a member function of its own. Note that printNameAndSalary() uses variables both from the class it belongs to (Employee::m_hourlySalary) and the parent class (Person::m_name).</p><p>This gives us a derivation chart that looks like this:</p><p><img src="https://www.learncpp.com/images/CppTutorial/Section11/EmployeeInheritance.gif" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Section11/EmployeeInheritance.gif"></p><p>Note that Employee and BaseballPlayer don’t have any direct relationship, even though they both inherit from Person.</p><p>Here’s a full example using Employee:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>class Person</code><code>{</code><code>public:</code><code>    std::string m_name{};</code><code>    int m_age{};</code><code></code><code>    const std::string&amp; getName() const { return m_name; }</code><code>    int getAge() const { return m_age; }</code><code></code><code>    Person(const std::string&amp; name = "", int age = 0)</code><code>        : m_name{name}, m_age{age}</code><code>    {</code><code>    }</code><code>};</code><code></code><code>// Employee publicly inherits from Person</code><code>class Employee: public Person</code><code>{</code><code>public:</code><code>    double m_hourlySalary{};</code><code>    long m_employeeID{};</code><code></code><code>    Employee(double hourlySalary = 0.0, long employeeID = 0)</code><code>        : m_hourlySalary{hourlySalary}, m_employeeID{employeeID}</code><code>    {</code><code>    }</code><code></code><code>    void printNameAndSalary() const</code><code>    {</code><code>        std::cout &lt;&lt; m_name &lt;&lt; ": " &lt;&lt; m_hourlySalary &lt;&lt; '\n';</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Employee frank{20.25, 12345};</code><code>    frank.m_name = "Frank"; // we can do this because m_name is public</code><code></code><code>    frank.printNameAndSalary();</code><code>    </code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>Frank: 20.25
</pre><p><strong>Inheritance chains</strong></p><p>It’s possible to inherit from a class that is itself derived from another class. There is nothing noteworthy or special when doing so -- everything proceeds as in the examples above.</p><p>For example, let’s write a Supervisor class. A Supervisor is an Employee, which is a Person. We’ve already written an Employee class, so let’s use that as the base class from which to derive Supervisor:</p><pre class="language-cpp line-numbers"><code>class Supervisor: public Employee</code><code>{</code><code>public:</code><code>    // This Supervisor can oversee a max of 5 employees</code><code>    long m_overseesIDs[5]{};</code><code>};</code></pre><p>Now our derivation chart looks like this:</p><p><img src="https://www.learncpp.com/images/CppTutorial/Section11/SupervisorInheritance.gif" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Section11/SupervisorInheritance.gif"></p><p>All Supervisor objects inherit the functions and variables from both Employee and Person, and add their own m_overseesIDs member variable.</p><p>By constructing such inheritance chains, we can create a set of reusable classes that are very general (at the top) and become progressively more specific at each level of inheritance.</p><p><strong>Why is this kind of inheritance useful?</strong></p><p>Inheriting from a base class means we don’t have to redefine the information from the base class in our derived classes. We automatically receive the member functions and member variables of the base class through inheritance, and then simply add the additional functions or member variables we want. This not only saves work, but also means that if we ever update or modify the base class (e.g. add new functions, or fix a bug), all of our derived classes will automatically inherit the changes!</p><p>For example, if we ever added a new function to Person, both Employee and Supervisor would automatically gain access to it. If we added a new variable to Employee, Supervisor would also gain access to it. This allows us to construct new classes in an easy, intuitive, and low-maintenance way!</p><p><strong>Conclusion</strong></p><p>Inheritance allows us to reuse classes by having other classes inherit their members. In future lessons, we’ll continue to explore how this works.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">17.3 — Order of construction of derived classes</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson on <a href="https://www.learncpp.com/cpp-tutorial/112-basic-inheritance-in-c/">basic inheritance in C++</a>, you learned that classes can inherit members and functions from other classes. In this lesson, we’re going to take a closer look at the order of construction that happens when a derived class is instantiated.</p><p>First, let’s introduce some new classes that will help us illustrate some important points.</p><pre class="language-cpp line-numbers"><code>class Base</code><code>{</code><code>public:</code><code>    int m_id {};</code><code></code><code>    Base(int id=0)</code><code>        : m_id { id }</code><code>    {</code><code>    }</code><code></code><code>    int getId() const { return m_id; }</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    double m_cost {};</code><code></code><code>    Derived(double cost=0.0)</code><code>        : m_cost { cost }</code><code>    {</code><code>    }</code><code></code><code>    double getCost() const { return m_cost; }</code><code>};</code></pre><p>In this example, class Derived is derived from class Base.</p><p><img src="https://www.learncpp.com/images/CppTutorial/Section11/DerivedBase.gif" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Section11/DerivedBase.gif"></p><p>Because Derived inherits functions and variables from Base, you may assume that the members of Base are copied into Derived. However, this is not true. Instead, we can consider Derived as a two part class: one part Derived, and one part Base.</p><p><img src="https://www.learncpp.com/images/CppTutorial/Section11/DerivedBaseCombined.gif" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Section11/DerivedBaseCombined.gif"></p><p>You’ve already seen plenty examples of what happens when we instantiate a normal (non-derived) class:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Base base;</code><code></code><code>    return 0;</code><code>}</code></pre><p>Base is a non-derived class because it does not inherit from any other classes. C++ allocates memory for Base, then calls Base’s default constructor to do the initialization.</p><p>Now let’s take a look at what happens when we instantiate a derived class:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Derived derived;</code><code></code><code>    return 0;</code><code>}</code></pre><p>If you were to try this yourself, you wouldn’t notice any difference from the previous example where we instantiate non-derived class Base. But behind the scenes, things happen slightly differently. As mentioned above, Derived is really two parts: a Base part, and a Derived part. When C++ constructs derived objects, it does so in phases. First, the most-base class (at the top of the inheritance tree) is constructed first. Then each child class is constructed in order, until the most-child class (at the bottom of the inheritance tree) is constructed last.</p><p>So when we instantiate an instance of Derived, first the Base portion of Derived is constructed (using the Base default constructor). Once the Base portion is finished, the Derived portion is constructed (using the Derived default constructor). At this point, there are no more derived classes, so we are done.</p><p>This process is actually easy to illustrate.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>public:</code><code>    int m_id {};</code><code></code><code>    Base(int id=0)</code><code>        : m_id { id }</code><code>    {</code><code>        std::cout &lt;&lt; "Base\n";</code><code>    }</code><code></code><code>    int getId() const { return m_id; }</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    double m_cost {};</code><code></code><code>    Derived(double cost=0.0)</code><code>        : m_cost { cost }</code><code>    {</code><code>        std::cout &lt;&lt; "Derived\n";</code><code>    }</code><code></code><code>    double getCost() const { return m_cost; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Instantiating Base\n";</code><code>    Base base;</code><code></code><code>    std::cout &lt;&lt; "Instantiating Derived\n";</code><code>    Derived derived;</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program produces the following result:</p><pre>Instantiating Base
Base
Instantiating Derived
Base
Derived
</pre><p>As you can see, when we constructed Derived, the Base portion of Derived got constructed first. This makes sense: logically, a child can not exist without a parent. It’s also the safe way to do things: the child class often uses variables and functions from the parent, but the parent class knows nothing about the child. Instantiating the parent class first ensures those variables are already initialized by the time the derived class is created and ready to use them.</p><p><strong>Order of construction for inheritance chains</strong></p><p>It is sometimes the case that classes are derived from other classes, which are themselves derived from other classes. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class A</code><code>{</code><code>public:</code><code>    A()</code><code>    {</code><code>        std::cout &lt;&lt; "A\n";</code><code>    }</code><code>};</code><code></code><code>class B: public A</code><code>{</code><code>public:</code><code>    B()</code><code>    {</code><code>        std::cout &lt;&lt; "B\n";</code><code>    }</code><code>};</code><code></code><code>class C: public B</code><code>{</code><code>public:</code><code>    C()</code><code>    {</code><code>        std::cout &lt;&lt; "C\n";</code><code>    }</code><code>};</code><code></code><code>class D: public C</code><code>{</code><code>public:</code><code>    D()</code><code>    {</code><code>        std::cout &lt;&lt; "D\n";</code><code>    }</code><code>};</code></pre><p>Remember that C++ always constructs the “first” or “most base” class first. It then walks through the inheritance tree in order and constructs each successive derived class.</p><p>Here’s a short program that illustrates the order of creation all along the inheritance chain.</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Constructing A: \n";</code><code>    A a;</code><code></code><code>    std::cout &lt;&lt; "Constructing B: \n";</code><code>    B b;</code><code></code><code>    std::cout &lt;&lt; "Constructing C: \n";</code><code>    C c;</code><code></code><code>    std::cout &lt;&lt; "Constructing D: \n";</code><code>    D d;</code><code>}</code></pre><p>This code prints the following:</p><pre>Constructing A:
A
Constructing B:
A
B
Constructing C:
A
B
C
Constructing D:
A
B
C
D
</pre><p><strong>Conclusion</strong></p><p>C++ constructs derived classes in phases, starting with the most-base class (at the top of the inheritance tree) and finishing with the most-child class (at the bottom of the inheritance tree). As each class is constructed, the appropriate constructor from that class is called to initialize that part of the class.</p><p>You will note that our example classes in this section have all used base class default constructors (for simplicity). In the next lesson, we will take a closer look at the role of constructors in the process of constructing derived classes (including how to explicitly choose which base class constructor you want your derived class to use).</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">17.4 — Constructors and initialization of derived classes</h1></header><div class="entry-content" itemprop="articleBody"><p>In the past two lessons, we’ve explored some basics around inheritance in C++ and the order that derived classes are initialized. In this lesson, we’ll take a closer look at the role of constructors in the initialization of derived classes. To do so, we will continue to use the simple Base and Derived classes we developed in the previous lesson:</p><pre class="language-cpp line-numbers"><code>class Base</code><code>{</code><code>public:</code><code>    int m_id {};</code><code> </code><code>    Base(int id=0)</code><code>        : m_id{ id }</code><code>    {</code><code>    }</code><code> </code><code>    int getId() const { return m_id; }</code><code>};</code><code> </code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    double m_cost {};</code><code> </code><code>    Derived(double cost=0.0)</code><code>        : m_cost{ cost }</code><code>    {</code><code>    }</code><code> </code><code>    double getCost() const { return m_cost; }</code><code>};</code></pre><p>With non-derived classes, constructors only have to worry about their own members. For example, consider Base. We can create a Base object like this:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Base base{ 5 }; // use Base(int) constructor</code><code></code><code>    return 0;</code><code>}</code></pre><p>Here’s what actually happens when base is instantiated:</p><ol><li>Memory for base is set aside</li><li>The appropriate Base constructor is called</li><li>The member initializer list initializes variables</li><li>The body of the constructor executes</li><li>Control is returned to the caller</li></ol><p>This is pretty straightforward. With derived classes, things are slightly more complex:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Derived derived{ 1.3 }; // use Derived(double) constructor</code><code></code><code>    return 0;</code><code>}</code></pre><p>Here’s what actually happens when derived is instantiated:</p><ol><li>Memory for derived is set aside (enough for both the Base and Derived portions)</li><li>The appropriate Derived constructor is called</li><li><b>The Base object is constructed first using the appropriate Base constructor</b>. If no base constructor is specified, the default constructor will be used.</li><li>The member initializer list initializes variables</li><li>The body of the constructor executes</li><li>Control is returned to the caller</li></ol><p>The only real difference between this case and the non-inherited case is that before the Derived constructor can do anything substantial, the Base constructor is called first. The Base constructor sets up the Base portion of the object, control is returned to the Derived constructor, and the Derived constructor is allowed to finish up its job.</p><p><strong>Initializing base class members</strong></p><p>One of the current shortcomings of our Derived class as written is that there is no way to initialize m_id when we create a Derived object. What if we want to set both m_cost (from the Derived portion of the object) and m_id (from the Base portion of the object) when we create a Derived object?</p><p>New programmers often attempt to solve this problem as follows:</p><pre class="language-cpp line-numbers"><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    double m_cost {};</code><code></code><code>    Derived(double cost=0.0, int id=0)</code><code>        // does not work</code><code>        : m_cost{ cost }</code><code>        , m_id{ id }</code><code>    {</code><code>    }</code><code></code><code>    double getCost() const { return m_cost; }</code><code>};</code></pre><p>This is a good attempt, and is almost the right idea. We definitely need to add another parameter to our constructor, otherwise C++ will have no way of knowing what value we want to initialize m_id to.</p><p>However, C++ prevents classes from initializing inherited member variables in the member initializer list of a constructor. In other words, the value of a member variable can only be set in a member initializer list of a constructor belonging to the same class as the variable.</p><p>Why does C++ do this? The answer has to do with const and reference variables. Consider what would happen if m_id were const. Because const variables must be initialized with a value at the time of creation, the base class constructor must set its value when the variable is created. However, when the base class constructor finishes, the derived class constructor’s member initializer lists are then executed. Each derived class would then have the opportunity to initialize that variable, potentially changing its value! By restricting the initialization of variables to the constructor of the class those variables belong to, C++ ensures that all variables are initialized only once.</p><p>The end result is that the above example does not work because m_id was inherited from Base, and only non-inherited variables can be initialized in the member initializer list.</p><p>However, inherited variables can still have their values changed in the body of the constructor using an assignment. Consequently, new programmers often also try this:</p><pre class="language-cpp line-numbers"><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    double m_cost {};</code><code></code><code>    Derived(double cost=0.0, int id=0)</code><code>        : m_cost{ cost }</code><code>    {</code><code>        m_id = id;</code><code>    }</code><code></code><code>    double getCost() const { return m_cost; }</code><code>};</code></pre><p>While this actually works in this case, it wouldn’t work if m_id were a const or a reference (because const values and references have to be initialized in the member initializer list of the constructor). It’s also inefficient because m_id gets assigned a value twice: once in the member initializer list of the Base class constructor, and then again in the body of the Derived class constructor. And finally, what if the Base class needed access to this value during construction? It has no way to access it, since it’s not set until the Derived constructor is executed (which pretty much happens last).</p><p>So how do we properly initialize m_id when creating a Derived class object?</p><p>In all of the examples so far, when we instantiate a Derived class object, the Base class portion has been created using the default Base constructor. Why does it always use the default Base constructor? Because we never told it to do otherwise!</p><p>Fortunately, C++ gives us the ability to explicitly choose which Base class constructor will be called! To do this, simply add a call to the Base class constructor in the member initializer list of the derived class:</p><pre class="language-cpp line-numbers"><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    double m_cost {};</code><code></code><code>    Derived(double cost=0.0, int id=0)</code><code>        : Base{ id } // Call Base(int) constructor with value id!</code><code>        , m_cost{ cost }</code><code>    {</code><code>    }</code><code></code><code>    double getCost() const { return m_cost; }</code><code>};</code></pre><p>Now, when we execute this code:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    Derived derived{ 1.3, 5 }; // use Derived(double, int) constructor</code><code>    std::cout &lt;&lt; "Id: " &lt;&lt; derived.getId() &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "Cost: " &lt;&lt; derived.getCost() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>The base class constructor Base(int) will be used to initialize m_id to 5, and the derived class constructor will be used to initialize m_cost to 1.3!</p><p>Thus, the program will print:</p><pre>Id: 5
Cost: 1.3
</pre><p>In more detail, here’s what happens:</p><ol><li>Memory for derived is allocated.</li><li>The Derived(double, int) constructor is called, where cost = 1.3, and id = 5.</li><li>The compiler looks to see if we’ve asked for a particular Base class constructor. We have! So it calls Base(int) with id = 5.</li><li>The base class constructor member initializer list sets m_id to 5.</li><li>The base class constructor body executes, which does nothing.</li><li>The base class constructor returns.</li><li>The derived class constructor member initializer list sets m_cost to 1.3.</li><li>The derived class constructor body executes, which does nothing.</li><li>The derived class constructor returns.</li></ol><p>This may seem somewhat complex, but it’s actually very simple. All that’s happening is that the Derived constructor is calling a specific Base constructor to initialize the Base portion of the object. Because m_id lives in the Base portion of the object, the Base constructor is the only constructor that can initialize that value.</p><p>Note that it doesn’t matter where in the Derived constructor member initializer list the Base constructor is called -- it will always execute first.</p><p><strong>Now we can make our members private</strong></p><p>Now that you know how to initialize base class members, there’s no need to keep our member variables public. We make our member variables private again, as they should be.</p><p>As a quick refresher, public members can be accessed by anybody. Private members can only be accessed by member functions of the same class. Note that this means derived classes can not access private members of the base class directly! Derived classes will need to use access functions to access private members of the base class.</p><p>Consider:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>private: // our member is now private</code><code>    int m_id {};</code><code> </code><code>public:</code><code>    Base(int id=0)</code><code>        : m_id{ id }</code><code>    {</code><code>    }</code><code> </code><code>    int getId() const { return m_id; }</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>private: // our member is now private</code><code>    double m_cost;</code><code></code><code>public:</code><code>    Derived(double cost=0.0, int id=0)</code><code>        : Base{ id } // Call Base(int) constructor with value id!</code><code>        , m_cost{ cost }</code><code>    {</code><code>    }</code><code></code><code>    double getCost() const { return m_cost; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Derived derived{ 1.3, 5 }; // use Derived(double, int) constructor</code><code>    std::cout &lt;&lt; "Id: " &lt;&lt; derived.getId() &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "Cost: " &lt;&lt; derived.getCost() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above code, we made m_id and m_cost private. This is fine, since we use the relevant constructors to initialize them, and use a public accessor to get the values.</p><p>This prints, as expected:</p><pre>Id: 5
Cost: 1.3
</pre><p>We’ll talk more about access specifiers in the next lesson.</p><p><strong>Another example</strong></p><p>Let’s take a look at another pair of classes we’ve previously worked with:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class Person</code><code>{</code><code>public:</code><code>    std::string m_name;</code><code>    int m_age {};</code><code></code><code>    Person(const std::string_view name = "", int age = 0)</code><code>        : m_name{ name }, m_age{ age }</code><code>    {</code><code>    }</code><code></code><code>    const std::string&amp; getName() const { return m_name; }</code><code>    int getAge() const { return m_age; }</code><code>};</code><code></code><code>// BaseballPlayer publicly inheriting Person</code><code>class BaseballPlayer : public Person</code><code>{</code><code>public:</code><code>    double m_battingAverage {};</code><code>    int m_homeRuns {};</code><code></code><code>    BaseballPlayer(double battingAverage = 0.0, int homeRuns = 0)</code><code>       : m_battingAverage{ battingAverage },</code><code>         m_homeRuns{ homeRuns }</code><code>    {</code><code>    }</code><code>};</code></pre><p>As we’d previously written it, BaseballPlayer only initializes its own members and does not specify a Person constructor to use. This means every BaseballPlayer we create is going to use the default Person constructor, which will initialize the name to blank and age to 0. Because it makes sense to give our BaseballPlayer a name and age when we create them, we should modify this constructor to add those parameters.</p><p>Here’s our updated classes that use private members, with the BaseballPlayer class calling the appropriate Person constructor to initialize the inherited Person member variables:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class Person</code><code>{</code><code>private:</code><code>    std::string m_name;</code><code>    int m_age {};</code><code></code><code>public:</code><code>    Person(const std::string_view name = "", int age = 0)</code><code>        : m_name{ name }, m_age{ age }</code><code>    {</code><code>    }</code><code></code><code>    const std::string&amp; getName() const { return m_name; }</code><code>    int getAge() const { return m_age; }</code><code></code><code>};</code><code>// BaseballPlayer publicly inheriting Person</code><code>class BaseballPlayer : public Person</code><code>{</code><code>private:</code><code>    double m_battingAverage {};</code><code>    int m_homeRuns {};</code><code></code><code>public:</code><code>    BaseballPlayer(const std::string_view name = "", int age = 0,</code><code>        double battingAverage = 0.0, int homeRuns = 0)</code><code>        : Person{ name, age } // call Person(const std::string_view, int) to initialize these fields</code><code>        , m_battingAverage{ battingAverage }, m_homeRuns{ homeRuns }</code><code>    {</code><code>    }</code><code></code><code>    double getBattingAverage() const { return m_battingAverage; }</code><code>    int getHomeRuns() const { return m_homeRuns; }</code><code>};</code></pre><p>Now we can create baseball players like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    BaseballPlayer pedro{ "Pedro Cerrano", 32, 0.342, 42 };</code><code></code><code>    std::cout &lt;&lt; pedro.getName() &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; pedro.getAge() &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; pedro.getBattingAverage() &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; pedro.getHomeRuns() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This outputs:</p><pre>Pedro Cerrano
32
0.342
42
</pre><p>As you can see, the name and age from the base class were properly initialized, as was the number of home runs and batting average from the derived class.</p><p><strong>Inheritance chains</strong></p><p>Classes in an inheritance chain work in exactly the same way.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class A</code><code>{</code><code>public:</code><code>    A(int a)</code><code>    {</code><code>        std::cout &lt;&lt; "A: " &lt;&lt; a &lt;&lt; '\n';</code><code>    }</code><code>};</code><code></code><code>class B: public A</code><code>{</code><code>public:</code><code>    B(int a, double b)</code><code>    : A{ a }</code><code>    {</code><code>        std::cout &lt;&lt; "B: " &lt;&lt; b &lt;&lt; '\n';</code><code>    }</code><code>};</code><code></code><code>class C: public B</code><code>{</code><code>public:</code><code>    C(int a, double b, char c)</code><code>    : B{ a, b }</code><code>    {</code><code>        std::cout &lt;&lt; "C: " &lt;&lt; c &lt;&lt; '\n';</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    C c{ 5, 4.3, 'R' };</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this example, class C is derived from class B, which is derived from class A. So what happens when we instantiate an object of class C?</p><p>First, main() calls C(int, double, char). The C constructor calls B(int, double). The B constructor calls A(int). Because A does not inherit from anybody, this is the first class we’ll construct. A is constructed, prints the value 5, and returns control to B. B is constructed, prints the value 4.3, and returns control to C. C is constructed, prints the value ‘R’, and returns control to main(). And we’re done!</p><p>Thus, this program prints:</p><pre>A: 5
B: 4.3
C: R
</pre><p>It is worth mentioning that constructors can only call constructors from their immediate parent/base class. Consequently, the C constructor could not call or pass parameters to the A constructor directly. The C constructor can only call the B constructor (which has the responsibility of calling the A constructor).</p><p><strong>Destructors</strong></p><p>When a derived class is destroyed, each destructor is called in the <em>reverse</em> order of construction. In the above example, when c is destroyed, the C destructor is called first, then the B destructor, then the A destructor.</p><p><strong>Summary</strong></p><p>When constructing a derived class, the derived class constructor is responsible for determining which base class constructor is called. If no base class constructor is specified, the default base class constructor will be used. In that case, if no default base class constructor can be found (or created by default), the compiler will display an error. The classes are then constructed in order from most base to most derived.</p><p>At this point, you now understand enough about C++ inheritance to create your own inherited classes!</p><p><strong>Quiz time!</strong></p><ol start="1"><li>Let’s implement our Fruit example that we talked about in our introduction to inheritance. Create a Fruit base class that contains two private members: a name (std::string), and a color (std::string). Create an Apple class that inherits Fruit. Apple should have an additional private member: fiber (double). Create a Banana class that also inherits Fruit. Banana has no additional members.</li></ol><p>The following program should run:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	const Apple a{ "Red delicious", "red", 4.2 };</code><code>	std::cout &lt;&lt; a &lt;&lt; '\n';</code><code></code><code>	const Banana b{ "Cavendish", "yellow" };</code><code>	std::cout &lt;&lt; b &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>And print the following:</p><pre>Apple(Red delicious, red, 4.2)
Banana(Cavendish, yellow)
</pre><p>Hint: Because a and b are const, you’ll need to mind your consts. Make sure your parameters and functions are appropriately const.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <string></string></code><code>#include <iostream></iostream></code><code></code><code>class Fruit</code><code>{</code><code>private:</code><code>	std::string m_name;</code><code>	std::string m_color;</code><code></code><code>public:</code><code>	Fruit(const std::string&amp; name, const std::string&amp; color)</code><code>		: m_name{ name }, m_color{ color }</code><code>	{</code><code>	}</code><code></code><code>	const std::string&amp; getName() const { return m_name; }</code><code>	const std::string&amp; getColor() const { return m_color; }</code><code></code><code>};</code><code></code><code>class Apple : public Fruit</code><code>{</code><code>private:</code><code>	double m_fiber;</code><code></code><code>public:</code><code>	Apple(const std::string&amp; name, const std::string&amp; color, double fiber)</code><code>		:Fruit{ name, color },</code><code>		m_fiber{ fiber }</code><code>	{</code><code>	}</code><code></code><code>	double getFiber() const { return m_fiber; }</code><code></code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Apple&amp; a)</code><code>{</code><code>	out &lt;&lt; "Apple(" &lt;&lt; a.getName() &lt;&lt; ", " &lt;&lt; a.getColor() &lt;&lt; ", " &lt;&lt; a.getFiber() &lt;&lt; ')';</code><code>	return out;</code><code>}</code><code></code><code>class Banana : public Fruit</code><code>{</code><code>public:</code><code>	Banana(const std::string&amp; name, const std::string&amp; color)</code><code>		:Fruit{ name, color }</code><code>	{</code><code>	}</code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Banana&amp; b)</code><code>{</code><code>	out &lt;&lt; "Banana(" &lt;&lt; b.getName() &lt;&lt; ", " &lt;&lt; b.getColor() &lt;&lt; ')';</code><code>	return out;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	const Apple a{ "Red delicious", "red", 4.2 };</code><code>	std::cout &lt;&lt; a &lt;&lt; '\n';</code><code></code><code>	const Banana b{ "Cavendish", "yellow" };</code><code>	std::cout &lt;&lt; b &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">17.5 — Inheritance and access specifiers</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lessons in this chapter, you’ve learned a bit about how base inheritance works. In all of our examples so far, we’ve used public inheritance. That is, our derived class publicly inherits the base class.</p><p>In this lesson, we’ll take a closer look at public inheritance, as well as the two other kinds of inheritance (private and protected). We’ll also explore how the different kinds of inheritance interact with access specifiers to allow or restrict access to members.</p><p>To this point, you’ve seen the private and public access specifiers, which determine who can access the members of a class. As a quick refresher, public members can be accessed by anybody. Private members can only be accessed by member functions of the same class or friends. This means derived classes can not access private members of the base class directly!</p><pre class="language-cpp line-numbers"><code>class Base</code><code>{</code><code>private:</code><code>    int m_private {}; // can only be accessed by Base members and friends (not derived classes)</code><code>public:</code><code>    int m_public {}; // can be accessed by anybody</code><code>};</code></pre><p>This is pretty straightforward, and you should be quite used to it by now.</p><br><h3>The protected access specifier</h3><p>When dealing with inherited classes, things get a bit more complex.</p><p>C++ has a third access specifier that we have yet to talk about because it’s only useful in an inheritance context. The <strong>protected</strong> access specifier allows the class the member belongs to, friends, and derived classes to access the member. However, protected members are not accessible from outside the class.</p><pre class="language-cpp line-numbers"><code>class Base</code><code>{</code><code>public:</code><code>    int m_public {}; // can be accessed by anybody</code><code>protected:</code><code>    int m_protected {}; // can be accessed by Base members, friends, and derived classes</code><code>private:</code><code>    int m_private {}; // can only be accessed by Base members and friends (but not derived classes)</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    Derived()</code><code>    {</code><code>        m_public = 1; // allowed: can access public base members from derived class</code><code>        m_protected = 2; // allowed: can access protected base members from derived class</code><code>        m_private = 3; // not allowed: can not access private base members from derived class</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Base base;</code><code>    base.m_public = 1; // allowed: can access public members from outside class</code><code>    base.m_protected = 2; // not allowed: can not access protected members from outside class</code><code>    base.m_private = 3; // not allowed: can not access private members from outside class</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, you can see that the protected base member m_protected is directly accessible by the derived class, but not by the public.</p><br><h3>So when should I use the protected access specifier?</h3><p>With a protected attribute in a base class, derived classes can access that member directly. This means that if you later change anything about that protected attribute (the type, what the value means, etc…), you’ll probably need to change both the base class AND all of the derived classes.</p><p>Therefore, using the protected access specifier is most useful when you (or your team) are going to be the ones deriving from your own classes, and the number of derived classes is reasonable. That way, if you make a change to the implementation of the base class, and updates to the derived classes are necessary as a result, you can make the updates yourself (and have it not take forever, since the number of derived classes is limited).</p><p>Making your members private means the public and derived classes can’t directly make changes to the base class. This is good for insulating the public or derived classes from implementation changes, and for ensuring invariants are maintained properly. However, it also means your class may need a larger public (or protected) interface to support all of the functions that the public or derived classes need for operation, which has its own cost to build, test, and maintain.</p><p>In general, it’s better to make your members private if you can, and only use protected when derived classes are planned and the cost to build and maintain an interface to those private members is too high.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Favor private members over protected members.</p></div><br><h3>Different kinds of inheritance, and their impact on access</h3><p>First, there are three different ways for classes to inherit from other classes: public, protected, and private.</p><p>To do so, simply specify which type of access you want when choosing the class to inherit from:</p><pre class="language-cpp line-numbers"><code>// Inherit from Base publicly</code><code>class Pub: public Base</code><code>{</code><code>};</code><code></code><code>// Inherit from Base protectedly</code><code>class Pro: protected Base</code><code>{</code><code>};</code><code></code><code>// Inherit from Base privately</code><code>class Pri: private Base</code><code>{</code><code>};</code><code></code><code>class Def: Base // Defaults to private inheritance</code><code>{</code><code>};</code></pre><p>If you do not choose an inheritance type, C++ defaults to private inheritance (just like members default to private access if you do not specify otherwise).</p><p>That gives us 9 combinations: 3 member access specifiers (public, private, and protected), and 3 inheritance types (public, private, and protected).</p><p>So what’s the difference between these? In a nutshell, when members are inherited, the access specifier for an inherited member may be changed (in the derived class only) depending on the type of inheritance used. Put another way, members that were public or protected in the base class may change access specifiers in the derived class.</p><p>This might seem a little confusing, but it’s not that bad. We’ll spend the rest of this lesson exploring this in detail.</p><p>Keep in mind the following rules as we step through the examples:</p><ul><li>A class can always access its own (non-inherited) members.</li><li>The public accesses the members of a class based on the access specifiers of the class it is accessing.</li><li>A derived class accesses inherited members based on the access specifier inherited from the parent class. This varies depending on the access specifier and type of inheritance used.</li></ul><br><h3>Public inheritance</h3><p>Public inheritance is by far the most commonly used type of inheritance. In fact, very rarely will you see or use the other types of inheritance, so your primary focus should be on understanding this section. Fortunately, public inheritance is also the easiest to understand. When you inherit a base class publicly, inherited public members stay public, and inherited protected members stay protected. Inherited private members, which were inaccessible because they were private in the base class, stay inaccessible.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Access specifier in base class</th><th>Access specifier when inherited publicly</th></tr><tr><td>Public</td><td>Public</td></tr><tr><td>Protected</td><td>Protected</td></tr><tr><td>Private</td><td>Inaccessible</td></tr></tbody></table></div><p>Here’s an example showing how things work:</p><pre class="language-cpp line-numbers"><code>class Base</code><code>{</code><code>public:</code><code>    int m_public {};</code><code>protected:</code><code>    int m_protected {};</code><code>private:</code><code>    int m_private {};</code><code>};</code><code></code><code>class Pub: public Base // note: public inheritance</code><code>{</code><code>    // Public inheritance means:</code><code>    // Public inherited members stay public (so m_public is treated as public)</code><code>    // Protected inherited members stay protected (so m_protected is treated as protected)</code><code>    // Private inherited members stay inaccessible (so m_private is inaccessible)</code><code>public:</code><code>    Pub()</code><code>    {</code><code>        m_public = 1; // okay: m_public was inherited as public</code><code>        m_protected = 2; // okay: m_protected was inherited as protected</code><code>        m_private = 3; // not okay: m_private is inaccessible from derived class</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    // Outside access uses the access specifiers of the class being accessed.</code><code>    Base base;</code><code>    base.m_public = 1; // okay: m_public is public in Base</code><code>    base.m_protected = 2; // not okay: m_protected is protected in Base</code><code>    base.m_private = 3; // not okay: m_private is private in Base</code><code></code><code>    Pub pub;</code><code>    pub.m_public = 1; // okay: m_public is public in Pub</code><code>    pub.m_protected = 2; // not okay: m_protected is protected in Pub</code><code>    pub.m_private = 3; // not okay: m_private is inaccessible in Pub</code><code></code><code>    return 0;</code><code>}</code></pre><p>This is the same as the example above where we introduced the protected access specifier, except that we’ve instantiated the derived class as well, just to show that with public inheritance, things work identically in the base and derived class.</p><p>Public inheritance is what you should be using unless you have a specific reason not to.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use public inheritance unless you have a specific reason to do otherwise.</p></div><br><h3>Protected inheritance</h3><p>Protected inheritance is the least common method of inheritance. It is almost never used, except in very particular cases. With protected inheritance, the public and protected members become protected, and private members stay inaccessible.</p><p>Because this form of inheritance is so rare, we’ll skip the example and just summarize with a table:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Access specifier in base class</th><th>Access specifier when inherited protectedly</th></tr><tr><td>Public</td><td>Protected</td></tr><tr><td>Protected</td><td>Protected</td></tr><tr><td>Private</td><td>Inaccessible</td></tr></tbody></table></div><br><h3>Private inheritance</h3><p>With private inheritance, all members from the base class are inherited as private. This means private members are inaccessible, and protected and public members become private.</p><p>Note that this does not affect the way that the derived class accesses members inherited from its parent! It only affects the code trying to access those members through the derived class.</p><pre class="language-cpp line-numbers"><code>class Base</code><code>{</code><code>public:</code><code>    int m_public {};</code><code>protected:</code><code>    int m_protected {};</code><code>private:</code><code>    int m_private {};</code><code>};</code><code></code><code>class Pri: private Base // note: private inheritance</code><code>{</code><code>    // Private inheritance means:</code><code>    // Public inherited members become private (so m_public is treated as private)</code><code>    // Protected inherited members become private (so m_protected is treated as private)</code><code>    // Private inherited members stay inaccessible (so m_private is inaccessible)</code><code>public:</code><code>    Pri()</code><code>    {</code><code>        m_public = 1; // okay: m_public is now private in Pri</code><code>        m_protected = 2; // okay: m_protected is now private in Pri</code><code>        m_private = 3; // not okay: derived classes can't access private members in the base class</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    // Outside access uses the access specifiers of the class being accessed.</code><code>    // In this case, the access specifiers of base.</code><code>    Base base;</code><code>    base.m_public = 1; // okay: m_public is public in Base</code><code>    base.m_protected = 2; // not okay: m_protected is protected in Base</code><code>    base.m_private = 3; // not okay: m_private is private in Base</code><code></code><code>    Pri pri;</code><code>    pri.m_public = 1; // not okay: m_public is now private in Pri</code><code>    pri.m_protected = 2; // not okay: m_protected is now private in Pri</code><code>    pri.m_private = 3; // not okay: m_private is inaccessible in Pri</code><code></code><code>    return 0;</code><code>}</code></pre><p>To summarize in table form:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Access specifier in base class</th><th>Access specifier when inherited privately</th></tr><tr><td>Public</td><td>Private</td></tr><tr><td>Protected</td><td>Private</td></tr><tr><td>Private</td><td>Inaccessible</td></tr></tbody></table></div><p>Private inheritance can be useful when the derived class has no obvious relationship to the base class, but uses the base class for implementation internally. In such a case, we probably don’t want the public interface of the base class to be exposed through objects of the derived class (as it would be if we inherited publicly).</p><p>In practice, private inheritance is rarely used.</p><br><h3>A final example</h3><pre class="language-cpp line-numbers"><code>class Base</code><code>{</code><code>public:</code><code>	int m_public {};</code><code>protected:</code><code>	int m_protected {};</code><code>private:</code><code>	int m_private {};</code><code>};</code></pre><p>Base can access its own members without restriction. The public can only access m_public. Derived classes can access m_public and m_protected.</p><pre class="language-cpp line-numbers"><code>class D2 : private Base // note: private inheritance</code><code>{</code><code>	// Private inheritance means:</code><code>	// Public inherited members become private</code><code>	// Protected inherited members become private</code><code>	// Private inherited members stay inaccessible</code><code>public:</code><code>	int m_public2 {};</code><code>protected:</code><code>	int m_protected2 {};</code><code>private:</code><code>	int m_private2 {};</code><code>};</code></pre><p>D2 can access its own members without restriction. D2 can access Base’s m_public and m_protected members, but not m_private. Because D2 inherited Base privately, m_public and m_protected are now considered private when accessed through D2. This means the public can not access these variables when using a D2 object, nor can any classes derived from D2.</p><pre class="language-cpp line-numbers"><code>class D3 : public D2</code><code>{</code><code>	// Public inheritance means:</code><code>	// Public inherited members stay public</code><code>	// Protected inherited members stay protected</code><code>	// Private inherited members stay inaccessible</code><code>public:</code><code>	int m_public3 {};</code><code>protected:</code><code>	int m_protected3 {};</code><code>private:</code><code>	int m_private3 {};</code><code>};</code></pre><p>D3 can access its own members without restriction. D3 can access D2’s m_public2 and m_protected2 members, but not m_private2. Because D3 inherited D2 publicly, m_public2 and m_protected2 keep their access specifiers when accessed through D3. D3 has no access to Base’s m_private, which was already private in Base. Nor does it have access to Base’s m_protected or m_public, both of which became private when D2 inherited them.</p><br><h3>Summary</h3><p>The way that the access specifiers, inheritance types, and derived classes interact causes a lot of confusion. To try and clarify things as much as possible:</p><p>First, a class (and friends) can always access its own non-inherited members. The access specifiers only affect whether outsiders and derived classes can access those members.</p><p>Second, when derived classes inherit members, those members may change access specifiers in the derived class. This does not affect the derived classes’ own (non-inherited) members (which have their own access specifiers). It only affects whether outsiders and classes derived from the derived class can access those inherited members.</p><p>Here’s a table of all of the access specifier and inheritance types combinations:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Access specifier in base class</th><th>Access specifier when inherited publicly</th><th>Access specifier when inherited privately</th><th>Access specifier when inherited protectedly</th></tr><tr><td>Public</td><td>Public</td><td>Private</td><td>Protected</td></tr><tr><td>Protected</td><td>Protected</td><td>Private</td><td>Protected</td></tr><tr><td>Private</td><td>Inaccessible</td><td>Inaccessible</td><td>Inaccessible</td></tr></tbody></table></div><p>As a final note, although in the examples above, we’ve only shown examples using member variables, these access rules hold true for all members (e.g. member functions and types declared inside the class).</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">17.6 — Adding new functionality to a derived class</h1></header><div class="entry-content" itemprop="articleBody"><p>In the <a href="https://www.learncpp.com/cpp-tutorial/111-introduction-to-inheritance/">introduction to inheritance</a> lesson, we mentioned that one of the biggest benefits of using derived classes is the ability to reuse already written code. You can inherit the base class functionality and then add new functionality, modify existing functionality, or hide functionality you don’t want. In this and the next few lessons, we’ll take a closer look at how each of these things is done.</p><p>First, let’s start with a simple base class:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>protected:</code><code>    int m_value {};</code><code></code><code>public:</code><code>    Base(int value)</code><code>        : m_value { value }</code><code>    {</code><code>    }</code><code></code><code>    void identify() const { std::cout &lt;&lt; "I am a Base\n"; }</code><code>};</code></pre><p>Now, let’s create a derived class that inherits from Base. Because we want the derived class to be able to set the value of m_value when derived objects are instantiated, we’ll make the Derived constructor call the Base constructor in the initialization list.</p><pre class="language-cpp line-numbers"><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    Derived(int value)</code><code>        : Base { value }</code><code>    {</code><code>    }</code><code>};</code></pre><p><strong>Adding new functionality to a derived class</strong></p><p>In the above example, because we have access to the source code of the Base class, we can add functionality directly to Base if we desire.</p><p>There may be times when we have access to a base class but do not want to modify it. Consider the case where you have just purchased a library of code from a 3rd party vendor, but need some extra functionality. You could add to the original code, but this isn’t the best solution. What if the vendor sends you an update? Either your additions will be overwritten, or you’ll have to manually migrate them into the update, which is time-consuming and risky.</p><p>Alternatively, there may be times when it’s not even possible to modify the base class. Consider the code in the standard library. We aren’t able to modify the code that’s part of the standard library. But we are able to inherit from those classes, and then add our own functionality into our derived classes. The same goes for 3rd party libraries where you are provided with headers but the code comes precompiled.</p><p>In either case, the best answer is to derive your own class, and add the functionality you want to the derived class.</p><p>One obvious omission from the Base class is a way for the public to access m_value. We could remedy this by adding an access function in the Base class -- but for the sake of example we’re going to add it to the derived class instead. Because m_value has been declared as protected in the Base class, Derived has direct access to it.</p><p>To add new functionality to a derived class, simply declare that functionality in the derived class like normal:</p><pre class="language-cpp line-numbers"><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    Derived(int value)</code><code>        : Base { value }</code><code>    {</code><code>    }</code><code></code><code>    int getValue() const { return m_value; }</code><code>};</code></pre><p>Now the public will be able to call getValue() on an object of type Derived to access the value of m_value.</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Derived derived { 5 };</code><code>    std::cout &lt;&lt; "derived has value " &lt;&lt; derived.getValue() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This produces the result:</p><pre>derived has value 5
</pre><p>Although it may be obvious, objects of type Base have no access to the getValue() function in Derived. The following does not work:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Base base { 5 };</code><code>    std::cout &lt;&lt; "base has value " &lt;&lt; base.getValue() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This is because there is no getValue() function in Base. Function getValue() belongs to Derived. Because Derived is a Base, Derived has access to stuff in Base. However, Base does not have access to anything in Derived.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">17.7 — Calling inherited functions and overriding behavior</h1></header><div class="entry-content" itemprop="articleBody"><p>By default, derived classes inherit all of the behaviors defined in a base class. In this lesson, we’ll examine in more detail how member functions are selected, as well as how we can leverage this to change behaviors in a derived class.</p><p><strong>Calling a base class function</strong></p><p>When a member function is called with a derived class object, the compiler first looks to see if that member exists in the derived class. If not, it begins walking up the inheritance chain and checking whether the member has been defined in any of the parent classes. It uses the first one it finds.</p><p>Consequently, take a look at the following example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>protected:</code><code>    int m_value {};</code><code></code><code>public:</code><code>    Base(int value)</code><code>        : m_value { value }</code><code>    {</code><code>    }</code><code></code><code>    void identify() const { std::cout &lt;&lt; "I am a Base\n"; }</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    Derived(int value)</code><code>        : Base { value }</code><code>    {</code><code>    }</code><code>};</code><code>int main()</code><code>{</code><code>    Base base { 5 };</code><code>    base.identify();</code><code></code><code>    Derived derived { 7 };</code><code>    derived.identify();</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints</p><pre>I am a Base
I am a Base
</pre><p>When derived.identify() is called, the compiler looks to see if function identify() has been defined in the Derived class. It hasn’t. Then it starts looking in the inherited classes (which in this case is Base). Base has defined an identify() function, so it uses that one. In other words, Base::identify() was used because Derived::identify() doesn’t exist.</p><p>This means that if the behavior provided by a base class is sufficient, we can simply use the base class behavior.</p><p><strong>Redefining behaviors</strong></p><p>However, if we had defined Derived::identify() in the Derived class, it would have been used instead.</p><p>This means that we can make functions work differently with our derived classes by redefining them in the derived class!</p><p>In our above example, it would be more accurate if <code>derived.identify()</code> printed “I am a Derived”. Let’s modify function identify() in the Derived class so it returns the correct response when we call function identify() with a Derived object.</p><p>To modify the way a function defined in a base class works in the derived class, simply redefine the function in the derived class.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    Derived(int value)</code><code>        : Base { value }</code><code>    {</code><code>    }</code><code></code><code>    int getValue() const { return m_value; }</code><code></code><code>    // Here's our modified function</code><code>    void identify() const { std::cout &lt;&lt; "I am a Derived\n"; }</code><code>};</code></pre><p>Here’s the same example as above, using the new Derived::identify() function:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Base base { 5 };</code><code>    base.identify();</code><code></code><code>    Derived derived { 7 };</code><code>    derived.identify();</code><code></code><code>    return 0;</code><code>}</code></pre><pre>I am a Base
I am a Derived
</pre><p>Note that when you redefine a function in the derived class, the derived function does not inherit the access specifier of the function with the same name in the base class. It uses whatever access specifier it is defined under in the derived class. Therefore, a function that is defined as private in the base class can be redefined as public in the derived class, or vice-versa!</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>private:</code><code>	void print() const </code><code>	{</code><code>		std::cout &lt;&lt; "Base";</code><code>	}</code><code>};</code><code> </code><code>class Derived : public Base</code><code>{</code><code>public:</code><code>	void print() const </code><code>	{</code><code>		std::cout &lt;&lt; "Derived ";</code><code>	}</code><code>};</code><code> </code><code> </code><code>int main()</code><code>{</code><code>	Derived derived;</code><code>	derived.print(); // calls derived::print(), which is public</code><code>	return 0;</code><code>}</code></pre><p><strong>Adding to existing functionality</strong></p><p>Sometimes we don’t want to completely replace a base class function, but instead want to add additional functionality to it. In the above example, note that Derived::identify() completely hides Base::identify()! This may not be what we want. It is possible to have our derived function call the base version of the function of the same name (in order to reuse code) and then add additional functionality to it.</p><p>To have a derived function call a base function of the same name, simply do a normal function call, but prefix the function with the scope qualifier (the name of the base class and two colons). The following example redefines Derived::identify() so it first calls Base::identify() and then does its own additional stuff.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    Derived(int value)</code><code>        : Base { value }</code><code>    {</code><code>    }</code><code></code><code>    int getValue() const  { return m_value; }</code><code></code><code>    void identify() const </code><code>    {</code><code>        Base::identify(); // call Base::identify() first</code><code>        std::cout &lt;&lt; "I am a Derived\n"; // then identify ourselves</code><code>    }</code><code>};</code></pre><p>Now consider the following example:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Base base { 5 };</code><code>    base.identify();</code><code></code><code>    Derived derived { 7 };</code><code>    derived.identify();</code><code></code><code>    return 0;</code><code>}</code></pre><pre>I am a Base
I am a Base
I am a Derived
</pre><p>When <code>derived.identify()</code> is executed, it resolves to Derived::identify(). However, the first thing Derived::identify() does is call Base::identify(), which prints “I am a Base”. When Base::identify() returns, Derived::identify() continues executing and prints “I am a Derived”.</p><p>This should be pretty straightforward. Why do we need to use the scope resolution operator (::)? If we had defined Derived::identify() like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    Derived(int value)</code><code>        : Base { value }</code><code>    {</code><code>    }</code><code></code><code>    int getValue() const { return m_value; }</code><code></code><code>    void identify() const </code><code>    {</code><code>        identify(); // Note: no scope resolution!</code><code>        cout &lt;&lt; "I am a Derived";</code><code>    }</code><code>};</code></pre><p>Calling function identify() without a scope resolution qualifier would default to the identify() in the current class, which would be Derived::identify(). This would cause Derived::identify() to call itself, which would lead to an infinite loop!</p><p>There’s one bit of trickiness that we can run into when trying to call friend functions in base classes, such as operator&lt;&lt;. Because friend functions of the base class aren’t actually part of the base class, using the scope resolution qualifier won’t work. Instead, we need a way to make our Derived class temporarily look like the Base class so that the right version of the function can be called.</p><p>Fortunately, that’s easy to do, using static_cast. Here’s an example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>private:</code><code>	int m_value {};</code><code></code><code>public:</code><code>	Base(int value)</code><code>		: m_value{ value }</code><code>	{</code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Base&amp; b)</code><code>	{</code><code>		out &lt;&lt; "In Base\n";</code><code>		out &lt;&lt; b.m_value &lt;&lt; '\n';</code><code>		return out;</code><code>	}</code><code>};</code><code></code><code>class Derived : public Base</code><code>{</code><code>public:</code><code>	Derived(int value)</code><code>		: Base{ value }</code><code>	{</code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Derived&amp; d)</code><code>	{</code><code>		out &lt;&lt; "In Derived\n";</code><code>		// static_cast Derived to a Base object, so we call the right version of operator&lt;&lt;</code><code>		out &lt;&lt; static_cast<const base&="">(d); </const></code><code>		return out;</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Derived derived { 7 };</code><code></code><code>	std::cout &lt;&lt; derived &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>Because a Derived is-a Base, we can static_cast our Derived object into a Base, so that the appropriate version of operator&lt;&lt; that uses a Base is called.</p><p>This prints:</p><pre>In Derived
In Base
7
</pre></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">17.8 — Hiding inherited functionality</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>Changing an inherited member’s access level</strong></p><p>C++ gives us the ability to change an inherited member’s access specifier in the derived class. This is done by using a <em>using declaration</em> to identify the (scoped) base class member that is having its access changed in the derived class, under the new access specifier.</p><p>For example, consider the following Base:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>private:</code><code>    int m_value {};</code><code></code><code>public:</code><code>    Base(int value)</code><code>        : m_value { value }</code><code>    {</code><code>    }</code><code></code><code>protected:</code><code>    void printValue() const { std::cout &lt;&lt; m_value; }</code><code>};</code></pre><p>Because Base::printValue() has been declared as protected, it can only be called by Base or its derived classes. The public can not access it.</p><p>Let’s define a Derived class that changes the access specifier of printValue() to public:</p><pre class="language-cpp line-numbers"><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    Derived(int value)</code><code>        : Base { value }</code><code>    {</code><code>    }</code><code></code><code>    // Base::printValue was inherited as protected, so the public has no access</code><code>    // But we're changing it to public via a using declaration</code><code>    using Base::printValue; // note: no parenthesis here</code><code>};</code></pre><p>This means that this code will now work:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Derived derived { 7 };</code><code></code><code>    // printValue is public in Derived, so this is okay</code><code>    derived.printValue(); // prints 7</code><code>    return 0;</code><code>}</code></pre><p>You can only change the access specifiers of base members the derived class would normally be able to access. Therefore, you can never change the access specifier of a base member from private to protected or public, because derived classes do not have access to private members of the base class.</p><p><strong>Hiding functionality</strong></p><p>In C++, it is not possible to remove or restrict functionality from a base class other than by modifying the source code. However, in a derived class, it is possible to hide functionality that exists in the base class, so that it can not be accessed through the derived class. This can be done simply by changing the relevant access specifier.</p><p>For example, we can make a public member private:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>class Base</code><code>{</code><code>public:</code><code>	int m_value {};</code><code>};</code><code></code><code>class Derived : public Base</code><code>{</code><code>private:</code><code>	using Base::m_value;</code><code></code><code>public:</code><code>	Derived(int value)</code><code>	// We can't initialize m_value, since it's a Base member (Base must initialize it)</code><code>	{</code><code>		// But we can assign it a value</code><code>		m_value = value;</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Derived derived { 7 };</code><code></code><code>	// The following won't work because m_value has been redefined as private</code><code>	std::cout &lt;&lt; derived.m_value;</code><code></code><code>	return 0;</code><code>}</code></pre><p>Note that this allowed us to take a poorly designed base class and encapsulate its data in our derived class. Alternatively, instead of inheriting Base’s members publicly and making m_value private by overriding its access specifier, we could have inherited Base privately, which would have caused all of Base’s member to be inherited privately in the first place.</p><p>You can also mark member functions as deleted in the derived class, which ensures they can’t be called at all through a derived object:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>class Base</code><code>{</code><code>private:</code><code>	int m_value {};</code><code></code><code>public:</code><code>	Base(int value)</code><code>		: m_value { value }</code><code>	{</code><code>	}</code><code></code><code>	int getValue() const { return m_value; }</code><code>};</code><code></code><code>class Derived : public Base</code><code>{</code><code>public:</code><code>	Derived(int value)</code><code>		: Base { value }</code><code>	{</code><code>	}</code><code></code><code></code><code>	int getValue() = delete; // mark this function as inaccessible</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Derived derived { 7 };</code><code></code><code>	// The following won't work because getValue() has been deleted!</code><code>	std::cout &lt;&lt; derived.getValue();</code><code></code><code>	return 0;</code><code>}</code></pre><p>In the above example, we’ve marked the getValue() function as deleted. This means that the compiler will complain when we try to call the derived version of the function. Note that the Base version of getValue() is still accessible though. We can call Base::getValue() in one of two ways:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	Derived derived { 7 };</code><code></code><code>	// We can call the Base::getValue() function directly</code><code>	std::cout &lt;&lt; derived.Base::getValue();</code><code></code><code>	// Or we can upcast Derived to a Base reference and getValue() will resolve to Base::getValue()</code><code>	std::cout &lt;&lt; static_cast<base&>(derived).getValue();</base&></code><code></code><code>	return 0;</code><code>}</code></pre><p>If using the casting method, we cast to a Base&amp; rather than a Base to avoid making a copy of the Base portion of <code>derived</code>.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">17.9 — Multiple inheritance</h1></header><div class="entry-content" itemprop="articleBody"><p>So far, all of the examples of inheritance we’ve presented have been single inheritance -- that is, each inherited class has one and only one parent. However, C++ provides the ability to do multiple inheritance. <strong>Multiple inheritance</strong> enables a derived class to inherit members from more than one parent.</p><p>Let’s say we wanted to write a program to keep track of a bunch of teachers. A teacher is a person. However, a teacher is also an employee (they are their own employer if working for themselves). Multiple inheritance can be used to create a Teacher class that inherits properties from both Person and Employee. To use multiple inheritance, simply specify each base class (just like in single inheritance), separated by a comma.</p><p><img src="https://www.learncpp.com/images/CppTutorial/Section11/PersonTeacher.gif" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Section11/PersonTeacher.gif"></p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class Person</code><code>{</code><code>private:</code><code>    std::string m_name;</code><code>    int m_age{};</code><code></code><code>public:</code><code>    Person(std::string_view name, int age)</code><code>        : m_name{ name }, m_age{ age }</code><code>    {</code><code>    }</code><code></code><code>    const std::string&amp; getName() const { return m_name; }</code><code>    int getAge() const { return m_age; }</code><code>};</code><code></code><code>class Employee</code><code>{</code><code>private:</code><code>    std::string m_employer;</code><code>    double m_wage{};</code><code></code><code>public:</code><code>    Employee(std::string_view employer, double wage)</code><code>        : m_employer{ employer }, m_wage{ wage }</code><code>    {</code><code>    }</code><code></code><code>    const std::string&amp; getEmployer() const { return m_employer; }</code><code>    double getWage() const { return m_wage; }</code><code>};</code><code></code><code>// Teacher publicly inherits Person and Employee</code><code>class Teacher : public Person, public Employee</code><code>{</code><code>private:</code><code>    int m_teachesGrade{};</code><code></code><code>public:</code><code>    Teacher(std::string_view name, int age, std::string_view employer, double wage, int teachesGrade)</code><code>        : Person{ name, age }, Employee{ employer, wage }, m_teachesGrade{ teachesGrade }</code><code>    {</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Teacher t{ "Mary", 45, "Boo", 14.3, 8 };</code><code></code><code>    return 0;</code><code>}</code></pre><br><h3>Mixins</h3><p>A <span class="cpp-definition">mixin</span> (also spelled “mix-in”) is a small class that can be inherited from in order to add properties to a class. The name mixin indicates that the class is intended to be mixed into other classes, not instantiated on its own.</p><p>In the following example, the <code>Box</code> and <code>Label</code> classes are mixins that we inherit from in order to create a new <code>Button</code> class.</p><pre class="language-cpp line-numbers"><code>// h/t to reader Waldo for this example</code><code>#include <string></string></code><code></code><code>struct Point2D</code><code>{</code><code>	int x;</code><code>	int y;</code><code>};</code><code></code><code>class Box // mixin Box class</code><code>{</code><code>public:</code><code>	void setTopLeft(Point2D point) { m_topLeft = point; }</code><code>	void setBottomRight(Point2D point) { m_bottomRight = point; }</code><code>private:</code><code>	Point2D m_topLeft{};</code><code>	Point2D m_bottomRight{};</code><code>};</code><code></code><code>class Label // mixin Label class</code><code>{</code><code>public:</code><code>	void setText(const std::string_view str) { m_text = str; }</code><code>	void setFontSize(int fontSize) { m_fontSize = fontSize; }</code><code>private:</code><code>	std::string m_text{};</code><code>	int m_fontSize{};</code><code>};</code><code></code><code>class Button : public Box, public Label {};</code><code></code><code>int main()</code><code>{</code><code>	Button button{};</code><code>	button.Box::setTopLeft({ 1, 1 });</code><code>	button.Box::setBottomRight({ 10, 10 });</code><code>	button.Label::setText("Username: ");</code><code>	button.Label::setFontSize(6);</code><code>}</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>For advanced readers</h4><p>Because mixins are designed to add functionality to the derived class, not to provide an interface, mixins typically do not use virtual functions (covered in the next chapter). Instead, if a mixin class needs to be customized to work in a particular way, templates are typically used. For this reason, mixin classes are often templatized.</p><p>Perhaps surprisingly, a derived class can inherit from a mixin base class using the derived class as a template type parameter. Such inheritance is called <span class="cpp-definition">Curiously Recurring Template Pattern</span> (CRTP for short), which looks like this:</p><pre class="language-cpp line-numbers"><code>// The Curiously Recurring Template Pattern (CRTP)</code><code></code><code>template <class t=""></class></code><code>class Mixin</code><code>{</code><code>    // Mixin<t> can use template type parameter T to access members of Derived</t></code><code>    // via (static_cast<t*>(this))</t*></code><code>};</code><code></code><code>class Derived : public Mixin<derived></derived></code><code>{</code><code>};</code></pre><p>You can find a simple example using CRTP <a href="https://en.cppreference.com/w/cpp/language/crtp">here</a>.</p></div><p><strong>Problems with multiple inheritance</strong></p><p>While multiple inheritance seems like a simple extension of single inheritance, multiple inheritance introduces a lot of issues that can markedly increase the complexity of programs and make them a maintenance nightmare. Let’s take a look at some of these situations.</p><p>First, ambiguity can result when multiple base classes contain a function with the same name. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class USBDevice</code><code>{</code><code>private:</code><code>    long m_id {};</code><code></code><code>public:</code><code>    USBDevice(long id)</code><code>        : m_id { id }</code><code>    {</code><code>    }</code><code></code><code>    long getID() const { return m_id; }</code><code>};</code><code></code><code>class NetworkDevice</code><code>{</code><code>private:</code><code>    long m_id {};</code><code></code><code>public:</code><code>    NetworkDevice(long id)</code><code>        : m_id { id }</code><code>    {</code><code>    }</code><code></code><code>    long getID() const { return m_id; }</code><code>};</code><code></code><code>class WirelessAdapter: public USBDevice, public NetworkDevice</code><code>{</code><code>public:</code><code>    WirelessAdapter(long usbId, long networkId)</code><code>        : USBDevice { usbId }, NetworkDevice { networkId }</code><code>    {</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    WirelessAdapter c54G { 5442, 181742 };</code><code>    std::cout &lt;&lt; c54G.getID(); // Which getID() do we call?</code><code></code><code>    return 0;</code><code>}</code></pre><p>When <code>c54G.getID()</code> is compiled, the compiler looks to see if WirelessAdapter contains a function named getID(). It doesn’t. The compiler then looks to see if any of the parent classes have a function named getID(). See the problem here? The problem is that c54G actually contains TWO getID() functions: one inherited from USBDevice, and one inherited from NetworkDevice. Consequently, this function call is ambiguous, and you will receive a compiler error if you try to compile it.</p><p>However, there is a way to work around this problem: you can explicitly specify which version you meant to call:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    WirelessAdapter c54G { 5442, 181742 };</code><code>    std::cout &lt;&lt; c54G.USBDevice::getID();</code><code></code><code>    return 0;</code><code>}</code></pre><p>While this workaround is pretty simple, you can see how things can get complex when your class inherits from four or six base classes, which inherit from other classes themselves. The potential for naming conflicts increases exponentially as you inherit more classes, and each of these naming conflicts needs to be resolved explicitly.</p><p>Second, and more serious is the <a href="https://en.wikipedia.org/wiki/Diamond_problem">diamond problem</a>, which your author likes to call the “diamond of doom”. This occurs when a class multiply inherits from two classes which each inherit from a single base class. This leads to a diamond shaped inheritance pattern.</p><p>For example, consider the following set of classes:</p><pre class="language-cpp line-numbers"><code>class PoweredDevice</code><code>{</code><code>};</code><code></code><code>class Scanner: public PoweredDevice</code><code>{</code><code>};</code><code></code><code>class Printer: public PoweredDevice</code><code>{</code><code>};</code><code></code><code>class Copier: public Scanner, public Printer</code><code>{</code><code>};</code></pre><p><img src="https://www.learncpp.com/images/CppTutorial/Section11/PoweredDevice.gif" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Section11/PoweredDevice.gif"></p><p>Scanners and printers are both powered devices, so they derived from PoweredDevice. However, a copy machine incorporates the functionality of both Scanners and Printers.</p><p>There are many issues that arise in this context, including whether Copier should have one or two copies of PoweredDevice, and how to resolve certain types of ambiguous references. While most of these issues can be addressed through explicit scoping, the maintenance overhead added to your classes in order to deal with the added complexity can cause development time to skyrocket. We’ll talk more about ways to resolve the diamond problem in the next chapter (lesson <a href="https://www.learncpp.com/cpp-tutorial/virtual-base-classes/">18.8 -- Virtual base classes</a>).</p><p><strong>Is multiple inheritance more trouble than it’s worth?</strong></p><p>As it turns out, most of the problems that can be solved using multiple inheritance can be solved using single inheritance as well. Many object-oriented languages (eg. Smalltalk, PHP) do not even support multiple inheritance. Many relatively modern languages such as Java and C# restrict classes to single inheritance of normal classes, but allow multiple inheritance of interface classes (which we will talk about later). The driving idea behind disallowing multiple inheritance in these languages is that it simply makes the language too complex, and ultimately causes more problems than it fixes.</p><p>Many authors and experienced programmers believe multiple inheritance in C++ should be avoided at all costs due to the many potential problems it brings. Your author does not agree with this approach, because there are times and situations when multiple inheritance is the best way to proceed. However, multiple inheritance should be used extremely judiciously.</p><p>As an interesting aside, you have already been using classes written using multiple inheritance without knowing it: the iostream library objects std::cin and std::cout are both implemented using multiple inheritance!</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Avoid multiple inheritance unless alternatives lead to more complexity.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">17.x — Chapter 17 comprehensive quiz</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Summary</h3><p>Inheritance allows us to model an is-a relationship between two objects. The object being inherited from is called the parent class, base class, or superclass. The object doing the inheriting is called the child class, derived class, or subclass.</p><p>When a derived class inherits from a base class, the derived class acquires all of the members of the base class.</p><p style="clear:both"></p><p></p><p>When a derived class is constructed, the base portion of the class is constructed first, and then the derived portion is constructed. In more detail:</p><ol><li>Memory for the derived class is set aside (enough for both the base and derived portions).</li><li>The appropriate derived class constructor is called.</li><li>The base class object is constructed first using the appropriate base class constructor. If no base class constructor is specified, the default constructor will be used.</li><li>The initialization list of the derived class initializes members of the derived class.</li><li>The body of the derived class constructor executes.</li><li>Control is returned to the caller.</li></ol><p>Destruction happens in the opposite order, from most-derived to most-base class.</p><p>C++ has 3 access specifiers: public, private, and protected. The protected access specifier allows the class the member belongs to, friends, and derived classes to access protected members, but not the public.</p><p>Classes can inherit from another class publicly, privately, or protectedly. Classes almost always inherit publicly.</p><p>Here’s a table of all of the access specifier and inheritance types combinations:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Access specifier in base class</th><th>Access specifier when inherited publicly</th><th>Access specifier when inherited privately</th><th>Access specifier when inherited protectedly</th></tr><tr><td>Public</td><td>Public</td><td>Private</td><td>Protected</td></tr><tr><td>Private</td><td>Inaccessible</td><td>Inaccessible</td><td>Inaccessible</td></tr><tr><td>Protected</td><td>Protected</td><td>Private</td><td>Protected</td></tr></tbody></table></div><p>Derived classes can add new functions, change the way functions that exist in the base class work in the derived class, change an inherited member’s access level, or hide functionality.</p><p>Multiple inheritance enables a derived class to inherit members from more than one parent. You should generally avoid multiple inheritance unless alternatives lead to more complexity.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>For each of the following programs, determine what they output, or if they would not compile, indicate why. This exercise is meant to be done by inspection, so do not compile these (otherwise the answers are trivial).</p><p>a)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>public:</code><code>	Base()</code><code>	{</code><code>		std::cout &lt;&lt; "Base()\n";</code><code>	}</code><code>	~Base()</code><code>	{</code><code>		std::cout &lt;&lt; "~Base()\n";</code><code>	}</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>	Derived()</code><code>	{</code><code>		std::cout &lt;&lt; "Derived()\n";</code><code>	}</code><code>	~Derived()</code><code>	{</code><code>		std::cout &lt;&lt; "~Derived()\n";</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Derived d;</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>Construction happens in order from most-Parent to most-Child. Destruction happens in the opposite order.</p><pre>Base()
Derived()
~Derived()
~Base()
</pre></div><p>b)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>public:</code><code>	Base()</code><code>	{</code><code>		std::cout &lt;&lt; "Base()\n";</code><code>	}</code><code>	~Base()</code><code>	{</code><code>		std::cout &lt;&lt; "~Base()\n";</code><code>	}</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>	Derived()</code><code>	{</code><code>		std::cout &lt;&lt; "Derived()\n";</code><code>	}</code><code>	~Derived()</code><code>	{</code><code>		std::cout &lt;&lt; "~Derived()\n";</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Derived d;</code><code>	Base b;</code><code></code><code>	return 0;</code><code>}</code></pre><p>Hint: Local variables are destroyed in the opposite order of definition.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>First we construct d, which prints:</p><pre>Base()
Derived()
</pre><p>Then we construct b, which prints:</p><pre>Base()
</pre><p>Then we destruct b, which prints:</p><pre>~Base()
</pre><p>Then we destruct d, which prints:</p><pre>~Derived()
~Base()
</pre></div><p>c)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>private:</code><code>	int m_x {};</code><code>public:</code><code>	Base(int x): m_x{ x }</code><code>	{</code><code>		std::cout &lt;&lt; "Base()\n";</code><code>	}</code><code>	~Base()</code><code>	{</code><code>		std::cout &lt;&lt; "~Base()\n";</code><code>	}</code><code></code><code>	void print() const { std::cout &lt;&lt; "Base: " &lt;&lt; m_x &lt;&lt; '\n';  }</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>	Derived(int y):  Base{ y }</code><code>	{</code><code>		std::cout &lt;&lt; "Derived()\n";</code><code>	}</code><code>	~Derived()</code><code>	{</code><code>		std::cout &lt;&lt; "~Derived()\n";</code><code>	}</code><code></code><code>	void print() const { std::cout &lt;&lt; "Derived: " &lt;&lt; m_x &lt;&lt; '\n'; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Derived d{ 5 };</code><code>	d.print();</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>Doesn’t compile, Derived::print() can’t access private member m_x</p></div><p>d)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>protected:</code><code>	int m_x {};</code><code>public:</code><code>	Base(int x): m_x{ x }</code><code>	{</code><code>		std::cout &lt;&lt; "Base()\n";</code><code>	}</code><code>	~Base()</code><code>	{</code><code>		std::cout &lt;&lt; "~Base()\n";</code><code>	}</code><code></code><code>	void print() const { std::cout &lt;&lt; "Base: " &lt;&lt; m_x &lt;&lt; '\n';  }</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>	Derived(int y):  Base{ y }</code><code>	{</code><code>		std::cout &lt;&lt; "Derived()\n";</code><code>	}</code><code>	~Derived()</code><code>	{</code><code>		std::cout &lt;&lt; "~Derived()\n";</code><code>	}</code><code></code><code>	void print() const { std::cout &lt;&lt; "Derived: " &lt;&lt; m_x &lt;&lt; '\n'; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Derived d{ 5 };</code><code>	d.print();</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><pre>Base()
Derived()
Derived: 5
~Derived()
~Base()
</pre></div><p>e)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>protected:</code><code>	int m_x {};</code><code>public:</code><code>	Base(int x): m_x{ x }</code><code>	{</code><code>		std::cout &lt;&lt; "Base()\n";</code><code>	}</code><code>	~Base()</code><code>	{</code><code>		std::cout &lt;&lt; "~Base()\n";</code><code>	}</code><code></code><code>	void print() const { std::cout &lt;&lt; "Base: " &lt;&lt; m_x &lt;&lt; '\n';  }</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>	Derived(int y):  Base{ y }</code><code>	{</code><code>		std::cout &lt;&lt; "Derived()\n";</code><code>	}</code><code>	~Derived()</code><code>	{</code><code>		std::cout &lt;&lt; "~Derived()\n";</code><code>	}</code><code></code><code>	void print() const { std::cout &lt;&lt; "Derived: " &lt;&lt; m_x &lt;&lt; '\n'; }</code><code>};</code><code></code><code>class D2 : public Derived</code><code>{</code><code>public:</code><code>	D2(int z): Derived{ z }</code><code>	{</code><code>		std::cout &lt;&lt; "D2()\n";</code><code>	}</code><code>	~D2()</code><code>	{</code><code>		std::cout &lt;&lt; "~D2()\n";</code><code>	}</code><code></code><code>        // note: no print() function here</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	D2 d{ 5 };</code><code>	d.print();</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><p>Base()<br>Derived()<br>D2()<br>Derived: 5<br>~D2()<br>~Derived()<br>~Base()</p></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #2</p><p>a) Write an Apple class and a Banana class that are derived from a common Fruit class. Fruit should have two members: a name and a color.</p><p>The following program should run:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	Apple a{ "red" };</code><code>	Banana b{};</code><code></code><code>	std::cout &lt;&lt; "My " &lt;&lt; a.getName() &lt;&lt; " is " &lt;&lt; a.getColor() &lt;&lt; ".\n";</code><code>	std::cout &lt;&lt; "My " &lt;&lt; b.getName() &lt;&lt; " is " &lt;&lt; b.getColor() &lt;&lt; ".\n";</code><code>	</code><code>	return 0;</code><code>}</code></pre><p>And produce the result:</p><pre>My apple is red.
My banana is yellow.
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class Fruit</code><code>{</code><code>private:</code><code>	std::string m_name;</code><code>	std::string m_color;</code><code></code><code>public:</code><code>	Fruit(const std::string_view name, const std::string_view color)</code><code>		: m_name{ name }, m_color{ color }</code><code>	{</code><code>	}</code><code></code><code>	const std::string&amp; getName() const { return m_name; }</code><code>	const std::string&amp; getColor() const { return m_color; }</code><code>};</code><code></code><code>class Apple: public Fruit</code><code>{</code><code>public:</code><code>	Apple(const std::string_view color="red")</code><code>		: Fruit{ "apple", color }</code><code>	{</code><code>	}</code><code>};</code><code></code><code>class Banana : public Fruit</code><code>{</code><code>public:</code><code>	Banana()</code><code>		: Fruit{ "banana", "yellow" }</code><code>	{</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Apple a{ "red" };</code><code>	Banana b;</code><code></code><code>	std::cout &lt;&lt; "My " &lt;&lt; a.getName() &lt;&lt; " is " &lt;&lt; a.getColor() &lt;&lt; ".\n";</code><code>	std::cout &lt;&lt; "My " &lt;&lt; b.getName() &lt;&lt; " is " &lt;&lt; b.getColor() &lt;&lt; ".\n";</code><code>	</code><code>	return 0;</code><code>}</code></pre></div><p>b) Add a new class to the previous program called GrannySmith that inherits from Apple.</p><p>The following program should run:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	Apple a{ "red" };</code><code>	Banana b;</code><code>	GrannySmith c;</code><code></code><code>	std::cout &lt;&lt; "My " &lt;&lt; a.getName() &lt;&lt; " is " &lt;&lt; a.getColor() &lt;&lt; ".\n";</code><code>	std::cout &lt;&lt; "My " &lt;&lt; b.getName() &lt;&lt; " is " &lt;&lt; b.getColor() &lt;&lt; ".\n";</code><code>	std::cout &lt;&lt; "My " &lt;&lt; c.getName() &lt;&lt; " is " &lt;&lt; c.getColor() &lt;&lt; ".\n";</code><code>	</code><code>	return 0;</code><code>}</code></pre><p>And produce the result:</p><pre>My apple is red.
My banana is yellow.
My granny smith apple is green.
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class Fruit</code><code>{</code><code>private:</code><code>	std::string m_name;</code><code>	std::string m_color;</code><code></code><code>public:</code><code>	Fruit(const std::string_view name, const std::string_view color)</code><code>		: m_name{ name }, m_color{ color }</code><code>	{</code><code>	}</code><code></code><code>	const std::string&amp; getName() const { return m_name; }</code><code>	const std::string&amp; getColor() const { return m_color; }</code><code>};</code><code></code><code>class Apple: public Fruit</code><code>{</code><code>// The previous constructor we used for Apple had a fixed name ("apple").</code><code>// We need a new constructor for GrannySmith to use to set the name of the fruit</code><code>protected: // protected so only derived classes can access</code><code>	Apple(const std::string_view name, const std::string_view color)</code><code>		: Fruit{ name, color }</code><code>	{</code><code>	}</code><code></code><code>public:</code><code>	Apple(const std::string_view color="red")</code><code>		: Fruit{ "apple", color }</code><code>	{</code><code>	}</code><code>};</code><code></code><code>class Banana : public Fruit</code><code>{</code><code>public:</code><code>	Banana()</code><code>		: Fruit{ "banana", "yellow" }</code><code>	{</code><code>	}</code><code>};</code><code></code><code>class GrannySmith : public Apple</code><code>{</code><code>public:</code><code>	GrannySmith()</code><code>		: Apple{ "granny smith apple", "green" }</code><code>	{</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Apple a{ "red" };</code><code>	Banana b;</code><code>	GrannySmith c;</code><code></code><code>	std::cout &lt;&lt; "My " &lt;&lt; a.getName() &lt;&lt; " is " &lt;&lt; a.getColor() &lt;&lt; ".\n";</code><code>	std::cout &lt;&lt; "My " &lt;&lt; b.getName() &lt;&lt; " is " &lt;&lt; b.getColor() &lt;&lt; ".\n";</code><code>	std::cout &lt;&lt; "My " &lt;&lt; c.getName() &lt;&lt; " is " &lt;&lt; c.getColor() &lt;&lt; ".\n";</code><code></code><code>	return 0;</code><code>}</code></pre></div></div><div class="quiz" style="clear:both"><p class="quiz-header">Question #3</p><p>Challenge time! The following quiz question is more difficult and lengthy. We’re going to write a simple game where you fight monsters. The goal of the game is to collect as much gold as you can before you die or get to level 20.</p><p>Our program is going to consist of 3 classes: a Creature class, a Player class, and a Monster class. Player and Monster both inherit from Creature.</p><p>a) First create the Creature class. Creatures have 5 attributes: A name (std::string), a symbol (a char), an amount of health (int), the amount of damage they do per attack (int), and the amount of gold they are carrying (int). Implement these as class members. Write a full set of getters (a get function for each member). Add three other functions: void reduceHealth(int) reduces the Creature’s health by an integer amount. bool isDead() returns true when the Creature’s health is 0 or less. void addGold(int) adds gold to the Creature.</p><p>The following program should run:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>	Creature o{ "orc", 'o', 4, 2, 10 };</code><code>	o.addGold(5);</code><code>	o.reduceHealth(1);</code><code>	std::cout &lt;&lt; "The " &lt;&lt; o.getName() &lt;&lt; " has " &lt;&lt; o.getHealth() &lt;&lt; " health and is carrying " &lt;&lt; o.getGold() &lt;&lt; " gold.\n";</code><code></code><code>	return 0;</code><code>}</code></pre><p>And produce the result:</p><pre>The orc has 3 health and is carrying 15 gold.
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_7'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_7" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view> // Requires C++17</string_view></code><code></code><code>class Creature</code><code>{</code><code>protected:</code><code>	std::string m_name;</code><code>	char m_symbol {};</code><code>	int m_health {};</code><code>	int m_damage {};</code><code>	int m_gold {};</code><code></code><code>public:</code><code>	Creature(std::string_view name, char symbol, int health, int damage, int gold)</code><code>		: m_name{ name }</code><code>		, m_symbol{ symbol }</code><code>		, m_health{ health }</code><code>		, m_damage{ damage }</code><code>		, m_gold{ gold }</code><code>	{</code><code>	}</code><code></code><code>	const std::string&amp; getName() const { return m_name; }</code><code>	char getSymbol() const { return m_symbol; }</code><code>	int getHealth() const { return m_health; }</code><code>	int getDamage() const { return m_damage; }</code><code>	int getGold() const { return m_gold; }</code><code></code><code>	void reduceHealth(int health) { m_health -= health; }</code><code>	bool isDead() const { return m_health &lt;= 0; }</code><code>	void addGold(int gold) { m_gold += gold; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Creature o{ "orc", 'o', 4, 2, 10 };</code><code>	o.addGold(5);</code><code>	o.reduceHealth(1);</code><code>	std::cout &lt;&lt; "The " &lt;&lt; o.getName() &lt;&lt; " has " &lt;&lt; o.getHealth() &lt;&lt; " health and is carrying " &lt;&lt; o.getGold() &lt;&lt; " gold.\n";</code><code></code><code>	return 0;</code><code>}</code></pre></div><p>b) Now we’re going to create the Player class. The Player class inherits from Creature. Player has one additional member, the player’s level, which starts at 1. The player has a custom name (entered by the user), uses symbol ‘@’, has 10 health, does 1 damage to start, and has no gold. Write a function called levelUp() that increases the player’s level and damage by 1. Also write a getter for the level member. Finally, write a function called hasWon() that returns true if the player has reached level 20.</p><p>Write a new main() function that asks the user for their name and produces the output as follows:</p><pre>Enter your name: Alex
Welcome, Alex.
You have 10 health and are carrying 0 gold.
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_8'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_8" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view> // std::string_view requires C++17</string_view></code><code></code><code>class Creature</code><code>{</code><code>protected:</code><code>	std::string m_name;</code><code>	char m_symbol {};</code><code>	int m_health {};</code><code>	int m_damage {};</code><code>	int m_gold {};</code><code></code><code>public:</code><code>	Creature(std::string_view name, char symbol, int health, int damage, int gold)</code><code>		: m_name{ name }</code><code>		, m_symbol{ symbol }</code><code>		, m_health{ health }</code><code>		, m_damage{ damage }</code><code>		, m_gold{ gold }</code><code>	{</code><code>	}</code><code></code><code>	const std::string&amp; getName() const { return m_name; }</code><code>	char getSymbol() const { return m_symbol; }</code><code>	int getHealth() const { return m_health; }</code><code>	int getDamage() const { return m_damage; }</code><code>	int getGold() const { return m_gold; }</code><code></code><code>	void reduceHealth(int health) { m_health -= health; }</code><code>	bool isDead() const { return m_health &lt;= 0; }</code><code>	void addGold(int gold) { m_gold += gold; }</code><code>};</code><code></code><code>class Player : public Creature</code><code>{</code><code>	int m_level{ 1 };</code><code></code><code>public:</code><code>	Player(std::string_view name)</code><code>		: Creature{ name, '@', 10, 1, 0 }</code><code>	{</code><code>	}</code><code></code><code>	void levelUp()</code><code>	{</code><code>		++m_level;</code><code>		++m_damage;</code><code>	}</code><code></code><code>	int getLevel() const { return m_level; }</code><code>	bool hasWon() const { return m_level &gt;= 20; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Enter your name: ";</code><code>	std::string playerName;</code><code>	std::cin &gt;&gt; playerName;</code><code></code><code>	Player p{ playerName };</code><code>	std::cout &lt;&lt; "Welcome, " &lt;&lt; p.getName() &lt;&lt; ".\n";</code><code></code><code>	std::cout &lt;&lt; "You have " &lt;&lt; p.getHealth() &lt;&lt; " health and are carrying " &lt;&lt; p.getGold() &lt;&lt; " gold.\n";</code><code></code><code>	return 0;</code><code>}</code></pre></div><p>c) Next up is the Monster class. Monster also inherits from Creature. Monsters have no non-inherited member variables.</p><p>First, write an empty Monster class inheriting from Creature, and then add an enum inside the Monster class named Type that contains enumerators for the 3 monsters that we’ll have in this game: DRAGON, ORC, and SLIME (you’ll also want a max_types enumerator, as that will come in handy in a bit).</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_9'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_9" style="display:none"><pre class="language-cpp line-numbers"><code>class Monster : public Creature</code><code>{</code><code>public:</code><code>	enum class Type</code><code>	{</code><code>		dragon,</code><code>		orc,</code><code>		slime,</code><code>		max_types</code><code>	};</code><code>};</code></pre></div><p>d) Each Monster type will have a different name, symbol, starting health, gold, and damage. Here is a table of stats for each monster Type:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Type</th><th>Name</th><th>Symbol</th><th>Health</th><th>Damage</th><th>Gold</th></tr><tr><td>dragon</td><td>dragon</td><td>D</td><td>20</td><td>4</td><td>100</td></tr><tr><td>orc</td><td>orc</td><td>o</td><td>4</td><td>2</td><td>25</td></tr><tr><td>slime</td><td>slime</td><td>s</td><td>1</td><td>1</td><td>10</td></tr></tbody></table></div><p>Next step is to write a Monster constructor, so we can create monsters. The Monster constructor should take a Type enum as a parameter, and then create a Monster with the appropriate stats for that kind of monster.</p><p>There are a number of different ways to implement this (some better, some worse). However in this case, because all of our monster attributes are predefined (not random), we’ll use a lookup table. A lookup table is an array that holds all of the predefined attributes. We can use the lookup table to look up the attributes for a given monster as needed.</p><p>So how do we implement this lookup table? It’s not hard. We just need an array that contains an element for each monster Type. Each array element will contain a Creature that contains all of the predefined attribute values for that Type of Monster. We place this array inside of a static member function of Monster so that we can get a default Creature for a given Monster::Type.</p><p>The definition of the lookup table is as follows:</p><pre class="language-cpp line-numbers"><code>// As a private member of Monster</code><code>static const Creature&amp; getDefaultCreature(Type type)</code><code>{</code><code>  static const std::array<creature, static_cast<std::size_t="">(Type::max_types)&gt; monsterData{</creature,></code><code>    { { "dragon", 'D', 20, 4, 100 },</code><code>      { "orc", 'o', 4, 2, 25 },</code><code>      { "slime", 's', 1, 1, 10 } }</code><code>  };</code><code></code><code>  return monsterData.at(static_cast<std::size_t>(type));</std::size_t></code><code>}</code></pre><p>Now we can call this function to lookup any values we need! For example, to get a Dragon’s gold, we can call <code>getDefaultCreature(Type::dragon).getGold()</code>.</p><p>Use this function and base class constructors to implement your Monster constructor.</p><p>The following program should compile:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>	Monster m{ Monster::Type::orc };</code><code>	std::cout &lt;&lt; "A " &lt;&lt; m.getName() &lt;&lt; " (" &lt;&lt; m.getSymbol() &lt;&lt; ") was created.\n";</code><code></code><code>	return 0;</code><code>}</code></pre><p>and print:</p><pre>A orc (o) was created.
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_10'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_10" style="display:none"><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view> // std::string_view requires C++17</string_view></code><code></code><code>class Creature</code><code>{</code><code>protected:</code><code>  std::string m_name;</code><code>  char m_symbol {};</code><code>  int m_health {};</code><code>  int m_damage {};</code><code>  int m_gold {};</code><code></code><code>public:</code><code>  Creature(std::string_view name, char symbol, int health, int damage, int gold)</code><code>    : m_name{ name }</code><code>    , m_symbol{ symbol }</code><code>    , m_health{ health }</code><code>    , m_damage{ damage }</code><code>    , m_gold{ gold }</code><code>  {</code><code>  }</code><code></code><code>  const std::string&amp; getName() const { return m_name; }</code><code>  char getSymbol() const { return m_symbol; }</code><code>  int getHealth() const { return m_health; }</code><code>  int getDamage() const { return m_damage; }</code><code>  int getGold() const { return m_gold; }</code><code></code><code>  void reduceHealth(int health) { m_health -= health; }</code><code>  bool isDead() const { return m_health &lt;= 0; }</code><code>  void addGold(int gold) { m_gold += gold; }</code><code>};</code><code></code><code>class Player : public Creature</code><code>{</code><code>  int m_level{ 1 };</code><code></code><code>public:</code><code>  Player(std::string_view name)</code><code>      : Creature{ name, '@', 10, 1, 0 }</code><code>  {</code><code>  }</code><code></code><code>  void levelUp()</code><code>  {</code><code>    ++m_level;</code><code>    ++m_damage;</code><code>  }</code><code></code><code>  int getLevel() const { return m_level; }</code><code>};</code><code></code><code>class Monster : public Creature</code><code>{</code><code>public:</code><code>  enum class Type</code><code>  {</code><code>    dragon,</code><code>    orc,</code><code>    slime,</code><code>    max_types</code><code>  };</code><code></code><code>private:</code><code>  static const Creature&amp; getDefaultCreature(Type type)</code><code>  {</code><code>    static const std::array<creature, static_cast<std::size_t="">(Type::max_types)&gt; monsterData{</creature,></code><code>      { { "dragon", 'D', 20, 4, 100 },</code><code>        { "orc", 'o', 4, 2, 25 },</code><code>        { "slime", 's', 1, 1, 10 } }</code><code>    };</code><code></code><code>    return monsterData.at(static_cast<std::size_t>(type));</std::size_t></code><code>  }</code><code></code><code>public:</code><code>  Monster(Type type)</code><code>      : Creature{ getDefaultCreature(type) }</code><code>  {</code><code>  }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>  Monster m{ Monster::Type::orc };</code><code>  std::cout &lt;&lt; "A " &lt;&lt; m.getName() &lt;&lt; " (" &lt;&lt; m.getSymbol() &lt;&lt; ") was created.\n";</code><code></code><code>  return 0;</code><code>}</code></pre></div><p>e) Finally, add a <code>static</code> function to Monster named <code>getRandomMonster()</code>. This function should pick a random number from <code>0</code> to <code>max_types-1</code> and return a monster (by value) with that <code>Type</code> (you’ll need to <code>static_cast</code> the <code>int</code> to a <code>Type</code> to pass it to the <code>Monster</code> constructor).</p><p>Lesson <a href="https://www.learncpp.com/cpp-tutorial/generating-random-numbers-using-mersenne-twister/">7.19 -- Generating random numbers using Mersenne Twister</a> contains code you can use to pick a random number.</p><p>The following main function should run:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <cstdlib> // for rand() and srand()</cstdlib></code><code>#include <ctime> // for time()</ctime></code><code></code><code>int main()</code><code>{</code><code>	std::srand(static_cast<unsigned int="">(std::time(nullptr))); // set initial seed value to system clock</unsigned></code><code>	std::rand(); // get rid of first result</code><code></code><code>	for (int i{ 0 }; i &lt; 10; ++i)</code><code>	{</code><code>		Monster m{ Monster::getRandomMonster() };</code><code>		std::cout &lt;&lt; "A " &lt;&lt; m.getName() &lt;&lt; " (" &lt;&lt; m.getSymbol() &lt;&lt; ") was created.\n";</code><code>	}</code><code></code><code>	return 0;</code><code>}</code></pre><p>The results of this program should be randomized.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_11'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_11" style="display:none"><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <cstdlib> // for rand() and srand()</cstdlib></code><code>#include <ctime> // for time()</ctime></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code> </code><code>// Generate a random number between min and max (inclusive)</code><code>// Assumes std::srand() has already been called</code><code>// Assumes max - min &lt;= RAND_MAX</code><code>int getRandomNumber(int min, int max)</code><code>{</code><code>  static constexpr double fraction{ 1.0 / (RAND_MAX + 1.0) }; // static used for efficiency, so we only calculate this value once</code><code>  // evenly distribute the random number across our range</code><code>  return min + static_cast<int>((max - min + 1) * (std::rand() * fraction));</int></code><code>}</code><code> </code><code>class Creature</code><code>{</code><code>protected:</code><code>  std::string m_name;</code><code>  char m_symbol {};</code><code>  int m_health {};</code><code>  int m_damage {};</code><code>  int m_gold {};</code><code> </code><code>public:</code><code>  Creature(std::string_view name, char symbol, int health, int damage, int gold)</code><code>    : m_name{ name }</code><code>    , m_symbol{ symbol }</code><code>    , m_health{ health }</code><code>    , m_damage{ damage }</code><code>    , m_gold{ gold }</code><code>  {</code><code>  }</code><code> </code><code>  char getSymbol() const { return m_symbol; }</code><code>  const std::string&amp; getName() const { return m_name; }</code><code>  bool isDead() const { return m_health &lt;= 0; }</code><code>  int getGold() const { return m_gold; }</code><code>  void addGold(int gold) { m_gold += gold; }</code><code>  void reduceHealth(int health) { m_health -= health; }</code><code>  int getHealth() const { return m_health; }</code><code>  int getDamage() const { return m_damage; }</code><code>};</code><code> </code><code>class Player : public Creature</code><code>{</code><code>  int m_level{ 1 };</code><code> </code><code>public:</code><code>  Player(const std::string&amp; name)</code><code>      : Creature{ name, '@', 10, 1, 0 }</code><code>  {</code><code>  }</code><code> </code><code>  void levelUp()</code><code>  {</code><code>    ++m_level;</code><code>    ++m_damage;</code><code>  }</code><code> </code><code>  int getLevel() const { return m_level; }</code><code>  bool hasWon() const { return m_level &gt;= 20; }</code><code>};</code><code> </code><code>class Monster : public Creature</code><code>{</code><code>public:</code><code>  enum class Type</code><code>  {</code><code>    dragon,</code><code>    orc,</code><code>    slime,</code><code>    max_types</code><code>  };</code><code> </code><code>private:</code><code>  static const Creature&amp; getDefaultCreature(Type type)</code><code>  {</code><code>    static const std::array<creature, static_cast<std::size_t="">(Type::max_types)&gt; monsterData{</creature,></code><code>      { { "dragon", 'D', 20, 4, 100 },</code><code>        { "orc", 'o', 4, 2, 25 },</code><code>        { "slime", 's', 1, 1, 10 } }</code><code>    };</code><code></code><code>    return monsterData.at(static_cast<std::size_t>(type));</std::size_t></code><code>  }</code><code></code><code>public:</code><code>  Monster(Type type)</code><code>      : Creature{ getDefaultCreature(type) }</code><code>  {</code><code>  }</code><code> </code><code>  static Monster getRandomMonster()</code><code>  {</code><code>    int num{ getRandomNumber(0, static_cast<int>(Type::max_types) - 1) };</int></code><code>    return Monster{ static_cast<type>(num) };</type></code><code>  }</code><code>};</code><code> </code><code>int main()</code><code>{</code><code>  std::srand(static_cast<unsigned int="">(std::time(nullptr))); // set initial seed value to system clock</unsigned></code><code>  std::rand(); // get rid of first result</code><code> </code><code>  for (int i{ 0 }; i &lt; 10; ++i)</code><code>  {</code><code>    Monster m{ Monster::getRandomMonster() };</code><code>    std::cout &lt;&lt; "A " &lt;&lt; m.getName() &lt;&lt; " (" &lt;&lt; m.getSymbol() &lt;&lt; ") was created.\n";</code><code>  }</code><code> </code><code>  return 0;</code><code>}</code></pre></div><p>f) We’re finally set to write our game logic!</p><p>Here are the rules for the game:</p><p>The player encounters one randomly generated monster at a time.<br>For each monster, the player has two choices: (R)un or (F)ight.<br>If the player decides to Run, they have a 50% chance of escaping.<br>If the player escapes, they move to the next encounter with no ill effects.<br>If the player does not escape, the monster gets a free attack, and the player chooses their next action.<br>If the player chooses to fight, the player attacks first. The monster’s health is reduced by the player’s damage.<br>If the monster dies, the player takes any gold the monster is carrying. The player also levels up, increasing their level and damage by 1.<br>If the monster does not die, the monster attacks the player back. The player’s health is reduced by the monster’s damage.<br>The game ends when the player has died (loss) or reached level 20 (win)<br>If the player dies, the game should tell the player what level they were and how much gold they had.<br>If the player wins, the game should tell the player they won, and how much gold they had</p><p>Here’s a sample game session:</p><p>Enter your name: Alex<br>Welcome, Alex<br>You have encountered a slime (s).<br>(R)un or (F)ight: f<br>You hit the slime for 1 damage.<br>You killed the slime.<br>You are now level 2.<br>You found 10 gold.<br>You have encountered a dragon (D).<br>(R)un or (F)ight: r<br>You failed to flee.<br>The dragon hit you for 4 damage.<br>(R)un or (F)ight: r<br>You successfully fled.<br>You have encountered a orc (o).<br>(R)un or (F)ight: f<br>You hit the orc for 2 damage.<br>The orc hit you for 2 damage.<br>(R)un or (F)ight: f<br>You hit the orc for 2 damage.<br>You killed the orc.<br>You are now level 3.<br>You found 25 gold.<br>You have encountered a dragon (D).<br>(R)un or (F)ight: r<br>You failed to flee.<br>The dragon hit you for 4 damage.<br>You died at level 3 and with 35 gold.<br>Too bad you can’t take it with you!</p><p>Hint: Create 4 functions:</p><ul><li>The main() function should handle game setup (creating the Player) and the main game loop.</li><li>fightMonster() handles the fight between the Player and a single Monster, including asking the player what they want to do, handling the run or fight cases.</li><li>attackMonster() handles the player attacking the monster, including leveling up.</li><li>attackPlayer() handles the monster attacking the player.</li></ul><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_12'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_12" style="display:none"><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <cstdlib> // for rand() and srand()</cstdlib></code><code>#include <ctime> // for time()</ctime></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>// Generate a random number between min and max (inclusive)</code><code>// Assumes std::srand() has already been called</code><code>// Assumes max - min &lt;= RAND_MAX</code><code>int getRandomNumber(int min, int max)</code><code>{</code><code>  static constexpr double fraction{ 1.0 / (RAND_MAX + 1.0) }; // static used for efficiency, so we only calculate this value once</code><code>  // evenly distribute the random number across our range</code><code>  return min + static_cast<int>((max - min + 1) * (std::rand() * fraction));</int></code><code>}</code><code></code><code>class Creature</code><code>{</code><code>protected:</code><code>  std::string m_name;</code><code>  char m_symbol {};</code><code>  int m_health {};</code><code>  int m_damage {};</code><code>  int m_gold {};</code><code></code><code>public:</code><code>  Creature(std::string_view name, char symbol, int health, int damage, int gold)</code><code>    : m_name{ name }</code><code>    , m_symbol{ symbol }</code><code>    , m_health{ health }</code><code>    , m_damage{ damage }</code><code>    , m_gold{ gold }</code><code>  {</code><code>  }</code><code></code><code>  char getSymbol() const { return m_symbol; }</code><code>  const std::string&amp; getName() const { return m_name; }</code><code>  bool isDead() const { return m_health &lt;= 0; }</code><code>  int getGold() const { return m_gold; }</code><code>  void addGold(int gold) { m_gold += gold; }</code><code>  void reduceHealth(int health) { m_health -= health; }</code><code>  int getHealth() const { return m_health; }</code><code>  int getDamage() const { return m_damage; }</code><code>};</code><code></code><code>class Player : public Creature</code><code>{</code><code>  int m_level{ 1 };</code><code></code><code>public:</code><code>  Player(std::string_view name)</code><code>      : Creature{ name, '@', 10, 1, 0 }</code><code>  {</code><code>  }</code><code></code><code>  void levelUp()</code><code>  {</code><code>    ++m_level;</code><code>    ++m_damage;</code><code>  }</code><code></code><code>  int getLevel() const { return m_level; }</code><code>  bool hasWon() const { return m_level &gt;= 20; }</code><code>};</code><code></code><code>class Monster : public Creature</code><code>{</code><code>public:</code><code>  enum class Type</code><code>  {</code><code>    dragon,</code><code>    orc,</code><code>    slime,</code><code>    max_types</code><code>  };</code><code></code><code>private:</code><code>  static const Creature&amp; getDefaultCreature(Type type)</code><code>  {</code><code>    static const std::array<creature, static_cast<std::size_t="">(Type::max_types)&gt; monsterData{</creature,></code><code>      { { "dragon", 'D', 20, 4, 100 },</code><code>        { "orc", 'o', 4, 2, 25 },</code><code>        { "slime", 's', 1, 1, 10 } }</code><code>    };</code><code></code><code>    return monsterData.at(static_cast<std::size_t>(type));</std::size_t></code><code>  }</code><code></code><code>public:</code><code>  Monster(Type type)</code><code>      : Creature{ getDefaultCreature(type) }</code><code>  {</code><code>  }</code><code></code><code>  static Monster getRandomMonster()</code><code>  {</code><code>    int num{ getRandomNumber(0, static_cast<int>(Type::max_types) - 1) };</int></code><code>    return Monster{ static_cast<type>(num) };</type></code><code>  }</code><code>};</code><code></code><code>// This function handles the player attacking the monster</code><code>void attackMonster(Player&amp; player, Monster&amp; monster)</code><code>{</code><code>  // If the player is dead, we can't attack the monster</code><code>  if (player.isDead())</code><code>    return;</code><code></code><code>  std::cout &lt;&lt; "You hit the " &lt;&lt; monster.getName() &lt;&lt; " for " &lt;&lt; player.getDamage() &lt;&lt; " damage.\n";</code><code></code><code>  // Reduce the monster's health by the player's damage</code><code>  monster.reduceHealth(player.getDamage());</code><code></code><code>  // If the monster is now dead, level the player up</code><code>  if (monster.isDead())</code><code>  {</code><code>    std::cout &lt;&lt; "You killed the " &lt;&lt; monster.getName() &lt;&lt; ".\n";</code><code>    player.levelUp();</code><code>    std::cout &lt;&lt; "You are now level " &lt;&lt; player.getLevel() &lt;&lt; ".\n";</code><code>    std::cout &lt;&lt; "You found " &lt;&lt; monster.getGold() &lt;&lt; " gold.\n";</code><code>    player.addGold(monster.getGold());</code><code>  }</code><code>}</code><code></code><code>// This function handles the monster attacking the player</code><code>void attackPlayer(const Monster&amp; monster, Player&amp; player)</code><code>{</code><code>  // If the monster is dead, it can't attack the player</code><code>  if (monster.isDead())</code><code>    return;</code><code></code><code>  // Reduce the player's health by the monster's damage</code><code>  player.reduceHealth(monster.getDamage());</code><code>  std::cout &lt;&lt; "The " &lt;&lt; monster.getName() &lt;&lt; " hit you for " &lt;&lt; monster.getDamage() &lt;&lt; " damage.\n";</code><code>}</code><code></code><code>// This function handles the entire fight between a player and a randomly generated monster</code><code>void fightMonster(Player&amp; player)</code><code>{</code><code>  // First randomly generate a monster</code><code>  Monster monster{ Monster::getRandomMonster() };</code><code>  std::cout &lt;&lt; "You have encountered a " &lt;&lt; monster.getName() &lt;&lt; " (" &lt;&lt; monster.getSymbol() &lt;&lt; ").\n";</code><code></code><code>  // While the monster isn't dead and the player isn't dead, the fight continues</code><code>  while (!monster.isDead() &amp;&amp; !player.isDead())</code><code>  {</code><code>    std::cout &lt;&lt; "(R)un or (F)ight: ";</code><code>    char input{};</code><code>    std::cin &gt;&gt; input;</code><code>    if (input == 'R' || input == 'r')</code><code>    {</code><code>      // 50% chance of fleeing successfully</code><code>      if (getRandomNumber(1, 2) == 1)</code><code>      {</code><code>        std::cout &lt;&lt; "You successfully fled.\n";</code><code>        return; // success ends the encounter</code><code>      }</code><code>      else</code><code>      {</code><code>        // Failure to flee gives the monster a free attack on the player</code><code>        std::cout &lt;&lt; "You failed to flee.\n";</code><code>        attackPlayer(monster, player);</code><code>        continue;</code><code>      }</code><code>    }</code><code></code><code>    if (input == 'F' || input == 'f')</code><code>    {</code><code>      // Player attacks first, monster attacks second</code><code>      attackMonster(player, monster);</code><code>      attackPlayer(monster, player);</code><code>    }</code><code>  }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  std::srand(static_cast<unsigned int="">(std::time(nullptr))); // set initial seed value to system clock</unsigned></code><code>  std::rand(); // get rid of first result</code><code></code><code>  std::cout &lt;&lt; "Enter your name: ";</code><code>  std::string playerName;</code><code>  std::cin &gt;&gt; playerName;</code><code></code><code>  Player player{ playerName };</code><code>  std::cout &lt;&lt; "Welcome, " &lt;&lt; player.getName() &lt;&lt; '\n';</code><code></code><code>  // If the player isn't dead and hasn't won yet, the game continues</code><code>  while (!player.isDead() &amp;&amp; !player.hasWon())</code><code>    fightMonster(player);</code><code></code><code>  // At this point, the player is either dead or has won</code><code>  if (player.isDead())</code><code>  {</code><code>    std::cout &lt;&lt; "You died at level " &lt;&lt; player.getLevel() &lt;&lt; " and with " &lt;&lt; player.getGold() &lt;&lt; " gold.\n";</code><code>    std::cout &lt;&lt; "Too bad you can't take it with you!\n";</code><code>  }</code><code>  else</code><code>  {</code><code>    std::cout &lt;&lt; "You won the game with " &lt;&lt; player.getGold() &lt;&lt; " gold!\n";</code><code>  }</code><code></code><code>  return 0;</code><code>}</code></pre></div><p>g) Extra credit:<br>Reader <a href="https://www.learncpp.com/cpp-tutorial/11-x-chapter-11-comprehensive-quiz/comment-page-5/#comment-471079">Tom</a> didn’t sharpen his sword enough to defeat the mighty dragon. Help him by implementing the following potions in different sizes:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Type</th><th>Effect (Small)</th><th>Effect (Medium)</th><th>Effect (Large)</th></tr><tr><td>Health</td><td>+2 Health</td><td>+2 Health</td><td>+5 Health</td></tr><tr><td>Strength</td><td>+1 Damage</td><td>+1 Damage</td><td>+1 Damage</td></tr><tr><td>Poison</td><td>-1 Health</td><td>-1 Health</td><td>-1 Health</td></tr></tbody></table></div><p>Feel free to get creative and add more potions or change their effects!</p><p>The player has a 30% chance of finding a potion after every won fight and has the choice between drinking or not drinking it. If the player doesn’t drink the potion, it disappears. The player doesn’t know what type of potion was found until the player drinks it, at which point the type and size of the potion is revealed and the effect is applied.</p><p>In the following example, the player found a poison potion and died from drinking it (Poison was much more damaging in this example)</p><pre>You have encountered a slime (s).
(R)un or (F)ight: f
You hit the slime for 1 damage.
You killed the slime.
You are now level 2.
You found 10 gold.
You found a mythical potion! Do you want to drink it? [y/n]: y
You drank a Medium potion of Poison
You died at level 2 and with 10 gold.
Too bad you can't take it with you!
</pre><p><a class="hint_link_show" href="javascript:void(0)" onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Show Hint</a></p><div class="wphint" id="cpp_hint_id_0" style="display:none;margin-bottom:1em">Hint: Add a Potion class that has a type and size member variable, along with a member function that returns its name and a static member function the creates a random Potion, similar to the getRandomMonster() function.<br>In the Player class, add a drinkPotion() member function the applies the potion’s effect.</div><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_13'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_13" style="display:none"><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <cstdlib></cstdlib></code><code>#include <ctime></ctime></code><code>#include <iostream></iostream></code><code>#include <sstream> // for std::stringstream</sstream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>int getRandomNumber(int min, int max)</code><code>{</code><code>    static constexpr double fraction{ 1.0 / (RAND_MAX + 1.0) };</code><code>    return min + static_cast<int>((max - min + 1) * (std::rand() * fraction));</int></code><code>}</code><code></code><code>class Potion</code><code>{</code><code>public:</code><code>    // All possible types of potions</code><code>    enum PotionType</code><code>    {</code><code>        health,</code><code>        strength,</code><code>        poison,</code><code></code><code>        // For random potion generation</code><code>        max_type</code><code>    };</code><code></code><code>    enum PotionSize</code><code>    {</code><code>        small,</code><code>        medium,</code><code>        large,</code><code></code><code>        max_size</code><code>    };</code><code></code><code></code><code>private:</code><code>    PotionType m_type{};</code><code>    PotionSize m_size{};</code><code></code><code>public:</code><code>    Potion(PotionType type, PotionSize size)</code><code>        : m_type{ type },</code><code>        m_size{ size }</code><code>    {</code><code>    }</code><code></code><code>    PotionType getType() const { return m_type; }</code><code>    PotionSize getSize() const { return m_size; }</code><code></code><code>    // The names of potions are compile-time literals, we can</code><code>    // return a std::string_view.</code><code>    static std::string_view getPotionTypeName(PotionType type)</code><code>    {</code><code>        static constexpr std::array names{</code><code>          "Health",</code><code>          "Strength",</code><code>          "Poison"</code><code>        };</code><code></code><code>        return names.at(static_cast<std::size_t>(type));</std::size_t></code><code>    }</code><code></code><code>    static std::string_view getPotionSizeName(PotionSize size)</code><code>    {</code><code>        static constexpr std::array names{</code><code>          "Small",</code><code>          "Medium",</code><code>          "Large"</code><code>        };</code><code></code><code>        return names.at(static_cast<std::size_t>(size));</std::size_t></code><code>    }</code><code></code><code>    std::string getName() const</code><code>    {</code><code>        // We use a std::stringstream, but this could also be solved using</code><code>        // std::string.</code><code>        // We first used std::stringstream in lesson 7.13.</code><code>        std::stringstream result{};</code><code></code><code>        result &lt;&lt; getPotionSizeName(getSize()) &lt;&lt; " potion of " &lt;&lt; getPotionTypeName(getType());</code><code></code><code>        // We can extract the string from an std::stringstream by using the str()</code><code>        // member function.</code><code>        return result.str();</code><code>    }</code><code></code><code>    static Potion getRandomPotion()</code><code>    {</code><code>        return {</code><code>          static_cast<potiontype>(getRandomNumber(0, static_cast<int>(PotionType::max_type) - 1)),</int></potiontype></code><code>          static_cast<potionsize>(getRandomNumber(0, static_cast<int>(PotionSize::max_size) - 1))</int></potionsize></code><code>        };</code><code>    }</code><code>};</code><code></code><code>class Creature</code><code>{</code><code>protected:</code><code>    std::string m_name;</code><code>    char m_symbol{};</code><code>    int m_health{};</code><code>    int m_damage{};</code><code>    int m_gold{};</code><code></code><code>public:</code><code>    Creature(std::string_view name, char symbol, int health, int damage, int gold)</code><code>        : m_name{ name }</code><code>        , m_symbol{ symbol }</code><code>        , m_health{ health }</code><code>        , m_damage{ damage }</code><code>        , m_gold{ gold }</code><code>    {</code><code>    }</code><code></code><code>    char getSymbol() const { return m_symbol; }</code><code>    const std::string&amp; getName() const { return m_name; }</code><code>    bool isDead() const { return m_health &lt;= 0; }</code><code>    int getGold() const { return m_gold; }</code><code>    void addGold(int gold) { m_gold += gold; }</code><code>    void reduceHealth(int health) { m_health -= health; }</code><code>    int getHealth() const { return m_health; }</code><code>    int getDamage() const { return m_damage; }</code><code>};</code><code></code><code>class Player : public Creature</code><code>{</code><code>    int m_level{ 1 };</code><code></code><code>public:</code><code>    Player(std::string_view name)</code><code>        : Creature{ name, '@', 10, 1, 0 }</code><code>    {</code><code>    }</code><code></code><code>    void levelUp()</code><code>    {</code><code>        ++m_level;</code><code>        ++m_damage;</code><code>    }</code><code></code><code>    int getLevel() const { return m_level; }</code><code>    bool hasWon() const { return m_level &gt;= 20; }</code><code></code><code>    // Applies a potion's effect to the player</code><code>    void drinkPotion(const Potion&amp; potion)</code><code>    {</code><code>        switch (potion.getType())</code><code>        {</code><code>        case Potion::health:</code><code>            // Only a health potion's size affects its power. All other</code><code>            // potions are independent of size.</code><code>            m_health += ((potion.getSize() == Potion::large) ? 5 : 2);</code><code>            break;</code><code>        case Potion::strength:</code><code>            ++m_damage;</code><code>            break;</code><code>        case Potion::poison:</code><code>            reduceHealth(1);</code><code>            break;</code><code>            // Handle max_type to silence the compiler warning. Don't use default:</code><code>            // because we want the compiler to warn us if we add a new potion but</code><code>            // forget to implement its effect.</code><code>        case Potion::max_type:</code><code>            break;</code><code>        }</code><code>    }</code><code>};</code><code></code><code>class Monster : public Creature</code><code>{</code><code>public:</code><code>    enum class Type</code><code>    {</code><code>        dragon,</code><code>        orc,</code><code>        slime,</code><code>        max_types</code><code>    };</code><code></code><code>private:</code><code>    static const Creature&amp; getDefaultCreature(Type type)</code><code>    {</code><code>        static const std::array<creature, static_cast<std::size_t="">(Type::max_types)&gt; monsterData{</creature,></code><code>          { { "dragon", 'D', 20, 4, 100 },</code><code>            { "orc", 'o', 4, 2, 25 },</code><code>            { "slime", 's', 1, 1, 10 } }</code><code>        };</code><code></code><code>        return monsterData.at(static_cast<std::size_t>(type));</std::size_t></code><code>    }</code><code></code><code>public:</code><code>    Monster(Type type)</code><code>        : Creature{ getDefaultCreature(type) }</code><code>    {</code><code>    }</code><code></code><code>    static Monster getRandomMonster()</code><code>    {</code><code>        int num{ getRandomNumber(0, static_cast<int>(Type::max_types) - 1) };</int></code><code>        return Monster{ static_cast<type>(num) };</type></code><code>    }</code><code>};</code><code></code><code>// We moved this out of attackMonster() to keep the function shorter.</code><code>void onMonsterKilled(Player&amp; player, const Monster&amp; monster)</code><code>{</code><code>    std::cout &lt;&lt; "You killed the " &lt;&lt; monster.getName() &lt;&lt; ".\n";</code><code>    player.levelUp();</code><code>    std::cout &lt;&lt; "You are now level " &lt;&lt; player.getLevel() &lt;&lt; ".\n";</code><code>    std::cout &lt;&lt; "You found " &lt;&lt; monster.getGold() &lt;&lt; " gold.\n";</code><code>    player.addGold(monster.getGold());</code><code></code><code>    // 30% chance of finding a potion</code><code>    constexpr int potionChance{ 30 };</code><code>    if (getRandomNumber(1, 100) &lt;= potionChance)</code><code>    {</code><code>        // Generate a random potion</code><code>        auto potion{ Potion::getRandomPotion() };</code><code></code><code>        std::cout &lt;&lt; "You found a mythical potion! Do you want to drink it? [y/n]: ";</code><code>        char choice{};</code><code>        std::cin &gt;&gt; choice;</code><code></code><code>        if (choice == 'Y' || choice == 'y')</code><code>        {</code><code>            // Apply the effect</code><code>            player.drinkPotion(potion);</code><code>            // Reveal the potion type and size</code><code>            std::cout &lt;&lt; "You drank a " &lt;&lt; potion.getName() &lt;&lt; ".\n";</code><code>        }</code><code>    }</code><code>}</code><code></code><code>void attackMonster(Player&amp; player, Monster&amp; monster)</code><code>{</code><code>    if (player.isDead())</code><code>        return;</code><code></code><code>    std::cout &lt;&lt; "You hit the " &lt;&lt; monster.getName() &lt;&lt; " for " &lt;&lt; player.getDamage() &lt;&lt; " damage.\n";</code><code></code><code>    monster.reduceHealth(player.getDamage());</code><code></code><code>    if (monster.isDead())</code><code>    {</code><code>        // Reward the player</code><code>        onMonsterKilled(player, monster);</code><code>    }</code><code>}</code><code></code><code>void attackPlayer(const Monster&amp; monster, Player&amp; player)</code><code>{</code><code>    if (monster.isDead())</code><code>        return;</code><code></code><code>    player.reduceHealth(monster.getDamage());</code><code>    std::cout &lt;&lt; "The " &lt;&lt; monster.getName() &lt;&lt; " hit you for " &lt;&lt; monster.getDamage() &lt;&lt; " damage.\n";</code><code>}</code><code></code><code>void fightMonster(Player&amp; player)</code><code>{</code><code>    Monster monster{ Monster::getRandomMonster() };</code><code>    std::cout &lt;&lt; "You have encountered a " &lt;&lt; monster.getName() &lt;&lt; " (" &lt;&lt; monster.getSymbol() &lt;&lt; ").\n";</code><code></code><code>    while (!monster.isDead() &amp;&amp; !player.isDead())</code><code>    {</code><code>        std::cout &lt;&lt; "(R)un or (F)ight: ";</code><code>        char input;</code><code>        std::cin &gt;&gt; input;</code><code>        if (input == 'R' || input == 'r')</code><code>        {</code><code>            if (getRandomNumber(1, 2) == 1)</code><code>            {</code><code>                std::cout &lt;&lt; "You successfully fled.\n";</code><code>                return;</code><code>            }</code><code>            else</code><code>            {</code><code>                std::cout &lt;&lt; "You failed to flee.\n";</code><code>                attackPlayer(monster, player);</code><code>                continue;</code><code>            }</code><code>        }</code><code></code><code>        if (input == 'F' || input == 'f')</code><code>        {</code><code>            attackMonster(player, monster);</code><code>            attackPlayer(monster, player);</code><code>        }</code><code>    }</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::srand(static_cast<unsigned int="">(std::time(nullptr)));</unsigned></code><code>    std::rand();</code><code></code><code>    std::cout &lt;&lt; "Enter your name: ";</code><code>    std::string playerName;</code><code>    std::cin &gt;&gt; playerName;</code><code></code><code>    Player player{ playerName };</code><code>    std::cout &lt;&lt; "Welcome, " &lt;&lt; player.getName() &lt;&lt; '\n';</code><code></code><code>    while (!player.isDead() &amp;&amp; !player.hasWon())</code><code>        fightMonster(player);</code><code></code><code>    if (player.isDead())</code><code>    {</code><code>        std::cout &lt;&lt; "You died at level " &lt;&lt; player.getLevel() &lt;&lt; " and with " &lt;&lt; player.getGold() &lt;&lt; " gold.\n";</code><code>        std::cout &lt;&lt; "Too bad you can't take it with you!\n";</code><code>    }</code><code>    else</code><code>    {</code><code>        std::cout &lt;&lt; "You won the game with " &lt;&lt; player.getGold() &lt;&lt; " gold!\n";</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">18.1 — Pointers and references to the base class of derived objects</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous chapter, you learned all about how to use inheritance to derive new classes from existing classes. In this chapter, we are going to focus on one of the most important and powerful aspects of inheritance -- virtual functions.</p><p>But before we discuss what virtual functions are, let’s first set the table for why we need them.</p><p>In the chapter on <a href="https://www.learncpp.com/cpp-tutorial/113-order-of-construction-of-derived-classes/">construction of derived classes</a>, you learned that when you create a derived class, it is composed of multiple parts: one part for each inherited class, and a part for itself.</p><p>For example, here’s a simple case:</p><pre class="language-cpp line-numbers"><code>#include <string_view></string_view></code><code></code><code>class Base</code><code>{</code><code>protected:</code><code>    int m_value {};</code><code></code><code>public:</code><code>    Base(int value)</code><code>        : m_value{ value }</code><code>    {</code><code>    }</code><code></code><code>    std::string_view getName() const { return "Base"; }</code><code>    int getValue() const { return m_value; }</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    Derived(int value)</code><code>        : Base{ value }</code><code>    {</code><code>    }</code><code></code><code>    std::string_view getName() const { return "Derived"; }</code><code>    int getValueDoubled() const { return m_value * 2; }</code><code>};</code></pre><p>When we create a Derived object, it contains a Base part (which is constructed first), and a Derived part (which is constructed second). Remember that inheritance implies an is-a relationship between two classes. Since a Derived is-a Base, it is appropriate that Derived contain a Base part.</p><p><strong>Pointers, references, and derived classes</strong></p><p>It should be fairly intuitive that we can set Derived pointers and references to Derived objects:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    Derived derived{ 5 };</code><code>    std::cout &lt;&lt; "derived is a " &lt;&lt; derived.getName() &lt;&lt; " and has value " &lt;&lt; derived.getValue() &lt;&lt; '\n';</code><code></code><code>    Derived&amp; rDerived{ derived };</code><code>    std::cout &lt;&lt; "rDerived is a " &lt;&lt; rDerived.getName() &lt;&lt; " and has value " &lt;&lt; rDerived.getValue() &lt;&lt; '\n';</code><code></code><code>    Derived* pDerived{ &amp;derived };</code><code>    std::cout &lt;&lt; "pDerived is a " &lt;&lt; pDerived-&gt;getName() &lt;&lt; " and has value " &lt;&lt; pDerived-&gt;getValue() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This produces the following output:</p><pre>derived is a Derived and has value 5
rDerived is a Derived and has value 5
pDerived is a Derived and has value 5
</pre><p>However, since Derived has a Base part, a more interesting question is whether C++ will let us set a Base pointer or reference to a Derived object. It turns out, we can!</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    Derived derived{ 5 };</code><code></code><code>    // These are both legal!</code><code>    Base&amp; rBase{ derived };</code><code>    Base* pBase{ &amp;derived };</code><code></code><code>    std::cout &lt;&lt; "derived is a " &lt;&lt; derived.getName() &lt;&lt; " and has value " &lt;&lt; derived.getValue() &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "rBase is a " &lt;&lt; rBase.getName() &lt;&lt; " and has value " &lt;&lt; rBase.getValue() &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; "pBase is a " &lt;&lt; pBase-&gt;getName() &lt;&lt; " and has value " &lt;&lt; pBase-&gt;getValue() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This produces the result:</p><pre>derived is a Derived and has value 5
rBase is a Base and has value 5
pBase is a Base and has value 5
</pre><p>This result may not be quite what you were expecting at first!</p><p>It turns out that because rBase and pBase are a Base reference and pointer, they can only see members of Base (or any classes that Base inherited). So even though Derived::getName() shadows (hides) Base::getName() for Derived objects, the Base pointer/reference can not see Derived::getName(). Consequently, they call Base::getName(), which is why rBase and pBase report that they are a Base rather than a Derived.</p><p>Note that this also means it is not possible to call Derived::getValueDoubled() using rBase or pBase. They are unable to see anything in Derived.</p><p>Here’s another slightly more complex example that we’ll build on in the next lesson:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code>#include <string></string></code><code></code><code>class Animal</code><code>{</code><code>protected:</code><code>    std::string m_name;</code><code></code><code>    // We're making this constructor protected because</code><code>    // we don't want people creating Animal objects directly,</code><code>    // but we still want derived classes to be able to use it.</code><code>    Animal(std::string_view name)</code><code>        : m_name{ name }</code><code>    {</code><code>    }</code><code>    </code><code>    // To prevent slicing (covered later)</code><code>    Animal(const Animal&amp;) = default;</code><code>    Animal&amp; operator=(const Animal&amp;) = default;</code><code></code><code>public:</code><code>    std::string_view getName() const { return m_name; }</code><code>    std::string_view speak() const { return "???"; }</code><code>};</code><code></code><code>class Cat: public Animal</code><code>{</code><code>public:</code><code>    Cat(std::string_view name)</code><code>        : Animal{ name }</code><code>    {</code><code>    }</code><code></code><code>    std::string_view speak() const { return "Meow"; }</code><code>};</code><code></code><code>class Dog: public Animal</code><code>{</code><code>public:</code><code>    Dog(std::string_view name)</code><code>        : Animal{ name }</code><code>    {</code><code>    }</code><code></code><code>    std::string_view speak() const { return "Woof"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    const Cat cat{ "Fred" };</code><code>    std::cout &lt;&lt; "cat is named " &lt;&lt; cat.getName() &lt;&lt; ", and it says " &lt;&lt; cat.speak() &lt;&lt; '\n';</code><code></code><code>    const Dog dog{ "Garbo" };</code><code>    std::cout &lt;&lt; "dog is named " &lt;&lt; dog.getName() &lt;&lt; ", and it says " &lt;&lt; dog.speak() &lt;&lt; '\n';</code><code></code><code>    const Animal* pAnimal{ &amp;cat };</code><code>    std::cout &lt;&lt; "pAnimal is named " &lt;&lt; pAnimal-&gt;getName() &lt;&lt; ", and it says " &lt;&lt; pAnimal-&gt;speak() &lt;&lt; '\n';</code><code></code><code>    pAnimal = &amp;dog;</code><code>    std::cout &lt;&lt; "pAnimal is named " &lt;&lt; pAnimal-&gt;getName() &lt;&lt; ", and it says " &lt;&lt; pAnimal-&gt;speak() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This produces the result:</p><pre>cat is named Fred, and it says Meow
dog is named Garbo, and it says Woof
pAnimal is named Fred, and it says ???
pAnimal is named Garbo, and it says ???
</pre><p>We see the same issue here. Because pAnimal is an Animal pointer, it can only see the Animal portion of the class. Consequently, <code>pAnimal-&gt;speak()</code> calls Animal::speak() rather than the Dog::Speak() or Cat::speak() function.</p><p><strong>Use for pointers and references to base classes</strong></p><p>Now you might be saying, “The above examples seem kind of silly. Why would I set a pointer or reference to the base class of a derived object when I can just use the derived object?” It turns out that there are quite a few good reasons.</p><p>First, let’s say you wanted to write a function that printed an animal’s name and sound. Without using a pointer to a base class, you’d have to write it using overloaded functions, like this:</p><pre class="language-cpp line-numbers"><code>void report(const Cat&amp; cat)</code><code>{</code><code>    std::cout &lt;&lt; cat.getName() &lt;&lt; " says " &lt;&lt; cat.speak() &lt;&lt; '\n';</code><code>}</code><code></code><code>void report(const Dog&amp; dog)</code><code>{</code><code>    std::cout &lt;&lt; dog.getName() &lt;&lt; " says " &lt;&lt; dog.speak() &lt;&lt; '\n';</code><code>}</code></pre><p>Not too difficult, but consider what would happen if we had 30 different animal types instead of 2. You’d have to write 30 almost identical functions! Plus, if you ever added a new type of animal, you’d have to write a new function for that one too. This is a huge waste of time considering the only real difference is the type of the parameter.</p><p>However, because Cat and Dog are derived from Animal, Cat and Dog have an Animal part. Therefore, it makes sense that we should be able to do something like this:</p><pre class="language-cpp line-numbers"><code>void report(const Animal&amp; rAnimal)</code><code>{</code><code>    std::cout &lt;&lt; rAnimal.getName() &lt;&lt; " says " &lt;&lt; rAnimal.speak() &lt;&lt; '\n';</code><code>}</code></pre><p>This would let us pass in any class derived from Animal, even ones that we created after we wrote the function! Instead of one function per derived class, we get one function that works with all classes derived from Animal!</p><p>The problem is, of course, that because rAnimal is an Animal reference, <code>rAnimal.speak()</code> will call Animal::speak() instead of the derived version of speak().</p><p>Second, let’s say you had 3 cats and 3 dogs that you wanted to keep in an array for easy access. Because arrays can only hold objects of one type, without a pointer or reference to a base class, you’d have to create a different array for each derived type, like this:</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <iostream></iostream></code><code></code><code>// Cat and Dog from the example above</code><code></code><code>int main()</code><code>{</code><code>    const auto&amp; cats{ std::to_array<cat>({{ "Fred" }, { "Misty" }, { "Zeke" }}) };</cat></code><code>    const auto&amp; dogs{ std::to_array<dog>({{ "Garbo" }, { "Pooky" }, { "Truffle" }}) };</dog></code><code>    </code><code>    // Before C++20</code><code>    // const std::array<cat, 3=""> cats{{ { "Fred" }, { "Misty" }, { "Zeke" } }};</cat,></code><code>    // const std::array<dog, 3=""> dogs{{ { "Garbo" }, { "Pooky" }, { "Truffle" } }};</dog,></code><code></code><code>    for (const auto&amp; cat : cats)</code><code>    {</code><code>        std::cout &lt;&lt; cat.getName() &lt;&lt; " says " &lt;&lt; cat.speak() &lt;&lt; '\n';</code><code>    }</code><code></code><code>    for (const auto&amp; dog : dogs)</code><code>    {</code><code>        std::cout &lt;&lt; dog.getName() &lt;&lt; " says " &lt;&lt; dog.speak() &lt;&lt; '\n';</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>Now, consider what would happen if you had 30 different types of animals. You’d need 30 arrays, one for each type of animal!</p><p>However, because both Cat and Dog are derived from Animal, it makes sense that we should be able to do something like this:</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <iostream></iostream></code><code></code><code>// Cat and Dog from the example above</code><code></code><code>int main()</code><code>{</code><code>    const Cat fred{ "Fred" };</code><code>    const Cat misty{ "Misty" };</code><code>    const Cat zeke{ "Zeke" };</code><code></code><code>    const Dog garbo{ "Garbo" };</code><code>    const Dog pooky{ "Pooky" };</code><code>    const Dog truffle{ "Truffle" };</code><code></code><code>    // Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects</code><code>    // Note: to_array requires C++20 support (and at the time of writing, Visual Studio 2022 still doesn't support it correctly)</code><code>    const auto animals{ std::to_array<const animal*="">({&amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke }) };</const></code><code>    </code><code>    // Before C++20, with the array size being explicitly specified</code><code>    // const std::array<const 6="" animal*,=""> animals{ &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke };</const></code><code>    </code><code>    for (const auto animal : animals)</code><code>    {</code><code>        std::cout &lt;&lt; animal-&gt;getName() &lt;&lt; " says " &lt;&lt; animal-&gt;speak() &lt;&lt; '\n';</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>While this compiles and executes, unfortunately the fact that each element of array “animals” is a pointer to an Animal means that <code>animal-&gt;speak()</code> will call Animal::speak() instead of the derived class version of speak() that we want. The output is</p><pre>Fred says ???
Garbo says ???
Misty says ???
Pooky says ???
Truffle says ???
Zeke says ???
</pre><p>Although both of these techniques could save us a lot of time and energy, they have the same problem. The pointer or reference to the base class calls the base version of the function rather than the derived version. If only there was some way to make those base pointers call the derived version of a function instead of the base version…</p><p>Want to take a guess what virtual functions are for? :)</p><p><strong>Quiz time</strong></p><ol start="1"><li>Our Animal/Cat/Dog example above doesn’t work like we want because a reference or pointer to an Animal can’t access the derived version of speak() needed to return the right value for the Cat or Dog. One way to work around this issue would be to make the data returned by the speak() function accessible as part of the Animal base class (much like the Animal’s name is accessible via member m_name).</li></ol><p>Update the Animal, Cat, and Dog classes in the lesson above by adding a new member to Animal named m_speak. Initialize it appropriately. The following program should work properly:</p><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    const Cat fred{ "Fred" };</code><code>    const Cat misty{ "Misty" };</code><code>    const Cat zeke{ "Zeke" };</code><code></code><code>    const Dog garbo{ "Garbo" };</code><code>    const Dog pooky{ "Pooky" };</code><code>    const Dog truffle{ "Truffle" };</code><code></code><code>    // Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects</code><code>    const auto animals{ std::to_array<const animal*="">({ &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke }) };</const></code><code>    </code><code>    // Before C++20, with the array size being explicitly specified</code><code>    // const std::array<const 6="" animal*,=""> animals{ &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke };</const></code><code>    </code><code>    for (const auto animal : animals)</code><code>    {</code><code>        std::cout &lt;&lt; animal-&gt;getName() &lt;&lt; " says " &lt;&lt; animal-&gt;speak() &lt;&lt; '\n';</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <array></array></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code>#include <iostream></iostream></code><code></code><code>class Animal</code><code>{</code><code>protected:</code><code>    std::string m_name;</code><code>    std::string m_speak;</code><code></code><code>    // We're making this constructor protected because</code><code>    // we don't want people creating Animal objects directly,</code><code>    // but we still want derived classes to be able to use it.</code><code>    Animal(std::string_view name, std::string_view speak)</code><code>        : m_name{ name }, m_speak{ speak }</code><code>    {</code><code>    }</code><code>    </code><code>    // To prevent slicing (covered later)</code><code>    Animal(const Animal&amp;) = delete;</code><code>    Animal&amp; operator=(const Animal&amp;) = delete;</code><code></code><code>public:</code><code>    std::string_view getName() const { return m_name; }</code><code>    std::string_view speak() const { return m_speak; }</code><code>};</code><code></code><code>class Cat: public Animal</code><code>{</code><code>public:</code><code>    Cat(std::string_view name)</code><code>        : Animal{ name, "Meow" }</code><code>    {</code><code>    }</code><code>};</code><code></code><code>class Dog: public Animal</code><code>{</code><code>public:</code><code>    Dog(std::string_view name)</code><code>        : Animal{ name, "Woof" }</code><code>    {</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    const Cat fred{ "Fred" };</code><code>    const Cat misty{ "Misty" };</code><code>    const Cat zeke{ "Zeke" };</code><code></code><code>    const Dog garbo{ "Garbo" };</code><code>    const Dog pooky{ "Pooky" };</code><code>    const Dog truffle{ "Truffle" };</code><code></code><code>    // Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects</code><code>    const auto animals{ std::to_array<const animal*="">({ &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke }) };</const></code><code>    </code><code>    // Before C++20, with the array size being explicitly specified</code><code>    // const std::array<const 6="" animal*,=""> animals{ &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke };</const></code><code>    </code><code>    // animal is not a reference, because we're looping over pointers</code><code>    for (const auto animal : animals)</code><code>    {</code><code>        std::cout &lt;&lt; animal-&gt;getName() &lt;&lt; " says " &lt;&lt; animal-&gt;speak() &lt;&lt; '\n';</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre></div><ol start="2"><li>Why is the above solution non-optimal?</li></ol><p>Hint: Think about the future state of Cat and Dog where we want to differentiate Cats and Dogs in more ways.<br>Hint: Think about the ways in which having a member that needs to be set at initialization limits you.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none">The current solution is non-optimal because we need to add a member for each way we wanted to differentiate Cat and Dog. Over time, our Animal class could become quite large memory-wise, and complicated!<p>Also, this solution only works if the base class member can be determined at initialization time. For example, if speak() returned a randomized result for each Animal (e.g. calling Dog::speak() could return “woof”, “arf”, or “yip”), this kind of solution starts to get awkward and fall apart.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">18.2 — Virtual functions and polymorphism</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson on <a href="https://www.learncpp.com/cpp-tutorial/121-pointers-and-references-to-the-base-class-of-derived-objects/">pointers and references to the base class of derived objects</a>, we took a look at a number of examples where using pointers or references to a base class had the potential to simplify code. However, in every case, we ran up against the problem that the base pointer or reference was only able to call the base version of a function, not a derived version.</p><p>Here’s a simple example of this behavior:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>class Base</code><code>{</code><code>public:</code><code>    std::string_view getName() const { return "Base"; }</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    std::string_view getName() const { return "Derived"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Derived derived;</code><code>    Base&amp; rBase{ derived };</code><code>    std::cout &lt;&lt; "rBase is a " &lt;&lt; rBase.getName() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This example prints the result:</p><pre>rBase is a Base
</pre><p>Because rBase is a Base reference, it calls Base::getName(), even though it’s actually referencing the Base portion of a Derived object.</p><p>In this lesson, we will show how to address this issue using virtual functions.</p><p><strong>Virtual functions and polymorphism</strong></p><p>A <strong>virtual function</strong> is a special type of function that, when called, resolves to the most-derived version of the function that exists between the base and derived class. This capability is known as <strong>polymorphism</strong>. A derived function is considered a match if it has the same signature (name, parameter types, and whether it is const) and return type as the base version of the function. Such functions are called <strong>overrides</strong>.</p><p>To make a function virtual, simply place the “virtual” keyword before the function declaration.</p><p>Here’s the above example with a virtual function:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>class Base</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() const { return "Base"; } // note addition of virtual keyword</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() const { return "Derived"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Derived derived;</code><code>    Base&amp; rBase{ derived };</code><code>    std::cout &lt;&lt; "rBase is a " &lt;&lt; rBase.getName() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This example prints the result:</p><pre>rBase is a Derived
</pre><p>Because rBase is a reference to the Base portion of a Derived object, when <em>rBase.getName()</em> is evaluated, it would normally resolve to Base::getName(). However, Base::getName() is virtual, which tells the program to go look and see if there are any more-derived versions of the function available between Base and Derived. In this case, it will resolve to Derived::getName()!</p><p>Let’s take a look at a slightly more complex example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>class A</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() const { return "A"; }</code><code>};</code><code></code><code>class B: public A</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() const { return "B"; }</code><code>};</code><code></code><code>class C: public B</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() const { return "C"; }</code><code>};</code><code></code><code>class D: public C</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() const { return "D"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    C c;</code><code>    A&amp; rBase{ c };</code><code>    std::cout &lt;&lt; "rBase is a " &lt;&lt; rBase.getName() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>What do you think this program will output?</p><p>Let’s look at how this works. First, we instantiate a C class object. rBase is an A reference, which we set to reference the A portion of the C object. Finally, we call rBase.getName(). rBase.getName() evaluates to A::getName(). However, A::getName() is virtual, so the compiler will call the most-derived match between A and C. In this case, that is C::getName(). Note that it will not call D::getName(), because our original object was a C, not a D, so only functions between A and C are considered.</p><p>As a result, our program outputs:</p><pre>rBase is a C
</pre><p><strong>A more complex example</strong></p><p>Let’s take another look at the Animal example we were working with in the previous lesson. Here’s the original class, along with some test code:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class Animal</code><code>{</code><code>protected:</code><code>    std::string m_name;</code><code></code><code>    // We're making this constructor protected because</code><code>    // we don't want people creating Animal objects directly,</code><code>    // but we still want derived classes to be able to use it.</code><code>    Animal(const std::string&amp; name)</code><code>        : m_name{ name }</code><code>    {</code><code>    }</code><code></code><code>public:</code><code>    const std::string&amp; getName() const { return m_name; }</code><code>    std::string_view speak() const { return "???"; }</code><code>};</code><code></code><code>class Cat: public Animal</code><code>{</code><code>public:</code><code>    Cat(const std::string&amp; name)</code><code>        : Animal{ name }</code><code>    {</code><code>    }</code><code></code><code>    std::string_view speak() const { return "Meow"; }</code><code>};</code><code></code><code>class Dog: public Animal</code><code>{</code><code>public:</code><code>    Dog(const std::string&amp; name)</code><code>        : Animal{ name }</code><code>    {</code><code>    }</code><code></code><code>    std::string_view speak() const { return "Woof"; }</code><code>};</code><code></code><code>void report(const Animal&amp; animal)</code><code>{</code><code>    std::cout &lt;&lt; animal.getName() &lt;&lt; " says " &lt;&lt; animal.speak() &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Cat cat{ "Fred" };</code><code>    Dog dog{ "Garbo" };</code><code></code><code>    report(cat);</code><code>    report(dog);</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>Fred says ???
Garbo says ???
</pre><p>Here’s the equivalent class with the speak() function made virtual:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class Animal</code><code>{</code><code>protected:</code><code>    std::string m_name;</code><code></code><code>    // We're making this constructor protected because</code><code>    // we don't want people creating Animal objects directly,</code><code>    // but we still want derived classes to be able to use it.</code><code>    Animal(const std::string&amp; name)</code><code>        : m_name{ name }</code><code>    {</code><code>    }</code><code></code><code>public:</code><code>    const std::string&amp; getName() const { return m_name; }</code><code>    virtual std::string_view speak() const { return "???"; }</code><code>};</code><code></code><code>class Cat: public Animal</code><code>{</code><code>public:</code><code>    Cat(const std::string&amp; name)</code><code>        : Animal{ name }</code><code>    {</code><code>    }</code><code></code><code>    virtual std::string_view speak() const { return "Meow"; }</code><code>};</code><code></code><code>class Dog: public Animal</code><code>{</code><code>public:</code><code>    Dog(const std::string&amp; name)</code><code>        : Animal{ name }</code><code>    {</code><code>    }</code><code></code><code>    virtual std::string_view speak() const { return "Woof"; }</code><code>};</code><code></code><code>void report(const Animal&amp; animal)</code><code>{</code><code>    std::cout &lt;&lt; animal.getName() &lt;&lt; " says " &lt;&lt; animal.speak() &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Cat cat{ "Fred" };</code><code>    Dog dog{ "Garbo" };</code><code></code><code>    report(cat);</code><code>    report(dog);</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program produces the result:</p><pre>Fred says Meow
Garbo says Woof
</pre><p>It works!</p><p>When animal.speak() is evaluated, the program notes that Animal::speak() is a virtual function. In the case where animal is referencing the Animal portion of a Cat object, the program looks at all the classes between Animal and Cat to see if it can find a more derived function. In that case, it finds Cat::speak(). In the case where animal references the Animal portion of a Dog object, the program resolves the function call to Dog::speak().</p><p>Note that we didn’t make Animal::getName() virtual. This is because getName() is never overridden in any of the derived classes, therefore there is no need.</p><p>Similarly, the following array example now works as expected:</p><pre class="language-cpp line-numbers"><code>Cat fred{ "Fred" };</code><code>Cat misty{ "Misty" };</code><code>Cat zeke{ "Zeke" };</code><code> </code><code>Dog garbo{ "Garbo" };</code><code>Dog pooky{ "Pooky" };</code><code>Dog truffle{ "Truffle" };</code><code></code><code>// Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects</code><code>Animal* animals[]{ &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke };</code><code></code><code>for (const auto* animal : animals)</code><code>    std::cout &lt;&lt; animal-&gt;getName() &lt;&lt; " says " &lt;&lt; animal-&gt;speak() &lt;&lt; '\n';</code></pre><p>Which produces the result:</p><pre>Fred says Meow
Garbo says Woof
Misty says Meow
Pooky says Woof
Truffle says Woof
Zeke says Meow
</pre><p>Even though these two examples only use Cat and Dog, any other classes we derive from Animal would also work with our report() function and animal array without further modification! This is perhaps the biggest benefit of virtual functions -- the ability to structure your code in such a way that newly derived classes will automatically work with the old code without modification!</p><p>A word of warning: the signature of the derived class function must <em>exactly</em> match the signature of the base class virtual function in order for the derived class function to be used. If the derived class function has different parameter types, the program will likely still compile fine, but the virtual function will not resolve as intended. In the next lesson, we’ll discuss how to guard against this.</p><p>Also note that if a function is marked as virtual, all matching overrides are also considered virtual, even if they are not explicitly marked as such.</p><p><strong>Return types of virtual functions</strong></p><p>Under normal circumstances, the return type of a virtual function and its override must match. Consider the following example:</p><pre class="language-cpp line-numbers"><code>class Base</code><code>{</code><code>public:</code><code>    virtual int getValue() const { return 5; }</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    virtual double getValue() const { return 6.78; }</code><code>};</code></pre><p>In this case, Derived::getValue() is not considered a matching override for Base::getValue() and compilation will fail.</p><p><strong>Do not call virtual functions from constructors or destructors</strong></p><p>Here’s another gotcha that often catches unsuspecting new programmers. You should not call virtual functions from constructors or destructors. Why?</p><p>Remember that when a Derived class is created, the Base portion is constructed first. If you were to call a virtual function from the Base constructor, and Derived portion of the class hadn’t even been created yet, it would be unable to call the Derived version of the function because there’s no Derived object for the Derived function to work on. In C++, it will call the Base version instead.</p><p>A similar issue exists for destructors. If you call a virtual function in a Base class destructor, it will always resolve to the Base class version of the function, because the Derived portion of the class will already have been destroyed.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Never call virtual functions from constructors or destructors.</p></div><p><strong>The downside of virtual functions</strong></p><p>Since most of the time you’ll want your functions to be virtual, why not just make all functions virtual? The answer is because it’s inefficient -- resolving a virtual function call takes longer than resolving a regular one. Furthermore, the compiler also has to allocate an extra pointer for each class object that has one or more virtual functions. We’ll talk about this more in future lessons in this chapter.</p><p><strong>Quiz time</strong></p><ol start="1"><li>What do the following programs print? This exercise is meant to be done by inspection, not by compiling the examples with your compiler.</li></ol><p>1a)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>class A</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() const { return "A"; }</code><code>};</code><code></code><code>class B: public A</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() const { return "B"; }</code><code>};</code><code></code><code>class C: public B</code><code>{</code><code>public:</code><code>// Note: no getName() function here</code><code>};</code><code></code><code>class D: public C</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() const { return "D"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    C c;</code><code>    A&amp; rBase{ c };</code><code>    std::cout &lt;&lt; rBase.getName() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none">B. rBase is an A reference pointing to a C object. Normally rBase.getName() would call A::getName(), but A::getName() is virtual so it instead calls the most derived matching function between A and C. That is B::getName(), which prints B.</div><p>1b)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>class A</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() const { return "A"; }</code><code>};</code><code></code><code>class B: public A</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() const { return "B"; }</code><code>};</code><code></code><code>class C: public B</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() const { return "C"; }</code><code>};</code><code></code><code>class D: public C</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() const { return "D"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    C c;</code><code>    B&amp; rBase{ c }; // note: rBase is a B this time</code><code>    std::cout &lt;&lt; rBase.getName() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none">C. This is pretty straightforward, as C::getName() is the most derived matching call between classes B and C.</div><p>1c)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>class A</code><code>{</code><code>public:</code><code>    // note: no virtual keyword</code><code>    std::string_view getName() const { return "A"; }</code><code>};</code><code></code><code>class B: public A</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() const { return "B"; }</code><code>};</code><code></code><code>class C: public B</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() const { return "C"; }</code><code>};</code><code></code><code>class D: public C</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() const { return "D"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    C c;</code><code>    A&amp; rBase{ c };</code><code>    std::cout &lt;&lt; rBase.getName() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none">A. Since A is not virtual, when rBase.getName() is called, A::getName() is called.</div><p>1d)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>class A</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() const { return "A"; }</code><code>};</code><code></code><code>class B: public A</code><code>{</code><code>public:</code><code>    // note: no virtual keyword in B, C, and D</code><code>    std::string_view getName() const { return "B"; }</code><code>};</code><code></code><code>class C: public B</code><code>{</code><code>public:</code><code>    std::string_view getName() const { return "C"; }</code><code>};</code><code></code><code>class D: public C</code><code>{</code><code>public:</code><code>    std::string_view getName() const { return "D"; } </code><code>};</code><code></code><code>int main()</code><code>{</code><code>    C c;</code><code>    B&amp; rBase{ c }; // note: rBase is a B this time</code><code>    std::cout &lt;&lt; rBase.getName() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none">C. Even though B and C aren’t marked as virtual functions, A::getName() is virtual and B::getName() and C::getName() are overrides. Therefore, B::getName() and C::getName() are considered implicitly virtual, and thus the call to rBase.getName() resolves to C::getName(), not B::getName().</div><p>1e)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>class A</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() const { return "A"; }</code><code>};</code><code></code><code>class B: public A</code><code>{</code><code>public:</code><code>    // Note: Functions in B, C, and D are non-const.</code><code>    virtual std::string_view getName() { return "B"; }</code><code>};</code><code></code><code>class C: public B</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() { return "C"; }</code><code>};</code><code></code><code>class D: public C</code><code>{</code><code>public:</code><code>    virtual std::string_view getName() { return "D"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    C c;</code><code>    A&amp; rBase{ c };</code><code>    std::cout &lt;&lt; rBase.getName() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none">A. This one is a little trickier. rBase is an A reference to a C object, so rBase.getName() would normally call A::getName(). But A::getName() is virtual, so it calls the most derived version of the function between A and C. And that is A::getName(). Because B::getName() and c::getName() are not const, they are not considered overrides! Consequently, this program prints A.</div><p>1f)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>class A</code><code>{</code><code>public:</code><code>	A() { std::cout &lt;&lt; getName(); } // note addition of constructor</code><code></code><code>	virtual std::string_view getName() const { return "A"; }</code><code>};</code><code></code><code>class B : public A</code><code>{</code><code>public:</code><code>	virtual std::string_view getName() const { return "B"; }</code><code>};</code><code></code><code>class C : public B</code><code>{</code><code>public:</code><code>	virtual std::string_view getName() const { return "C"; }</code><code>};</code><code></code><code>class D : public C</code><code>{</code><code>public:</code><code>	virtual std::string_view getName() const { return "D"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	C c;</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none">A. Another tricky one. When we create a C object, the A part is constructed first. When the A constructor is called to do this, it calls virtual function getName(). Because the B and C parts of the class aren’t set up yet, this resolves to A::getName().</div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">18.3 — The override and final specifiers, and covariant return types</h1></header><div class="entry-content" itemprop="articleBody"><p>To address some common challenges with inheritance, there are two special identifiers: override and final. Note that these identifiers are not considered keywords -- they are normal identifiers that have special meaning in certain contexts.</p><p>Although final isn’t used very much, override is a fantastic addition that you should use regularly. In this lesson, we’ll take a look at both, as well as one exception to the rule that virtual function override return types must match.</p><br><h3>The override specifier</h3><p>As we mentioned in the previous lesson, a derived class virtual function is only considered an override if its signature and return types match exactly. That can lead to inadvertent issues, where a function that was intended to be an override actually isn’t.</p><p>Consider the following example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>class A</code><code>{</code><code>public:</code><code>	virtual std::string_view getName1(int x) { return "A"; }</code><code>	virtual std::string_view getName2(int x) { return "A"; }</code><code>};</code><code></code><code>class B : public A</code><code>{</code><code>public:</code><code>	virtual std::string_view getName1(short int x) { return "B"; } // note: parameter is a short int</code><code>	virtual std::string_view getName2(int x) const { return "B"; } // note: function is const</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	B b{};</code><code>	A&amp; rBase{ b };</code><code>	std::cout &lt;&lt; rBase.getName1(1) &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; rBase.getName2(2) &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>Because rBase is an A reference to a B object, the intention here is to use virtual functions to access B::getName1() and B::getName2(). However, because B::getName1() takes a different parameter (a short int instead of an int), it’s not considered an override of A::getName1(). More insidiously, because B::getName2() is const and A::getName2() isn’t, B::getName2() isn’t considered an override of A::getName2().</p><p>Consequently, this program prints:</p><pre>A
A
</pre><p>In this particular case, because A and B just print their names, it’s fairly easy to see that we messed up our overrides, and that the wrong virtual function is being called. However, in a more complicated program, where the functions have behaviors or return values that aren’t printed, such issues can be very difficult to debug.</p><p>To help address the issue of functions that are meant to be overrides but aren’t, the override specifier can be applied to any virtual function by placing the specifier in the same place const would go. If the function does not override a base class function (or is applied to a non-virtual function), the compiler will flag the function as an error.</p><pre class="language-cpp line-numbers"><code>#include <string_view></string_view></code><code></code><code>class A</code><code>{</code><code>public:</code><code>	virtual std::string_view getName1(int x) { return "A"; }</code><code>	virtual std::string_view getName2(int x) { return "A"; }</code><code>	virtual std::string_view getName3(int x) { return "A"; }</code><code>};</code><code></code><code>class B : public A</code><code>{</code><code>public:</code><code>	std::string_view getName1(short int x) override { return "B"; } // compile error, function is not an override</code><code>	std::string_view getName2(int x) const override { return "B"; } // compile error, function is not an override</code><code>	std::string_view getName3(int x) override { return "B"; } // okay, function is an override of A::getName3(int)</code><code></code><code>};</code><code></code><code>int main()</code><code>{</code><code>	return 0;</code><code>}</code></pre><p>The above program produces two compile errors: one for B::getName1(), and one for B::getName2(), because neither override a prior function. B::getName3() does override A::getName3(), so no error is produced for that line.</p><p>Because there is no performance penalty for using the override specifier and it helps ensure you’ve actually overridden the function you think you have, all virtual override functions should be tagged using the override specifier. Additionally, because the override specifier implies virtual, there’s no need to tag functions using the override specifier with the virtual keyword.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use the virtual keyword on virtual functions in a base class. Use the override specifier (but not the virtual keyword) on override functions in derived classes.</p></div><br><h3>The final specifier</h3><p>There may be cases where you don’t want someone to be able to override a virtual function, or inherit from a class. The final specifier can be used to tell the compiler to enforce this. If the user tries to override a function or inherit from a class that has been specified as final, the compiler will give a compile error.</p><p>In the case where we want to restrict the user from overriding a function, the <strong>final specifier</strong> is used in the same place the override specifier is, like so:</p><pre class="language-cpp line-numbers"><code>#include <string_view></string_view></code><code></code><code>class A</code><code>{</code><code>public:</code><code>	virtual std::string_view getName() { return "A"; }</code><code>};</code><code></code><code>class B : public A</code><code>{</code><code>public:</code><code>	// note use of final specifier on following line -- that makes this function no longer overridable</code><code>	std::string_view getName() override final { return "B"; } // okay, overrides A::getName()</code><code>};</code><code></code><code>class C : public B</code><code>{</code><code>public:</code><code>	std::string_view getName() override { return "C"; } // compile error: overrides B::getName(), which is final</code><code>};</code></pre><p>In the above code, B::getName() overrides A::getName(), which is fine. But B::getName() has the final specifier, which means that any further overrides of that function should be considered an error. And indeed, C::getName() tries to override B::getName() (the override specifier here isn’t relevant, it’s just there for good practice), so the compiler will give a compile error.</p><p>In the case where we want to prevent inheriting from a class, the final specifier is applied after the class name:</p><pre class="language-cpp line-numbers"><code>#include <string_view></string_view></code><code></code><code>class A</code><code>{</code><code>public:</code><code>	virtual std::string_view getName() { return "A"; }</code><code>};</code><code></code><code>class B final : public A // note use of final specifier here</code><code>{</code><code>public:</code><code>	std::string_view getName() override { return "B"; }</code><code>};</code><code></code><code>class C : public B // compile error: cannot inherit from final class</code><code>{</code><code>public:</code><code>	std::string_view getName() override { return "C"; }</code><code>};</code></pre><p>In the above example, class B is declared final. Thus, when C tries to inherit from B, the compiler will give a compile error.</p><br><h3>Covariant return types</h3><p>There is one special case in which a derived class virtual function override can have a different return type than the base class and still be considered a matching override. If the return type of a virtual function is a pointer or a reference to some class, override functions can return a pointer or a reference to a derived class. These are called <strong>covariant return types</strong>. Here is an example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string_view></string_view></code><code></code><code>class Base</code><code>{</code><code>public:</code><code>	// This version of getThis() returns a pointer to a Base class</code><code>	virtual Base* getThis() { std::cout &lt;&lt; "called Base::getThis()\n"; return this; }</code><code>	void printType() { std::cout &lt;&lt; "returned a Base\n"; }</code><code>};</code><code></code><code>class Derived : public Base</code><code>{</code><code>public:</code><code>	// Normally override functions have to return objects of the same type as the base function</code><code>	// However, because Derived is derived from Base, it's okay to return Derived* instead of Base*</code><code>	Derived* getThis() override { std::cout &lt;&lt; "called Derived::getThis()\n";  return this; }</code><code>	void printType() { std::cout &lt;&lt; "returned a Derived\n"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Derived d{};</code><code>	Base* b{ &amp;d };</code><code>	d.getThis()-&gt;printType(); // calls Derived::getThis(), returns a Derived*, calls Derived::printType</code><code>	b-&gt;getThis()-&gt;printType(); // calls Derived::getThis(), returns a Base*, calls Base::printType</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>called Derived::getThis()
returned a Derived
called Derived::getThis()
returned a Base
</pre><p>One interesting note about covariant return types: C++ can’t dynamically select types, so you’ll always get the type that matches the actual version of the function being called.</p><p>In the above example, we first call d.getThis(). Since d is a Derived, this calls Derived::getThis(), which returns a Derived*. This Derived* is then used to call non-virtual function Derived::printType().</p><p>Now the interesting case. We then call b-&gt;getThis(). Variable b is a Base pointer to a Derived object. Base::getThis() is a virtual function, so this calls Derived::getThis(). Although Derived::getThis() returns a Derived*, because Base version of the function returns a Base*, the returned Derived* is upcast to a Base*. Because Base::printType() is non-virtual, Base::printType() is called.</p><p>In other words, in the above example, you only get a Derived* if you call getThis() with an object that is typed as a Derived object in the first place.</p><p>Note that if printType() were virtual instead of non-virtual, the result of b-&gt;getThis() (an object of type Base*) would have undergone virtual function resolution, and Derived::printType() would have been called.</p><p>Covariant return types are often used in cases where a virtual member function returns a pointer or reference to the class containing the member function (e.g. Base::getThis() returns a Base*, and Derived::getThis() returns a Derived*). However, this isn’t strictly necessary. Covariant return types can be used in any case where the return type of the override member function is derived from the return type of the base virtual member function.</p><br><h3>Quiz time</h3><p class="cpp-quiz-question" style="clear:both">Question #1</p><p>What does the following program output?</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class A</code><code>{</code><code>public:</code><code>    void print()</code><code>    {</code><code>        std::cout &lt;&lt; "A";</code><code>    }</code><code>    virtual void vprint()</code><code>    {</code><code>        std::cout &lt;&lt; "A";</code><code>    }</code><code>};</code><code>class B : public A</code><code>{</code><code>public:</code><code>    void print()</code><code>    {</code><code>        std::cout &lt;&lt; "B";</code><code>    }</code><code>    void vprint() override</code><code>    {</code><code>        std::cout &lt;&lt; "B";</code><code>    }</code><code>};</code><code></code><code></code><code>class C</code><code>{</code><code>private:</code><code>    A m_a{};</code><code></code><code>public:</code><code>    virtual A&amp; get()</code><code>    {</code><code>        return m_a;</code><code>    }</code><code>};</code><code></code><code>class D : public C</code><code>{</code><code>private:</code><code>    B m_b{};</code><code></code><code>public:</code><code>    B&amp; get() override</code><code>    {</code><code>        return m_b;</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    // case 1</code><code>    D d;</code><code>    d.get().print();</code><code>    d.get().vprint();</code><code>    std::cout &lt;&lt; '\n';</code><code> </code><code>    // case 2</code><code>    C c;</code><code>    c.get().print();</code><code>    c.get().vprint();</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    // case 3</code><code>    C&amp; ref{ d };</code><code>    ref.get().print();</code><code>    ref.get().vprint();</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre>BB
AA
AB
</pre><p>In all cases, because <code>get()</code> has a covariant return type, the return type of <code>get()</code> will be the return type of the <code>get()</code> member function of the implicit object.</p><p>Case 1 is straightforward. In both statements, <code>d.get()</code> calls <code>D::get()</code>, which returns <code>m_b</code>. Because <code>get()</code> is being called on <code>d</code>, which is of type <code>D</code>, the return type of <code>D::get()</code> is used, which is type <code>B&amp;</code>. The calls to <code>print()</code> and <code>vprint()</code> resolve to <code>B::print()</code> and <code>B::vprint()</code> respectively.</p><p>Case 2 is also straightforward. In both statements, <code>c.get()</code> calls <code>C::get()</code>, which returns <code>m_a</code>. Because <code>get()</code> is being called on <code>c</code>, which is of type <code>C</code>, the return type of <code>C::get()</code> is used, which is type <code>A&amp;</code>. The calls to <code>print()</code> and <code>vprint()</code> resolve to <code>A::print()</code> and <code>A::vprint()</code> respectively.</p><p>Case 3 is the interesting one. <code>ref</code> is a <code>C&amp;</code> referencing a <code>D</code>. <code>ref.get()</code> is a virtual function, so <code>ref.get()</code> virtually resolves to <code>D::get()</code>, which returns <code>m_b</code>. However, <code>get()</code> has a covariant return type, so the return type of <code>get()</code> is determined by the type of the implicit object that <code>get()</code> is called on. Since <code>ref</code> is a <code>C&amp;</code>, the return type of <code>C::get()</code> is used, which means the return type of <code>ref.get()</code> is <code>A&amp;</code> (referencing object <code>m_b</code>, which is a <code>B</code>).</p><p>Because the return type of <code>ref.get()</code> is an <code>A&amp;</code>, non-virtual function call <code>ref.get().print()</code> resolves to <code>A::print()</code>.</p><p>When virtual function <code>ref.get().vprint()</code> is called, virtual function resolution is used. Although the return type of <code>ref.get()</code> is an <code>A&amp;</code>, the object being reference is actually a <code>B</code>. Therefore, <code>B::vprint()</code> is called.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">18.4 — Virtual destructors, virtual assignment, and overriding virtualization</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>Virtual destructors</strong></p><p>Although C++ provides a default destructor for your classes if you do not provide one yourself, it is sometimes the case that you will want to provide your own destructor (particularly if the class needs to deallocate memory). You should <strong>always</strong> make your destructors virtual if you’re dealing with inheritance. Consider the following example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>class Base</code><code>{</code><code>public:</code><code>    ~Base() // note: not virtual</code><code>    {</code><code>        std::cout &lt;&lt; "Calling ~Base()\n";</code><code>    }</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>private:</code><code>    int* m_array;</code><code></code><code>public:</code><code>    Derived(int length)</code><code>      : m_array{ new int[length] }</code><code>    {</code><code>    }</code><code></code><code>    ~Derived() // note: not virtual (your compiler may warn you about this)</code><code>    {</code><code>        std::cout &lt;&lt; "Calling ~Derived()\n";</code><code>        delete[] m_array;</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Derived* derived { new Derived(5) };</code><code>    Base* base { derived };</code><code></code><code>    delete base;</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note: If you compile the above example, your compiler may warn you about the non-virtual destructor (which is intentional for this example). You may need to disable the compiler flag that treats warnings as errors to proceed.</p><p>Because base is a Base pointer, when base is deleted, the program looks to see if the Base destructor is virtual. It’s not, so it assumes it only needs to call the Base destructor. We can see this in the fact that the above example prints:</p><pre>Calling ~Base()
</pre><p>However, we really want the delete function to call Derived’s destructor (which will call Base’s destructor in turn), otherwise m_array will not be deleted. We do this by making Base’s destructor virtual:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>class Base</code><code>{</code><code>public:</code><code>    virtual ~Base() // note: virtual</code><code>    {</code><code>        std::cout &lt;&lt; "Calling ~Base()\n";</code><code>    }</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>private:</code><code>    int* m_array;</code><code></code><code>public:</code><code>    Derived(int length)</code><code>      : m_array{ new int[length] }</code><code>    {</code><code>    }</code><code></code><code>    virtual ~Derived() // note: virtual</code><code>    {</code><code>        std::cout &lt;&lt; "Calling ~Derived()\n";</code><code>        delete[] m_array;</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Derived* derived { new Derived(5) };</code><code>    Base* base { derived };</code><code></code><code>    delete base;</code><code></code><code>    return 0;</code><code>}</code></pre><p>Now this program produces the following result:</p><pre>Calling ~Derived()
Calling ~Base()
</pre><div class="cpp-note cpp-lightgreenbackground"><h4>Rule</h4><p>Whenever you are dealing with inheritance, you should make any explicit destructors virtual.</p></div><p>As with normal virtual member functions, if a base class function is virtual, all derived overrides will be considered virtual regardless of whether they are specified as such. It is not necessary to create an empty derived class destructor just to mark it as virtual.</p><p>Note that if you want your base class to have a virtual destructor that is otherwise empty, you can define your destructor this way:</p><pre class="language-cpp line-numbers"><code>    virtual ~Base() = default; // generate a virtual default destructor</code></pre><p><strong>Virtual assignment</strong></p><p>It is possible to make the assignment operator virtual. However, unlike the destructor case where virtualization is always a good idea, virtualizing the assignment operator really opens up a bag full of worms and gets into some advanced topics outside of the scope of this tutorial. Consequently, we are going to recommend you leave your assignments non-virtual for now, in the interest of simplicity.</p><p><strong>Ignoring virtualization</strong></p><p>Very rarely you may want to ignore the virtualization of a function. For example, consider the following code:</p><pre class="language-cpp line-numbers"><code>class Base</code><code>{</code><code>public:</code><code>    virtual ~Base() = default;</code><code>    virtual const char* getName() const { return "Base"; }</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    virtual const char* getName() const { return "Derived"; }</code><code>};</code></pre><p>There may be cases where you want a Base pointer to a Derived object to call Base::getName() instead of Derived::getName(). To do so, simply use the scope resolution operator:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>int main()</code><code>{</code><code>    Derived derived;</code><code>    const Base&amp; base { derived };</code><code>    // Calls Base::getName() instead of the virtualized Derived::getName()</code><code>    std::cout &lt;&lt; base.Base::getName() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>You probably won’t use this very often, but it’s good to know it’s at least possible.</p><p><strong>Should we make all destructors virtual?</strong></p><p>This is a common question asked by new programmers. As noted in the top example, if the base class destructor isn’t marked as virtual, then the program is at risk for leaking memory if a programmer later deletes a base class pointer that is pointing to a derived object. One way to avoid this is to mark all your destructors as virtual. But should you?</p><p>It’s easy to say yes, so that way you can later use any class as a base class -- but there’s a performance penalty for doing so (a virtual pointer added to every instance of your class). So you have to balance that cost, as well as your intent.</p><p>Conventional wisdom (as initially put forth by Herb Sutter, a highly regarded C++ guru) has suggested avoiding the non-virtual destructor memory leak situation as follows, “A base class destructor should be either public and virtual, or protected and nonvirtual.” A class with a protected destructor can’t be deleted via a pointer, thus preventing the accidental deleting of a derived class through a base pointer when the base class has a non-virtual destructor. Unfortunately, this also means the base class can’t be deleted through a base class pointer, which essentially means the class can’t be dynamically allocated or deleted except by a derived class. This also precludes using smart pointers (such as std::unique_ptr and std::shared_ptr) for such classes, which limits the usefulness of that rule (we cover smart pointers in a later chapter). It also means the base class can’t be allocated on the stack. That’s a pretty heavy set of penalties.</p><p>Now that the final specifier has been introduced into the language, our recommendations are as follows:</p><ul><li>If you intend your class to be inherited from, make sure your destructor is virtual.</li><li>If you do not intend your class to be inherited from, mark your class as final. This will prevent other classes from inheriting from it in the first place, without imposing any other use restrictions on the class itself.</li></ul></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">18.5 — Early binding and late binding</h1></header><div class="entry-content" itemprop="articleBody"><p>In this lesson and the next, we are going to take a closer look at how virtual functions are implemented. While this information is not strictly necessary to effectively use virtual functions, it is interesting. Nevertheless, you can consider both sections optional reading.</p><p>When a C++ program is executed, it executes sequentially, beginning at the top of main(). When a function call is encountered, the point of execution jumps to the beginning of the function being called. How does the CPU know to do this?</p><p>When a program is compiled, the compiler converts each statement in your C++ program into one or more lines of machine language. Each line of machine language is given its own unique sequential address. This is no different for functions -- when a function is encountered, it is converted into machine language and given the next available address. Thus, each function ends up with a unique address.</p><p><strong>Binding</strong> refers to the process that is used to convert identifiers (such as variable and function names) into addresses. Although binding is used for both variables and functions, in this lesson we’re going to focus on function binding.</p><p><strong>Early binding</strong></p><p>Most of the function calls the compiler encounters will be direct function calls. A direct function call is a statement that directly calls a function. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void printValue(int value)</code><code>{</code><code>    std::cout &lt;&lt; value;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    printValue(5); // This is a direct function call</code><code>    return 0;</code><code>}</code></pre><p>Direct function calls can be resolved using a process known as early binding. <strong>Early binding</strong> (also called static binding) means the compiler (or linker) is able to directly associate the identifier name (such as a function or variable name) with a machine address. Remember that all functions have a unique address. So when the compiler (or linker) encounters a function call, it replaces the function call with a machine language instruction that tells the CPU to jump to the address of the function.</p><p>Let’s take a look at a simple calculator program that uses early binding:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code><code></code><code>int subtract(int x, int y)</code><code>{</code><code>    return x - y;</code><code>}</code><code></code><code>int multiply(int x, int y)</code><code>{</code><code>    return x * y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x{};</code><code>    std::cout &lt;&lt; "Enter a number: ";</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    int y{};</code><code>    std::cout &lt;&lt; "Enter another number: ";</code><code>    std::cin &gt;&gt; y;</code><code></code><code>    int op{};</code><code>    do</code><code>    {</code><code>        std::cout &lt;&lt; "Enter an operation (0=add, 1=subtract, 2=multiply): ";</code><code>        std::cin &gt;&gt; op;</code><code>    } while (op &lt; 0 || op &gt; 2);</code><code></code><code>    int result {};</code><code>    switch (op)</code><code>    {</code><code>        // call the target function directly using early binding</code><code>        case 0: result = add(x, y); break;</code><code>        case 1: result = subtract(x, y); break;</code><code>        case 2: result = multiply(x, y); break;</code><code>    }</code><code></code><code>    std::cout &lt;&lt; "The answer is: " &lt;&lt; result &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because add(), subtract(), and multiply() are all direct function calls, the compiler will use early binding to resolve the add(), subtract(), and multiply() function calls. The compiler will replace the add() function call with an instruction that tells the CPU to jump to the address of the add() function. The same holds true for subtract() and multiply().</p><p><strong>Late Binding</strong></p><p>In some programs, it is not possible to know which function will be called until runtime (when the program is run). This is known as <strong>late binding</strong> (or dynamic binding). In C++, one way to get late binding is to use function pointers. To review function pointers briefly, a function pointer is a type of pointer that points to a function instead of a variable. The function that a function pointer points to can be called by using the function call operator (()) on the pointer.</p><p>For example, the following code calls the add() function:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    // Create a function pointer and make it point to the add function</code><code>    int (*pFcn)(int, int) { add };</code><code>    std::cout &lt;&lt; pFcn(5, 3) &lt;&lt; '\n'; // add 5 + 3</code><code></code><code>    return 0;</code><code>}</code></pre><p>Calling a function via a function pointer is also known as an indirect function call. The following calculator program is functionally identical to the calculator example above, except it uses a function pointer instead of a direct function call:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int add(int x, int y)</code><code>{</code><code>    return x + y;</code><code>}</code><code></code><code>int subtract(int x, int y)</code><code>{</code><code>    return x - y;</code><code>}</code><code></code><code>int multiply(int x, int y)</code><code>{</code><code>    return x * y;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    int x{};</code><code>    std::cout &lt;&lt; "Enter a number: ";</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    int y{};</code><code>    std::cout &lt;&lt; "Enter another number: ";</code><code>    std::cin &gt;&gt; y;</code><code></code><code>    int op{};</code><code>    do</code><code>    {</code><code>        std::cout &lt;&lt; "Enter an operation (0=add, 1=subtract, 2=multiply): ";</code><code>        std::cin &gt;&gt; op;</code><code>    } while (op &lt; 0 || op &gt; 2);</code><code></code><code>    // Create a function pointer named pFcn (yes, the syntax is ugly)</code><code>    int (*pFcn)(int, int) { nullptr };</code><code></code><code>    // Set pFcn to point to the function the user chose</code><code>    switch (op)</code><code>    {</code><code>        case 0: pFcn = add; break;</code><code>        case 1: pFcn = subtract; break;</code><code>        case 2: pFcn = multiply; break;</code><code>    }</code><code></code><code>    // Call the function that pFcn is pointing to with x and y as parameters</code><code>    // This uses late binding</code><code>    std::cout &lt;&lt; "The answer is: " &lt;&lt; pFcn(x, y) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this example, instead of calling the add(), subtract(), or multiply() function directly, we’ve instead set pFcn to point at the function we wish to call. Then we call the function through the pointer. The compiler is unable to use early binding to resolve the function call <code>pFcn(x, y)</code> because it can not tell which function pFcn will be pointing to at compile time!</p><p>Late binding is slightly less efficient since it involves an extra level of indirection. With early binding, the CPU can jump directly to the function’s address. With late binding, the program has to read the address held in the pointer and then jump to that address. This involves one extra step, making it slightly slower. However, the advantage of late binding is that it is more flexible than early binding, because decisions about what function to call do not need to be made until run time.</p><p>In the next lesson, we’ll take a look at how late binding is used to implement virtual functions.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">18.6 — The virtual table</h1></header><div class="entry-content" itemprop="articleBody"><p>To implement virtual functions, C++ uses a special form of late binding known as the virtual table. The <strong>virtual table</strong> is a lookup table of functions used to resolve function calls in a dynamic/late binding manner. The virtual table sometimes goes by other names, such as “vtable”, “virtual function table”, “virtual method table”, or “dispatch table”.</p><p>Because knowing how the virtual table works is not necessary to use virtual functions, this section can be considered optional reading.</p><p>The virtual table is actually quite simple, though it’s a little complex to describe in words. First, every class that uses virtual functions (or is derived from a class that uses virtual functions) is given its own virtual table. This table is simply a static array that the compiler sets up at compile time. A virtual table contains one entry for each virtual function that can be called by objects of the class. Each entry in this table is simply a function pointer that points to the most-derived function accessible by that class.</p><p>Second, the compiler also adds a hidden pointer that is a member of the base class, which we will call *__vptr. *__vptr is set (automatically) when a class object is created so that it points to the virtual table for that class. Unlike the *this pointer, which is actually a function parameter used by the compiler to resolve self-references, *__vptr is a real pointer. Consequently, it makes each class object allocated bigger by the size of one pointer. It also means that *__vptr is inherited by derived classes, which is important.</p><p>By now, you’re probably confused as to how these things all fit together, so let’s take a look at a simple example:</p><pre class="language-cpp line-numbers"><code>class Base</code><code>{</code><code>public:</code><code>    virtual void function1() {};</code><code>    virtual void function2() {};</code><code>};</code><code></code><code>class D1: public Base</code><code>{</code><code>public:</code><code>    void function1() override {};</code><code>};</code><code></code><code>class D2: public Base</code><code>{</code><code>public:</code><code>    void function2() override {};</code><code>};</code></pre><p>Because there are 3 classes here, the compiler will set up 3 virtual tables: one for Base, one for D1, and one for D2.</p><p>The compiler also adds a hidden pointer member to the most base class that uses virtual functions. Although the compiler does this automatically, we’ll put it in the next example just to show where it’s added:</p><pre class="language-cpp line-numbers"><code>class Base</code><code>{</code><code>public:</code><code>    VirtualTable* __vptr;</code><code>    virtual void function1() {};</code><code>    virtual void function2() {};</code><code>};</code><code></code><code>class D1: public Base</code><code>{</code><code>public:</code><code>    void function1() override {};</code><code>};</code><code></code><code>class D2: public Base</code><code>{</code><code>public:</code><code>    void function2() override {};</code><code>};</code></pre><p>When a class object is created, *__vptr is set to point to the virtual table for that class. For example, when an object of type Base is created, *__vptr is set to point to the virtual table for Base. When objects of type D1 or D2 are constructed, *__vptr is set to point to the virtual table for D1 or D2 respectively.</p><p>Now, let’s talk about how these virtual tables are filled out. Because there are only two virtual functions here, each virtual table will have two entries (one for function1() and one for function2()). Remember that when these virtual tables are filled out, each entry is filled out with the most-derived function an object of that class type can call.</p><p>The virtual table for Base objects is simple. An object of type Base can only access the members of Base. Base has no access to D1 or D2 functions. Consequently, the entry for function1 points to Base::function1() and the entry for function2 points to Base::function2().</p><p>The virtual table for D1 is slightly more complex. An object of type D1 can access members of both D1 and Base. However, D1 has overridden function1(), making D1::function1() more derived than Base::function1(). Consequently, the entry for function1 points to D1::function1(). D1 hasn’t overridden function2(), so the entry for function2 will point to Base::function2().</p><p>The virtual table for D2 is similar to D1, except the entry for function1 points to Base::function1(), and the entry for function2 points to D2::function2().</p><p>Here’s a picture of this graphically:</p><p><img src="https://www.learncpp.com/images/CppTutorial/Section12/VTable.gif" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Section12/VTable.gif"></p><p>Although this diagram is kind of crazy looking, it’s really quite simple: the *__vptr in each class points to the virtual table for that class. The entries in the virtual table point to the most-derived version of the function that objects of that class are allowed to call.</p><p>So consider what happens when we create an object of type D1:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    D1 d1;</code><code>}</code></pre><p>Because d1 is a D1 object, d1 has its *__vptr set to the D1 virtual table.</p><p>Now, let’s set a base pointer to D1:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    D1 d1;</code><code>    Base* dPtr = &amp;d1;</code><code></code><code>    return 0;</code><code>}</code></pre><p>Note that because dPtr is a base pointer, it only points to the Base portion of d1. However, also note that *__vptr is in the Base portion of the class, so dPtr has access to this pointer. Finally, note that dPtr-&gt;__vptr points to the D1 virtual table! Consequently, even though dPtr is of type Base, it still has access to D1’s virtual table (through __vptr).</p><p>So what happens when we try to call dPtr-&gt;function1()?</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    D1 d1;</code><code>    Base* dPtr = &amp;d1;</code><code>    dPtr-&gt;function1();</code><code></code><code>    return 0;</code><code>}</code></pre><p>First, the program recognizes that function1() is a virtual function. Second, the program uses dPtr-&gt;__vptr to get to D1’s virtual table. Third, it looks up which version of function1() to call in D1’s virtual table. This has been set to D1::function1(). Therefore, dPtr-&gt;function1() resolves to D1::function1()!</p><p>Now, you might be saying, “But what if dPtr really pointed to a Base object instead of a D1 object. Would it still call D1::function1()?”. The answer is no.</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Base b;</code><code>    Base* bPtr = &amp;b;</code><code>    bPtr-&gt;function1();</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this case, when b is created, __vptr points to Base’s virtual table, not D1’s virtual table. Consequently, bPtr-&gt;__vptr will also be pointing to Base’s virtual table. Base’s virtual table entry for function1() points to Base::function1(). Thus, bPtr-&gt;function1() resolves to Base::function1(), which is the most-derived version of function1() that a Base object should be able to call.</p><p>By using these tables, the compiler and program are able to ensure function calls resolve to the appropriate virtual function, even if you’re only using a pointer or reference to a base class!</p><p>Calling a virtual function is slower than calling a non-virtual function for a couple of reasons: First, we have to use the *__vptr to get to the appropriate virtual table. Second, we have to index the virtual table to find the correct function to call. Only then can we call the function. As a result, we have to do 3 operations to find the function to call, as opposed to 2 operations for a normal indirect function call, or one operation for a direct function call. However, with modern computers, this added time is usually fairly insignificant.</p><p>Also as a reminder, any class that uses virtual functions has a *__vptr, and thus each object of that class will be bigger by one pointer. Virtual functions are powerful, but they do have a performance cost.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">18.7 — Pure virtual functions, abstract base classes, and interface classes</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>Pure virtual (abstract) functions and abstract base classes</strong></p><p>So far, all of the virtual functions we have written have a body (a definition). However, C++ allows you to create a special kind of virtual function called a <strong>pure virtual function</strong> (or <strong>abstract function</strong>) that has no body at all! A pure virtual function simply acts as a placeholder that is meant to be redefined by derived classes.</p><p>To create a pure virtual function, rather than define a body for the function, we simply assign the function the value 0.</p><pre class="language-cpp line-numbers"><code>class Base</code><code>{</code><code>public:</code><code>    const char* sayHi() const { return "Hi"; } // a normal non-virtual function    </code><code></code><code>    virtual const char* getName() const { return "Base"; } // a normal virtual function</code><code></code><code>    virtual int getValue() const = 0; // a pure virtual function</code><code></code><code>    int doSomething() = 0; // Compile error: can not set non-virtual functions to 0</code><code>};</code></pre><p>When we add a pure virtual function to our class, we are effectively saying, “it is up to the derived classes to implement this function”.</p><p>Using a pure virtual function has two main consequences: First, any class with one or more pure virtual functions becomes an <strong>abstract base class</strong>, which means that it can not be instantiated! Consider what would happen if we could create an instance of Base:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Base base; // We can't instantiate an abstract base class, but for the sake of example, pretend this was allowed</code><code>    base.getValue(); // what would this do?</code><code></code><code>    return 0;</code><code>}</code></pre><p>Because there’s no definition for getValue(), what would base.getValue() resolve to?</p><p>Second, any derived class must define a body for this function, or that derived class will be considered an abstract base class as well.</p><p><strong>A pure virtual function example</strong></p><p>Let’s take a look at an example of a pure virtual function in action. In a previous lesson, we wrote a simple Animal base class and derived a Cat and a Dog class from it. Here’s the code as we left it:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>class Animal</code><code>{</code><code>protected:</code><code>    std::string m_name;</code><code></code><code>    // We're making this constructor protected because</code><code>    // we don't want people creating Animal objects directly,</code><code>    // but we still want derived classes to be able to use it.</code><code>    Animal(const std::string&amp; name)</code><code>        : m_name{ name }</code><code>    {</code><code>    }</code><code></code><code>public:</code><code>    std::string getName() const { return m_name; }</code><code>    virtual const char* speak() const { return "???"; }</code><code>    </code><code>    virtual ~Animal() = default;</code><code>};</code><code></code><code>class Cat: public Animal</code><code>{</code><code>public:</code><code>    Cat(const std::string&amp; name)</code><code>        : Animal{ name }</code><code>    {</code><code>    }</code><code></code><code>    const char* speak() const override { return "Meow"; }</code><code>};</code><code></code><code>class Dog: public Animal</code><code>{</code><code>public:</code><code>    Dog(const std::string&amp; name)</code><code>        : Animal{ name }</code><code>    {</code><code>    }</code><code></code><code>    const char* speak() const override { return "Woof"; }</code><code>};</code></pre><p>We’ve prevented people from allocating objects of type Animal by making the constructor protected. However, it is still possible to create derived classes that do not redefine function speak().</p><p>For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>class Cow : public Animal</code><code>{</code><code>public:</code><code>    Cow(const std::string&amp; name)</code><code>        : Animal{ name }</code><code>    {</code><code>    }</code><code></code><code>    // We forgot to redefine speak</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Cow cow{"Betsy"};</code><code>    std::cout &lt;&lt; cow.getName() &lt;&lt; " says " &lt;&lt; cow.speak() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This will print:</p><pre>Betsy says ???
</pre><p>What happened? We forgot to redefine function speak(), so cow.Speak() resolved to Animal.speak(), which isn’t what we wanted.</p><p>A better solution to this problem is to use a pure virtual function:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>class Animal // This Animal is an abstract base class</code><code>{</code><code>protected:</code><code>    std::string m_name;</code><code></code><code>public:</code><code>    Animal(const std::string&amp; name)</code><code>        : m_name{ name }</code><code>    {</code><code>    }</code><code></code><code>    const std::string&amp; getName() const { return m_name; }</code><code>    virtual const char* speak() const = 0; // note that speak is now a pure virtual function</code><code>    </code><code>    virtual ~Animal() = default;</code><code>};</code></pre><p>There are a couple of things to note here. First, speak() is now a pure virtual function. This means Animal is now an abstract base class, and can not be instantiated. Consequently, we do not need to make the constructor protected any longer (though it doesn’t hurt). Second, because our Cow class was derived from Animal, but we did not define Cow::speak(), Cow is also an abstract base class. Now when we try to compile this code:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Cow: public Animal</code><code>{</code><code>public:</code><code>    Cow(const std::string&amp; name)</code><code>        : Animal{ name }</code><code>    {</code><code>    }</code><code></code><code>    // We forgot to redefine speak</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Cow cow{ "Betsy" };</code><code>    std::cout &lt;&lt; cow.getName() &lt;&lt; " says " &lt;&lt; cow.speak() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>The compiler will give us a warning because Cow is an abstract base class and we can not create instances of abstract base classes (Line numbers are wrong, because the Animal class was omitted from the above example):</p><pre>&lt;source&gt;(33): error C2259: 'Cow': cannot instantiate abstract class
&lt;source&gt;(20): note: see declaration of 'Cow'
&lt;source&gt;(33): note: due to following members:
&lt;source&gt;(33): note: 'const char *Animal::speak(void) const': is abstract
&lt;source&gt;(15): note: see declaration of 'Animal::speak'
</pre><p>This tells us that we will only be able to instantiate Cow if Cow provides a body for speak().</p><p>Let’s go ahead and do that:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>class Animal // This Animal is an abstract base class</code><code>{</code><code>protected:</code><code>    std::string m_name;</code><code></code><code>public:</code><code>    Animal(const std::string&amp; name)</code><code>        : m_name{ name }</code><code>    {</code><code>    }</code><code></code><code>    const std::string&amp; getName() const { return m_name; }</code><code>    virtual const char* speak() const = 0; // note that speak is now a pure virtual function</code><code>    </code><code>    virtual ~Animal() = default;</code><code>};</code><code></code><code>class Cow: public Animal</code><code>{</code><code>public:</code><code>    Cow(const std::string&amp; name)</code><code>        : Animal(name)</code><code>    {</code><code>    }</code><code></code><code>    const char* speak() const override { return "Moo"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Cow cow{ "Betsy" };</code><code>    std::cout &lt;&lt; cow.getName() &lt;&lt; " says " &lt;&lt; cow.speak() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Now this program will compile and print:</p><pre>Betsy says Moo
</pre><p>A pure virtual function is useful when we have a function that we want to put in the base class, but only the derived classes know what it should return. A pure virtual function makes it so the base class can not be instantiated, and the derived classes are forced to define these functions before they can be instantiated. This helps ensure the derived classes do not forget to redefine functions that the base class was expecting them to.</p><p>Just like with normal virtual functions, pure virtual functions can be called using a reference (or pointer) to a base class:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Cow cow{ "Betsy" };</code><code>    Animal&amp; a{ cow };</code><code></code><code>    std::cout &lt;&lt; a.speak(); // resolves to Cow::speak(), prints "Moo"</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above example, <code>a.speak()</code> resolves to <code>Cow::speak()</code> via virtual function resolution.</p><p>Since classes with pure virtual functions have a virtual function, don’t forget to make your destructor virtual too.</p><p><strong>Pure virtual functions with definitions</strong></p><p>It turns out that we can create pure virtual functions that have definitions:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code></code><code>class Animal // This Animal is an abstract base class</code><code>{</code><code>protected:</code><code>    std::string m_name;</code><code></code><code>public:</code><code>    Animal(const std::string&amp; name)</code><code>        : m_name{ name }</code><code>    {</code><code>    }</code><code></code><code>    std::string getName() { return m_name; }</code><code>    virtual const char* speak() const = 0; // The = 0 means this function is pure virtual</code><code>    </code><code>    virtual ~Animal() = default;</code><code>};</code><code></code><code>const char* Animal::speak() const  // even though it has a definition</code><code>{</code><code>    return "buzz";</code><code>}</code></pre><p>In this case, speak() is still considered a pure virtual function because of the “= 0” (even though it has been given a definition) and Animal is still considered an abstract base class (and thus can’t be instantiated). Any class that inherits from Animal needs to provide its own definition for speak() or it will also be considered an abstract base class.</p><p>When providing a definition for a pure virtual function, the definition must be provided separately (not inline).</p><div class="cpp-note cpp-lightyellowbackground"><h4>For Visual Studio users</h4><p>Visual Studio mistakenly allows pure virtual function declarations to be definitions, for example</p><pre class="language-cpp line-numbers"><code>// wrong!</code><code>virtual const char* speak() const = 0</code><code>{</code><code>  return "buzz";</code><code>}</code></pre><p>This is wrong and cannot be disabled.</p></div><p>This paradigm can be useful when you want your base class to provide a default implementation for a function, but still force any derived classes to provide their own implementation. However, if the derived class is happy with the default implementation provided by the base class, it can simply call the base class implementation directly. For example:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code>#include <iostream></iostream></code><code></code><code>class Animal // This Animal is an abstract base class</code><code>{</code><code>protected:</code><code>    std::string m_name;</code><code></code><code>public:</code><code>    Animal(const std::string&amp; name)</code><code>        : m_name(name)</code><code>    {</code><code>    }</code><code></code><code>    const std::string&amp; getName() const { return m_name; }</code><code>    virtual const char* speak() const = 0; // note that speak is a pure virtual function</code><code>    </code><code>    virtual ~Animal() = default;</code><code>};</code><code></code><code>const char* Animal::speak() const</code><code>{</code><code>    return "buzz"; // some default implementation</code><code>}</code><code></code><code>class Dragonfly: public Animal</code><code>{</code><code></code><code>public:</code><code>    Dragonfly(const std::string&amp; name)</code><code>        : Animal{name}</code><code>    {</code><code>    }</code><code></code><code>    const char* speak() const override// this class is no longer abstract because we defined this function</code><code>    {</code><code>        return Animal::speak(); // use Animal's default implementation</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Dragonfly dfly{"Sally"};</code><code>    std::cout &lt;&lt; dfly.getName() &lt;&lt; " says " &lt;&lt; dfly.speak() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>The above code prints:</p><pre>Sally says buzz
</pre><p>This capability isn’t used very commonly.</p><p>A destructor can be made pure virtual, but must be given a definition so that it can be called when a derived object is destructed.</p><p><strong>Interface classes</strong></p><p>An <strong>interface class</strong> is a class that has no member variables, and where <em>all</em> of the functions are pure virtual! In other words, the class is purely a definition, and has no actual implementation. Interfaces are useful when you want to define the functionality that derived classes must implement, but leave the details of how the derived class implements that functionality entirely up to the derived class.</p><p>Interface classes are often named beginning with an I. Here’s a sample interface class:</p><pre class="language-cpp line-numbers"><code>class IErrorLog</code><code>{</code><code>public:</code><code>    virtual bool openLog(const char* filename) = 0;</code><code>    virtual bool closeLog() = 0;</code><code></code><code>    virtual bool writeError(const char* errorMessage) = 0;</code><code></code><code>    virtual ~IErrorLog() {} // make a virtual destructor in case we delete an IErrorLog pointer, so the proper derived destructor is called</code><code>};</code></pre><p>Any class inheriting from IErrorLog must provide implementations for all three functions in order to be instantiated. You could derive a class named FileErrorLog, where openLog() opens a file on disk, closeLog() closes the file, and writeError() writes the message to the file. You could derive another class called ScreenErrorLog, where openLog() and closeLog() do nothing, and writeError() prints the message in a pop-up message box on the screen.</p><p>Now, let’s say you need to write some code that uses an error log. If you write your code so it includes FileErrorLog or ScreenErrorLog directly, then you’re effectively stuck using that kind of error log (at least without recoding your program). For example, the following function effectively forces callers of mySqrt() to use a FileErrorLog, which may or may not be what they want.</p><pre class="language-cpp line-numbers"><code>#include <cmath> // for sqrt()</cmath></code><code></code><code>double mySqrt(double value, FileErrorLog&amp; log)</code><code>{</code><code>    if (value &lt; 0.0)</code><code>    {</code><code>        log.writeError("Tried to take square root of value less than 0");</code><code>        return 0.0;</code><code>    }</code><code>    else</code><code>    {</code><code>        return std::sqrt(value);</code><code>    }</code><code>}</code></pre><p>A much better way to implement this function is to use IErrorLog instead:</p><pre class="language-cpp line-numbers"><code>#include <cmath> // for sqrt()</cmath></code><code>double mySqrt(double value, IErrorLog&amp; log)</code><code>{</code><code>    if (value &lt; 0.0)</code><code>    {</code><code>        log.writeError("Tried to take square root of value less than 0");</code><code>        return 0.0;</code><code>    }</code><code>    else</code><code>    {</code><code>        return std::sqrt(value);</code><code>    }</code><code>}</code></pre><p>Now the caller can pass in <em>any</em> class that conforms to the IErrorLog interface. If they want the error to go to a file, they can pass in an instance of FileErrorLog. If they want it to go to the screen, they can pass in an instance of ScreenErrorLog. Or if they want to do something you haven’t even thought of, such as sending an email to someone when there’s an error, they can derive a new class from IErrorLog (e.g. EmailErrorLog) and use an instance of that! By using IErrorLog, your function becomes more independent and flexible.</p><p>Don’t forget to include a virtual destructor for your interface classes, so that the proper derived destructor will be called if a pointer to the interface is deleted.</p><p>Interface classes have become extremely popular because they are easy to use, easy to extend, and easy to maintain. In fact, some modern languages, such as Java and C#, have added an “interface” keyword that allows programmers to directly define an interface class without having to explicitly mark all of the member functions as abstract. Furthermore, although Java (prior to version 8) and C# will not let you use multiple inheritance on normal classes, they will let you multiple inherit as many interfaces as you like. Because interfaces have no data and no function bodies, they avoid a lot of the traditional problems with multiple inheritance while still providing much of the flexibility.</p><p><strong>Pure virtual functions and the virtual table</strong></p><p>Abstract classes still have virtual tables, as these can still be used if you have a pointer or reference to the abstract class. The virtual table entry for a class with a pure virtual function will generally either contain a null pointer, or point to a generic function that prints an error (sometimes this function is named __purecall).</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">18.8 — Virtual base classes</h1></header><div class="entry-content" itemprop="articleBody"><p>Last chapter, in lesson <a href="https://www.learncpp.com/cpp-tutorial/multiple-inheritance/">17.9 -- Multiple inheritance</a>, we left off talking about the “diamond problem”. In this section, we will resume this discussion.</p><p>Note: This section is an advanced topic and can be skipped or skimmed if desired.</p><p><strong>The diamond problem</strong></p><p>Here is our example from the previous lesson (with some constructors) illustrating the diamond problem:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class PoweredDevice</code><code>{</code><code>public:</code><code>    PoweredDevice(int power)</code><code>    {</code><code>		std::cout &lt;&lt; "PoweredDevice: " &lt;&lt; power &lt;&lt; '\n';</code><code>    }</code><code>};</code><code></code><code>class Scanner: public PoweredDevice</code><code>{</code><code>public:</code><code>    Scanner(int scanner, int power)</code><code>        : PoweredDevice{ power }</code><code>    {</code><code>		std::cout &lt;&lt; "Scanner: " &lt;&lt; scanner &lt;&lt; '\n';</code><code>    }</code><code>};</code><code></code><code>class Printer: public PoweredDevice</code><code>{</code><code>public:</code><code>    Printer(int printer, int power)</code><code>        : PoweredDevice{ power }</code><code>    {</code><code>		std::cout &lt;&lt; "Printer: " &lt;&lt; printer &lt;&lt; '\n';</code><code>    }</code><code>};</code><code></code><code>class Copier: public Scanner, public Printer</code><code>{</code><code>public:</code><code>    Copier(int scanner, int printer, int power)</code><code>        : Scanner{ scanner, power }, Printer{ printer, power }</code><code>    {</code><code>    }</code><code>};</code></pre><p>Although you might expect to get an inheritance diagram that looks like this:</p><p><img src="https://www.learncpp.com/images/CppTutorial/Section11/PoweredDevice.gif" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Section11/PoweredDevice.gif"></p><p>If you were to create a Copier class object, by default you would end up with two copies of the PoweredDevice class -- one from Printer, and one from Scanner. This has the following structure:</p><p><img src="https://www.learncpp.com/images/CppTutorial/Section11/PoweredDevice2.gif" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/Section11/PoweredDevice2.gif"></p><p>We can create a short example that will show this in action:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Copier copier{ 1, 2, 3 };</code><code></code><code>    return 0;</code><code>}</code></pre><p>This produces the result:</p><pre>PoweredDevice: 3
Scanner: 1
PoweredDevice: 3
Printer: 2
</pre><p>As you can see, PoweredDevice got constructed twice.</p><p>While this is often desired, other times you may want only one copy of PoweredDevice to be shared by both Scanner and Printer.</p><p><strong>Virtual base classes</strong></p><p>To share a base class, simply insert the “virtual” keyword in the inheritance list of the derived class. This creates what is called a <strong>virtual base class</strong>, which means there is only one base object. The base object is shared between all objects in the inheritance tree and it is only constructed once. Here is an example (without constructors for simplicity) showing how to use the virtual keyword to create a shared base class:</p><pre class="language-cpp line-numbers"><code>class PoweredDevice</code><code>{</code><code>};</code><code></code><code>class Scanner: virtual public PoweredDevice</code><code>{</code><code>};</code><code></code><code>class Printer: virtual public PoweredDevice</code><code>{</code><code>};</code><code></code><code>class Copier: public Scanner, public Printer</code><code>{</code><code>};</code></pre><p>Now, when you create a Copier class object, you will get only one copy of PoweredDevice per Copier that will be shared by both Scanner and Printer.</p><p>However, this leads to one more problem: if Scanner and Printer share a PoweredDevice base class, who is responsible for creating it? The answer, as it turns out, is Copier. The Copier constructor is responsible for creating PoweredDevice. Consequently, this is one time when Copier is allowed to call a non-immediate-parent constructor directly:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class PoweredDevice</code><code>{</code><code>public:</code><code>    PoweredDevice(int power)</code><code>    {</code><code>		std::cout &lt;&lt; "PoweredDevice: " &lt;&lt; power &lt;&lt; '\n';</code><code>    }</code><code>};</code><code></code><code>class Scanner: virtual public PoweredDevice // note: PoweredDevice is now a virtual base class</code><code>{</code><code>public:</code><code>    Scanner(int scanner, int power)</code><code>        : PoweredDevice{ power } // this line is required to create Scanner objects, but ignored in this case</code><code>    {</code><code>		std::cout &lt;&lt; "Scanner: " &lt;&lt; scanner &lt;&lt; '\n';</code><code>    }</code><code>};</code><code></code><code>class Printer: virtual public PoweredDevice // note: PoweredDevice is now a virtual base class</code><code>{</code><code>public:</code><code>    Printer(int printer, int power)</code><code>        : PoweredDevice{ power } // this line is required to create Printer objects, but ignored in this case</code><code>    {</code><code>		std::cout &lt;&lt; "Printer: " &lt;&lt; printer &lt;&lt; '\n';</code><code>    }</code><code>};</code><code></code><code>class Copier: public Scanner, public Printer</code><code>{</code><code>public:</code><code>    Copier(int scanner, int printer, int power)</code><code>        : PoweredDevice{ power }, // PoweredDevice is constructed here</code><code>        Scanner{ scanner, power }, Printer{ printer, power }</code><code>    {</code><code>    }</code><code>};</code></pre><p>This time, our previous example:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Copier copier{ 1, 2, 3 };</code><code></code><code>    return 0;</code><code>}</code></pre><p>produces the result:</p><pre>PoweredDevice: 3
Scanner: 1
Printer: 2
</pre><p>As you can see, PoweredDevice only gets constructed once.</p><p>There are a few details that we would be remiss if we did not mention.</p><p>First, virtual base classes are always created before non-virtual base classes, which ensures all bases get created before their derived classes.</p><p>Second, note that the Scanner and Printer constructors still have calls to the PoweredDevice constructor. When creating an instance of Copier, these constructor calls are simply ignored because Copier is responsible for creating the PoweredDevice, not Scanner or Printer. However, if we were to create an instance of Scanner or Printer, those constructor calls would be used, and normal inheritance rules apply.</p><p>Third, if a class inherits one or more classes that have virtual parents, the <em>most</em> derived class is responsible for constructing the virtual base class. In this case, Copier inherits Printer and Scanner, both of which have a PoweredDevice virtual base class. Copier, the most derived class, is responsible for creation of PoweredDevice. Note that this is true even in a single inheritance case: if Copier singly inherited from Printer, and Printer was virtually inherited from PoweredDevice, Copier is still responsible for creating PoweredDevice.</p><p>Fourth, all classes inheriting a virtual base class will have a virtual table, even if they would normally not have one otherwise, and thus instances of the class will be larger by a pointer.</p><p>Because Scanner and Printer derive virtually from PoweredDevice, Copier will only be one PoweredDevice subobject. Scanner and Printer both need to know how to find that single PoweredDevice subobject, so they can access its members (because after all, they are derived from it). This is typically done through some virtual table magic (which essentially stores the offset from each subclass to the PoweredDevice subobject).</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">18.9 — Object slicing</h1></header><div class="entry-content" itemprop="articleBody"><p>Let’s go back to an example we looked at previously:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>protected:</code><code>    int m_value{};</code><code> </code><code>public:</code><code>    Base(int value)</code><code>        : m_value{ value }</code><code>    {</code><code>    }</code><code> </code><code>    virtual const char* getName() const { return "Base"; }</code><code>    int getValue() const { return m_value; }</code><code>};</code><code> </code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    Derived(int value)</code><code>        : Base{ value }</code><code>    {</code><code>    }</code><code> </code><code>    const char* getName() const override { return "Derived"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    Derived derived{ 5 };</code><code>    std::cout &lt;&lt; "derived is a " &lt;&lt; derived.getName() &lt;&lt; " and has value " &lt;&lt; derived.getValue() &lt;&lt; '\n';</code><code> </code><code>    Base&amp; ref{ derived };</code><code>    std::cout &lt;&lt; "ref is a " &lt;&lt; ref.getName() &lt;&lt; " and has value " &lt;&lt; ref.getValue() &lt;&lt; '\n';</code><code> </code><code>    Base* ptr{ &amp;derived };</code><code>    std::cout &lt;&lt; "ptr is a " &lt;&lt; ptr-&gt;getName() &lt;&lt; " and has value " &lt;&lt; ptr-&gt;getValue() &lt;&lt; '\n';</code><code> </code><code>    return 0;</code><code>}</code></pre><p>In the above example, ref references and ptr points to derived, which has a Base part, and a Derived part. Because ref and ptr are of type Base, ref and ptr can only see the Base part of derived -- the Derived part of derived still exists, but simply can’t be seen through ref or ptr. However, through use of virtual functions, we can access the most-derived version of a function. Consequently, the above program prints:</p><pre>derived is a Derived and has value 5
ref is a Derived and has value 5
ptr is a Derived and has value 5
</pre><p>But what happens if instead of setting a Base reference or pointer to a Derived object, we simply <em>assign</em> a Derived object to a Base object?</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Derived derived{ 5 };</code><code>    Base base{ derived }; // what happens here?</code><code>    std::cout &lt;&lt; "base is a " &lt;&lt; base.getName() &lt;&lt; " and has value " &lt;&lt; base.getValue() &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Remember that derived has a Base part and a Derived part. When we assign a Derived object to a Base object, only the Base portion of the Derived object is copied. The Derived portion is not. In the example above, base receives a copy of the Base portion of derived, but not the Derived portion. That Derived portion has effectively been “sliced off”. Consequently, the assigning of a Derived class object to a Base class object is called <strong>object slicing</strong> (or slicing for short).</p><p>Because variable base does not have a Derived part, base.getName() resolves to Base::getName().</p><p>The above example prints:</p><pre>base is a Base and has value 5
</pre><p>Used conscientiously, slicing can be benign. However, used improperly, slicing can cause unexpected results in quite a few different ways. Let’s examine some of those cases.</p><p><strong>Slicing and functions</strong></p><p>Now, you might think the above example is a bit silly. After all, why would you assign derived to base like that? You probably wouldn’t. However, slicing is much more likely to occur accidentally with functions.</p><p>Consider the following function:</p><pre class="language-cpp line-numbers"><code>void printName(const Base base) // note: base passed by value, not reference</code><code>{</code><code>    std::cout &lt;&lt; "I am a " &lt;&lt; base.getName() &lt;&lt; '\n';</code><code>}</code></pre><p>This is a pretty simple function with a const base object parameter that is passed by value. If we call this function like such:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Derived d{ 5 };</code><code>    printName(d); // oops, didn't realize this was pass by value on the calling end</code><code></code><code>    return 0;</code><code>}</code></pre><p>When you wrote this program, you may not have noticed that base is a value parameter, not a reference. Therefore, when called as printName(d), while we might have expected base.getName() to call virtualized function getName() and print “I am a Derived”, that is not what happens. Instead, Derived object d is sliced and only the Base portion is copied into the base parameter. When base.getName() executes, even though the getName() function is virtualized, there’s no Derived portion of the class for it to resolve to. Consequently, this program prints:</p><pre class="language-cpp line-numbers"><code>I am a Base</code></pre><p>In this case, it’s pretty obvious what happened, but if your functions don’t actually print any identifying information like this, tracking down the error can be challenging.</p><p>Of course, slicing here can all be easily avoided by making the function parameter a reference instead of a pass by value (yet another reason why passing classes by reference instead of value is a good idea).</p><pre class="language-cpp line-numbers"><code>void printName(const Base&amp; base) // note: base now passed by reference</code><code>{</code><code>    std::cout &lt;&lt; "I am a " &lt;&lt; base.getName() &lt;&lt; '\n';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    Derived d{ 5 };</code><code>    printName(d);</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>I am a Derived
</pre><p><strong>Slicing vectors</strong></p><p>Yet another area where new programmers run into trouble with slicing is trying to implement polymorphism with std::vector. Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <vector></vector></code><code></code><code>int main()</code><code>{</code><code>	std::vector<base> v{};</code><code>	v.push_back(Base{ 5 }); // add a Base object to our vector</code><code>	v.push_back(Derived{ 6 }); // add a Derived object to our vector</code><code></code><code>        // Print out all of the elements in our vector</code><code>	for (const auto&amp; element : v)</code><code>		std::cout &lt;&lt; "I am a " &lt;&lt; element.getName() &lt;&lt; " with value " &lt;&lt; element.getValue() &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This program compiles just fine. But when run, it prints:</p><pre>I am a Base with value 5
I am a Base with value 6
</pre><p>Similar to the previous examples, because the std::vector was declared to be a vector of type Base, when Derived(6) was added to the vector, it was sliced.</p><p>Fixing this is a little more difficult. Many new programmers try creating a std::vector of references to an object, like this:</p><pre class="language-cpp line-numbers"><code>std::vector<base&> v{};</base&></code></pre><p>Unfortunately, this won’t compile. The elements of std::vector must be assignable, whereas references can’t be reassigned (only initialized).</p><p>One way to address this is to make a vector of pointers:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <vector></vector></code><code></code><code>int main()</code><code>{</code><code>	std::vector<base*> v{};</base*></code><code>	</code><code>	Base b{ 5 }; // b and d can't be anonymous objects</code><code>	Derived d{ 6 };</code><code></code><code>	v.push_back(&amp;b); // add a Base object to our vector</code><code>	v.push_back(&amp;d); // add a Derived object to our vector</code><code></code><code>	// Print out all of the elements in our vector</code><code>	for (const auto* element : v)</code><code>		std::cout &lt;&lt; "I am a " &lt;&lt; element-&gt;getName() &lt;&lt; " with value " &lt;&lt; element-&gt;getValue() &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>I am a Base with value 5
I am a Derived with value 6
</pre><p>which works! A few comments about this. First, nullptr is now a valid option, which may or may not be desirable. Second, you now have to deal with pointer semantics, which can be awkward. But on the upside, this also allows the possibility of dynamic memory allocation, which is useful if your objects might otherwise go out of scope.</p><p>Another option is to use std::reference_wrapper, which is a class that mimics an reassignable reference:</p><pre class="language-cpp line-numbers"><code>#include <functional> // for std::reference_wrapper</functional></code><code>#include <iostream></iostream></code><code>#include <vector></vector></code><code></code><code>class Base</code><code>{</code><code>protected:</code><code>    int m_value{};</code><code></code><code>public:</code><code>    Base(int value)</code><code>        : m_value{ value }</code><code>    {</code><code>    }</code><code></code><code>    virtual const char* getName() const { return "Base"; }</code><code>    int getValue() const { return m_value; }</code><code>};</code><code></code><code>class Derived : public Base</code><code>{</code><code>public:</code><code>    Derived(int value)</code><code>        : Base{ value }</code><code>    {</code><code>    }</code><code></code><code>    const char* getName() const override { return "Derived"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	std::vector<std::reference_wrapper<base>&gt; v{}; // a vector of reassignable references to Base</std::reference_wrapper<base></code><code></code><code>	Base b{ 5 }; // b and d can't be anonymous objects</code><code>	Derived d{ 6 };</code><code></code><code>	v.push_back(b); // add a Base object to our vector</code><code>	v.push_back(d); // add a Derived object to our vector</code><code></code><code>	// Print out all of the elements in our vector</code><code>	// we use .get() to get our element out of the std::reference_wrapper</code><code>	for (const auto&amp; element : v) // element has type const std::reference_wrapper<base>&amp;</code><code>		std::cout &lt;&lt; "I am a " &lt;&lt; element.get().getName() &lt;&lt; " with value " &lt;&lt; element.get().getValue() &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p><strong>The Frankenobject</strong></p><p>In the above examples, we’ve seen cases where slicing lead to the wrong result because the derived class had been sliced off. Now let’s take a look at another dangerous case where the derived object still exists!</p><p>Consider the following code:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Derived d1{ 5 };</code><code>    Derived d2{ 6 };</code><code>    Base&amp; b{ d2 };</code><code></code><code>    b = d1; // this line is problematic</code><code></code><code>    return 0;</code><code>}</code></pre><p>The first three lines in the function are pretty straightforward. Create two Derived objects, and set a Base reference to the second one.</p><p>The fourth line is where things go astray. Since b points at d2, and we’re assigning d1 to b, you might think that the result would be that d1 would get copied into d2 -- and it would, if b were a Derived. But b is a Base, and the operator= that C++ provides for classes isn’t virtual by default. Consequently, only the Base portion of d1 is copied into d2.</p><p>As a result, you’ll discover that d2 now has the Base portion of d1 and the Derived portion of d2. In this particular example, that’s not a problem (because the Derived class has no data of its own), but in most cases, you’ll have just created a Frankenobject -- composed of parts of multiple objects. Worse, there’s no easy way to prevent this from happening (other than avoiding assignments like this as much as possible).</p><p><strong>Conclusion</strong></p><p>Although C++ supports assigning derived objects to base objects via object slicing, in general, this is likely to cause nothing but headaches, and you should generally try to avoid slicing. Make sure your function parameters are references (or pointers) and try to avoid any kind of pass-by-value when it comes to derived classes.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">18.10 — Dynamic casting</h1></header><div class="entry-content" itemprop="articleBody"><p>Way back in lesson <a href="https://www.learncpp.com/cpp-tutorial/explicit-type-conversion-casting-and-static-cast/">8.5 -- Explicit type conversion (casting) and static_cast</a>, we examined the concept of casting, and the use of static_cast to convert variables from one type to another.</p><p>In this lesson, we’ll continue by examining another type of cast: dynamic_cast.</p><p><strong>The need for dynamic_cast</strong></p><p>When dealing with polymorphism, you’ll often encounter cases where you have a pointer to a base class, but you want to access some information that exists only in a derived class.</p><p>Consider the following (slightly contrived) program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>class Base</code><code>{</code><code>protected:</code><code>	int m_value{};</code><code></code><code>public:</code><code>	Base(int value)</code><code>		: m_value{value}</code><code>	{</code><code>	}</code><code>	</code><code>	virtual ~Base() = default;</code><code>};</code><code></code><code>class Derived : public Base</code><code>{</code><code>protected:</code><code>	std::string m_name{};</code><code></code><code>public:</code><code>	Derived(int value, const std::string&amp; name)</code><code>		: Base{value}, m_name{name}</code><code>	{</code><code>	}</code><code></code><code>	const std::string&amp; getName() const { return m_name; }</code><code>};</code><code></code><code>Base* getObject(bool returnDerived)</code><code>{</code><code>	if (returnDerived)</code><code>		return new Derived{1, "Apple"};</code><code>	else</code><code>		return new Base{2};</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Base* b{ getObject(true) };</code><code></code><code>	// how do we print the Derived object's name here, having only a Base pointer?</code><code></code><code>	delete b;</code><code></code><code>	return 0;</code><code>}</code></pre><p>In this program, function getObject() always returns a Base pointer, but that pointer may be pointing to either a Base or a Derived object. In the case where the pointer is pointing to a Derived object, how would we call Derived::getName()?</p><p>One way would be to add a virtual function to Base called getName() (so we could call it with a Base pointer/reference, and have it dynamically resolve to Derived::getName()). But what would this function return if you called it with a Base pointer/reference that was actually pointing to a Base object? There isn’t really any value that makes sense. Furthermore, we would be polluting our Base class with things that really should only be the concern of the Derived class.</p><p>We know that C++ will implicitly let you convert a Derived pointer into a Base pointer (in fact, getObject() does just that). This process is sometimes called <strong>upcasting</strong>. However, what if there was a way to convert a Base pointer back into a Derived pointer? Then we could call Derived::getName() directly using that pointer, and not have to worry about virtual function resolution at all.</p><p><strong>dynamic_cast</strong></p><p>C++ provides a casting operator named <strong>dynamic_cast</strong> that can be used for just this purpose. Although dynamic casts have a few different capabilities, by far the most common use for dynamic casting is for converting base-class pointers into derived-class pointers. This process is called <strong>downcasting</strong>.</p><p>Using dynamic_cast works just like static_cast. Here’s our example main() from above, using a dynamic_cast to convert our Base pointer back into a Derived pointer:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	Base* b{ getObject(true) };</code><code></code><code>	Derived* d{ dynamic_cast<derived*>(b) }; // use dynamic cast to convert Base pointer into Derived pointer</derived*></code><code></code><code>	std::cout &lt;&lt; "The name of the Derived is: " &lt;&lt; d-&gt;getName() &lt;&lt; '\n';</code><code></code><code>	delete b;</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>The name of the Derived is: Apple
</pre><p><strong>dynamic_cast failure</strong></p><p>The above example works because b is actually pointing to a Derived object, so converting b into a Derived pointer is successful.</p><p>However, we’ve made quite a dangerous assumption: that b is pointing to a Derived object. What if b wasn’t pointing to a Derived object? This is easily tested by changing the argument to getObject() from true to false. In that case, getObject() will return a Base pointer to a Base object. When we try to dynamic_cast that to a Derived, it will fail, because the conversion can’t be made.</p><p>If a dynamic_cast fails, the result of the conversion will be a null pointer.</p><p>Because we haven’t checked for a null pointer result, we access d-&gt;getName(), which will try to dereference a null pointer, leading to undefined behavior (probably a crash).</p><p>In order to make this program safe, we need to ensure the result of the dynamic_cast actually succeeded:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	Base* b{ getObject(true) };</code><code></code><code>	Derived* d{ dynamic_cast<derived*>(b) }; // use dynamic cast to convert Base pointer into Derived pointer</derived*></code><code></code><code>	if (d) // make sure d is non-null</code><code>		std::cout &lt;&lt; "The name of the Derived is: " &lt;&lt; d-&gt;getName() &lt;&lt; '\n';</code><code></code><code>	delete b;</code><code></code><code>	return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightgreenbackground"><h4>Rule</h4><p>Always ensure your dynamic casts actually succeeded by checking for a null pointer result.</p></div><p>Note that because dynamic_cast does some consistency checking at runtime (to ensure the conversion can be made), use of dynamic_cast does incur a performance penalty.</p><p>Also note that there are several cases where downcasting using dynamic_cast will not work:</p><ol start="1"><li>With protected or private inheritance.</li><li>For classes that do not declare or inherit any virtual functions (and thus don’t have a virtual table).</li><li>In certain cases involving virtual base classes (see <a href="https://msdn.microsoft.com/en-us/library/cby9kycs.aspx">this page</a> for an example of some of these cases, and how to resolve them).</li></ol><p><strong>Downcasting with static_cast</strong></p><p>It turns out that downcasting can also be done with static_cast. The main difference is that static_cast does no runtime type checking to ensure that what you’re doing makes sense. This makes using static_cast faster, but more dangerous. If you cast a Base* to a Derived*, it will “succeed” even if the Base pointer isn’t pointing to a Derived object. This will result in undefined behavior when you try to access the resulting Derived pointer (that is actually pointing to a Base object).</p><p>If you’re absolutely sure that the pointer you’re downcasting will succeed, then using static_cast is acceptable. One way to ensure that you know what type of object you’re pointing to is to use a virtual function. Here’s one (not great) way to do that:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>// Class identifier</code><code>enum class ClassID</code><code>{</code><code>	base,</code><code>	derived</code><code>	// Others can be added here later</code><code>};</code><code></code><code>class Base</code><code>{</code><code>protected:</code><code>	int m_value{};</code><code></code><code>public:</code><code>	Base(int value)</code><code>		: m_value{value}</code><code>	{</code><code>	}</code><code></code><code>	virtual ~Base() = default;</code><code>	virtual ClassID getClassID() const { return ClassID::base; }</code><code>};</code><code></code><code>class Derived : public Base</code><code>{</code><code>protected:</code><code>	std::string m_name{};</code><code></code><code>public:</code><code>	Derived(int value, const std::string&amp; name)</code><code>		: Base{value}, m_name{name}</code><code>	{</code><code>	}</code><code></code><code>	const std::string&amp; getName() const { return m_name; }</code><code>	virtual ClassID getClassID() const { return ClassID::derived; }</code><code></code><code>};</code><code></code><code>Base* getObject(bool bReturnDerived)</code><code>{</code><code>	if (bReturnDerived)</code><code>		return new Derived{1, "Apple"};</code><code>	else</code><code>		return new Base{2};</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Base* b{ getObject(true) };</code><code></code><code>	if (b-&gt;getClassID() == ClassID::derived)</code><code>	{</code><code>		// We already proved b is pointing to a Derived object, so this should always succeed</code><code>		Derived* d{ static_cast<derived*>(b) };</derived*></code><code>		std::cout &lt;&lt; "The name of the Derived is: " &lt;&lt; d-&gt;getName() &lt;&lt; '\n';</code><code>	}</code><code></code><code>	delete b;</code><code></code><code>	return 0;</code><code>}</code></pre><p>But if you’re going to go through all of the trouble to implement this (and pay the cost of calling a virtual function and processing the result), you might as well just use dynamic_cast.</p><p><strong>dynamic_cast and references</strong></p><p>Although all of the above examples show dynamic casting of pointers (which is more common), dynamic_cast can also be used with references. This works analogously to how dynamic_cast works with pointers.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>class Base</code><code>{</code><code>protected:</code><code>	int m_value;</code><code></code><code>public:</code><code>	Base(int value)</code><code>		: m_value{value}</code><code>	{</code><code>	}</code><code></code><code>	virtual ~Base() = default; </code><code>};</code><code></code><code>class Derived : public Base</code><code>{</code><code>protected:</code><code>	std::string m_name;</code><code></code><code>public:</code><code>	Derived(int value, const std::string&amp; name)</code><code>		: Base{value}, m_name{name}</code><code>	{</code><code>	}</code><code></code><code>	const std::string&amp; getName() const { return m_name; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Derived apple{1, "Apple"}; // create an apple</code><code>	Base&amp; b{ apple }; // set base reference to object</code><code>	Derived&amp; d{ dynamic_cast<derived&>(b) }; // dynamic cast using a reference instead of a pointer</derived&></code><code></code><code>	std::cout &lt;&lt; "The name of the Derived is: " &lt;&lt; d.getName() &lt;&lt; '\n'; // we can access Derived::getName through d</code><code></code><code>	return 0;</code><code>}</code></pre><p>Because C++ does not have a “null reference”, dynamic_cast can’t return a null reference upon failure. Instead, if the dynamic_cast of a reference fails, an exception of type std::bad_cast is thrown. We talk about exceptions later in this tutorial.</p><p><strong>dynamic_cast vs static_cast</strong></p><p>New programmers are sometimes confused about when to use static_cast vs dynamic_cast. The answer is quite simple: use static_cast unless you’re downcasting, in which case dynamic_cast is usually a better choice. However, you should also consider avoiding casting altogether and just use virtual functions.</p><p><strong>Downcasting vs virtual functions</strong></p><p>There are some developers who believe dynamic_cast is evil and indicative of a bad class design. Instead, these programmers say you should use virtual functions.</p><p>In general, using a virtual function <em>should</em> be preferred over downcasting. However, there are times when downcasting is the better choice:</p><ul><li>When you can not modify the base class to add a virtual function (e.g. because the base class is part of the standard library)</li><li>When you need access to something that is derived-class specific (e.g. an access function that only exists in the derived class)</li><li>When adding a virtual function to your base class doesn’t make sense (e.g. there is no appropriate value for the base class to return). Using a pure virtual function may be an option here if you don’t need to instantiate the base class.</li></ul><p><strong>A warning about dynamic_cast and RTTI</strong></p><p>Run-time type information (RTTI) is a feature of C++ that exposes information about an object’s data type at runtime. This capability is leveraged by dynamic_cast. Because RTTI has a pretty significant space performance cost, some compilers allow you to turn RTTI off as an optimization. Needless to say, if you do this, dynamic_cast won’t function correctly.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">18.11 — Printing inherited classes using operator&lt;&lt;</h1></header><div class="entry-content" itemprop="articleBody"><p>Consider the following program that makes use of a virtual function:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>public:</code><code>	virtual void print() const { std::cout &lt;&lt; "Base";  }</code><code>};</code><code></code><code>class Derived : public Base</code><code>{</code><code>public:</code><code>	void print() const override { std::cout &lt;&lt; "Derived"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Derived d{};</code><code>	Base&amp; b{ d };</code><code>	b.print(); // will call Derived::print()</code><code></code><code>	return 0;</code><code>}</code></pre><p>By now, you should be comfortable with the fact that b.print() will call Derived::print() (because b is pointing to a Derived class object, Base::print() is a virtual function, and Derived::print() is an override).</p><p>While calling member functions like this to do output is okay, this style of function doesn’t mix well with std::cout:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	Derived d{};</code><code>	Base&amp; b{ d };</code><code></code><code>	std::cout &lt;&lt; "b is a ";</code><code>	b.print(); // messy, we have to break our print statement to call this function</code><code>	std::cout &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>In this lesson, we’ll look at how to override operator&lt;&lt; for classes using inheritance, so that we can use operator&lt;&lt; as expected, like this:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; "b is a " &lt;&lt; b &lt;&lt; '\n'; // much better</code></pre><p><strong>The challenges with operator&lt;&lt;</strong></p><p>Let’s start by overloading operator&lt;&lt; in the typical way:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>public:</code><code>	virtual void print() const { std::cout &lt;&lt; "Base"; }</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Base&amp; b)</code><code>	{</code><code>		out &lt;&lt; "Base";</code><code>		return out;</code><code>	}</code><code>};</code><code></code><code>class Derived : public Base</code><code>{</code><code>public:</code><code>	void print() const override { std::cout &lt;&lt; "Derived"; }</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Derived&amp; d)</code><code>	{</code><code>		out &lt;&lt; "Derived";</code><code>		return out;</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Base b{};</code><code>	std::cout &lt;&lt; b &lt;&lt; '\n';</code><code></code><code>	Derived d{};</code><code>	std::cout &lt;&lt; d &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>Because there is no need for virtual function resolution here, this program works as we’d expect, and prints:</p><pre>Base
Derived
</pre><p>Now, consider the following main() function instead:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Derived d{};</code><code>    Base&amp; bref{ d };</code><code>    std::cout &lt;&lt; bref &lt;&lt; '\n';</code><code>    </code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>Base
</pre><p>That’s probably not what we were expecting. This happens because our version of operator&lt;&lt; that handles Base objects isn’t virtual, so std::cout &lt;&lt; bref calls the version of operator&lt;&lt; that handles Base objects rather than Derived objects.</p><p>Therein lies the challenge.</p><p><strong>Can we make Operator &lt;&lt; virtual?</strong></p><p>If this issue is that operator&lt;&lt; isn’t virtual, can’t we simply make it virtual?</p><p>The short answer is no. There are a number of reasons for this.</p><p>First, only member functions can be virtualized -- this makes sense, since only classes can inherit from other classes, and there’s no way to override a function that lives outside of a class (you can overload non-member functions, but not override them). Because we typically implement operator&lt;&lt; as a friend, and friends aren’t considered member functions, a friend version of operator&lt;&lt; is ineligible to be virtualized. (For a review of why we implement operator&lt;&lt; this way, please revisit lesson <a href="https://www.learncpp.com/cpp-tutorial/overloading-operators-using-member-functions/">14.5 -- Overloading operators using member functions</a>).</p><p>Second, even if we could virtualize operator&lt;&lt; there’s the problem that the function parameters for Base::operator&lt;&lt; and Derived::operator&lt;&lt; differ (the Base version would take a Base parameter and the Derived version would take a Derived parameter). Consequently, the Derived version wouldn’t be considered an override of the Base version, and thus be ineligible for virtual function resolution.</p><p>So what’s a programmer to do?</p><p><strong>The solution</strong></p><p>The answer, as it turns out, is surprisingly simple.</p><p>First, we set up operator&lt;&lt; as a friend in our base class as usual. But instead of having operator&lt;&lt; do the printing itself, we delegate that responsibility to a normal member function that <em>can</em> be virtualized!</p><p>Here’s the full solution that works:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>public:</code><code>	// Here's our overloaded operator&lt;&lt;</code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Base&amp; b)</code><code>	{</code><code>		// Delegate printing responsibility for printing to member function print()</code><code>		return b.print(out);</code><code>	}</code><code></code><code>	// We'll rely on member function print() to do the actual printing</code><code>	// Because print is a normal member function, it can be virtualized</code><code>	virtual std::ostream&amp; print(std::ostream&amp; out) const</code><code>	{</code><code>		out &lt;&lt; "Base";</code><code>		return out;</code><code>	}</code><code>};</code><code></code><code>class Derived : public Base</code><code>{</code><code>public:</code><code>	// Here's our override print function to handle the Derived case</code><code>	std::ostream&amp; print(std::ostream&amp; out) const override</code><code>	{</code><code>		out &lt;&lt; "Derived";</code><code>		return out;</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Base b{};</code><code>	std::cout &lt;&lt; b &lt;&lt; '\n';</code><code></code><code>	Derived d{};</code><code>	std::cout &lt;&lt; d &lt;&lt; '\n'; // note that this works even with no operator&lt;&lt; that explicitly handles Derived objects</code><code></code><code>	Base&amp; bref{ d };</code><code>	std::cout &lt;&lt; bref &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>The above program works in all three cases:</p><pre>Base
Derived
Derived
</pre><p>Let’s examine how in more detail.</p><p>First, in the Base case, we call operator&lt;&lt;, which calls virtual function print(). Since our Base reference parameter points to a Base object, b.print() resolves to Base::print(), which does the printing. Nothing too special here.</p><p>In the Derived case, the compiler first looks to see if there’s an operator&lt;&lt; that takes a Derived object. There isn’t one, because we didn’t define one. Next the compiler looks to see if there’s an operator&lt;&lt; that takes a Base object. There is, so the compiler does an implicit upcast of our Derived object to a Base&amp; and calls the function (we could have done this upcast ourselves, but the compiler is helpful in this regard). This function then calls virtual print(), which resolves to Derived::print().</p><p>Note that we don’t need to define an operator&lt;&lt; for each derived class! The version that handles Base objects works just fine for both Base objects and any class derived from Base!</p><p>The third case proceeds as a mix of the first two. First, the compiler matches variable bref with operator&lt;&lt; that takes a Base. That calls our virtual print() function. Since the Base reference is actually pointing to a Derived object, this resolves to Derived::print(), as we intended.</p><p>Problem solved.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">18.x — Chapter 18 comprehensive quiz</h1></header><div class="entry-content" itemprop="articleBody"><p>And so our journey through C++’s inheritance and virtual functions comes to an end. Fret not, dear reader, for there are plenty of other areas of C++ to explore as we move forward.</p><p><strong>Chapter summary</strong></p><p>C++ allows you to set base class pointers and references to a derived object. This is useful when we want to write a function or array that can work with any type of object derived from a base class.</p><p>Without virtual functions, base class pointers and references to a derived class will only have access to base class member variables and versions of functions.</p><p>A virtual function is a special type of function that resolves to the most-derived version of the function (called an override) that exists between the base and derived class. To be considered an override, the derived class function must have the same signature and return type as the virtual base class function. The one exception is for covariant return types, which allow an override to return a pointer or reference to a derived class if the base class function returns a pointer or reference to the base class.</p><p>A function that is intended to be an override should use the override specifier to ensure that it is actually an override.</p><p>The final specifier can be used to prevent overrides of a function or inheritance from a class.</p><p>If you intend to use inheritance, you should make your destructor virtual, so the proper destructor is called if a pointer to the base class is deleted.</p><p>You can ignore virtual resolution by using the scope resolution operator to directly specify which class’s version of the function you want: e.g. <code>base.Base::getName()</code>.</p><p>Early binding occurs when the compiler encounters a direct function call. The compiler or linker can resolve these function calls directly. Late binding occurs when a function pointer is called. In these cases, which function will be called can not be resolved until runtime. Virtual functions use late binding and a virtual table to determine which version of the function to call.</p><p>Using virtual functions has a cost: virtual functions take longer to call, and the necessity of the virtual table increases the size of every object containing a virtual function by one pointer.</p><p>A virtual function can be made pure virtual/abstract by adding “= 0” to the end of the virtual function prototype. A class containing a pure virtual function is called an abstract class, and can not be instantiated. A class that inherits pure virtual functions must concretely define them or it will also be considered abstract. Pure virtual functions can have a body, but they are still considered abstract.</p><p>An interface class is one with no member variables and all pure virtual functions. These are often named starting with a capital I.</p><p>A virtual base class is a base class that is only included once, no matter how many times it is inherited by an object.</p><p>When a derived class is assigned to a base class object, the base class only receives a copy of the base portion of the derived class. This is called object slicing.</p><p>Dynamic casting can be used to convert a pointer to a base class object into a pointer to a derived class object. This is called downcasting. A failed conversion will return a null pointer.</p><p>The easiest way to overload operator&lt;&lt; for inherited classes is to write an overloaded operator&lt;&lt; for the most-base class, and then call a virtual member function to do the printing.</p><p><strong>Quiz time</strong></p><ol start="1"><li>Each of the following programs has some kind of defect. Inspect each program (visually, not by compiling) and determine what is wrong with the program. The output of each program is supposed to be “Derived”.</li></ol><p>1a)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>protected:</code><code>	int m_value;</code><code></code><code>public:</code><code>	Base(int value)</code><code>		: m_value{ value }</code><code>	{</code><code>	}</code><code></code><code>	const char* getName() const { return "Base"; }</code><code>};</code><code></code><code>class Derived : public Base</code><code>{</code><code>public:</code><code>	Derived(int value)</code><code>		: Base{ value }</code><code>	{</code><code>	}</code><code></code><code>	const char* getName() const { return "Derived"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Derived d{ 5 };</code><code>	Base&amp; b{ d };</code><code>	std::cout &lt;&lt; b.getName() &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none">Base::getName() wasn’t made virtual, so b.getName() doesn’t resolve to Derived::getName().</div><p>1b)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>protected:</code><code>	int m_value;</code><code></code><code>public:</code><code>	Base(int value)</code><code>		: m_value{ value }</code><code>	{</code><code>	}</code><code></code><code>	virtual const char* getName() { return "Base"; }</code><code>};</code><code></code><code>class Derived : public Base</code><code>{</code><code>public:</code><code>	Derived(int value)</code><code>		: Base{ value }</code><code>	{</code><code>	}</code><code></code><code>	virtual const char* getName() const { return "Derived"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Derived d{ 5 };</code><code>	Base&amp; b{ d };</code><code>	std::cout &lt;&lt; b.getName() &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none">Base::getName() is non-const and Derived::getName() is const, so Derived::getName() is not considered an override.</div><p>1c)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>protected:</code><code>	int m_value;</code><code></code><code>public:</code><code>	Base(int value)</code><code>		: m_value{ value }</code><code>	{</code><code>	}</code><code></code><code>	virtual const char* getName() { return "Base"; }</code><code>};</code><code></code><code>class Derived : public Base</code><code>{</code><code>public:</code><code>	Derived(int value)</code><code>		: Base{ value }</code><code>	{</code><code>	}</code><code></code><code>	const char* getName() override { return "Derived"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Derived d{ 5 };</code><code>	Base b{ d };</code><code>	std::cout &lt;&lt; b.getName() &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none">d was assigned to b by value, causing d to get sliced.</div><p>1d)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base final</code><code>{</code><code>protected:</code><code>	int m_value;</code><code></code><code>public:</code><code>	Base(int value)</code><code>		: m_value{ value }</code><code>	{</code><code>	}</code><code></code><code>	virtual const char* getName() { return "Base"; }</code><code>};</code><code></code><code>class Derived : public Base</code><code>{</code><code>public:</code><code>	Derived(int value)</code><code>		: Base{ value }</code><code>	{</code><code>	}</code><code></code><code>	const char* getName() override { return "Derived"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Derived d{ 5 };</code><code>	Base&amp; b{ d };</code><code>	std::cout &lt;&lt; b.getName() &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none">Base was declared as final, so Derived can’t be derived from it. This will cause a compile error.</div><p>1e)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>protected:</code><code>	int m_value;</code><code></code><code>public:</code><code>	Base(int value)</code><code>		: m_value{ value }</code><code>	{</code><code>	}</code><code></code><code>	virtual const char* getName() { return "Base"; }</code><code>};</code><code></code><code>class Derived : public Base</code><code>{</code><code>public:</code><code>	Derived(int value)</code><code>		: Base{ value }</code><code>	{</code><code>	}</code><code></code><code>	virtual const char* getName() = 0;</code><code>};</code><code></code><code>const char* Derived::getName()</code><code>{</code><code>	return "Derived";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Derived d{ 5 };</code><code>	Base&amp; b{ d };</code><code>	std::cout &lt;&lt; b.getName() &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none">Derived::getName() is a pure virtual function (with a body), and therefore Derived is an abstract class that can’t be instantiated.</div><p>1f)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>protected:</code><code>	int m_value;</code><code></code><code>public:</code><code>	Base(int value)</code><code>		: m_value{ value }</code><code>	{</code><code>	}</code><code></code><code>	virtual const char* getName() { return "Base"; }</code><code>};</code><code></code><code>class Derived : public Base</code><code>{</code><code>public:</code><code>	Derived(int value)</code><code>		: Base{ value }</code><code>	{</code><code>	}</code><code></code><code>	virtual const char* getName() { return "Derived"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	auto* d{ new Derived(5) };</code><code>	Base* b{ d };</code><code>	std::cout &lt;&lt; b-&gt;getName() &lt;&lt; '\n';</code><code>	delete b;</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none">This program actually produces the right output, but has a different issue. We’re deleting b, which is a Base pointer, but we never added a virtual destructor to the Base class. Consequently, the program only deletes the Base portion of the Derived object, and the Derived portion is left as leaked memory.</div><p>2a) Create an abstract class named Shape. This class should have three functions: a pure virtual print function that takes and returns a std::ostream&amp;, an overloaded operator&lt;&lt; and an empty virtual destructor.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none"><pre class="language-cpp line-numbers"><code>class Shape</code><code>{</code><code>public:</code><code>	virtual std::ostream&amp; print(std::ostream&amp; out) const = 0;</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Shape&amp; p)</code><code>	{</code><code>		return p.print(out);</code><code>	}</code><code>	virtual ~Shape() = default;</code><code>};</code></pre></div><p>2b) Derive two classes from Shape: a Triangle, and a Circle. The Triangle should have 3 Points as members. The Circle should have one center Point, and an integer radius. Overload the print() function so the following program runs:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    Circle c{ Point{ 1, 2 }, 7 };</code><code>    std::cout &lt;&lt; c &lt;&lt; '\n';</code><code></code><code>    Triangle t{Point{ 1, 2 }, Point{ 3, 4 }, Point{ 5, 6 }};</code><code>    std::cout &lt;&lt; t &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This should print:</p><pre>Circle(Point(1, 2), radius 7)
Triangle(Point(1, 2), Point(3, 4), Point(5, 6))
</pre><p>Here’s a Point class you can use:</p><pre class="language-cpp line-numbers"><code>class Point</code><code>{</code><code>private:</code><code>	int m_x{};</code><code>	int m_y{};</code><code></code><code>public:</code><code>	Point(int x, int y)</code><code>		: m_x{ x }, m_y{ y }</code><code>	{</code><code></code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Point&amp; p)</code><code>	{</code><code>		return out &lt;&lt; "Point(" &lt;&lt; p.m_x &lt;&lt; ", " &lt;&lt; p.m_y &lt;&lt; ')';</code><code>	}</code><code>};</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_7'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_7" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Point</code><code>{</code><code>private:</code><code>	int m_x{};</code><code>	int m_y{};</code><code></code><code>public:</code><code>	Point(int x, int y)</code><code>		: m_x{ x }, m_y{ y }</code><code>	{</code><code></code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Point&amp; p)</code><code>	{</code><code>		return out &lt;&lt; "Point(" &lt;&lt; p.m_x &lt;&lt; ", " &lt;&lt; p.m_y &lt;&lt; ')';</code><code>	}</code><code>};</code><code></code><code>class Shape</code><code>{</code><code>public:</code><code>	virtual std::ostream&amp; print(std::ostream&amp; out) const = 0;</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Shape&amp; p)</code><code>	{</code><code>		return p.print(out);</code><code>	}</code><code>	virtual ~Shape() = default;</code><code>};</code><code></code><code>class Triangle : public Shape</code><code>{</code><code>private:</code><code>	Point m_p1;</code><code>	Point m_p2;</code><code>	Point m_p3;</code><code></code><code>public:</code><code>	Triangle(const Point&amp; p1, const Point&amp; p2, const Point&amp; p3)</code><code>		: m_p1{ p1 }, m_p2{ p2 }, m_p3{ p3 }</code><code>	{</code><code>	}</code><code></code><code>	std::ostream&amp; print(std::ostream&amp; out) const override</code><code>	{</code><code>		return out &lt;&lt; "Triangle(" &lt;&lt; m_p1 &lt;&lt; ", " &lt;&lt; m_p2 &lt;&lt; ", " &lt;&lt; m_p3 &lt;&lt; ')';</code><code>	}</code><code>};</code><code></code><code>class Circle : public Shape</code><code>{</code><code>private:</code><code>	Point m_center;</code><code>	int m_radius;</code><code></code><code>public:</code><code>	Circle(const Point&amp; center, int radius)</code><code>		: m_center{ center }, m_radius{ radius }</code><code>	{</code><code>	}</code><code></code><code>	std::ostream&amp; print(std::ostream&amp; out) const override</code><code>	{</code><code>		return out &lt;&lt; "Circle(" &lt;&lt; m_center &lt;&lt; ", radius " &lt;&lt; m_radius &lt;&lt; ')';</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Circle c{ Point{ 1, 2 }, 7 };</code><code>	std::cout &lt;&lt; c &lt;&lt; '\n';</code><code></code><code>	Triangle t{ Point{ 1, 2 }, Point{ 3, 4 }, Point{ 5, 6 } };</code><code>	std::cout &lt;&lt; t &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre></div><p>2c) Given the above classes (Point, Shape, Circle, and Triangle), finish the following program:</p><pre class="language-cpp line-numbers"><code>#include <vector></vector></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	std::vector<shape*> v{</shape*></code><code>	  new Circle{Point{ 1, 2 }, 7},</code><code>	  new Triangle{Point{ 1, 2 }, Point{ 3, 4 }, Point{ 5, 6 }},</code><code>	  new Circle{Point{ 7, 8 }, 3}</code><code>	};</code><code></code><code>	// print each shape in vector v on its own line here</code><code></code><code>	std::cout &lt;&lt; "The largest radius is: " &lt;&lt; getLargestRadius(v) &lt;&lt; '\n'; // write this function</code><code></code><code>	// delete each element in the vector here</code><code></code><code>	return 0;</code><code>}</code></pre><p>The program should print the following:</p><pre>Circle(Point(1, 2), radius 7)
Triangle(Point(1, 2), Point(3, 4), Point(5, 6))
Circle(Point(7, 8), radius 3)
The largest radius is: 7
</pre><p>Hint: You’ll need to add a getRadius() function to Circle, and downcast a Shape* into a Circle* to access it.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_8'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_8" style="display:none"><pre class="language-cpp line-numbers"><code>#include <vector></vector></code><code>#include <iostream></iostream></code><code>#include <algorithm> // for std::max</algorithm></code><code></code><code>class Point</code><code>{</code><code>private:</code><code>	int m_x{};</code><code>	int m_y{};</code><code></code><code>public:</code><code>	Point(int x, int y)</code><code>		: m_x{ x }, m_y{ y }</code><code>	{</code><code></code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Point&amp; p)</code><code>	{</code><code>		return out &lt;&lt; "Point(" &lt;&lt; p.m_x &lt;&lt; ", " &lt;&lt; p.m_y &lt;&lt; ')';</code><code>	}</code><code>};</code><code></code><code>class Shape</code><code>{</code><code>public:</code><code>	virtual std::ostream&amp; print(std::ostream&amp; out) const = 0;</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Shape&amp; p)</code><code>	{</code><code>		return p.print(out);</code><code>	}</code><code>	virtual ~Shape() = default;</code><code>};</code><code></code><code>class Triangle : public Shape</code><code>{</code><code>private:</code><code>	Point m_p1;</code><code>	Point m_p2;</code><code>	Point m_p3;</code><code></code><code>public:</code><code>	Triangle(const Point&amp; p1, const Point&amp; p2, const Point&amp; p3)</code><code>		: m_p1{ p1 }, m_p2{ p2 }, m_p3{ p3 }</code><code>	{</code><code>	}</code><code></code><code>	std::ostream&amp; print(std::ostream&amp; out) const override</code><code>	{</code><code>		return out &lt;&lt; "Triangle(" &lt;&lt; m_p1 &lt;&lt; ", " &lt;&lt; m_p2 &lt;&lt; ", " &lt;&lt; m_p3 &lt;&lt; ')';</code><code>	}</code><code>};</code><code></code><code></code><code>class Circle : public Shape</code><code>{</code><code>private:</code><code>	Point m_center;</code><code>	int m_radius{};</code><code></code><code>public:</code><code>	Circle(const Point&amp; center, int radius)</code><code>		: m_center{ center }, m_radius{ radius }</code><code>	{</code><code>	}</code><code></code><code>	std::ostream&amp; print(std::ostream&amp; out) const override</code><code>	{</code><code>		out &lt;&lt; "Circle(" &lt;&lt; m_center &lt;&lt; ", radius " &lt;&lt; m_radius &lt;&lt; ')';</code><code>		return out;</code><code>	}</code><code></code><code>	int getRadius() const { return m_radius; }</code><code>};</code><code></code><code>// h/t to reader Olivier for this updated solution</code><code>// assumes radiuses are &gt;= 0</code><code>int getLargestRadius(const std::vector<shape*>&amp; v)</shape*></code><code>{</code><code>	int largestRadius{ 0 };</code><code></code><code>	// Loop through all the shapes in the vector</code><code>	for (const auto* element : v)</code><code>	{</code><code>		// // Ensure the dynamic cast succeeds by checking for a null pointer result</code><code>		if (auto * c{ dynamic_cast<const circle*="">(element) })</const></code><code>		{</code><code>			largestRadius = std::max(largestRadius, c-&gt;getRadius());</code><code>		}</code><code>	}</code><code></code><code>	return largestRadius;</code><code>}</code><code>int main()</code><code>{</code><code>	std::vector<shape*> v{</shape*></code><code>		  new Circle{Point{ 1, 2 }, 7},</code><code>		  new Triangle{Point{ 1, 2 }, Point{ 3, 4 }, Point{ 5, 6 }},</code><code>		  new Circle{Point{ 7, 8 }, 3}</code><code>	};</code><code></code><code>	for (const auto* element : v) // element will be a Shape*</code><code>		std::cout &lt;&lt; *element &lt;&lt; '\n';</code><code></code><code>	std::cout &lt;&lt; "The largest radius is: " &lt;&lt; getLargestRadius(v) &lt;&lt; '\n';</code><code></code><code>	for (const auto* element : v)</code><code>		delete element;</code><code></code><code>	return 0;</code><code>}</code></pre></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">19.1 — Template classes</h1></header><div class="entry-content" itemprop="articleBody"><p>In a previous chapter, we covered function templates (<a href="https://www.learncpp.com/cpp-tutorial/function-templates/">8.13 -- Function templates</a>), which allow us to generalize functions to work with many different data types. While this is a great start down the road to generalized programming, it doesn’t solve all of our problems. Let’s take a look at an example of one such problem, and see what templates can further do for us.</p><br><h3>Templates and container classes</h3><p>In the lesson on <a href="https://www.learncpp.com/cpp-tutorial/container-classes/">16.6 -- Container classes</a>, you learned how to use composition to implement classes that contained multiple instances of other classes. As one example of such a container, we took a look at the IntArray class. Here is a simplified example of that class:</p><pre class="language-cpp line-numbers"><code>#ifndef INTARRAY_H</code><code>#define INTARRAY_H</code><code></code><code>#include <cassert></cassert></code><code></code><code>class IntArray</code><code>{</code><code>private:</code><code>    int m_length{};</code><code>    int* m_data{};</code><code></code><code>public:</code><code></code><code>    IntArray(int length)</code><code>    {</code><code>        assert(length &gt; 0);</code><code>        m_data = new int[length]{};</code><code>        m_length = length;</code><code>    }</code><code></code><code>    // We don't want to allow copies of IntArray to be created.</code><code>    IntArray(const IntArray&amp;) = delete;</code><code>    IntArray&amp; operator=(const IntArray&amp;) = delete;</code><code></code><code>    ~IntArray()</code><code>    {</code><code>        delete[] m_data;</code><code>    }</code><code></code><code>    void erase()</code><code>    {</code><code>        delete[] m_data;</code><code>        // We need to make sure we set m_data to 0 here, otherwise it will</code><code>        // be left pointing at deallocated memory!</code><code>        m_data = nullptr;</code><code>        m_length = 0;</code><code>    }</code><code></code><code>    int&amp; operator[](int index)</code><code>    {</code><code>        assert(index &gt;= 0 &amp;&amp; index &lt; m_length);</code><code>        return m_data[index];</code><code>    }</code><code></code><code>    int getLength() const { return m_length; }</code><code>};</code><code></code><code>#endif</code></pre><p>While this class provides an easy way to create arrays of integers, what if we want to create an array of doubles? Using traditional programming methods, we’d have to create an entirely new class! Here’s an example of DoubleArray, an array class used to hold doubles.</p><pre class="language-cpp line-numbers"><code>#ifndef DOUBLEARRAY_H</code><code>#define DOUBLEARRAY_H</code><code></code><code>#include <cassert></cassert></code><code></code><code>class DoubleArray</code><code>{</code><code>private:</code><code>    int m_length{};</code><code>    double* m_data{};</code><code></code><code>public:</code><code></code><code>    DoubleArray(int length)</code><code>    {</code><code>        assert(length &gt; 0);</code><code>        m_data = new double[length]{};</code><code>        m_length = length;</code><code>    }</code><code></code><code>    DoubleArray(const DoubleArray&amp;) = delete;</code><code>    DoubleArray&amp; operator=(const DoubleArray&amp;) = delete;</code><code></code><code>    ~DoubleArray()</code><code>    {</code><code>        delete[] m_data;</code><code>    }</code><code></code><code>    void erase()</code><code>    {</code><code>        delete[] m_data;</code><code>        // We need to make sure we set m_data to 0 here, otherwise it will</code><code>        // be left pointing at deallocated memory!</code><code>        m_data = nullptr;</code><code>        m_length = 0;</code><code>    }</code><code></code><code>    double&amp; operator[](int index)</code><code>    {</code><code>        assert(index &gt;= 0 &amp;&amp; index &lt; m_length);</code><code>        return m_data[index];</code><code>    }</code><code></code><code>    int getLength() const { return m_length; }</code><code>};</code><code></code><code>#endif</code></pre><p>Although the code listings are lengthy, you’ll note the two classes are almost identical! In fact, the only substantive difference is the contained data type (int vs double). As you likely have guessed, this is another area where templates can be put to good use, to free us from having to create classes that are bound to one specific data type.</p><p>Creating template classes works pretty much identically to creating template functions, so we’ll proceed by example. Here’s our array class, templated version:</p><p>Array.h:</p><pre class="language-cpp line-numbers"><code>#ifndef ARRAY_H</code><code>#define ARRAY_H</code><code></code><code>#include <cassert></cassert></code><code></code><code>template <typename t=""> // added</typename></code><code>class Array</code><code>{</code><code>private:</code><code>    int m_length{};</code><code>    T* m_data{}; // changed type to T</code><code></code><code>public:</code><code></code><code>    Array(int length)</code><code>    {</code><code>        assert(length &gt; 0);</code><code>        m_data = new T[length]{}; // allocated an array of objects of type T</code><code>        m_length = length;</code><code>    }</code><code></code><code>    Array(const Array&amp;) = delete;</code><code>    Array&amp; operator=(const Array&amp;) = delete;</code><code></code><code>    ~Array()</code><code>    {</code><code>        delete[] m_data;</code><code>    }</code><code></code><code>    void erase()</code><code>    {</code><code>        delete[] m_data;</code><code>        // We need to make sure we set m_data to 0 here, otherwise it will</code><code>        // be left pointing at deallocated memory!</code><code>        m_data = nullptr;</code><code>        m_length = 0;</code><code>    }</code><code></code><code>    T&amp; operator[](int index) // now returns a T&amp;</code><code>    {</code><code>        assert(index &gt;= 0 &amp;&amp; index &lt; m_length);</code><code>        return m_data[index];</code><code>    }</code><code></code><code>    // templated getLength() function defined below</code><code>    int getLength() const; </code><code>};</code><code></code><code>// member functions defined outside the class need their own template declaration</code><code>template <typename t=""></typename></code><code>int Array<t>::getLength() const // note class name is Array<t>, not Array</t></t></code><code>{</code><code>  return m_length;</code><code>}</code><code></code><code>#endif</code></pre><p>As you can see, this version is almost identical to the IntArray version, except we’ve added the template declaration, and changed the contained data type from int to T.</p><p>Note that we’ve also defined the getLength() function outside of the class declaration. This isn’t necessary, but new programmers typically stumble when trying to do this for the first time due to the syntax, so an example is instructive. Each templated member function defined outside the class declaration needs its own template declaration. Also, note that the name of the templated array class is Array&lt;T&gt;, not Array -- Array would refer to a non-templated version of a class named Array, unless Array is used inside of the class. For example, the copy constructor and copy-assignment operator used Array rather than Array&lt;T&gt;. When the class name is used without template arguments inside of the class, the arguments are the same as the ones of the current instantiation.</p><p>Here’s a short example using the above templated array class:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include "Array.h"</code><code></code><code>int main()</code><code>{</code><code>	Array<int> intArray { 12 };</int></code><code>	Array<double> doubleArray { 12 };</double></code><code></code><code>	for (int count{ 0 }; count &lt; intArray.getLength(); ++count)</code><code>	{</code><code>		intArray[count] = count;</code><code>		doubleArray[count] = count + 0.5;</code><code>	}</code><code></code><code>	for (int count{ intArray.getLength() - 1 }; count &gt;= 0; --count)</code><code>		std::cout &lt;&lt; intArray[count] &lt;&lt; '\t' &lt;&lt; doubleArray[count] &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This example prints the following:</p><pre>11     11.5
10     10.5
9       9.5
8       8.5
7       7.5
6       6.5
5       5.5
4       4.5
3       3.5
2       2.5
1       1.5
0       0.5
</pre><p>Template classes are instanced in the same way template functions are -- the compiler stencils out a copy upon demand, with the template parameter replaced by the actual data type the user needs, and then compiles the copy. If you don’t ever use a template class, the compiler won’t even compile it.</p><p>Template classes are ideal for implementing container classes, because it is highly desirable to have containers work across a wide variety of data types, and templates allow you to do so without duplicating code. Although the syntax is ugly, and the error messages can be cryptic, template classes are truly one of C++’s best and most useful features.</p><br><h3>Template classes in the standard library</h3><p>Now that we’ve covered template classes, you should understand what std::vector&lt;int&gt; means now -- std::vector is actually a template class, and int is the type parameter to the template! The standard library is full of predefined template classes available for your use. We’ll cover these in later chapters.</p><br><h3>Splitting up template classes</h3><p>A template is not a class or a function -- it is a stencil used to create classes or functions. As such, it does not work in quite the same way as normal functions or classes. In most cases, this isn’t much of a issue. However, there is one area that commonly causes problems for developers.</p><p>With non-template classes, the common procedure is to put the class definition in a header file, and the member function definitions in a similarly named code file. In this way, the source for the class is compiled as a separate project file. However, with templates, this does not work. Consider the following:</p><p>Array.h:</p><pre class="language-cpp line-numbers"><code>#ifndef ARRAY_H</code><code>#define ARRAY_H</code><code></code><code>#include <cassert></cassert></code><code></code><code>template <typename t=""></typename></code><code>class Array</code><code>{</code><code>private:</code><code>    int m_length{};</code><code>    T* m_data{};</code><code></code><code>public:</code><code></code><code>    Array(int length)</code><code>    {</code><code>        assert(length &gt; 0);</code><code>        m_data = new T[length]{};</code><code>        m_length = length;</code><code>    }</code><code></code><code>    Array(const Array&amp;) = delete;</code><code>    Array&amp; operator=(const Array&amp;) = delete;</code><code></code><code>    ~Array()</code><code>    {</code><code>        delete[] m_data;</code><code>    }</code><code></code><code>    void erase()</code><code>    {</code><code>        delete[] m_data;</code><code></code><code>        m_data = nullptr;</code><code>        m_length = 0;</code><code>    }</code><code></code><code>    T&amp; operator[](int index)</code><code>    {</code><code>        assert(index &gt;= 0 &amp;&amp; index &lt; m_length);</code><code>        return m_data[index];</code><code>    }</code><code></code><code>    int getLength() const; </code><code>};</code><code></code><code>#endif</code></pre><p>Array.cpp:</p><pre class="language-cpp line-numbers"><code>#include "Array.h"</code><code></code><code>template <typename t=""></typename></code><code>int Array<t>::getLength() const // note class name is Array<t>, not Array</t></t></code><code>{</code><code>  return m_length;</code><code>}</code></pre><p>main.cpp:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include "Array.h"</code><code></code><code>int main()</code><code>{</code><code>	Array<int> intArray(12);</int></code><code>	Array<double> doubleArray(12);</double></code><code></code><code>	for (int count{ 0 }; count &lt; intArray.getLength(); ++count)</code><code>	{</code><code>		intArray[count] = count;</code><code>		doubleArray[count] = count + 0.5;</code><code>	}</code><code></code><code>	for (int count{ intArray.getLength() - 1 }; count &gt;= 0; --count)</code><code>		std::cout &lt;&lt; intArray[count] &lt;&lt; '\t' &lt;&lt; doubleArray[count] &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>The above program will compile, but cause a linker error:</p><pre>unresolved external symbol "public: int __thiscall Array&lt;int&gt;::getLength(void)" (<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d0ef97b5a49cb5beb7a4b890">[email&nbsp;protected]</a><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="78475c390a0a19013830">[email&nbsp;protected]</a>@@QAEHXZ)
</pre><p>In order for the compiler to use a template, it must see both the template definition (not just a declaration) and the template type used to instantiate the template. Also remember that C++ compiles files individually. When the Array.h header is #included in main, the template class definition is copied into main.cpp. When the compiler sees that we need two template instances, Array&lt;int&gt;, and Array&lt;double&gt;, it will instantiate these, and compile them as part of main.cpp. However, when it gets around to compiling Array.cpp separately, it will have forgotten that we need an Array&lt;int&gt; and Array&lt;double&gt;, so that template function is never instantiated. Thus, we get a linker error, because the compiler can’t find a definition for Array&lt;int&gt;::getLength() or Array&lt;double&gt;::getLength().</p><p>There are quite a few ways to work around this.</p><p>The easiest way is to simply put all of your template class code in the header file (in this case, put the contents of Array.cpp into Array.h, below the class). In this way, when you #include the header, all of the template code will be in one place. The upside of this solution is that it is simple. The downside here is that if the template class is used in many places, you will end up with many local copies of the template class, which can increase your compile and link times (your linker should remove the duplicate definitions, so it shouldn’t bloat your executable). This is our preferred solution unless the compile or link times start to become a problem.</p><p>If you feel that putting the Array.cpp code into the Array.h header makes the header too long/messy, an alternative is to move the contents of Array.cpp to a new file named Array.inl (.inl stands for inline), and then include Array.inl at the bottom of the Array.h header (inside the header guard). That yields the same result as putting all the code in the header, but helps keep things a little more organized.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>If you use the .inl method and then get a compiler error about duplicate definitions, your compiler is most likely compiling the .inl file as part of the project as if it were a code file. This results in the contents of the .inl getting compiled twice: once when your compiler compiles the .inl, and once when the .cpp file that includes the .inl gets compiled, and we run afoul of the one definition rule. If this happens, you’ll need to exclude the .inl file from being compiled as part of the build.</p><p>Excluding the .inl from the build can usually be done by right clicking on the .inl file in the project view, and then choosing properties. The setting will be somewhere in there. In Visual Studio, set “Exclude From Build” to “Yes”. In Code::Blocks, uncheck “Compile file” and “Link file”.</p></div><p>Other solutions involve #including .cpp files, but we don’t recommend these because of the non-standard usage of #include.</p><p>Another alternative is to use a three-file approach. The template class definition goes in the header. The template class member functions goes in the code file. Then you add a third file, which contains <em>all</em> of the instantiated classes you need:</p><p>templates.cpp:</p><pre class="language-cpp line-numbers"><code>// Ensure the full Array template definition can be seen</code><code>#include "Array.h"</code><code>#include "Array.cpp" // we're breaking best practices here, but only in this one place</code><code></code><code>// #include other .h and .cpp template definitions you need here</code><code></code><code>template class Array<int>; // Explicitly instantiate template Array<int></int></int></code><code>template class Array<double>; // Explicitly instantiate template Array<double></double></double></code><code></code><code>// instantiate other templates here</code></pre><p>The “template class” command causes the compiler to explicitly instantiate the template class. In the above case, the compiler will stencil out definitions for Array&lt;int&gt; and Array&lt;double&gt; inside of templates.cpp. Other code files that want to use these types can include Array.h (to satisfy the compiler), and the linker will link in these explicit type definitions from template.cpp.</p><p>This method may be more efficient (depending on how your compiler and linker handle templates and duplicate definitions), but requires maintaining the templates.cpp file for each program.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">19.2 — Template non-type parameters</h1></header><div class="entry-content" itemprop="articleBody"><p>In previous lessons, you’ve learned how to use template type parameters to create functions and classes that are type independent. A template type parameter is a placeholder type that is substituted for a type passed in as an argument.</p><p>However, template type parameters are not the only type of template parameters available. Template classes and functions can make use of another kind of template parameter known as a non-type parameter.</p><p><strong>Non-type parameters</strong></p><p>A template non-type parameter is a template parameter where the type of the parameter is predefined and is substituted for a constexpr value passed in as an argument.</p><p>A non-type parameter can be any of the following types:</p><ul><li>An integral type</li><li>An enumeration type</li><li>A pointer or reference to a class object</li><li>A pointer or reference to a function</li><li>A pointer or reference to a class member function</li><li>std::nullptr_t</li><li>A floating point type (since C++20)</li></ul><p>In the following example, we create a non-dynamic (static) array class that uses both a type parameter and a non-type parameter. The type parameter controls the data type of the static array, and the integral non-type parameter controls how large the static array is.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t,="" int="" size=""> // size is an integral non-type parameter</typename></code><code>class StaticArray</code><code>{</code><code>private:</code><code>    // The non-type parameter controls the size of the array</code><code>    T m_array[size] {};</code><code></code><code>public:</code><code>    T* getArray();</code><code>	</code><code>    T&amp; operator[](int index)</code><code>    {</code><code>        return m_array[index];</code><code>    }</code><code>};</code><code></code><code>// Showing how a function for a class with a non-type parameter is defined outside of the class</code><code>template <typename t,="" int="" size=""></typename></code><code>T* StaticArray<t, size="">::getArray()</t,></code><code>{</code><code>    return m_array;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    // declare an integer array with room for 12 integers</code><code>    StaticArray<int, 12=""> intArray;</int,></code><code></code><code>    // Fill it up in order, then print it backwards</code><code>    for (int count { 0 }; count &lt; 12; ++count)</code><code>        intArray[count] = count;</code><code></code><code>    for (int count { 11 }; count &gt;= 0; --count)</code><code>        std::cout &lt;&lt; intArray[count] &lt;&lt; ' ';</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    // declare a double buffer with room for 4 doubles</code><code>    StaticArray<double, 4=""> doubleArray;</double,></code><code></code><code>    for (int count { 0 }; count &lt; 4; ++count)</code><code>        doubleArray[count] = 4.4 + 0.1 * count;</code><code></code><code>    for (int count { 0 }; count &lt; 4; ++count)</code><code>        std::cout &lt;&lt; doubleArray[count] &lt;&lt; ' ';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This code produces the following:</p><pre>11 10 9 8 7 6 5 4 3 2 1 0
4.4 4.5 4.6 4.7
</pre><p>One noteworthy thing about the above example is that we do not have to dynamically allocate the m_array member variable! This is because for any given instance of the StaticArray class, size must be constexpr. For example, if you instantiate a StaticArray&lt;int, 12&gt;, the compiler replaces size with 12. Thus m_array is of type int[12], which can be allocated statically.</p><p>This functionality is used by the standard library class std::array. When you allocate a std::array&lt;int, 5&gt;, the int is a type parameter, and the 5 is a non-type parameter!</p><p>Note that if you try to instantiate a template non-type parameter with a non-constexpr value, it will not work:</p><pre class="language-cpp line-numbers"><code>template <int size=""></int></code><code>class Foo</code><code>{</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    int x{ 4 }; // x is non-constexpr</code><code>    Foo<x> f; // error: the template non-type argument must be constexpr</x></code><code></code><code>    return 0;</code><code>}</code></pre><p>In such a case, your compiler will issue an error.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">19.3 — Function template specialization</h1></header><div class="entry-content" itemprop="articleBody"><p>When instantiating a function template for a given type, the compiler stencils out a copy of the templated function and replaces the template type parameters with the actual types used in the variable declaration. This means a particular function will have the same implementation details for each instanced type (just using different types). While most of the time, this is exactly what you want, occasionally there are cases where it is useful to implement a templated function slightly different for a specific data type.</p><p>Template specialization is one way to accomplish this.</p><p>Let’s take a look at a very simple template class:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>class Storage</code><code>{</code><code>private:</code><code>    T m_value {};</code><code>public:</code><code>    Storage(T value)</code><code>      : m_value { value }</code><code>    {</code><code>    }</code><code></code><code>    void print()</code><code>    {</code><code>        std::cout &lt;&lt; m_value &lt;&lt; '\n';</code><code>    }</code><code>};</code></pre><p>The above code will work fine for many data types:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    // Define some storage units</code><code>    Storage<int> nValue { 5 };</int></code><code>    Storage<double> dValue { 6.7 };</double></code><code></code><code>    // Print out some values</code><code>    nValue.print();</code><code>    dValue.print();</code><code>}</code></pre><p>This prints:</p><pre>5
6.7
</pre><p>Now, let’s say we want double values (and only double values) to output in scientific notation. To do so, we can use a <strong>function template specialization</strong> (sometimes called a full or explicit function template specialization) to create a specialized version of the print() function for type double. This is extremely simple: simply define the specialized function (if the function is a member function, do so outside of the class definition), replacing the template type with the specific type you wish to redefine the function for. Here is our specialized print() function for doubles:</p><pre class="language-cpp line-numbers"><code>template &lt;&gt;</code><code>void Storage<double>::print()</double></code><code>{</code><code>    std::cout &lt;&lt; std::scientific &lt;&lt; m_value &lt;&lt; '\n';</code><code>}</code></pre><p>When the compiler goes to instantiate Storage&lt;double&gt;::print(), it will see we’ve already explicitly defined that function, and it will use the one we’ve defined instead of stenciling out a version from the generic templated class.</p><p>The template &lt;&gt; tells the compiler that this is a template function, but that there are no template parameters (since in this case, we’re explicitly specifying all of the types). Some compilers may allow you to omit this, but it’s correct to include it.</p><p>As a result, when we rerun the above program, it will print:</p><pre>5
6.700000e+000
</pre><p><strong>Another example</strong></p><p>Now let’s take a look at another example where template specialization can be useful. Consider what happens if we try to use our templated Storage class with datatype const char*:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>template <typename t=""></typename></code><code>class Storage</code><code>{</code><code>private:</code><code>    T m_value {};</code><code>public:</code><code>    Storage(T value)</code><code>      : m_value { value }</code><code>    {</code><code>    }</code><code></code><code>    void print()</code><code>    {</code><code>        std::cout &lt;&lt; m_value &lt;&lt; '\n';</code><code>    }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    // Dynamically allocate a temporary string</code><code>    std::string s;</code><code></code><code>    // Ask user for their name</code><code>    std::cout &lt;&lt; "Enter your name: ";</code><code>    std::cin &gt;&gt; s;</code><code></code><code>    // Store the name</code><code>    Storage<char*> storage(s.data());</char*></code><code></code><code>    storage.print(); // Prints our name</code><code></code><code>    s.clear(); // clear the std::string</code><code></code><code>    storage.print(); // Prints nothing</code><code>}</code></pre><p>As it turns out, instead of printing the name, the second storage.print() prints nothing! What’s going on here?</p><p>When Storage is instantiated for type char*, the constructor for Storage&lt;char*&gt; looks like this:</p><pre class="language-cpp line-numbers"><code>template &lt;&gt;</code><code>Storage<char*>::Storage(char* value)</char*></code><code>      : m_value { value }</code><code>{</code><code>}</code></pre><p>In other words, this just does a pointer assignment (shallow copy)! As a result, m_value ends up pointing at the same memory location as string. When we delete string in main(), we end up deleting the value that m_value was pointing at! And thus, we get garbage when trying to print that value.</p><p>Fortunately, we can fix this problem using template specialization. Instead of doing a pointer copy, we’d really like our constructor to make a copy of the input string. So let’s write a specialized constructor for datatype char* that does exactly that:</p><pre class="language-cpp line-numbers"><code>template &lt;&gt;</code><code>Storage<char*>::Storage(char* const value)</char*></code><code>{</code><code>    if (!value)</code><code>        return;</code><code></code><code>    // Figure out how long the string in value is</code><code>    int length { 0 };</code><code>    while (value[length] != '\0')</code><code>        ++length;</code><code>    ++length; // +1 to account for null terminator</code><code></code><code>    // Allocate memory to hold the value string</code><code>    m_value = new char[length];</code><code></code><code>    // Copy the actual value string into the m_value memory we just allocated</code><code>    for (int count=0; count &lt; length; ++count)</code><code>        m_value[count] = value[count];</code><code>}</code></pre><p>Now when we allocate a variable of type Storage&lt;char*&gt;, this constructor will get used instead of the default one. As a result, m_value will receive its own copy of string. Consequently, when we delete string, m_value will be unaffected.</p><p>However, this class now has a memory leak for type char*, because m_value will not be deleted when a Storage<char> variable goes out of scope. As you might have guessed, this can also be solved by specializing a Storage&lt;char*&gt; destructor:</char></p><pre class="language-cpp line-numbers"><code>template &lt;&gt;</code><code>Storage<char*>::~Storage()</char*></code><code>{</code><code>    delete[] m_value;</code><code>}</code></pre><p>That way, when variables of type Storage&lt;char*&gt; go out of scope, the memory allocated in the specialized constructor will be deleted in the specialized destructor.</p><p>However, perhaps surprisingly, the above specialized destructor won’t compile. This is because a specialized function must specialize an explicit function (not one that the compiler is providing a default for). Since we didn’t define a destructor in Storage&lt;T&gt;, the compiler is providing a default destructor for us, and thus we can’t provide a specialization. To solve this issue, we must explicitly define a destructor in Storage&lt;T&gt; Here’s the full code:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>template <typename t=""></typename></code><code>class Storage</code><code>{</code><code>private:</code><code>    T m_value{};</code><code>public:</code><code>    Storage(T value)</code><code>        : m_value{ value }</code><code>    {</code><code>    }</code><code>    ~Storage() {}; // need an explicitly defined destructor to specialize</code><code></code><code>    void print()</code><code>    {</code><code>        std::cout &lt;&lt; m_value &lt;&lt; '\n';</code><code>    }</code><code>};</code><code></code><code>template &lt;&gt;</code><code>Storage<char*>::Storage(char* const value)</char*></code><code>{</code><code>    if (!value)</code><code>        return;</code><code></code><code>    // Figure out how long the string in value is</code><code>    int length{ 0 };</code><code>    while (value[length] != '\0')</code><code>        ++length;</code><code>    ++length; // +1 to account for null terminator</code><code></code><code>    // Allocate memory to hold the value string</code><code>    m_value = new char[length];</code><code></code><code>    // Copy the actual value string into the m_value memory we just allocated</code><code>    for (int count = 0; count &lt; length; ++count)</code><code>        m_value[count] = value[count];</code><code>}</code><code></code><code>template &lt;&gt;</code><code>Storage<char*>::~Storage()</char*></code><code>{</code><code>    delete[] m_value;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    // Dynamically allocate a temporary string</code><code>    std::string s;</code><code></code><code>    // Ask user for their name </code><code>    std::cout &lt;&lt; "Enter your name: ";</code><code>    std::cin &gt;&gt; s;</code><code></code><code>    // Store the name</code><code>    Storage<char*> storage(s.data());</char*></code><code></code><code>    storage.print(); // Prints our name</code><code></code><code>    s.clear(); // clear the std::string</code><code></code><code>    storage.print(); // Prints our name</code><code>}</code></pre><p>Although the above examples have all used member functions, you can also specialize non-member template functions in the same way.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">19.4 — Class template specialization</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson <a href="https://www.learncpp.com/cpp-tutorial/function-template-specialization/">19.3 -- Function template specialization</a>, we saw how it was possible to specialize functions in order to provide different functionality for specific data types. As it turns out, it is not only possible to specialize functions, it is also possible to specialize an entire class!</p><p>Consider the case where you want to design a class that stores 8 objects. Here’s a simplified class to do so:</p><pre class="language-cpp line-numbers"><code>template <typename t=""></typename></code><code>class Storage8</code><code>{</code><code>private:</code><code>    T m_array[8];</code><code></code><code>public:</code><code>    void set(int index, const T&amp; value)</code><code>    {</code><code>        m_array[index] = value;</code><code>    }</code><code></code><code>    const T&amp; get(int index) const</code><code>    {</code><code>        return m_array[index];</code><code>    }</code><code>};</code></pre><p>Because this class is templated, it will work fine for any given type:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    // Define a Storage8 for integers</code><code>    Storage8<int> intStorage;</int></code><code></code><code>    for (int count{ 0 }; count &lt; 8; ++count)</code><code>        intStorage.set(count, count);</code><code></code><code>    for (int count{ 0 }; count &lt; 8; ++count)</code><code>        std::cout &lt;&lt; intStorage.get(count) &lt;&lt; '\n';</code><code></code><code>    // Define a Storage8 for bool</code><code>    Storage8<bool> boolStorage;</bool></code><code>    for (int count{ 0 }; count &lt; 8; ++count)</code><code>        boolStorage.set(count, count &amp; 3);</code><code></code><code>	std::cout &lt;&lt; std::boolalpha;</code><code></code><code>    for (int count{ 0 }; count &lt; 8; ++count)</code><code>    {</code><code>        std::cout &lt;&lt; boolStorage.get(count) &lt;&lt; '\n';</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>This example prints:</p><pre>0
1
2
3
4
5
6
7
false
true
true
true
false
true
true
true
</pre><p>While this class is completely functional, it turns out that the implementation of Storage8&lt;bool&gt; is much more inefficient than it needs to be. Because all variables must have an address, and the CPU can’t address anything smaller than a byte, all variables must be at least a byte in size. Consequently, a variable of type bool ends up using an entire byte even though technically it only needs a single bit to store its true or false value! Thus, a bool is 1 bit of useful information and 7 bits of wasted space. Our Storage8&lt;bool&gt; class, which contains 8 bools, is 1 byte worth of useful information and 7 bytes of wasted space.</p><p>As it turns out, using some basic bit logic, it’s possible to compress all 8 bools into a single byte, eliminating the wasted space altogether. However, in order to do this, we’ll need to revamp the class when used with type bool, replacing the array of 8 bools with a variable that is a single byte in size. While we could create an entirely new class to do so, this has one major downside: we have to give it a different name. Then the programmer has to remember that Storage8&lt;T&gt; is meant for non-bool types, whereas Storage8Bool (or whatever we name the new class) is meant for bools. That’s needless complexity we’d rather avoid. Fortunately, C++ provides us a better method: class template specialization.</p><p><strong>Class template specialization</strong></p><p>Class template specialization allows us to specialize a template class for a particular data type (or data types, if there are multiple template parameters). In this case, we’re going to use class template specialization to write a customized version of Storage8&lt;bool&gt; that will take precedence over the generic Storage8&lt;T&gt; class. This works analogously to how a specialized function takes precedence over a generic template function.</p><p>Class template specializations are treated as completely independent classes, even though they are allocated in the same way as the templated class. This means that we can change anything and everything about our specialization class, including the way it’s implemented and even the functions it makes public, just as if it were an independent class. Here’s our specialized class:</p><pre class="language-cpp line-numbers"><code>// Requires the Storage8 type definition from above</code><code></code><code>template &lt;&gt; // the following is a template class with no templated parameters</code><code>class Storage8<bool> // we're specializing Storage8 for bool</bool></code><code>{</code><code>// What follows is just standard class implementation details</code><code>private:</code><code>    unsigned char m_data{};</code><code></code><code>public:</code><code>    void set(int index, bool value)</code><code>    {</code><code>        // Figure out which bit we're setting/unsetting</code><code>        // This will put a 1 in the bit we're interested in turning on/off</code><code>        auto mask{ 1 &lt;&lt; index };</code><code></code><code>        if (value)  // If we're setting a bit</code><code>            m_data |= mask;   // use bitwise-or to turn that bit on</code><code>        else  // if we're turning a bit off</code><code>            m_data &amp;= ~mask;  // bitwise-and the inverse mask to turn that bit off</code><code>	}</code><code>	</code><code>    bool get(int index)</code><code>    {</code><code>        // Figure out which bit we're getting</code><code>        auto mask{ 1 &lt;&lt; index };</code><code>        // bitwise-and to get the value of the bit we're interested in</code><code>        // Then implicit cast to boolean</code><code>        return (m_data &amp; mask);</code><code>    }</code><code>};</code></pre><p>First, note that we start off with <code>template&lt;&gt;</code>. The template keyword tells the compiler that what follows is templated, and the empty angle braces means that there aren’t any template parameters. In this case, there aren’t any template parameters because we’re replacing the only template parameter (T) with a specific type (bool).</p><p>Next, we add <code><bool></bool></code> to the class name to denote that we’re specializing a bool version of class Storage8.</p><p>All of the other changes are just class implementation details. You do not need to understand how the bit-logic works in order to use the class (though you can review <a href="https://www.learncpp.com/cpp-tutorial/bitwise-operators/">O.2 -- Bitwise operators</a> if you want to figure it out, but need a refresher on how bitwise operators work).</p><p>Note that this specialization class utilizes a single unsigned char (1 byte) instead of an array of 8 bools (8 bytes).</p><p>Now, when we declare a class of type Storage8&lt;T&gt;, where T is not a bool, we’ll get a version stenciled from the generic templated Storage8&lt;T&gt; class. When we declare a class of type Storage8&lt;bool&gt;, we’ll get the specialized version we just created. Note that we have kept the publicly exposed interface of both classes the same -- while C++ gives us free reign to add, remove, or change functions of Storage8&lt;bool&gt; as we see fit, keeping a consistent interface means the programmer can use either class in exactly the same manner.</p><p>We can use the exact same example as before to show both Storage8&lt;T&gt; and Storage8&lt;bool&gt; being instantiated:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    // Define a Storage8 for integers (instantiates Storage8<t>, where T = int)</t></code><code>    Storage8<int> intStorage;</int></code><code></code><code>    for (int count{ 0 }; count &lt; 8; ++count)</code><code>    {</code><code>        intStorage.set(count, count);</code><code>	}</code><code></code><code>    for (int count{ 0 }; count &lt; 8; ++count)</code><code>    {</code><code>        std::cout &lt;&lt; intStorage.get(count) &lt;&lt; '\n';</code><code>    }</code><code></code><code>    // Define a Storage8 for bool  (instantiates Storage8<bool> specialization)</bool></code><code>    Storage8<bool> boolStorage;</bool></code><code>    </code><code>    for (int count{ 0 }; count &lt; 8; ++count)</code><code>    {</code><code>        boolStorage.set(count, count &amp; 3);</code><code>    }</code><code></code><code>	std::cout &lt;&lt; std::boolalpha;</code><code></code><code>    for (int count{ 0 }; count &lt; 8; ++count)</code><code>    {</code><code>        std::cout &lt;&lt; boolStorage.get(count) &lt;&lt; '\n';</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>As you might expect, this prints the same result as the previous example that used the non-specialized version of Storage8&lt;bool&gt;:</p><pre>0
1
2
3
4
5
6
7
false
true
true
true
false
true
true
true
</pre><p>It’s worth noting that keeping the public interface between your template class and all of the specializations similar is generally a good idea, as it makes them easier to use -- however, it’s not strictly necessary.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">19.5 — Partial template specialization</h1></header><div class="entry-content" itemprop="articleBody"><p>This lesson and the next are optional reading for those desiring a deeper knowledge of C++ templates. Partial template specialization is not used all that often (but can be useful in specific cases).</p><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/template-non-type-parameters/">19.2 -- Template non-type parameters</a>, you learned how expression parameters could be used to parameterize template classes.</p><p>Let’s take another look at the Static Array class we used in one of our previous examples:</p><pre class="language-cpp line-numbers"><code>template <typename t,="" int="" size=""> // size is the expression parameter</typename></code><code>class StaticArray</code><code>{</code><code>private:</code><code>    // The expression parameter controls the size of the array</code><code>    T m_array[size]{};</code><code> </code><code>public:</code><code>    T* getArray() { return m_array; }</code><code>	</code><code>    T&amp; operator[](int index)</code><code>    {</code><code>        return m_array[index];</code><code>    }</code><code>};</code></pre><p>This class takes two template parameters, a type parameter, and an expression parameter.</p><p>Now, let’s say we wanted to write a function to print out the whole array. Although we could implement this as a member function, we’re going to do it as a non-member function instead because it will make the successive examples easier to follow.</p><p>Using templates, we might write something like this:</p><pre class="language-cpp line-numbers"><code>template <typename t,="" int="" size=""></typename></code><code>void print(StaticArray<t, size="">&amp; array)</t,></code><code>{</code><code>    for (int count{ 0 }; count &lt; size; ++count)</code><code>        std::cout &lt;&lt; array[count] &lt;&lt; ' ';</code><code>}</code></pre><p>This would allow us to do the following:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cstring></cstring></code><code></code><code>template <typename t,="" int="" size=""> // size is the expression parameter</typename></code><code>class StaticArray</code><code>{</code><code>private:</code><code>	// The expression parameter controls the size of the array</code><code>	T m_array[size]{};</code><code></code><code>public:</code><code>	T* getArray() { return m_array; }</code><code></code><code>	T&amp; operator[](int index)</code><code>	{</code><code>		return m_array[index];</code><code>	}</code><code>};</code><code></code><code>template <typename t,="" int="" size=""></typename></code><code>void print(StaticArray<t, size="">&amp; array)</t,></code><code>{</code><code>	for (int count{ 0 }; count &lt; size; ++count)</code><code>		std::cout &lt;&lt; array[count] &lt;&lt; ' ';</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	// declare an int array</code><code>	StaticArray<int, 4=""> int4{};</int,></code><code>	int4[0] = 0;</code><code>	int4[1] = 1;</code><code>	int4[2] = 2;</code><code>	int4[3] = 3;</code><code></code><code>	// Print the array</code><code>	print(int4);</code><code></code><code>	return 0;</code><code>}</code></pre><p>and get the following result:</p><pre>0 1 2 3
</pre><p>Although this works, it has a design flaw. Consider the following:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    // declare a char array</code><code>    StaticArray<char, 14=""> char14{};</char,></code><code></code><code>    std::strcpy(char14.getArray(), "Hello, world!");</code><code></code><code>    // Print the array</code><code>    print(char14);</code><code></code><code>    return 0;</code><code>}</code></pre><p>(We covered std::strcpy in lesson <a href="https://www.learncpp.com/cpp-tutorial/c-style-strings/">11.6 -- C-style strings</a> if you need a refresher)</p><p>This program will compile, execute, and produce the following value (or one similar):</p><pre>H e l l o ,   w o r l d !
</pre><p>For non-char types, it makes sense to put a space between each array element, so they don’t run together. However, with a char type, it makes more sense to print everything run together as a C-style string, which our print() function doesn’t do.</p><p>So how can we fix this?</p><p><strong>Template specialization to the rescue?</strong></p><p>One might first think of using template specialization. The problem with full template specialization is that all template parameters must be explicitly defined.</p><p>Consider:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cstring></cstring></code><code></code><code>template <typename t,="" int="" size=""> // size is the expression parameter</typename></code><code>class StaticArray</code><code>{</code><code>private:</code><code>	// The expression parameter controls the size of the array</code><code>	T m_array[size]{};</code><code></code><code>public:</code><code>	T* getArray() { return m_array; }</code><code></code><code>	T&amp; operator[](int index)</code><code>	{</code><code>		return m_array[index];</code><code>	}</code><code>};</code><code></code><code>template <typename t,="" int="" size=""></typename></code><code>void print(StaticArray<t, size="">&amp; array)</t,></code><code>{</code><code>	for (int count{ 0 }; count &lt; size; ++count)</code><code>		std::cout &lt;&lt; array[count] &lt;&lt; ' ';</code><code>}</code><code></code><code>// Override print() for fully specialized StaticArray<char, 14=""></char,></code><code>template &lt;&gt;</code><code>void print(StaticArray<char, 14="">&amp; array)</char,></code><code>{</code><code>	for (int count{ 0 }; count &lt; 14; ++count)</code><code>		std::cout &lt;&lt; array[count];</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    // declare a char array</code><code>    StaticArray<char, 14=""> char14{};</char,></code><code></code><code>    std::strcpy(char14.getArray(), "Hello, world!");</code><code></code><code>    // Print the array</code><code>    print(char14);</code><code></code><code>    return 0;</code><code>}</code></pre><p>As you can see, we’ve now provided an overloaded print function for fully specialized StaticArray&lt;char, 14&gt;. Indeed, this prints:</p><pre>Hello, world!
</pre><p>Although this solves the issue of making sure print() can be called with a StaticArray&lt;char, 14&gt;, it brings up another problem: using full template specialization means we have to explicitly define the length of the array this function will accept! Consider the following example:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    // declare a char array</code><code>    StaticArray<char, 12=""> char12{};</char,></code><code></code><code>    std::strcpy(char12.getArray(), "Hello, mom!");</code><code></code><code>    // Print the array</code><code>    print(char12);</code><code></code><code>    return 0;</code><code>}</code></pre><p>Calling print() with char12 will call the version of print() that takes a StaticArray&lt;T, size&gt;, because char12 is of type StaticArray&lt;char, 12&gt;, and our overloaded print() will only be called when passed a StaticArray&lt;char, 14&gt;.</p><p>Although we could make a copy of print() that handles StaticArray&lt;char, 12&gt;, what happens when we want to call print() with an array size of 5, or 22? We’d have to copy the function for each different array size. That’s redundant.</p><p>Obviously full template specialization is too restrictive a solution here. The solution we are looking for is partial template specialization.</p><p><strong>Partial template specialization</strong></p><p>Partial template specialization allows us to specialize classes (but not individual functions!) where some, but not all, of the template parameters have been explicitly defined. For our challenge above, the ideal solution would be to have our overloaded print function work with StaticArray of type char, but leave the length expression parameter templated so it can vary as needed. Partial template specialization allows us to do just that!</p><p>Here’s our example with an overloaded print function that takes a partially specialized StaticArray:</p><pre class="language-cpp line-numbers"><code>// overload of print() function for partially specialized StaticArray<char, size=""></char,></code><code>template <int size=""> // size is still a templated expression parameter</int></code><code>void print(StaticArray<char, size="">&amp; array) // we're explicitly defining type char here</char,></code><code>{</code><code>	for (int count{ 0 }; count &lt; size; ++count)</code><code>		std::cout &lt;&lt; array[count];</code><code>}</code></pre><p>As you can see here, we’ve explicitly declared that this function will only work for StaticArray of type char, but size is still a templated expression parameter, so it will work for char arrays of any size. That’s all there is to it!</p><p>Here’s a full program using this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cstring></cstring></code><code></code><code>template <typename t,="" int="" size=""> // size is the expression parameter</typename></code><code>class StaticArray</code><code>{</code><code>private:</code><code>	// The expression parameter controls the size of the array</code><code>	T m_array[size]{};</code><code></code><code>public:</code><code>	T* getArray() { return m_array; }</code><code></code><code>	T&amp; operator[](int index)</code><code>	{</code><code>		return m_array[index];</code><code>	}</code><code>};</code><code></code><code>template <typename t,="" int="" size=""></typename></code><code>void print(StaticArray<t, size="">&amp; array)</t,></code><code>{</code><code>	for (int count{ 0 }; count &lt; size; ++count)</code><code>		std::cout &lt;&lt; array[count] &lt;&lt; ' ';</code><code>}</code><code></code><code>// overload of print() function for partially specialized StaticArray<char, size=""></char,></code><code>template <int size=""></int></code><code>void print(StaticArray<char, size="">&amp; array)</char,></code><code>{</code><code>	for (int count{ 0 }; count &lt; size; ++count)</code><code>		std::cout &lt;&lt; array[count];</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	// Declare an char array of size 14</code><code>	StaticArray<char, 14=""> char14{};</char,></code><code></code><code>	std::strcpy(char14.getArray(), "Hello, world!");</code><code></code><code>	// Print the array</code><code>	print(char14);</code><code></code><code>	std::cout &lt;&lt; ' ';</code><code></code><code>	// Now declare an char array of size 12</code><code>	StaticArray<char, 12=""> char12{};</char,></code><code></code><code>	std::strcpy(char12.getArray(), "Hello, mom!");</code><code></code><code>	// Print the array</code><code>	print(char12);</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>Hello, world! Hello, mom!
</pre><p>Just as we expect.</p><p>Partial template specialization can only be used with classes, not template functions (functions must be fully specialized). Our void print(StaticArray&lt;char, size&gt; &amp;array) example works because the print function is not partially specialized (it’s just an overloaded function using a class parameter that’s partially specialized).</p><p><strong>Partial template specialization for member functions</strong></p><p>The limitation on the partial specialization of functions can lead to some challenges when dealing with member functions. For example, what if we had defined StaticArray like this?</p><pre class="language-cpp line-numbers"><code>template <typename t,="" int="" size=""> // size is the expression parameter</typename></code><code>class StaticArray</code><code>{</code><code>private:</code><code>    // The expression parameter controls the size of the array</code><code>    T m_array[size]{};</code><code> </code><code>public:</code><code>    T* getArray() { return m_array; }</code><code>	</code><code>    T&amp; operator[](int index)</code><code>    {</code><code>        return m_array[index];</code><code>    }</code><code></code><code>    void print()</code><code>    {</code><code>        for (int i{ 0 }; i &lt; size; ++i)</code><code>            std::cout &lt;&lt; m_array[i] &lt;&lt; ' ';</code><code>        std::cout &lt;&lt; '\n';</code><code>    }</code><code>};</code></pre><p>print() is now a member function of class StaticArray&lt;T, int&gt;. So what happens when we want to partially specialize print(), so that it works differently? You might try this:</p><pre class="language-cpp line-numbers"><code>// Doesn't work</code><code>template <int size=""></int></code><code>void StaticArray<double, size="">::print()</double,></code><code>{</code><code>	for (int i{ 0 }; i &lt; size; ++i)</code><code>		std::cout &lt;&lt; std::scientific &lt;&lt; m_array[i] &lt;&lt; ' ';</code><code>	std::cout &lt;&lt; '\n';</code><code>}</code></pre><p>Unfortunately, this doesn’t work, because we’re trying to partially specialize a function, which is disallowed.</p><p>So how do we get around this? One obvious way is to partially specialize the entire class:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t,="" int="" size=""> // size is the expression parameter</typename></code><code>class StaticArray</code><code>{</code><code>private:</code><code>	// The expression parameter controls the size of the array</code><code>	T m_array[size]{};</code><code></code><code>public:</code><code>	T* getArray() { return m_array; }</code><code></code><code>	T&amp; operator[](int index)</code><code>	{</code><code>		return m_array[index];</code><code>	}</code><code>	void print()</code><code>	{</code><code>		for (int i{ 0 }; i &lt; size; ++i)</code><code>			std::cout &lt;&lt; m_array[i] &lt;&lt; ' ';</code><code>		std::cout &lt;&lt; '\n';</code><code>	}</code><code>};</code><code></code><code>template <int size=""> // size is the expression parameter</int></code><code>class StaticArray<double, size=""></double,></code><code>{</code><code>private:</code><code>	// The expression parameter controls the size of the array</code><code>	double m_array[size]{};</code><code></code><code>public:</code><code>	double* getArray() { return m_array; }</code><code></code><code>	double&amp; operator[](int index)</code><code>	{</code><code>		return m_array[index];</code><code>	}</code><code>	void print()</code><code>	{</code><code>		for (int i{ 0 }; i &lt; size; ++i)</code><code>			std::cout &lt;&lt; std::scientific &lt;&lt; m_array[i] &lt;&lt; ' ';</code><code>		std::cout &lt;&lt; '\n';</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	// declare an integer array with room for 6 integers</code><code>	StaticArray<int, 6=""> intArray{};</int,></code><code></code><code>	// Fill it up in order, then print it</code><code>	for (int count{ 0 }; count &lt; 6; ++count)</code><code>		intArray[count] = count;</code><code></code><code>	intArray.print();</code><code></code><code>	// declare a double buffer with room for 4 doubles</code><code>	StaticArray<double, 4=""> doubleArray{};</double,></code><code></code><code>	for (int count{ 0 }; count &lt; 4; ++count)</code><code>		doubleArray[count] = (4.0 + 0.1 * count);</code><code></code><code>	doubleArray.print();</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>0 1 2 3 4 5
4.000000e+00 4.100000e+00 4.200000e+00 4.300000e+00
</pre><p>While it works, this isn’t a great solution, because we had to duplicate a lot of code from StaticArray&lt;T, size&gt; to StaticArray&lt;double, size&gt;.</p><p>If only there were some way to reuse the code in StaticArray&lt;T, size&gt; in StaticArray&lt;double, size&gt;. Sounds like a job for inheritance!</p><p>You might start off trying to write that code like this:</p><pre class="language-cpp line-numbers"><code>template <int size=""> // size is the expression parameter</int></code><code>class StaticArray<double, size="">: public StaticArray&lt; // Then what?</double,></code></pre><p>How do we reference StaticArray<t size="">? We can’t.</t></p><p>Fortunately, there’s a workaround, by using a common base class:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t,="" int="" size=""> // size is the expression parameter</typename></code><code>class StaticArray_Base</code><code>{</code><code>protected:</code><code>	// The expression parameter controls the size of the array</code><code>	T m_array[size]{};</code><code></code><code>public:</code><code>	T* getArray() { return m_array; }</code><code></code><code>	T&amp; operator[](int index)</code><code>	{</code><code>		return m_array[index];</code><code>	}</code><code></code><code>	void print()</code><code>	{</code><code>		for (int i{ 0 }; i &lt; size; ++i)</code><code>			std::cout &lt;&lt; m_array[i] &lt;&lt; ' ';</code><code>		std::cout &lt;&lt; '\n';</code><code>	}</code><code></code><code>	virtual ~StaticArray_Base() = default;</code><code>};</code><code></code><code>template <typename t,="" int="" size=""> // size is the expression parameter</typename></code><code>class StaticArray: public StaticArray_Base<t, size=""></t,></code><code>{</code><code>};</code><code></code><code>template <int size=""> // size is the expression parameter</int></code><code>class StaticArray<double, size="">: public StaticArray_Base<double, size=""></double,></double,></code><code>{</code><code>public:</code><code></code><code>	void print()</code><code>	{</code><code>		for (int i{ 0 }; i &lt; size; ++i)</code><code>			std::cout &lt;&lt; std::scientific &lt;&lt; this-&gt;m_array[i] &lt;&lt; ' ';</code><code>// note: The this-&gt; prefix in the above line is needed.</code><code>// See https://stackoverflow.com/a/6592617 or https://isocpp.org/wiki/faq/templates#nondependent-name-lookup-members for more info on why.</code><code>		std::cout &lt;&lt; '\n';</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	// declare an integer array with room for 6 integers</code><code>	StaticArray<int, 6=""> intArray{};</int,></code><code></code><code>	// Fill it up in order, then print it</code><code>	for (int count{ 0 }; count &lt; 6; ++count)</code><code>		intArray[count] = count;</code><code></code><code>	intArray.print();</code><code></code><code>	// declare a double buffer with room for 4 doubles</code><code>	StaticArray<double, 4=""> doubleArray{};</double,></code><code></code><code>	for (int count{ 0 }; count &lt; 4; ++count)</code><code>		doubleArray[count] = (4.0 + 0.1 * count);</code><code></code><code>	doubleArray.print();</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints the same as above, but has significantly less duplicated code.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">19.6 — Partial template specialization for pointers</h1></header><div class="entry-content" itemprop="articleBody"><p>In previous lesson <a href="https://www.learncpp.com/cpp-tutorial/function-template-specialization/">19.3 -- Function template specialization</a>, we took a look at a simple templated Storage class:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>class Storage</code><code>{</code><code>private:</code><code>    T m_value;</code><code>public:</code><code>    Storage(T value)</code><code>        : m_value { value }</code><code>    {</code><code>    }</code><code> </code><code>    ~Storage()</code><code>    {</code><code>    }</code><code> </code><code>    void print() const</code><code>    {</code><code>        std::cout &lt;&lt; m_value &lt;&lt; '\n';</code><code>    }</code><code>};</code></pre><p>We showed that this class had problems when template parameter T was of type char* because of the shallow copy/pointer assignment that takes place in the constructor. In that lesson, we used full template specialization to create a specialized version of the Storage constructor for type char* that allocated memory and created an actual deep copy of m_value. For reference, here’s the fully specialized char* Storage constructor and destructor:</p><pre class="language-cpp line-numbers"><code>// You need to include the Storage<t> class from the example above here</t></code><code></code><code>template &lt;&gt;</code><code>Storage<char*>::Storage(char* value)</char*></code><code>{</code><code>    // Figure out how long the string in value is</code><code>    int length { 0 };</code><code></code><code>    while (value[length] != '\0')</code><code>        ++length;</code><code>    ++length; // +1 to account for null terminator</code><code> </code><code>    // Allocate memory to hold the value string</code><code>    m_value = new char[length];</code><code> </code><code>    // Copy the actual value string into the m_value memory we just allocated</code><code>    for (int count=0; count &lt; length; ++count)</code><code>        m_value[count] = value[count];</code><code>}</code><code></code><code>template&lt;&gt;</code><code>Storage<char*>::~Storage()</char*></code><code>{</code><code>	delete[] m_value;</code><code>}</code></pre><p>While that worked great for Storage&lt;char*&gt;, what about other pointer types (such as int*)? It’s fairly easy to see that if T is any pointer type, then we run into the problem of the constructor doing a pointer assignment instead of making an actual deep copy of the element being pointed to.</p><p>Because full template specialization forces us to fully resolve templated types, in order to fix this issue we’d have to define a new specialized constructor (and destructor) for each and every pointer type we wanted to use Storage with! This leads to lots of duplicate code, which as you well know by now is something we want to avoid as much as possible.</p><p>Fortunately, partial template specialization offers us a convenient solution. In this case, we’ll use class partial template specialization to define a special version of the Storage class that works for pointer values. This class is considered partially specialized because we’re telling the compiler that it’s only for use with pointer types, even though we haven’t specified the underlying type exactly.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// You need to include the Storage<t> class from the example above here</t></code><code></code><code>template <typename t=""></typename></code><code>class Storage<t*> // this is a partial-specialization of Storage that works with pointer types</t*></code><code>{</code><code>private:</code><code>    T* m_value;</code><code>public:</code><code>    Storage(T* value) // for pointer type T</code><code>        : m_value { new T { *value } } // this copies a single value, not an array</code><code>    {</code><code>    }</code><code></code><code>    ~Storage()</code><code>    {</code><code>        delete m_value; // so we use scalar delete here, not array delete</code><code>    }</code><code></code><code>    void print() const</code><code>    {</code><code>        std::cout &lt;&lt; *m_value &lt;&lt; '\n';</code><code>    }</code><code>};</code></pre><p>And an example of this working:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	// Declare a non-pointer Storage to show it works</code><code>	Storage<int> myint { 5 };</int></code><code>	myint.print();</code><code></code><code>	// Declare a pointer Storage to show it works</code><code>	int x { 7 };</code><code>	Storage<int*> myintptr { &amp;x };</int*></code><code></code><code>	// Let's show that myintptr is separate from x.</code><code>	// If we change x, myintptr should not change</code><code>	x = 9;</code><code>	myintptr.print();</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints the value:</p><pre>5
7
</pre><p>When myintptr is defined with an int* template parameter, the compiler sees that we have defined a partially specialized template class that works with any pointer type, and instantiates a version of Storage<int> using that template. The constructor of that class makes a deep copy of parameter x. Later, when we change x to 9, the myintptr.m_value is not affected because it’s pointing at its own separate copy of the value.</int></p><p>If the partial template specialization class did not exist, myintptr would have used the normal (non-partially-specialized) version of the template. The constructor of that class does a shallow copy pointer assignment, which means that myintptr.m_value and x would be referencing the same address. Then when we changed the value of x to 9, we would have changed myintptr’s value too.</p><p>It’s worth noting that because this partially specialized Storage class only allocates a single value, for C-style strings, only the first character will be copied. If the desire is to copy entire strings, a specialization of the constructor (and destructor) for type char* can be fully specialized. The fully specialized version will take precedence over the partially specialized version. Here’s an example program that uses both partial specialization for pointers, and full specialization for char*:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cstring></cstring></code><code></code><code>// Our Storage class for non-pointers</code><code>template <typename t=""></typename></code><code>class Storage</code><code>{</code><code>private:</code><code>	T m_value;</code><code>public:</code><code>	Storage(T value)</code><code>        : m_value { value }</code><code>	{</code><code>	}</code><code></code><code>	~Storage()</code><code>	{</code><code>	}</code><code></code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; m_value &lt;&lt; '\n';</code><code>	}</code><code>};</code><code></code><code>// Partial-specialization of Storage class for pointers</code><code>template <typename t=""></typename></code><code>class Storage<t*></t*></code><code>{</code><code>private:</code><code>	T* m_value;</code><code>public:</code><code>	Storage(T* value)</code><code>            : m_value { new T { *value } } // this copies a single value, not an array</code><code>	{</code><code>	}</code><code></code><code>	~Storage()</code><code>	{</code><code>		delete m_value;</code><code>	}</code><code></code><code>	void print() const</code><code>	{</code><code>		std::cout &lt;&lt; *m_value &lt;&lt; '\n';</code><code>	}</code><code>};</code><code></code><code>// Full specialization of constructor for type char*</code><code>template &lt;&gt;</code><code>Storage<char*>::Storage(char* value)</char*></code><code>{</code><code>	// Figure out how long the string in value is</code><code>	int length { 0 };</code><code>	while (value[length] != '\0')</code><code>		++length;</code><code>	++length; // +1 to account for null terminator</code><code></code><code>	// Allocate memory to hold the value string</code><code>	m_value = new char[length];</code><code></code><code>	// Copy the actual value string into the m_value memory we just allocated</code><code>	for (int count = 0; count &lt; length; ++count)</code><code>		m_value[count] = value[count];</code><code>}</code><code></code><code>// Full specialization of destructor for type char*</code><code>template&lt;&gt;</code><code>Storage<char*>::~Storage()</char*></code><code>{</code><code>	delete[] m_value;</code><code>}</code><code></code><code>// Full specialization of print function for type char*</code><code>// Without this, printing a Storage<char*> would call Storage<t*>::print(), which only prints the first char</t*></char*></code><code>template&lt;&gt;</code><code>void Storage<char*>::print() const</char*></code><code>{</code><code>	std::cout &lt;&lt; m_value;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	// Declare a non-pointer Storage to show it works</code><code>	Storage<int> myint { 5 };</int></code><code>	myint.print();</code><code></code><code>	// Declare a pointer Storage to show it works</code><code>	int x { 7 };</code><code>	Storage<int*> myintptr { &amp;x };</int*></code><code></code><code>	// If myintptr did a pointer assignment on x,</code><code>	// then changing x will change myintptr too</code><code>	x = 9;</code><code>	myintptr.print();</code><code></code><code>	// Dynamically allocate a temporary string</code><code>	char* name { new char[40]{ "Alex" } };</code><code></code><code>	// Store the name</code><code>	Storage<char*> myname { name };</char*></code><code></code><code>	// Delete the temporary string</code><code>	delete[] name;</code><code></code><code>	// Print out our name to prove we made a copy</code><code>	myname.print();</code><code>}</code></pre><p>This works as we expect:</p><pre>5
7
Alex
</pre><p>Using partial template class specialization to create separate pointer and non-pointer implementations of a class is extremely useful when you want a class to handle both differently, but in a way that’s completely transparent to the end-user.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">19.x — Chapter 19 comprehensive quiz</h1></header><div class="entry-content" itemprop="articleBody"><p>Templates allow us to write functions or classes using placeholder types, so that we can stencil out identical versions of the function or class using different types. A function or class that has been instantiated is called a function or class instance.</p><p>All template functions or classes must start with a template parameter declaration that tells the compiler that the following function or class is a template function or class. Within the template parameter declaration, the template type parameters or expression parameters are specified. Template type parameters are just placeholder types, normally named T, T1, T2, or other single letter names (e.g. S). Expression parameters are usually integral types, but can be a pointer or reference to a function, class object, or member function.</p><p>Splitting up template class definition and member function definitions doesn’t work like normal classes -- you can’t put your class definition in a header and member function definitions in a .cpp file. It’s usually best to keep all of them in a header file, with the member function definitions underneath the class.</p><p>Template specialization can be used when we want to override the default behavior from the templated function or class for a specific type. If all types are overridden, this is called full specialization. Classes also support partial specialization, where only some of the templated parameters are specialized. Functions can not be partially specialized.</p><p>Many classes in the C++ standard library use templates, including std::array and std::vector. Templates are often used for implementing container classes, so a container can be written once and used with any appropriate type.</p><p><strong>Quiz time</strong></p><ol start="1"><li>It’s sometimes useful to define data that travels in pairs. Write a templated class named Pair1 that allows the user to define one template type that is used for both values in the pair. The following function should work:</li></ol><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	Pair1<int> p1 { 5, 8 };</int></code><code>	std::cout &lt;&lt; "Pair: " &lt;&lt; p1.first() &lt;&lt; ' ' &lt;&lt; p1.second() &lt;&lt; '\n';</code><code></code><code>	const Pair1<double> p2 { 2.3, 4.5 };</double></code><code>	std::cout &lt;&lt; "Pair: " &lt;&lt; p2.first() &lt;&lt; ' ' &lt;&lt; p2.second() &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>and print:</p><pre>Pair: 5 8
Pair: 2.3 4.5
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>class Pair1</code><code>{</code><code>private:</code><code>	T m_x {};</code><code>	T m_y {};</code><code></code><code>public:</code><code>	Pair1(const T&amp; x, const T&amp; y)</code><code>		: m_x{ x }, m_y{ y }</code><code>	{</code><code>	}</code><code></code><code>	T&amp; first() { return m_x; }</code><code>	T&amp; second() { return m_y; }</code><code>	const T&amp; first() const { return m_x; }</code><code>	const T&amp; second() const { return m_y; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Pair1<int> p1 { 5, 8 };</int></code><code>	std::cout &lt;&lt; "Pair: " &lt;&lt; p1.first() &lt;&lt; ' ' &lt;&lt; p1.second() &lt;&lt; '\n';</code><code></code><code>	const Pair1<double> p2 { 2.3, 4.5 };</double></code><code>	std::cout &lt;&lt; "Pair: " &lt;&lt; p2.first() &lt;&lt; ' ' &lt;&lt; p2.second() &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre></div><ol start="2"><li>Write a Pair class that allows you to specify separate types for each of the two values in the pair.</li></ol><p>Note: We’re naming this class differently from the previous one because C++ does not currently allow you to “overload” classes that differ only in the number or type of template parameters.</p><p>The following program should work:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	Pair<int, double=""> p1 { 5, 6.7 };</int,></code><code>	std::cout &lt;&lt; "Pair: " &lt;&lt; p1.first() &lt;&lt; ' ' &lt;&lt; p1.second() &lt;&lt; '\n';</code><code></code><code>	const Pair<double, int=""> p2 { 2.3, 4 };</double,></code><code>	std::cout &lt;&lt; "Pair: " &lt;&lt; p2.first() &lt;&lt; ' ' &lt;&lt; p2.second() &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>and print:</p><pre>Pair: 5 6.7
Pair: 2.3 4
</pre><p>Hint: To define a template using two different types, separate the two types by a comma in the template parameter declaration. See lesson <a href="https://www.learncpp.com/cpp-tutorial/function-templates-with-multiple-template-types/">8.15 -- Function templates with multiple template types</a> for more information.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t,="" typename="" s=""></typename></code><code>class Pair</code><code>{</code><code>private:</code><code>	T m_x;</code><code>	S m_y;</code><code></code><code>public:</code><code>	Pair(const T&amp; x, const S&amp; y)</code><code>		: m_x{x}, m_y{y}</code><code>	{</code><code>	}</code><code></code><code>	T&amp; first() { return m_x; }</code><code>	S&amp; second() { return m_y; }</code><code>	const T&amp; first() const { return m_x; }</code><code>	const S&amp; second() const { return m_y; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Pair<int, double=""> p1 { 5, 6.7 };</int,></code><code>	std::cout &lt;&lt; "Pair: " &lt;&lt; p1.first() &lt;&lt; ' ' &lt;&lt; p1.second() &lt;&lt; '\n';</code><code></code><code>	const Pair<double, int=""> p2 { 2.3, 4 };</double,></code><code>	std::cout &lt;&lt; "Pair: " &lt;&lt; p2.first() &lt;&lt; ' ' &lt;&lt; p2.second() &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre></div><ol start="3"><li>A string-value pair is a special type of pair where the first value is always a string type, and the second value can be any type. Write a template class named StringValuePair that inherits from a partially specialized Pair class (using std::string as the first type, and allowing the user to specify the second type).</li></ol><p>The following program should run:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	StringValuePair<int> svp { "Hello", 5 };</int></code><code>	std::cout &lt;&lt; "Pair: " &lt;&lt; svp.first() &lt;&lt; ' ' &lt;&lt; svp.second() &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>and print:</p><pre>Pair: Hello 5
</pre><p>Hint: When you call the Pair constructor from the StringValuePair constructor, don’t forget to include the template parameters as part of the Pair class name.</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>template <typename t,="" typename="" s=""></typename></code><code>class Pair</code><code>{</code><code>private:</code><code>	T m_x {};</code><code>	S m_y {};</code><code></code><code>public:</code><code>	Pair(const T&amp; x, const S&amp; y)</code><code>		: m_x { x } , m_y { y }</code><code>	{</code><code>	}</code><code></code><code>	T&amp; first() { return m_x; }</code><code>	S&amp; second() { return m_y; }</code><code>	const T&amp; first() const { return m_x; }</code><code>	const S&amp; second() const { return m_y; }</code><code>};</code><code></code><code>template <typename s=""></typename></code><code>class StringValuePair : public Pair<std::string, s=""></std::string,></code><code>{</code><code>public:</code><code>	StringValuePair(const std::string&amp; key, const S&amp; value)</code><code>		: Pair<std::string, s=""> { key, value }</std::string,></code><code>	{</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	StringValuePair<int> svp { "Hello", 5 };</int></code><code>	std::cout &lt;&lt; "Pair: " &lt;&lt; svp.first() &lt;&lt; ' ' &lt;&lt; svp.second() &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">20.1 — The need for exceptions</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson on <a href="https://www.learncpp.com/cpp-tutorial/712-handling-errors-assert-cerr-exit-and-exceptions/">handling errors</a>, we talked about ways to use assert(), std::cerr, and exit() to handle errors. However, we punted on one further topic that we will now cover: exceptions.</p><p><strong>When return codes fail</strong></p><p>When writing reusable code, error handling is a necessity. One of the most common ways to handle potential errors is via return codes. For example:</p><pre class="language-cpp line-numbers"><code>#include <string_view></string_view></code><code></code><code>int findFirstChar(std::string_view string, char ch)</code><code>{</code><code>    // Step through each character in string</code><code>    for (std::size_t index{ 0 }; index &lt; string.length(); ++index)</code><code>        // If the character matches ch, return its index</code><code>        if (string[index] == ch)</code><code>            return index;</code><code></code><code>    // If no match was found, return -1</code><code>    return -1;</code><code>}</code></pre><p>This function returns the index of the first character matching ch within string. If the character can not be found, the function returns -1 as an error indicator.</p><p>The primary virtue of this approach is that it is extremely simple. However, using return codes has a number of drawbacks which can quickly become apparent when used in non-trivial cases:</p><p>First, return values can be cryptic -- if a function returns -1, is it trying to indicate an error, or is that actually a valid return value? It’s often hard to tell without digging into the guts of the function.</p><p>Second, functions can only return one value, so what happens when you need to return both a function result and an error code? Consider the following function:</p><pre class="language-cpp line-numbers"><code>double divide(int x, int y)</code><code>{</code><code>    return static_cast<double>(x)/y;</double></code><code>}</code></pre><p>This function is in desperate need of some error handling, because it will crash if the user passes in 0 for parameter y. However, it also needs to return the result of x/y. How can it do both? The most common answer is that either the result or the error handling will have to be passed back as a reference parameter, which makes for ugly code that is less convenient to use. For example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>double divide(int x, int y, bool&amp; outSuccess)</code><code>{</code><code>    if (y == 0)</code><code>    {</code><code>        outSuccess = false;</code><code>        return 0.0;</code><code>    }</code><code></code><code>    outSuccess = true;</code><code>    return static_cast<double>(x)/y;</double></code><code>}</code><code></code><code>int main()</code><code>{</code><code>    bool success {}; // we must now pass in a bool value to see if the call was successful</code><code>    double result { divide(5, 3, success) };</code><code></code><code>    if (!success) // and check it before we use the result</code><code>        std::cerr &lt;&lt; "An error occurred" &lt;&lt; std::endl;</code><code>    else</code><code>        std::cout &lt;&lt; "The answer is " &lt;&lt; result &lt;&lt; '\n';</code><code>}</code></pre><p>Third, in sequences of code where many things can go wrong, error codes have to be checked constantly. Consider the following snippet of code that involves parsing a text file for values that are supposed to be there:</p><pre class="language-cpp line-numbers"><code>    std::ifstream setupIni { "setup.ini" }; // open setup.ini for reading</code><code>    // If the file couldn't be opened (e.g. because it was missing) return some error enum</code><code>    if (!setupIni)</code><code>        return ERROR_OPENING_FILE;</code><code></code><code>    // Now read a bunch of values from a file</code><code>    if (!readIntegerFromFile(setupIni, m_firstParameter)) // try to read an integer from the file</code><code>        return ERROR_READING_VALUE; // Return enum value indicating value couldn't be read</code><code></code><code>    if (!readDoubleFromFile(setupIni, m_secondParameter)) // try to read a double from the file</code><code>        return ERROR_READING_VALUE;</code><code></code><code>    if (!readFloatFromFile(setupIni, m_thirdParameter)) // try to read a float from the file</code><code>        return ERROR_READING_VALUE;</code></pre><p>We haven’t covered file access yet, so don’t worry if you don’t understand how the above works -- just note the fact that every call requires an error-check and return back to the caller. Now imagine if there were twenty parameters of differing types -- you’re essentially checking for an error and returning ERROR_READING_VALUE twenty times! All of this error checking and returning values makes determining <em>what</em> the function is trying to do much harder to discern.</p><p>Fourth, return codes do not mix with constructors very well. What happens if you’re creating an object and something inside the constructor goes catastrophically wrong? Constructors have no return type to pass back a status indicator, and passing one back via a reference parameter is messy and must be explicitly checked. Furthermore, even if you do this, the object will still be created and then has to be dealt with or disposed of.</p><p>Finally, when an error code is returned to the caller, the caller may not always be equipped to handle the error. If the caller doesn’t want to handle the error, it either has to ignore it (in which case it will be lost forever), or return the error up the stack to the function that called it. This can be messy and lead to many of the same issues noted above.</p><p>To summarize, the primary issue with return codes is that the error handling code ends up intricately linked to the normal control flow of the code. This in turn ends up constraining both how the code is laid out, and how errors can be reasonably handled.</p><p><strong>Exceptions</strong></p><p>Exception handling provides a mechanism to decouple handling of errors or other exceptional circumstances from the typical control flow of your code. This allows more freedom to handle errors when and how ever is most useful for a given situation, alleviating most (if not all) of the messiness that return codes cause.</p><p>In the next lesson, we’ll take a look at how exceptions work in C++.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">20.2 — Basic exception handling</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson on <a href="https://www.learncpp.com/cpp-tutorial/151-the-need-for-exceptions/">the need for exceptions</a>, we talked about how using return codes causes your control flow and error flow to be intermingled, constraining both. Exceptions in C++ are implemented using three keywords that work in conjunction with each other: <strong>throw</strong>, <strong>try</strong>, and <strong>catch</strong>.</p><p><strong>Throwing exceptions</strong></p><p>We use signals all the time in real life to note that particular events have occurred. For example, during American football, if a player has committed a foul, the referee will throw a flag on the ground and whistle the play dead. A penalty is then assessed and executed. Once the penalty has been taken care of, play generally resumes as normal.</p><p>In C++, a <strong>throw statement</strong> is used to signal that an exception or error case has occurred (think of throwing a penalty flag). Signaling that an exception has occurred is also commonly called <strong>raising</strong> an exception.</p><p>To use a throw statement, simply use the throw keyword, followed by a value of any data type you wish to use to signal that an error has occurred. Typically, this value will be an error code, a description of the problem, or a custom exception class.</p><p>Here are some examples:</p><pre class="language-cpp line-numbers"><code>throw -1; // throw a literal integer value</code><code>throw ENUM_INVALID_INDEX; // throw an enum value</code><code>throw "Can not take square root of negative number"; // throw a literal C-style (const char*) string</code><code>throw dX; // throw a double variable that was previously defined</code><code>throw MyException("Fatal Error"); // Throw an object of class MyException</code></pre><p>Each of these statements acts as a signal that some kind of problem that needs to be handled has occurred.</p><p><strong>Looking for exceptions</strong></p><p>Throwing exceptions is only one part of the exception handling process. Let’s go back to our American football analogy: once a referee has thrown a penalty flag, what happens next? The players notice that a penalty has occurred and stop play. The normal flow of the football game is disrupted.</p><p>In C++, we use the <strong>try</strong> keyword to define a block of statements (called a <strong>try block</strong>). The try block acts as an observer, looking for any exceptions that are thrown by any of the statements within the try block.</p><p>Here’s an example of a try block:</p><pre class="language-cpp line-numbers"><code>try</code><code>{</code><code>    // Statements that may throw exceptions you want to handle go here</code><code>    throw -1; // here's a trivial throw statement</code><code>}</code></pre><p>Note that the try block doesn’t define HOW we’re going to handle the exception. It merely tells the program, “Hey, if any of the statements inside this try block throws an exception, grab it!”.</p><p><strong>Handling exceptions</strong></p><p>Finally, the end of our American football analogy: After the penalty has been called and play has stopped, the referee assesses the penalty and executes it. In other words, the penalty must be handled before normal play can resume.</p><p>Actually handling exceptions is the job of the catch block(s). The <strong>catch</strong> keyword is used to define a block of code (called a <strong>catch block</strong>) that handles exceptions for a single data type.</p><p>Here’s an example of a catch block that will catch integer exceptions:</p><pre class="language-cpp line-numbers"><code>catch (int x)</code><code>{</code><code>    // Handle an exception of type int here</code><code>    std::cerr &lt;&lt; "We caught an int exception with value" &lt;&lt; x &lt;&lt; '\n';</code><code>}</code></pre><p>Try blocks and catch blocks work together -- a try block detects any exceptions that are thrown by statements within the try block, and routes them to the appropriate catch block for handling. A try block must have at least one catch block immediately following it, but may have multiple catch blocks listed in sequence.</p><p>Once an exception has been caught by the try block and routed to a catch block for handling, the exception is considered handled, and execution will resume as normal after the catch block.</p><p>Catch parameters work just like function parameters, with the parameter being available within the subsequent catch block. Exceptions of fundamental types can be caught by value, but exceptions of non-fundamental types should be caught by const reference to avoid making an unnecessary copy.</p><p>Just like with functions, if the parameter is not going to be used in the catch block, the variable name can be omitted:</p><pre class="language-cpp line-numbers"><code>catch (double) // note: no variable name since we don't use it in the catch block below</code><code>{</code><code>    // Handle exception of type double here</code><code>    std::cerr &lt;&lt; "We caught an exception of type double" &lt;&lt; '\n';</code><code>}</code></pre><p>This can help prevent compiler warnings about unused variables.</p><p><strong>Putting throw, try, and catch together</strong></p><p>Here’s a full program that uses throw, try, and multiple catch blocks:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>    try</code><code>    {</code><code>        // Statements that may throw exceptions you want to handle go here</code><code>        throw -1; // here's a trivial example</code><code>    }</code><code>    catch (int x)</code><code>    {</code><code>        // Any exceptions of type int thrown within the above try block get sent here</code><code>        std::cerr &lt;&lt; "We caught an int exception with value: " &lt;&lt; x &lt;&lt; '\n';</code><code>    }</code><code>    catch (double) // no variable name since we don't use the exception itself in the catch block below</code><code>    {</code><code>        // Any exceptions of type double thrown within the above try block get sent here</code><code>        std::cerr &lt;&lt; "We caught an exception of type double" &lt;&lt; '\n';</code><code>    }</code><code>    catch (const std::string&amp;) // catch classes by const reference</code><code>    {</code><code>        // Any exceptions of type std::string thrown within the above try block get sent here</code><code>        std::cerr &lt;&lt; "We caught an exception of type std::string" &lt;&lt; '\n';</code><code>    }</code><code></code><code>    std::cout &lt;&lt; "Continuing on our merry way\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>Running the above try/catch block would produce the following result:</p><pre>We caught an int exception with value -1
Continuing on our merry way
</pre><p>A throw statement was used to raise an exception with the value -1, which is of type int. The throw statement was then caught by the enclosing try block, and routed to the appropriate catch block that handles exceptions of type int. This catch block printed the appropriate error message.</p><p>Once the exception was handled, the program continued as normal after the catch blocks, printing “Continuing on our merry way”.</p><p><strong>Recapping exception handling</strong></p><p>Exception handling is actually quite simple, and the following two paragraphs cover most of what you need to remember about it:</p><p>When an exception is raised (using <strong>throw</strong>), execution of the program immediately jumps to the nearest enclosing <strong>try</strong> block (propagating up the stack if necessary to find an enclosing try block -- we’ll discuss this in more detail next lesson). If any of the <strong>catch</strong> handlers attached to the try block handle that type of exception, that handler is executed and the exception is considered handled.</p><p>If no appropriate catch handlers exist, execution of the program propagates to the next enclosing try block. If no appropriate catch handlers can be found before the end of the program, the program will fail with an exception error.</p><p>Note that the compiler will not perform implicit conversions or promotions when matching exceptions with catch blocks! For example, a char exception will not match with an int catch block. An int exception will not match a float catch block. However, casts from a derived class to one of its parent classes will be performed.</p><p>That’s really all there is to it. The rest of this chapter will be dedicated to showing examples of these principles at work.</p><p><strong>Exceptions are handled immediately</strong></p><p>Here’s a short program that demonstrates how exceptions are handled immediately:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    try</code><code>    {</code><code>        throw 4.5; // throw exception of type double</code><code>        std::cout &lt;&lt; "This never prints\n";</code><code>    }</code><code>    catch (double x) // handle exception of type double</code><code>    {</code><code>        std::cerr &lt;&lt; "We caught a double of value: " &lt;&lt; x &lt;&lt; '\n';</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program is about as simple as it gets. Here’s what happens: the throw statement is the first statement that gets executed -- this causes an exception of type double to be raised. Execution <em>immediately</em> moves to the nearest enclosing try block, which is the only try block in this program. The catch handlers are then checked to see if any handler matches. Our exception is of type double, so we’re looking for a catch handler of type double. We have one, so it executes.</p><p>Consequently, the result of this program is as follows:</p><pre>We caught a double of value: 4.5
</pre><p>Note that “This never prints” is never printed, because the exception caused the execution path to jump immediately to the exception handler for doubles.</p><p><strong>A more realistic example</strong></p><p>Let’s take a look at an example that’s not quite so academic:</p><pre class="language-cpp line-numbers"><code>#include <cmath> // for sqrt() function</cmath></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number: ";</code><code>    double x {};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    try // Look for exceptions that occur within try block and route to attached catch block(s)</code><code>    {</code><code>        // If the user entered a negative number, this is an error condition</code><code>        if (x &lt; 0.0)</code><code>            throw "Can not take sqrt of negative number"; // throw exception of type const char*</code><code></code><code>        // Otherwise, print the answer</code><code>        std::cout &lt;&lt; "The sqrt of " &lt;&lt; x &lt;&lt; " is " &lt;&lt; std::sqrt(x) &lt;&lt; '\n';</code><code>    }</code><code>    catch (const char* exception) // catch exceptions of type const char*</code><code>    {</code><code>        std::cerr &lt;&lt; "Error: " &lt;&lt; exception &lt;&lt; '\n';</code><code>    }</code><code>}</code></pre><p>In this code, the user is asked to enter a number. If they enter a positive number, the if statement does not execute, no exception is thrown, and the square root of the number is printed. Because no exception is thrown in this case, the code inside the catch block never executes. The result is something like this:</p><pre>Enter a number: 9
The sqrt of 9 is 3
</pre><p>If the user enters a negative number, we throw an exception of type const char*. Because we’re within a try block and a matching exception handler is found, control immediately transfers to the const char* exception handler. The result is:</p><pre>Enter a number: -4
Error: Can not take sqrt of negative number
</pre><p>By now, you should be getting the basic idea behind exceptions. In the next lesson, we’ll do quite a few more examples to show how flexible exceptions are.</p><p><strong>What catch blocks typically do</strong></p><p>If an exception is routed to a catch block, it is considered “handled” even if the catch block is empty. However, typically you’ll want your catch blocks to do something useful. There are three common things that catch blocks do when they catch an exception:</p><p>First, catch blocks may print an error (either to the console, or a log file).</p><p>Second, catch blocks may return a value or error code back to the caller.</p><p>Third, a catch block may throw another exception. Because the catch block is outside of the try block, the newly thrown exception in this case is not handled by the preceding try block -- it’s handled by the next enclosing try block.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">20.3 — Exceptions, functions, and stack unwinding</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson on <a href="https://www.learncpp.com/cpp-tutorial/basic-exception-handling/">20.2 -- Basic exception handling</a>, we explained how throw, try, and catch work together to enable exception handling. In this lesson, we’ll talk about how exception handling interacts with functions.</p><p><strong>Throwing exceptions outside of a try block</strong></p><p>In the examples in the previous lesson, the throw statements were placed directly within a try block. If this were a necessity, exception handling would be of limited use.</p><p>One of the most useful properties of exception handling is that the throw statements do NOT have to be placed directly inside a try block due to the way exceptions propagate up the stack when thrown. This allows us to use exception handling in a much more modular fashion. We’ll demonstrate this by rewriting the square root program from the previous lesson to use a modular function.</p><pre class="language-cpp line-numbers"><code>#include <cmath> // for sqrt() function</cmath></code><code>#include <iostream></iostream></code><code></code><code>// A modular square root function</code><code>double mySqrt(double x)</code><code>{</code><code>    // If the user entered a negative number, this is an error condition</code><code>    if (x &lt; 0.0)</code><code>        throw "Can not take sqrt of negative number"; // throw exception of type const char*</code><code></code><code>    return std::sqrt(x);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number: ";</code><code>    double x {};</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    try // Look for exceptions that occur within try block and route to attached catch block(s)</code><code>    {</code><code>        double d = mySqrt(x);</code><code>        std::cout &lt;&lt; "The sqrt of " &lt;&lt; x &lt;&lt; " is " &lt;&lt; d &lt;&lt; '\n';</code><code>    }</code><code>    catch (const char* exception) // catch exceptions of type const char*</code><code>    {</code><code>        std::cerr &lt;&lt; "Error: " &lt;&lt; exception &lt;&lt; std::endl;</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>In this program, we’ve taken the code that checks for an exception and calculates the square root and put it inside a modular function called mySqrt(). We’ve then called this mySqrt() function from inside a try block. Let’s verify that it still works as expected:</p><pre>Enter a number: -4
Error: Can not take sqrt of negative number
</pre><p>It does!</p><p>Let’s revisit for a moment what happens when an exception is raised. First, the program looks to see if the exception can be handled immediately (which means it was thrown inside a try block). If not, the current function is terminated, and the program checks to see if the function’s caller will handle the exception. If not, it terminates the caller and checks the caller’s caller. Each function is terminated in sequence until a handler for the exception is found, or until main() is terminated without the exception being handled. This process is called <strong>unwinding the stack</strong> (see the lesson on <a href="https://www.learncpp.com/cpp-tutorial/79-the-stack-and-the-heap/">the stack and the heap</a> if you need a refresher on what the call stack is).</p><p>Now, let’s take a detailed look at how that applies to this program when an exception is raised from within mySqrt(). First, the program checks to see if the exception was thrown from within a try block inside the function. In this case, it was not. Then, the stack begins to unwind. First, mySqrt() terminates, and control returns to main(). The program now checks to see if we’re inside a try block. We are, and there’s a const char* handler, so the exception is handled by the try block within main().</p><p>To summarize, mySqrt() raised the exception, but the try/catch block in main() was the one who captured and handled the exception. Or, put another way, try blocks catch exceptions not only from statements within the try block, but also from functions that are called within the try block.</p><p>The most interesting part of the above program is that the mySqrt() function can throw an exception, but this exception is not immediately inside of a try block! This essentially means mySqrt is willing to say, “Hey, there’s a problem!”, but is unwilling to handle the problem itself. It is, in essence, delegating the responsibility for handling the exception to its caller (the equivalent of how using a return code passes the responsibility of handling an error back to a function’s caller).</p><p>At this point, some of you are probably wondering why it’s a good idea to pass errors back to the caller. Why not just make MySqrt() handle its own error? The problem is that different applications may want to handle errors in different ways. A console application may want to print a text message. A windows application may want to pop up an error dialog. In one application, this may be a fatal error, and in another application it may not be. By passing the error back up the stack, each application can handle an error from mySqrt() in a way that is the most context appropriate for it! Ultimately, this keeps mySqrt() as modular as possible, and the error handling can be placed in the less-modular parts of the code.</p><p><strong>Another stack unwinding example</strong></p><p>Here’s another example showing stack unwinding in practice, using a larger stack. Although this program is long, it’s pretty simple: main() calls first(), first() calls second(), second() calls third(), third() calls last(), and last() throws an exception.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void last() // called by third()</code><code>{</code><code>    std::cout &lt;&lt; "Start last\n";</code><code>    std::cout &lt;&lt; "last throwing int exception\n";</code><code></code><code>    throw -1;</code><code></code><code>    std::cout &lt;&lt; "End last\n";</code><code>}</code><code></code><code>void third() // called by second()</code><code>{</code><code>    std::cout &lt;&lt; "Start third\n";</code><code>    last();</code><code>    std::cout &lt;&lt; "End third\n";</code><code>}</code><code></code><code>void second() // called by first()</code><code>{</code><code>    std::cout &lt;&lt; "Start second\n";</code><code>    try</code><code>    {</code><code>        third();</code><code>    }</code><code>    catch (double)</code><code>    {</code><code>         std::cerr &lt;&lt; "second caught double exception\n";</code><code>    }</code><code>    std::cout &lt;&lt; "End second\n";</code><code>}</code><code></code><code>void first() // called by main()</code><code>{</code><code>    std::cout &lt;&lt; "Start first\n";</code><code>    try</code><code>    {</code><code>        second();</code><code>    }</code><code>    catch (int)</code><code>    {</code><code>         std::cerr &lt;&lt; "first caught int exception\n";</code><code>    }</code><code>    catch (double)</code><code>    {</code><code>         std::cerr &lt;&lt; "first caught double exception\n";</code><code>    }</code><code>    std::cout &lt;&lt; "End first\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Start main\n";</code><code>    try</code><code>    {</code><code>        first();</code><code>    }</code><code>    catch (int)</code><code>    {</code><code>         std::cerr &lt;&lt; "main caught int exception\n";</code><code>    }</code><code>    std::cout &lt;&lt; "End main\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>Take a look at this program in more detail, and see if you can figure out what gets printed and what doesn’t when it is run. The answer follows:</p><pre>Start main
Start first
Start second
Start third
Start last
last throwing int exception
first caught int exception
End first
End main
</pre><p>Let’s examine what happens in this case. The printing of all the “Start” statements is straightforward and doesn’t warrant further explanation. Function last() prints “last throwing int exception” and then throws an int exception. This is where things start to get interesting.</p><p>Because last() doesn’t handle the exception itself, the stack begins to unwind. Function last() terminates immediately and control returns to the caller, which is third().</p><p>Function third() doesn’t handle any exceptions, so it terminates immediately and control returns to second().</p><p>Function second() has a try block, and the call to third() is within it, so the program attempts to match the exception with an appropriate catch block. However, there are no handlers for exceptions of type int here, so second() terminates immediately and control returns to first(). Note that the integer exception is not implicitly converted to match the catch block handling a double.</p><p>Function first() also has a try block, and the call to second() is within it, so the program looks to see if there is a catch handler for int exceptions. There is! Consequently, first() handles the exception, and prints “first caught int exception”.</p><p>Because the exception has now been handled, control continues normally at the end of the catch block within first(). This means first() prints “End first” and then terminates normally.</p><p>Control returns to main(). Although main() has an exception handler for int, our exception has already been handled by first(), so the catch block within main() does not get executed. main() simply prints “End main” and then terminates normally.</p><p>There are quite a few interesting principles illustrated by this program:</p><p>First, the immediate caller of a function that throws an exception doesn’t have to handle the exception if it doesn’t want to. In this case, third() didn’t handle the exception thrown by last(). It delegated that responsibility to one of its callers up the stack.</p><p>Second, if a try block doesn’t have a catch handler for the type of exception being thrown, stack unwinding occurs just as if there were no try block at all. In this case, second() didn’t handle the exception either because it didn’t have the right kind of catch block.</p><p>Third, once an exception is handled, control flow proceeds as normal starting from the end of the catch blocks. This was demonstrated by first() handling the error and then terminating normally. By the time the program got back to main(), the exception had been thrown and handled already -- main() had no idea there even was an exception at all!</p><p>As you can see, stack unwinding provides us with some very useful behavior -- if a function does not want to handle an exception, it doesn’t have to. The exception will propagate up the stack until it finds someone who will! This allows us to decide where in the call stack is the most appropriate place to handle any errors that may occur.</p><p>In the next lesson, we’ll take a look at what happens when you don’t capture an exception, and a method to prevent that from happening.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">20.4 — Uncaught exceptions and catch-all handlers</h1></header><div class="entry-content" itemprop="articleBody"><p>By now, you should have a reasonable idea of how exceptions work. In this lesson, we’ll cover a few more interesting exception cases.</p><p><strong>Uncaught exceptions</strong></p><p>In the past few examples, there are quite a few cases where a function assumes its caller (or another function somewhere up the call stack) will handle the exception. In the following example, mySqrt() assumes someone will handle the exception that it throws -- but what happens if nobody actually does?</p><p>Here’s our square root program again, minus the try block in main():</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <cmath> // for sqrt() function</cmath></code><code></code><code>// A modular square root function</code><code>double mySqrt(double x)</code><code>{</code><code>    // If the user entered a negative number, this is an error condition</code><code>    if (x &lt; 0.0)</code><code>        throw "Can not take sqrt of negative number"; // throw exception of type const char*</code><code></code><code>    return std::sqrt(x);</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::cout &lt;&lt; "Enter a number: ";</code><code>    double x;</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    // Look ma, no exception handler!</code><code>    std::cout &lt;&lt; "The sqrt of " &lt;&lt; x &lt;&lt; " is " &lt;&lt; mySqrt(x) &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>Now, let’s say the user enters -4, and mySqrt(-4) raises an exception. Function mySqrt() doesn’t handle the exception, so the program stack unwinds and control returns to main(). But there’s no exception handler here either, so main() terminates. At this point, we just terminated our application!</p><p>When main() terminates with an unhandled exception, the operating system will generally notify you that an unhandled exception error has occurred. How it does this depends on the operating system, but possibilities include printing an error message, popping up an error dialog, or simply crashing. Some OSes are less graceful than others. Generally this is something you want to avoid altogether!</p><p><strong>Catch-all handlers</strong></p><p>And now we find ourselves in a conundrum: functions can potentially throw exceptions of any data type, and if an exception is not caught, it will propagate to the top of your program and cause it to terminate. Since it’s possible to call functions without knowing how they are even implemented (and thus, what type of exceptions they may throw), how can we possibly prevent this from happening?</p><p>Fortunately, C++ provides us with a mechanism to catch all types of exceptions. This is known as a <strong>catch-all handler</strong>. A catch-all handler works just like a normal catch block, except that instead of using a specific type to catch, it uses the ellipses operator (…) as the type to catch. For this reason, the catch-all handler is also sometimes called an “ellipsis catch handler”</p><p>If you recall from lesson <a href="https://www.learncpp.com/cpp-tutorial/ellipsis-and-why-to-avoid-them/">12.6 -- Ellipsis (and why to avoid them)</a>, ellipses were previously used to pass arguments of any type to a function. In this context, they represent exceptions of any data type. Here’s an simple example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>	try</code><code>	{</code><code>		throw 5; // throw an int exception</code><code>	}</code><code>	catch (double x)</code><code>	{</code><code>		std::cout &lt;&lt; "We caught an exception of type double: " &lt;&lt; x &lt;&lt; '\n';</code><code>	}</code><code>	catch (...) // catch-all handler</code><code>	{</code><code>		std::cout &lt;&lt; "We caught an exception of an undetermined type\n";</code><code>	}</code><code>}</code></pre><p>Because there is no specific exception handler for type int, the catch-all handler catches this exception. This example produces the following result:</p><pre>We caught an exception of an undetermined type
</pre><p>The catch-all handler must be placed last in the catch block chain. This is to ensure that exceptions can be caught by exception handlers tailored to specific data types if those handlers exist.</p><p>Often, the catch-all handler block is left empty:</p><pre class="language-cpp line-numbers"><code>catch(...) {} // ignore any unanticipated exceptions</code></pre><p>This will catch any unanticipated exceptions and prevent them from stack unwinding to the top of your program, but does no specific error handling.</p><p><strong>Using the catch-all handler to wrap main()</strong></p><p>One interesting use for the catch-all handler is to wrap the contents of main():</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code></code><code>    try</code><code>    {</code><code>        runGame();</code><code>    }</code><code>    catch(...)</code><code>    {</code><code>        std::cerr &lt;&lt; "Abnormal termination\n";</code><code>    }</code><code></code><code>    saveState(); // Save user's game</code><code>    return 1;</code><code>}</code></pre><p>In this case, if runGame() or any of the functions it calls throws an exception that is not caught, that exception will unwind the stack and eventually get caught by this catch-all handler. This will prevent main() from terminating, and gives us a chance to print an error of our choosing and then save the user’s state before exiting. This can be useful to catch and handle problems that may be unanticipated.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">20.5 — Exceptions, classes, and inheritance</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>Exceptions and member functions</strong></p><p>Up to this point in the tutorial, you’ve only seen exceptions used in non-member functions. However, exceptions are equally useful in member functions, and even more so in overloaded operators. Consider the following overloaded [] operator as part of a simple integer array class:</p><pre class="language-cpp line-numbers"><code>int&amp; IntArray::operator[](const int index)</code><code>{</code><code>    return m_data[index];</code><code>}</code></pre><p>Although this function will work great as long as index is a valid array index, this function is sorely lacking in some good error checking. We could add an assert statement to ensure the index is valid:</p><pre class="language-cpp line-numbers"><code>int&amp; IntArray::operator[](const int index)</code><code>{</code><code>    assert (index &gt;= 0 &amp;&amp; index &lt; getLength());</code><code>    return m_data[index];</code><code>}</code></pre><p>Now if the user passes in an invalid index, the program will cause an assertion error. Unfortunately, because overloaded operators have specific requirements as to the number and type of parameter(s) they can take and return, there is no flexibility for passing back error codes or Boolean values to the caller to handle. However, since exceptions do not change the signature of a function, they can be put to great use here. Here’s an example:</p><pre class="language-cpp line-numbers"><code>int&amp; IntArray::operator[](const int index)</code><code>{</code><code>    if (index &lt; 0 || index &gt;= getLength())</code><code>        throw index;</code><code></code><code>    return m_data[index];</code><code>}</code></pre><p>Now, if the user passes in an invalid index, operator[] will throw an int exception.</p><br><h3>When constructors fail</h3><p>Constructors are another area of classes in which exceptions can be very useful. If a constructor must fail for some reason (e.g. the user passed in invalid input), simply throw an exception to indicate the object failed to create. In such a case, the object’s construction is aborted, and all class members (which have already been created and initialized prior to the body of the constructor executing) are destructed as per usual.</p><p>However, the class’s destructor is never called (because the object never finished construction). Because the destructor never executes, you can’t rely on said destructor to clean up any resources that have already been allocated.</p><p>This leads to the question of what we should do if we’ve allocated resources in our constructor and then an exception occurs prior to the constructor finishing. How do we ensure the resources that we’ve already allocated get cleaned up properly? One way would be to wrap any code that can fail in a try block, use a corresponding catch block to catch the exception and do any necessary cleanup, and then rethrow the exception (a topic we’ll discuss in lesson <a href="https://www.learncpp.com/cpp-tutorial/rethrowing-exceptions/">20.6 -- Rethrowing exceptions</a>). However, this adds a lot of clutter, and it’s easy to get wrong, particularly if your class allocates multiple resources.</p><p>Fortunately, there is a better way. Taking advantage of the fact that class members are destructed even if the constructor fails, if you do the resource allocations inside the members of the class (rather than in the constructor itself), then those members can clean up after themselves when they are destructed.</p><p>Here’s an example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Member</code><code>{</code><code>public:</code><code>	Member()</code><code>	{</code><code>		std::cerr &lt;&lt; "Member allocated some resources\n";</code><code>	}</code><code></code><code>	~Member()</code><code>	{</code><code>		std::cerr &lt;&lt; "Member cleaned up\n";</code><code>	}</code><code>};</code><code></code><code>class A</code><code>{</code><code>private:</code><code>	int m_x {};</code><code>	Member m_member;</code><code></code><code>public:</code><code>	A(int x) : m_x{x}</code><code>	{</code><code>		if (x &lt;= 0)</code><code>			throw 1;</code><code>	}</code><code>	</code><code>	~A()</code><code>	{</code><code>		std::cerr &lt;&lt; "~A\n"; // should not be called</code><code>	}</code><code>};</code><code></code><code></code><code>int main()</code><code>{</code><code>	try</code><code>	{</code><code>		A a{0};</code><code>	}</code><code>	catch (int)</code><code>	{</code><code>		std::cerr &lt;&lt; "Oops\n";</code><code>	}</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>Member allocated some resources
Member cleaned up
Oops
</pre><p>In the above program, when class A throws an exception, all of the members of A are destructed. m_member’s destructor is called, providing an opportunity to clean up any resources that it allocated.</p><p>This is part of the reason that RAII (covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/destructors/">13.9 -- Destructors</a>) is advocated so highly -- even in exceptional circumstances, classes that implement RAII are able to clean up after themselves.</p><p>However, creating a custom class like Member to manage a resource allocation isn’t efficient. Fortunately, the C++ standard library comes with RAII-compliant classes to manage common resource types, such as files (std::fstream, covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/basic-file-io/">23.6 -- Basic file I/O</a>) and dynamic memory (std::unique_ptr and the other smart pointers, covered in <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-smart-pointers-move-semantics/">M.1 -- Introduction to smart pointers and move semantics</a>).</p><p>For example, instead of this:</p><pre class="language-cpp line-numbers"><code>class Foo</code><code>private:</code><code>    int* ptr; // Foo will handle allocation/deallocation</code></pre><p>Do this:</p><pre class="language-cpp line-numbers"><code>class Foo</code><code>private:</code><code>    std::unique_ptr<int> ptr; // std::unique_ptr will handle allocation/deallocation</int></code></pre><p>In the former case, if Foo’s constructor were to fail after ptr had allocated its dynamic memory, Foo would be responsible for cleanup, which can be challenging. In the latter case, if Foo’s constructor were to fail after ptr has allocated its dynamic memory, ptr’s destructor would execute and return that memory to the system. Foo doesn’t have to do any explicit cleanup when resource handling is delegated to RAII-compliant members!</p><br><h3>Exception classes</h3><p>One of the major problems with using basic data types (such as int) as exception types is that they are inherently vague. An even bigger problem is disambiguation of what an exception means when there are multiple statements or function calls within a try block.</p><pre class="language-cpp line-numbers"><code>// Using the IntArray overloaded operator[] above</code><code></code><code>try</code><code>{</code><code>    int* value{ new int{ array[index1] + array[index2]} };</code><code>}</code><code>catch (int value)</code><code>{</code><code>    // What are we catching here?</code><code>}</code></pre><p>In this example, if we were to catch an int exception, what does that really tell us? Was one of the array indexes out of bounds? Did operator+ cause integer overflow? Did operator new fail because it ran out of memory? Unfortunately, in this case, there’s just no easy way to disambiguate. While we can throw const char* exceptions to solve the problem of identifying WHAT went wrong, this still does not provide us the ability to handle exceptions from various sources differently.</p><p>One way to solve this problem is to use exception classes. An <strong>exception class</strong> is just a normal class that is designed specifically to be thrown as an exception. Let’s design a simple exception class to be used with our IntArray class:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class ArrayException</code><code>{</code><code>private:</code><code>	std::string m_error;</code><code></code><code>public:</code><code>	ArrayException(std::string_view error)</code><code>		: m_error{ error }</code><code>	{</code><code>	}</code><code></code><code>	const std::string&amp; getError() const { return m_error; }</code><code>};</code></pre><p>Here’s a full program using this class:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class ArrayException</code><code>{</code><code>private:</code><code>	std::string m_error;</code><code></code><code>public:</code><code>	ArrayException(std::string_view error)</code><code>		: m_error{ error }</code><code>	{</code><code>	}</code><code></code><code>	const std::string&amp; getError() const { return m_error; }</code><code>};</code><code></code><code>class IntArray</code><code>{</code><code>private:</code><code>	int m_data[3]{}; // assume array is length 3 for simplicity</code><code></code><code>public:</code><code>	IntArray() {}</code><code></code><code>	int getLength() const { return 3; }</code><code></code><code>	int&amp; operator[](const int index)</code><code>	{</code><code>		if (index &lt; 0 || index &gt;= getLength())</code><code>			throw ArrayException{ "Invalid index" };</code><code></code><code>		return m_data[index];</code><code>	}</code><code></code><code>};</code><code></code><code>int main()</code><code>{</code><code>	IntArray array;</code><code></code><code>	try</code><code>	{</code><code>		int value{ array[5] }; // out of range subscript</code><code>	}</code><code>	catch (const ArrayException&amp; exception)</code><code>	{</code><code>		std::cerr &lt;&lt; "An array exception occurred (" &lt;&lt; exception.getError() &lt;&lt; ")\n";</code><code>	}</code><code>}</code></pre><p>Using such a class, we can have the exception return a description of the problem that occurred, which provides context for what went wrong. And since ArrayException is its own unique type, we can specifically catch exceptions thrown by the array class and treat them differently from other exceptions if we wish.</p><p>Note that exception handlers should catch class exception objects by reference instead of by value. This prevents the compiler from making a copy of the exception, which can be expensive when the exception is a class object, and prevents object slicing when dealing with derived exception classes (which we’ll talk about in a moment). Catching exceptions by pointer should generally be avoided unless you have a specific reason to do so.</p><br><h3>Exceptions and inheritance</h3><p>Since it’s possible to throw classes as exceptions, and classes can be derived from other classes, we need to consider what happens when we use inherited classes as exceptions. As it turns out, exception handlers will not only match classes of a specific type, they’ll also match classes derived from that specific type as well! Consider the following example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>public:</code><code>    Base() {}</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    Derived() {}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    try</code><code>    {</code><code>        throw Derived();</code><code>    }</code><code>    catch (const Base&amp; base)</code><code>    {</code><code>        std::cerr &lt;&lt; "caught Base";</code><code>    }</code><code>    catch (const Derived&amp; derived)</code><code>    {</code><code>        std::cerr &lt;&lt; "caught Derived";</code><code>    }</code><code></code><code>    return 0;</code><code>}	</code></pre><p>In the above example we throw an exception of type Derived. However, the output of this program is:</p><pre>caught Base
</pre><p>What happened?</p><p>First, as mentioned above, derived classes will be caught by handlers for the base type. Because Derived is derived from Base, Derived is-a Base (they have an is-a relationship). Second, when C++ is attempting to find a handler for a raised exception, it does so sequentially. Consequently, the first thing C++ does is check whether the exception handler for Base matches the Derived exception. Because Derived is-a Base, the answer is yes, and it executes the catch block for type Base! The catch block for Derived is never even tested in this case.</p><p>In order to make this example work as expected, we need to flip the order of the catch blocks:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Base</code><code>{</code><code>public:</code><code>    Base() {}</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    Derived() {}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    try</code><code>    {</code><code>        throw Derived();</code><code>    }</code><code>    catch (const Derived&amp; derived)</code><code>    {</code><code>        std::cerr &lt;&lt; "caught Derived";</code><code>    }</code><code>    catch (const Base&amp; base)</code><code>    {</code><code>        std::cerr &lt;&lt; "caught Base";</code><code>    }</code><code></code><code>    return 0;</code><code>}	</code></pre><p>This way, the Derived handler will get first shot at catching objects of type Derived (before the handler for Base can). Objects of type Base will not match the Derived handler (Derived is-a Base, but Base is not a Derived), and thus will “fall through” to the Base handler.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Rule</h4><p>Handlers for derived exception classes should be listed before those for base classes.</p></div><p>The ability to use a handler to catch exceptions of derived types using a handler for the base class turns out to be exceedingly useful.</p><br><h3>std::exception</h3><p>Many of the classes and operators in the standard library throw exception classes on failure. For example, operator new can throw std::bad_alloc if it is unable to allocate enough memory. A failed dynamic_cast will throw std::bad_cast. And so on. As of C++20, there are 28 different exception classes that can be thrown, with more being added in each subsequent language standard.</p><p>The good news is that all of these exception classes are derived from a single class called <strong>std::exception</strong> (defined in the &lt;exception&gt; header). std::exception is a small interface class designed to serve as a base class to any exception thrown by the C++ standard library.</p><p>Much of the time, when an exception is thrown by the standard library, we won’t care whether it’s a bad allocation, a bad cast, or something else. We just care that something catastrophic went wrong and now our program is exploding. Thanks to std::exception, we can set up an exception handler to catch exceptions of type std::exception, and we’ll end up catching std::exception and all of the derived exceptions together in one place. Easy!</p><pre class="language-cpp line-numbers"><code>#include <cstddef> // for std::size_t</cstddef></code><code>#include <exception> // for std::exception</exception></code><code>#include <iostream></iostream></code><code>#include <limits></limits></code><code>#include <string> // for this example</string></code><code></code><code>int main()</code><code>{</code><code>    try</code><code>    {</code><code>        // Your code using standard library goes here</code><code>        // We'll trigger one of these exceptions intentionally for the sake of the example</code><code>        std::string s;</code><code>        s.resize(std::numeric_limits<std::size_t>::max()); // will trigger a std::length_error or allocation exception</std::size_t></code><code>    }</code><code>    // This handler will catch std::exception and all the derived exceptions too</code><code>    catch (const std::exception&amp; exception)</code><code>    {</code><code>        std::cerr &lt;&lt; "Standard exception: " &lt;&lt; exception.what() &lt;&lt; '\n';</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>On the author’s machine, the above program prints:</p><pre>Standard exception: string too long
</pre><p>The above example should be pretty straightforward. The one thing worth noting is that std::exception has a virtual member function named <strong>what()</strong> that returns a C-style string description of the exception. Most derived classes override the what() function to change the message. Note that this string is meant to be used for descriptive text only -- do not use it for comparisons, as it is not guaranteed to be the same across compilers.</p><p>Sometimes we’ll want to handle a specific type of exception differently. In this case, we can add a handler for that specific type, and let all the others “fall through” to the base handler. Consider:</p><pre class="language-cpp line-numbers"><code>try</code><code>{</code><code>     // code using standard library goes here</code><code>}</code><code>// This handler will catch std::length_error (and any exceptions derived from it) here</code><code>catch (const std::length_error&amp; exception)</code><code>{</code><code>    std::cerr &lt;&lt; "You ran out of memory!" &lt;&lt; '\n';</code><code>}</code><code>// This handler will catch std::exception (and any exception derived from it) that fall</code><code>// through here</code><code>catch (const std::exception&amp; exception)</code><code>{</code><code>    std::cerr &lt;&lt; "Standard exception: " &lt;&lt; exception.what() &lt;&lt; '\n';</code><code>}</code></pre><p>In this example, exceptions of type std::length_error will be caught by the first handler and handled there. Exceptions of type std::exception and all of the other derived classes will be caught by the second handler.</p><p>Such inheritance hierarchies allow us to use specific handlers to target specific derived exception classes, or to use base class handlers to catch the whole hierarchy of exceptions. This allows us a fine degree of control over what kind of exceptions we want to handle while ensuring we don’t have to do too much work to catch “everything else” in a hierarchy.</p><br><h3>Using the standard exceptions directly</h3><p>Nothing throws a std::exception directly, and neither should you. However, you should feel free to throw the other standard exception classes in the standard library if they adequately represent your needs. You can find a list of all the standard exceptions on <a href="http://en.cppreference.com/w/cpp/error/exception">cppreference</a>.</p><p>std::runtime_error (included as part of the stdexcept header) is a popular choice, because it has a generic name, and its constructor takes a customizable message:</p><pre class="language-cpp line-numbers"><code>#include <exception> // for std::exception</exception></code><code>#include <iostream></iostream></code><code>#include <stdexcept> // for std::runtime_error</stdexcept></code><code></code><code>int main()</code><code>{</code><code>	try</code><code>	{</code><code>		throw std::runtime_error("Bad things happened");</code><code>	}</code><code>	// This handler will catch std::exception and all the derived exceptions too</code><code>	catch (const std::exception&amp; exception)</code><code>	{</code><code>		std::cerr &lt;&lt; "Standard exception: " &lt;&lt; exception.what() &lt;&lt; '\n';</code><code>	}</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>Standard exception: Bad things happened
</pre><br><h3>Deriving your own classes from std::exception or std::runtime_error</h3><p>You can, of course, derive your own classes from std::exception, and override the virtual what() const member function. Here’s the same program as above, with ArrayException derived from std::exception:</p><pre class="language-cpp line-numbers"><code>#include <exception> // for std::exception</exception></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>class ArrayException : public std::exception</code><code>{</code><code>private:</code><code>	std::string m_error{}; // handle our own string</code><code></code><code>public:</code><code>	ArrayException(std::string_view error)</code><code>		: m_error{error}</code><code>	{</code><code>	}</code><code></code><code>	// std::exception::what() returns a const char*, so we must as well</code><code>	const char* what() const noexcept override { return m_error.c_str(); }</code><code>};</code><code></code><code>class IntArray</code><code>{</code><code>private:</code><code>	int m_data[3] {}; // assume array is length 3 for simplicity</code><code></code><code>public:</code><code>	IntArray() {}</code><code>	</code><code>	int getLength() const { return 3; }</code><code></code><code>	int&amp; operator[](const int index)</code><code>	{</code><code>		if (index &lt; 0 || index &gt;= getLength())</code><code>			throw ArrayException("Invalid index");</code><code></code><code>		return m_data[index];</code><code>	}</code><code></code><code>};</code><code></code><code>int main()</code><code>{</code><code>	IntArray array;</code><code></code><code>	try</code><code>	{</code><code>		int value{ array[5] };</code><code>	}</code><code>	catch (const ArrayException&amp; exception) // derived catch blocks go first</code><code>	{</code><code>		std::cerr &lt;&lt; "An array exception occurred (" &lt;&lt; exception.what() &lt;&lt; ")\n";</code><code>	}</code><code>	catch (const std::exception&amp; exception)</code><code>	{</code><code>		std::cerr &lt;&lt; "Some other std::exception occurred (" &lt;&lt; exception.what() &lt;&lt; ")\n";</code><code>	}</code><code>}</code></pre><p>Note that virtual function what() has specifier noexcept (which means the function promises not to throw exceptions itself). Therefore, our override should also have specifier noexcept.</p><p>Because std::runtime_error already has string handling capabilities, it’s also a popular base class for derived exception classes. Here’s the same example derived from std::runtime_error instead:</p><pre class="language-cpp line-numbers"><code>#include <exception> // for std::exception</exception></code><code>#include <iostream></iostream></code><code>#include <stdexcept> // for std::runtime_error</stdexcept></code><code>#include <string></string></code><code></code><code>class ArrayException : public std::runtime_error</code><code>{</code><code>public:</code><code>	// std::runtime_error takes a const char* null-terminated string.</code><code>	// std::string_view may not be null-terminated, so it's not a good choice here.</code><code>	// Our ArrayException will take a const std::string&amp; instead,</code><code>	// which is guaranteed to be null-terminated, and can be converted to a const char*.</code><code>	ArrayException(const std::string&amp; error)</code><code>		: std::runtime_error{ error.c_str() } // std::runtime_error will handle the string</code><code>	{</code><code>	}</code><code></code><code>        // no need to override what() since we can just use std::runtime_error::what()</code><code>};</code><code></code><code>class IntArray</code><code>{</code><code>private:</code><code>	int m_data[3]{}; // assume array is length 3 for simplicity</code><code></code><code>public:</code><code>	IntArray() {}</code><code></code><code>	int getLength() const { return 3; }</code><code></code><code>	int&amp; operator[](const int index)</code><code>	{</code><code>		if (index &lt; 0 || index &gt;= getLength())</code><code>			throw ArrayException("Invalid index");</code><code></code><code>		return m_data[index];</code><code>	}</code><code></code><code>};</code><code></code><code>int main()</code><code>{</code><code>	IntArray array;</code><code></code><code>	try</code><code>	{</code><code>		int value{ array[5] };</code><code>	}</code><code>	catch (const ArrayException&amp; exception) // derived catch blocks go first</code><code>	{</code><code>		std::cerr &lt;&lt; "An array exception occurred (" &lt;&lt; exception.what() &lt;&lt; ")\n";</code><code>	}</code><code>	catch (const std::exception&amp; exception)</code><code>	{</code><code>		std::cerr &lt;&lt; "Some other std::exception occurred (" &lt;&lt; exception.what() &lt;&lt; ")\n";</code><code>	}</code><code>}</code></pre><p>It’s up to you whether you want create your own standalone exception classes, use the standard exception classes, or derive your own exception classes from std::exception or std::runtime_error. All are valid approaches depending on your aims.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">20.6 — Rethrowing exceptions</h1></header><div class="entry-content" itemprop="articleBody"><p>Occasionally you may run into a case where you want to catch an exception, but not want to (or have the ability to) fully handle it at the point where you catch it. This is common when you want to log an error, but pass the issue along to the caller to actually handle.</p><p>When a function can use a return code, this is simple. Consider the following example:</p><pre class="language-cpp line-numbers"><code>Database* createDatabase(std::string filename)</code><code>{</code><code>    try</code><code>    {</code><code>        Database* d = new Database(filename);</code><code>        d-&gt;open(); // assume this throws an int exception on failure</code><code>        return d;</code><code>    }</code><code>    catch (int exception)</code><code>    {</code><code>        // Database creation failed</code><code>        delete d;</code><code>        // Write an error to some global logfile</code><code>        g_log.logError("Creation of Database failed");</code><code>    }</code><code></code><code>    return nullptr;</code><code>}</code></pre><p>In the above code snippet, the function is tasked with creating a Database object, opening the database, and returning the Database object. In the case where something goes wrong (e.g. the wrong filename is passed in), the exception handler logs an error, and then reasonably returns a null pointer.</p><p>Now consider the following function:</p><pre class="language-cpp line-numbers"><code>int getIntValueFromDatabase(Database* d, std::string table, std::string key)</code><code>{</code><code>    assert(d);</code><code></code><code>    try</code><code>    {</code><code>        return d-&gt;getIntValue(table, key); // throws int exception on failure</code><code>    }</code><code>    catch (int exception)</code><code>    {</code><code>        // Write an error to some global logfile</code><code>        g_log.logError("getIntValueFromDatabase failed");</code><code></code><code>        // However, we haven't actually handled this error</code><code>        // So what do we do here?</code><code>    }</code><code>}</code></pre><p>In the case where this function succeeds, it returns an integer value -- any integer value could be a valid value.</p><p>But what about the case where something goes wrong with getIntValue()? In that case, getIntValue() will throw an integer exception, which will be caught by the catch block in getIntValueFromDatabase(), which will log the error. But then how do we tell the caller of getIntValueFromDatabase() that something went wrong? Unlike the top example, there isn’t a good return code we can use here (because any integer return value could be a valid one).</p><p><strong>Throwing a new exception</strong></p><p>One obvious solution is to throw a new exception.</p><pre class="language-cpp line-numbers"><code>int getIntValueFromDatabase(Database* d, std::string table, std::string key)</code><code>{</code><code>    assert(d);</code><code></code><code>    try</code><code>    {</code><code>        return d-&gt;getIntValue(table, key); // throws int exception on failure</code><code>    }</code><code>    catch (int exception)</code><code>    {</code><code>        // Write an error to some global logfile</code><code>        g_log.logError("getIntValueFromDatabase failed");</code><code></code><code>        throw 'q'; // throw char exception 'q' up the stack to be handled by caller of getIntValueFromDatabase()</code><code>    }</code><code>}</code></pre><p>In the example above, the program catches the int exception from getIntValue(), logs the error, and then throws a new exception with char value ‘q’. Although it may seem weird to throw an exception from a catch block, this is allowed. Remember, only exceptions thrown within a try block are eligible to be caught. This means that an exception thrown within a catch block will not be caught by the catch block it’s in. Instead, it will be propagated up the stack to the caller.</p><p>The exception thrown from the catch block can be an exception of any type -- it doesn’t need to be the same type as the exception that was just caught.</p><p><strong>Rethrowing an exception (the wrong way)</strong></p><p>Another option is to rethrow the same exception. One way to do this is as follows:</p><pre class="language-cpp line-numbers"><code>int getIntValueFromDatabase(Database* d, std::string table, std::string key)</code><code>{</code><code>    assert(d);</code><code></code><code>    try</code><code>    {</code><code>        return d-&gt;getIntValue(table, key); // throws int exception on failure</code><code>    }</code><code>    catch (int exception)</code><code>    {</code><code>        // Write an error to some global logfile</code><code>        g_log.logError("getIntValueFromDatabase failed");</code><code></code><code>        throw exception;</code><code>    }</code><code>}</code></pre><p>Although this works, this method has a couple of downsides. First, this doesn’t throw the exact same exception as the one that is caught -- rather, it throws a copy-initialized copy of variable exception. Although the compiler is free to elide the copy, it may not, so this could be less performant.</p><p>But significantly, consider what happens in the following case:</p><pre class="language-cpp line-numbers"><code>int getIntValueFromDatabase(Database* d, std::string table, std::string key)</code><code>{</code><code>    assert(d);</code><code></code><code>    try</code><code>    {</code><code>        return d-&gt;getIntValue(table, key); // throws Derived exception on failure</code><code>    }</code><code>    catch (Base &amp;exception)</code><code>    {</code><code>        // Write an error to some global logfile</code><code>        g_log.logError("getIntValueFromDatabase failed");</code><code></code><code>        throw exception; // Danger: this throws a Base object, not a Derived object</code><code>    }</code><code>}</code></pre><p>In this case, getIntValue() throws a Derived object, but the catch block is catching a Base reference. This is fine, as we know we can have a Base reference to a Derived object. However, when we throw an exception, the thrown exception is copy-initialized from variable exception. Variable exception has type Base, so the copy-initialized exception also has type Base (not Derived!). In other words, our Derived object has been sliced!</p><p>You can see this in the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>class Base</code><code>{</code><code>public:</code><code>    Base() {}</code><code>    virtual void print() { std::cout &lt;&lt; "Base"; }</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    Derived() {}</code><code>    void print() override { std::cout &lt;&lt; "Derived"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    try</code><code>    {</code><code>        try</code><code>        {</code><code>            throw Derived{};</code><code>        }</code><code>        catch (Base&amp; b)</code><code>        {</code><code>            std::cout &lt;&lt; "Caught Base b, which is actually a ";</code><code>            b.print();</code><code>            std::cout &lt;&lt; '\n';</code><code>            throw b; // the Derived object gets sliced here</code><code>        }</code><code>    }</code><code>    catch (Base&amp; b)</code><code>    {</code><code>        std::cout &lt;&lt; "Caught Base b, which is actually a ";</code><code>        b.print();</code><code>        std::cout &lt;&lt; '\n';</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>Caught Base b, which is actually a Derived
Caught Base b, which is actually a Base
</pre><p>The fact that the second line indicates that Base is actually a Base rather than a Derived proves that the Derived object was sliced.</p><p><strong>Rethrowing an exception (the right way)</strong></p><p>Fortunately, C++ provides a way to rethrow the exact same exception as the one that was just caught. To do so, simply use the throw keyword from within the catch block (with no associated variable), like so:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>class Base</code><code>{</code><code>public:</code><code>    Base() {}</code><code>    virtual void print() { std::cout &lt;&lt; "Base"; }</code><code>};</code><code></code><code>class Derived: public Base</code><code>{</code><code>public:</code><code>    Derived() {}</code><code>    void print() override { std::cout &lt;&lt; "Derived"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>    try</code><code>    {</code><code>        try</code><code>        {</code><code>            throw Derived{};</code><code>        }</code><code>        catch (Base&amp; b)</code><code>        {</code><code>            std::cout &lt;&lt; "Caught Base b, which is actually a ";</code><code>            b.print();</code><code>            std::cout &lt;&lt; '\n';</code><code>            throw; // note: We're now rethrowing the object here</code><code>        }</code><code>    }</code><code>    catch (Base&amp; b)</code><code>    {</code><code>        std::cout &lt;&lt; "Caught Base b, which is actually a ";</code><code>        b.print();</code><code>        std::cout &lt;&lt; '\n';</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints:</p><pre>Caught Base b, which is actually a Derived
Caught Base b, which is actually a Derived
</pre><p>This throw keyword that doesn’t appear to throw anything in particular actually re-throws the exact same exception that was just caught. No copies are made, meaning we don’t have to worry about performance killing copies or slicing.</p><p>If rethrowing an exception is required, this method should be preferred over the alternatives.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Rule</h4><p>When rethrowing the same exception, use the throw keyword by itself</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">20.7 — Function try blocks</h1></header><div class="entry-content" itemprop="articleBody"><p>Try and catch blocks work well enough in most cases, but there is one particular case in which they are not sufficient. Consider the following example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class A</code><code>{</code><code>private:</code><code>	int m_x;</code><code>public:</code><code>	A(int x) : m_x{x}</code><code>	{</code><code>		if (x &lt;= 0)</code><code>			throw 1;</code><code>	}</code><code>};</code><code></code><code>class B : public A</code><code>{</code><code>public:</code><code>	B(int x) : A{x}</code><code>	{</code><code>		// What happens if creation of A fails and we want to handle it here?</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	try</code><code>	{</code><code>		B b{0};</code><code>	}</code><code>	catch (int)</code><code>	{</code><code>		std::cout &lt;&lt; "Oops\n";</code><code>	}</code><code>}</code></pre><p>In the above example, derived class B calls base class constructor A, which can throw an exception. Because the creation of object b has been placed inside a try block (in function main()), if A throws an exception, main’s try block will catch it. Consequently, this program prints:</p><pre>Oops
</pre><p>But what if we want to catch the exception inside of B? The call to base constructor A happens via the member initialization list, before the B constructor’s body is called. There’s no way to wrap a standard try block around it.</p><p>In this situation, we have to use a slightly modified try block called a <strong>function try block</strong>.</p><p><strong>Function try blocks</strong></p><p>Function try blocks are designed to allow you to establish an exception handler around the body of an entire function, rather than around a block of code.</p><p>The syntax for function try blocks is a little hard to describe, so we’ll show by example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class A</code><code>{</code><code>private:</code><code>	int m_x;</code><code>public:</code><code>	A(int x) : m_x{x}</code><code>	{</code><code>		if (x &lt;= 0)</code><code>			throw 1;</code><code>	}</code><code>};</code><code></code><code>class B : public A</code><code>{</code><code>public:</code><code>	B(int x) try : A{x} // note addition of try keyword here</code><code>	{</code><code>	}</code><code>	catch (...) // note this is at same level of indentation as the function itself</code><code>	{</code><code>                // Exceptions from member initializer list or constructor body are caught here</code><code></code><code>                std::cerr &lt;&lt; "Exception caught\n";</code><code></code><code>                // If an exception isn't explicitly thrown here, the current exception will be implicitly rethrown</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	try</code><code>	{</code><code>		B b{0};</code><code>	}</code><code>	catch (int)</code><code>	{</code><code>		std::cout &lt;&lt; "Oops\n";</code><code>	}</code><code>}</code></pre><p>When this program is run, it produces the output:</p><pre>Exception caught
Oops
</pre><p>Let’s examine this program in more detail.</p><p>First, note the addition of the “try” keyword before the member initializer list. This indicates that everything after that point (until the end of the function) should be considered inside of the try block.</p><p>Second, note that the associated catch block is at the same level of indentation as the entire function. Any exception thrown between the try keyword and the end of the function body will be eligible to be caught here.</p><p>Finally, unlike normal catch blocks, which allow you to either resolve an exception, throw a new exception, or rethrow an existing exception, with function-level try blocks, you must throw or rethrow an exception. If you do not explicitly throw a new exception, or rethrow the current exception (using the throw keyword by itself), the exception will be implicitly rethrown up the stack.</p><p>In the program above, because we did not explicitly throw an exception from the function-level catch block, the exception was implicitly rethrown, and was caught by the catch block in main(). This is the reason why the above program prints “Oops”!</p><p>Although function level try blocks can be used with non-member functions as well, they typically aren’t because there’s rarely a case where this would be needed. They are almost exclusively used with constructors!</p><p><strong>Function try blocks can catch both base and the current class exceptions</strong></p><p>In the above example, if either A or B’s constructor throws an exception, it will be caught by the try block around B’s constructor.</p><p>We can see that in the following example, where we’re throwing an exception from class B instead of class A:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class A</code><code>{</code><code>private:</code><code>	int m_x;</code><code>public:</code><code>	A(int x) : m_x{x}</code><code>	{</code><code>	}</code><code>};</code><code></code><code>class B : public A</code><code>{</code><code>public:</code><code>	B(int x) try : A{x} // note addition of try keyword here</code><code>	{</code><code>		if (x &lt;= 0) // moved this from A to B</code><code>			throw 1; // and this too</code><code>	}</code><code>	catch (...)</code><code>	{</code><code>                std::cerr &lt;&lt; "Exception caught\n";</code><code></code><code>                // If an exception isn't explicitly thrown here, the current exception will be implicitly rethrown</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	try</code><code>	{</code><code>		B b{0};</code><code>	}</code><code>	catch (int)</code><code>	{</code><code>		std::cout &lt;&lt; "Oops\n";</code><code>	}</code><code>}</code></pre><p>We get the same output:</p><pre>Exception caught
Oops
</pre><p><strong>Don’t use function try to clean up resources</strong></p><p>When construction of an object fails, the destructor of the class is not called. Consequently, you may be tempted to use a function try block as a way to clean up a class that had partially allocated resources before failing. However, referring to members of the failed object is considered undefined behavior since the object is “dead” before the catch block executes. This means that you can’t use function try to clean up after a class. If you want to clean up after a class, follow the standard rules for cleaning up classes that throw exceptions (see the “When constructors fail” subsection of lesson <a href="https://www.learncpp.com/cpp-tutorial/exceptions-classes-and-inheritance/">20.5 -- Exceptions, classes, and inheritance</a>).</p><p>Function try is useful primarily for either logging failures before passing the exception up the stack, or for changing the type of exception thrown.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">20.8 — Exception dangers and downsides</h1></header><div class="entry-content" itemprop="articleBody"><p>As with almost everything that has benefits, there are some potential downsides to exceptions as well. This article is not meant to be comprehensive, but just to point out some of the major issues that should be considered when using exceptions (or deciding whether to use them).</p><p><strong>Cleaning up resources</strong></p><p>One of the biggest problems that new programmers run into when using exceptions is the issue of cleaning up resources when an exception occurs. Consider the following example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>try</code><code>{</code><code>    openFile(filename);</code><code>    writeFile(filename, data);</code><code>    closeFile(filename);</code><code>}</code><code>catch (const FileException&amp; exception)</code><code>{</code><code>    std::cerr &lt;&lt; "Failed to write to file: " &lt;&lt; exception.what() &lt;&lt; '\n';</code><code>}</code></pre><p>What happens if WriteFile() fails and throws a FileException? At this point, we’ve already opened the file, and now control flow jumps to the FileException handler, which prints an error and exits. Note that the file was never closed! This example should be rewritten as follows:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>try</code><code>{</code><code>    openFile(filename);</code><code>    writeFile(filename, data);</code><code>}</code><code>catch (const FileException&amp; exception)</code><code>{</code><code>    std::cerr &lt;&lt; "Failed to write to file: " &lt;&lt; exception.what() &lt;&lt; '\n';</code><code>}</code><code></code><code>// Make sure file is closed</code><code>closeFile(filename);</code></pre><p>This kind of error often crops up in another form when dealing with dynamically allocated memory:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>try</code><code>{</code><code>    auto* john { new Person{ "John", 18, PERSON_MALE } };</code><code>    processPerson(john);</code><code>    delete john;</code><code>}</code><code>catch (const PersonException&amp; exception)</code><code>{</code><code>    std::cerr &lt;&lt; "Failed to process person: " &lt;&lt; exception.what() &lt;&lt; '\n';</code><code>}</code></pre><p>If processPerson() throws an exception, control flow jumps to the catch handler. As a result, john is never deallocated! This example is a little more tricky than the previous one -- because john is local to the try block, it goes out of scope when the try block exits. That means the exception handler can not access john at all (its been destroyed already), so there’s no way for it to deallocate the memory.</p><p>However, there are two relatively easy ways to fix this. First, declare john outside of the try block so it does not go out of scope when the try block exits:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>Person* john{ nullptr };</code><code></code><code>try</code><code>{</code><code>    john = new Person("John", 18, PERSON_MALE);</code><code>    processPerson(john);</code><code>}</code><code>catch (const PersonException&amp; exception)</code><code>{</code><code>    std::cerr &lt;&lt; "Failed to process person: " &lt;&lt; exception.what() &lt;&lt; '\n';</code><code>}</code><code></code><code>delete john;</code></pre><p>Because john is declared outside the try block, it is accessible both within the try block and the catch handlers. This means the catch handler can do cleanup properly.</p><p>The second way is to use a local variable of a class that knows how to cleanup itself when it goes out of scope (often called a “smart pointer”). The standard library provides a class called std::unique_ptr that can be used for this purpose. <strong>std::unique_ptr</strong> is a template class that holds a pointer, and deallocates it when it goes out of scope.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <memory> // for std::unique_ptr</memory></code><code></code><code>try</code><code>{</code><code>    auto* john { new Person("John", 18, PERSON_MALE) };</code><code>    std::unique_ptr<person> upJohn { john }; // upJohn now owns john</person></code><code></code><code>    ProcessPerson(john);</code><code></code><code>    // when upJohn goes out of scope, it will delete john</code><code>}</code><code>catch (const PersonException&amp; exception)</code><code>{</code><code>    std::cerr &lt;&lt; "Failed to process person: " &lt;&lt; exception.what() &lt;&lt; '\n';</code><code>}</code></pre><p>We’ll talk more about smart pointers in the next chapter.</p><p><strong>Exceptions and destructors</strong></p><p>Unlike constructors, where throwing exceptions can be a useful way to indicate that object creation did not succeed, exceptions should <em>never</em> be thrown in destructors.</p><p>The problem occurs when an exception is thrown from a destructor during the stack unwinding process. If that happens, the compiler is put in a situation where it doesn’t know whether to continue the stack unwinding process or handle the new exception. The end result is that your program will be terminated immediately.</p><p>Consequently, the best course of action is just to abstain from using exceptions in destructors altogether. Write a message to a log file instead.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Rule</h4><p>Destructors should not throw exceptions.</p></div><p><strong>Performance concerns</strong></p><p>Exceptions do come with a small performance price to pay. They increase the size of your executable, and they may also cause it to run slower due to the additional checking that has to be performed. However, the main performance penalty for exceptions happens when an exception is actually thrown. In this case, the stack must be unwound and an appropriate exception handler found, which is a relatively expensive operation.</p><p>As a note, some modern computer architectures support an exception model called zero-cost exceptions. Zero-cost exceptions, if supported, have no additional runtime cost in the non-error case (which is the case we most care about performance). However, they incur an even larger penalty in the case where an exception is found.</p><p><strong>So when should I use exceptions?</strong></p><p>Exception handling is best used when all of the following are true:</p><ul><li>The error being handled is likely to occur only infrequently.</li><li>The error is serious and execution could not continue otherwise.</li><li>The error cannot be handled at the place where it occurs.</li><li>There isn’t a good alternative way to return an error code back to the caller.</li></ul><p>As an example, let’s consider the case where you’ve written a function that expects the user to pass in the name of a file on disk. Your function will open this file, read some data, close the file, and pass back some result to the caller. Now, let’s say the user passes in the name of a file that doesn’t exist, or a null string. Is this a good candidate for an exception?</p><p>In this case, the first two bullets above are trivially met -- this isn’t something that’s going to happen often, and your function can’t calculate a result when it doesn’t have any data to work with. The function can’t handle the error either -- it’s not the job of the function to re-prompt the user for a new filename, and that might not even be appropriate, depending on how your program is designed. The fourth bullet is the key -- is there a good alternative way to return an error code back to the caller? It depends on the details of your program. If so (e.g. you can return a null pointer, or a status code to indicate failure), that’s probably the better choice. If not, then an exception would be reasonable.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">20.9 — Exception specifications and noexcept</h1></header><div class="entry-content" itemprop="articleBody"><p>(h/t to reader Koe for providing the first draft of this lesson!)</p><p>In C++, all functions are classified as either <span class="cpp-definition">non-throwing</span> (does not throw exceptions) or <span class="cpp-definition">potentially throwing</span> (may throw an exception).</p><p>Consider the following function declaration:</p><pre class="language-cpp line-numbers"><code>int doSomething(); // can this function throw an exception or not?</code></pre><p>Looking at a typical function declaration, it is not possible to determine whether a function might throw an exception or not. While comments may help enumerate whether a function throws exceptions or not (and if so, what kind of exceptions), documentation can grow stale and there is no compiler enforcement for comments.</p><p><span class="cpp-definition">Exception specifications</span> are a language mechanism that was originally designed to document what kind of exceptions a function might throw as part of a function specification. While most of the exception specifications have now been deprecated or removed, one useful exception specification was added as a replacement, which we’ll cover in this lesson.</p><br><h3>The noexcept specifier</h3><p>The <span class="cpp-definition">noexcept specifier</span> defines a function as non-throwing. To define a function as non-throwing, we can use the <code>noexcept</code> specifier in the function declaration, placed to the right of the function parameter list:</p><pre class="language-cpp line-numbers"><code>void doSomething() noexcept; // this function is non-throwing</code></pre><p>Note that <code>noexcept</code> doesn’t actually prevent the function from throwing exceptions or calling other functions that are potentially throwing. Rather, when an exception is thrown, if an exception exits a noexcept function, <code>std::terminate</code> will be called. And note that if <code>std::terminate</code> is called from inside a noexcept function, stack unwinding may or may not occur (depending on implementation and optimizations), which means your objects may or may not be destructed properly prior to termination.</p><p>Much like functions that differ only in their return values can not be overloaded, functions differing only in their exception specification can not be overloaded.</p><br><h3>The noexcept specifier with a Boolean parameter</h3><p>The <code>noexcept</code> specifier has an optional Boolean parameter. <code>noexcept(true)</code> is equivalent to <code>noexcept</code>, meaning the function is non-throwing. <code>noexcept(false)</code> means the function is potentially throwing. These parameters are typically only used in template functions, so that a template function can be dynamically created as non-throwing or potentially throwing based on some parameterized value.</p><br><h3>Which functions are non-throwing and potentially-throwing</h3><p>Functions that are implicitly non-throwing:</p><ul><li>Destructors</li></ul><p>Functions that are non-throwing by default for implicitly-declared or defaulted functions:</p><ul><li>Constructors: default, copy, move</li><li>Assignments: copy, move</li><li>Comparison operators (as of C++20)</li></ul><p>However, if any of these functions call (explicitly or implicitly) another function which is potentially throwing, then the listed function will be treated as potentially throwing as well. For example, if a class has a data member with a potentially throwing constructor, then the class’s constructors will be treated as potentially throwing as well. As another example, if a copy assignment operator calls a potentially throwing assignment operator, then the copy assignment will be potentially throwing as well.</p><p>Functions that are potentially throwing (if not implicitly-declared or defaulted):</p><ul><li>Normal functions</li><li>User-defined constructors</li><li>User-defined operators</li></ul><br><h3>The noexcept operator</h3><p>The noexcept operator can also be used inside functions. It takes an expression as an argument, and returns <code>true</code> or <code>false</code> if the compiler thinks it will throw an exception or not. The noexcept operator is checked statically at compile-time, and doesn’t actually evaluate the input expression.</p><pre class="language-cpp line-numbers"><code>void foo() {throw -1;}</code><code>void boo() {};</code><code>void goo() noexcept {};</code><code>struct S{};</code><code></code><code>constexpr bool b1{ noexcept(5 + 3) }; // true; ints are non-throwing</code><code>constexpr bool b2{ noexcept(foo()) }; // false; foo() throws an exception</code><code>constexpr bool b3{ noexcept(boo()) }; // false; boo() is implicitly noexcept(false)</code><code>constexpr bool b4{ noexcept(goo()) }; // true; goo() is explicitly noexcept(true)</code><code>constexpr bool b5{ noexcept(S{}) };   // true; a struct's default constructor is noexcept by default</code></pre><p>The noexcept operator can be used to conditionally execute code depending on whether it is potentially throwing or not. This is required to fulfill certain <span class="cpp-definition">exception safety guarantees</span>, which we’ll talk about in the next section.</p><br><h3>Exception safety guarantees</h3><p>An <span class="cpp-definition">exception safety guarantee</span> is a contractual guideline about how functions or classes will behave in the event an exception occurs. There are four levels of exception safety:</p><ul><li>No guarantee -- There are no guarantees about what will happen if an exception is thrown (e.g. a class may be left in an unusable state)</li><li>Basic guarantee -- If an exception is thrown, no memory will be leaked and the object is still usable, but the program may be left in a modified state.</li><li>Strong guarantee -- If an exception is thrown, no memory will be leaked and the program state will not be changed. This means the function must either completely succeed or have no side effects if it fails. This is easy if the failure happens before anything is modified in the first place, but can also be achieved by rolling back any changes so the program is returned to the pre-failure state.</li><li>No throw / No fail -- The function will always succeed (no-fail) or fail without throwing an exception (no-throw).</li></ul><p>Let’s look at the no-throw/no-fail guarantees in more detail:</p><p>The no-throw guarantee: if a function fails, then it won’t throw an exception. Instead, it will return an error code or ignore the problem. No-throw guarantees are required during stack unwinding when an exception is already being handled; for example, all destructors should have a no-throw guarantee (as should any functions those destructors call). Examples of code that should be no-throw:</p><ul><li>destructors and memory deallocation/cleanup functions</li><li>functions that higher-level no-throw functions need to call</li></ul><p>The no-fail guarantee: a function will always succeed in what it tries to do (and thus never has a need to throw an exception, thus, no-fail is a slightly stronger form of no-throw). Examples of code that should be no-fail:</p><ul><li>move constructors and move assignment (move semantics, covered in chapter M)</li><li>swap functions</li><li>clear/erase/reset functions on containers</li><li>operations on std::unique_ptr (also covered in chapter M)</li><li>functions that higher-level no-fail functions need to call</li></ul><br><h3>When to use noexcept</h3><p>Just because your code doesn’t explicitly throw any exceptions doesn’t mean you should start sprinkling <code>noexcept</code> around your code. By default, most functions are potentially throwing, so if your function calls other functions, there is a good chance it calls a function that is potentially throwing, and thus is potentially throwing too.</p><p>There are a few good reasons to mark functions a non-throwing:</p><ul><li>Non-throwing functions can be safely called from functions that are not exception-safe, such as destructors</li><li>Functions that are noexcept can enable the compiler to perform some optimizations that would not otherwise be available. Because a noexcept function cannot throw an exception outside the function, the compiler doesn’t have to worry about keeping the runtime stack in an unwindable state, which can allow it to produce faster code.</li><li>There are also a few cases where knowing a function is noexcept allows us to produce more efficient implementations in our own code: the standard library containers (such as <code>std::vector</code>) are noexcept aware and will use the noexcept operator to determine whether to use <code>move semantics</code> (faster) or <code>copy semantics</code> (slower) in some places. We cover move semantics in chapter M, and this optimization in lesson <a href="https://www.learncpp.com/cpp-tutorial/stdmove_if_noexcept/">M.5 -- std::move_if_noexcept</a>.</li></ul><p>The standard library’s policy is to use <code>noexcept</code> only on functions that <em>must not</em> throw or fail. Functions that are potentially throwing but do not actually throw exceptions (due to implementation) typically are not marked as <code>noexcept</code>.</p><p>For your code, there are two places that make sense to use <code>noexcept</code>:</p><ul><li>On constructors and overloaded assignment operators that are no-throw (to take advantage of optimizations).</li><li>On functions for which you want to express a no-throw or no-fail guarantee (e.g. to document that they can be safely called from destructors or other noexcept functions)</li></ul><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Make constructors and overloaded assignment operators <code>noexcept</code> when you can. Use <code>noexcept</code> on other functions to express a no-fail or no-throw guarantee.</p></div><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>If you are uncertain whether a function should have a no-fail/no-throw guarantee, error on the side of caution and do not mark it with <code>noexcept</code>. Reversing a decision to use noexcept violates an interface commitment to the user about the behavior of the function. Making guarantees stronger by retroactively adding noexcept is considered safe.</p></div><br><h3>Dynamic exception specifications</h3><div class="cpp-note cpp-lightgraybackground"><h4>Optional reading</h4><p>Before C++11, and until C++17, <em>dynamic exception specifications</em> were used in place of <code>noexcept</code>. The <span class="cpp-definition">dynamic exception specifications</span> syntax uses the <code>throw</code> keyword to list which exception types a function might directly or indirectly throw:</p><pre class="language-cpp line-numbers"><code>int doSomething() throw(); // does not throw exceptions</code><code>int doSomething() throw(std::out_of_range, int*); // may throw either std::out_of_range or a pointer to an integer</code><code>int doSomething() throw(...); // may throw anything</code></pre><p>Due to factors such as incomplete compiler implementations, some incompatibility with template functions, common misunderstandings about how they worked, and the fact that the standard library mostly didn’t use them, the dynamic exception specifications were deprecated in C++11 and removed from the language in C++17 and C++20. See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0003r0.html#2.0">this paper</a> for more context.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">20.x — Chapter 20 comprehensive quiz</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>Chapter review</strong></p><p>Exception handling provides a mechanism to decouple handling of errors or other exceptional circumstances from the typical control flow of your code. This allows more freedom to handle errors when and how ever is most useful for a given situation, alleviating many (if not all) of the messiness that return codes cause.</p><p>A <strong>throw</strong> statement is used to raise an exception. <strong>Try blocks</strong> look for exceptions thrown by the code written or called within them. These exceptions get routed to <strong>catch blocks</strong>, which catch exceptions of particular types (if they match) and handle them. By default, an exception that is caught is considered handled.</p><p>Exceptions are handled immediately. If an exception is raised, control jumps to the nearest enclosing try block, looking for catch handlers that can handle the exception. If no try block is found or no catch blocks matches, the stack will be unwound until a handler is found. If no handler is found before the entire stack is unwound, the program will terminate with an unhandled exception error.</p><p>Exceptions of any data type can be thrown, including classes.</p><p>Catch blocks can be configured to catch exceptions of a particular data type, or a catch-all handler can be set up by using the ellipses (…). A catch block catching a base class reference will also catch exceptions of a derived class. All of the exceptions thrown by the standard library are derived from the std::exception class (which lives in the exception header), so catching a std::exception by reference will catch all standard library exceptions. The what() member function can be used to determine what kind of std::exception was thrown.</p><p>Inside a catch block, a new exception may be thrown. Because this new exception is thrown outside of the try block associated with that catch block, it won’t be caught by the catch block it’s thrown within. Exceptions may be rethrown from a catch block by using the keyword throw by itself. Do not rethrow an exception using the exception variable that was caught, otherwise object slicing may result.</p><p>Function try blocks give you a way to catch any exception that occurs within a function or an associated member initialization list. These are typically only used with derived class constructors.</p><p>You should never throw an exception from a destructor.</p><p>The <strong>noexcept</strong> exception specifier can be used to denote that a function is no-throw/no-fail.</p><p>Finally, exception handling does have a cost. In most cases, code using exceptions will run slightly slower, and the cost of handling an exception is very high. You should only use exceptions to handle exceptional circumstances, not for normal error handling cases (e.g. invalid input).</p><p><strong>Chapter quiz</strong></p><ol start="1"><li>Write a Fraction class that has a constructor that takes a numerator and a denominator. If the user passes in a denominator of 0, throw an exception of type std::runtime_error (included in the stdexcept header). In your main program, ask the user to enter two integers. If the Fraction is valid, print the fraction. If the Fraction is invalid, catch a std::exception, and tell the user that they entered an invalid fraction.</li></ol><p>Here’s what one run of the program should output:</p><pre>Enter the numerator: 5
Enter the denominator: 0
Invalid denominator
</pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <stdexcept> // for std::runtime_error</stdexcept></code><code>#include <exception> // for std::exception</exception></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>	int m_numerator = 0;</code><code>	int m_denominator = 1;</code><code></code><code>public:</code><code>	Fraction(int numerator = 0, int denominator = 1)</code><code>		: m_numerator{ numerator }</code><code>		, m_denominator{ denominator }</code><code>	{</code><code>		if (m_denominator == 0)</code><code>			throw std::runtime_error("Invalid denominator");</code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);</code><code></code><code>};</code><code></code><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)</code><code>{</code><code>	out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>	return out;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::cout &lt;&lt; "Enter the numerator: ";</code><code>	int numerator{};</code><code>	std::cin &gt;&gt; numerator;</code><code></code><code>	std::cout &lt;&lt; "Enter the denominator: ";</code><code>	int denominator{};</code><code>	std::cin &gt;&gt; denominator;</code><code></code><code>	try</code><code>	{</code><code>		Fraction f{ numerator, denominator };</code><code>		std::cout &lt;&lt; "Your fraction is: " &lt;&lt; f &lt;&lt; '\n';</code><code>	}</code><code>	catch (const std::exception&amp; e)</code><code>	{</code><code>		std::cerr &lt;&lt; e.what() &lt;&lt; '\n';</code><code>	}</code><code></code><code>	return 0;</code><code>}</code></pre></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">M.1 — Introduction to smart pointers and move semantics</h1></header><div class="entry-content" itemprop="articleBody"><p>Consider a function in which we dynamically allocate a value:</p><pre class="language-cpp line-numbers"><code>void someFunction()</code><code>{</code><code>    Resource* ptr = new Resource(); // Resource is a struct or class</code><code></code><code>    // do stuff with ptr here</code><code></code><code>    delete ptr;</code><code>}</code></pre><p>Although the above code seems fairly straightforward, it’s fairly easy to forget to deallocate ptr. Even if you do remember to delete ptr at the end of the function, there are a myriad of ways that ptr may not be deleted if the function exits early. This can happen via an early return:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void someFunction()</code><code>{</code><code>    Resource* ptr = new Resource();</code><code></code><code>    int x;</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    if (x == 0)</code><code>        return; // the function returns early, and ptr won’t be deleted!</code><code></code><code>    // do stuff with ptr here</code><code></code><code>    delete ptr;</code><code>}</code></pre><p>or via a thrown exception:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void someFunction()</code><code>{</code><code>    Resource* ptr = new Resource();</code><code></code><code>    int x;</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    std::cin &gt;&gt; x;</code><code></code><code>    if (x == 0)</code><code>        throw 0; // the function returns early, and ptr won’t be deleted!</code><code></code><code>    // do stuff with ptr here</code><code></code><code>    delete ptr;</code><code>}</code></pre><p>In the above two programs, the early return or throw statement execute, causing the function to terminate without variable ptr being deleted. Consequently, the memory allocated for variable ptr is now leaked (and will be leaked again every time this function is called and returns early).</p><p>At heart, these kinds of issues occur because pointer variables have no inherent mechanism to clean up after themselves.</p><p><strong>Smart pointer classes to the rescue?</strong></p><p>One of the best things about classes is that they contain destructors that automatically get executed when an object of the class goes out of scope. So if you allocate (or acquire) memory in your constructor, you can deallocate it in your destructor, and be guaranteed that the memory will be deallocated when the class object is destroyed (regardless of whether it goes out of scope, gets explicitly deleted, etc…). This is at the heart of the RAII programming paradigm that we talked about in lesson <a href="https://www.learncpp.com/cpp-tutorial/destructors/">13.9 -- Destructors</a>.</p><p>So can we use a class to help us manage and clean up our pointers? We can!</p><p>Consider a class whose sole job was to hold and “own” a pointer passed to it, and then deallocate that pointer when the class object went out of scope. As long as objects of that class were only created as local variables, we could guarantee that the class would properly go out of scope (regardless of when or how our functions terminate) and the owned pointer would get destroyed.</p><p>Here’s a first draft of the idea:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>class Auto_ptr1</code><code>{</code><code>	T* m_ptr;</code><code>public:</code><code>	// Pass in a pointer to "own" via the constructor</code><code>	Auto_ptr1(T* ptr=nullptr)</code><code>		:m_ptr(ptr)</code><code>	{</code><code>	}</code><code>	</code><code>	// The destructor will make sure it gets deallocated</code><code>	~Auto_ptr1()</code><code>	{</code><code>		delete m_ptr;</code><code>	}</code><code></code><code>	// Overload dereference and operator-&gt; so we can use Auto_ptr1 like m_ptr.</code><code>	T&amp; operator*() const { return *m_ptr; }</code><code>	T* operator-&gt;() const { return m_ptr; }</code><code>};</code><code></code><code>// A sample class to prove the above works</code><code>class Resource</code><code>{</code><code>public:</code><code>    Resource() { std::cout &lt;&lt; "Resource acquired\n"; }</code><code>    ~Resource() { std::cout &lt;&lt; "Resource destroyed\n"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Auto_ptr1<resource> res(new Resource()); // Note the allocation of memory here</resource></code><code></code><code>        // ... but no explicit delete needed</code><code></code><code>	// Also note that the Resource in angled braces doesn't need a * symbol, since that's supplied by the template</code><code></code><code>	return 0;</code><code>} // res goes out of scope here, and destroys the allocated Resource for us</code></pre><p>This program prints:</p><pre>Resource acquired
Resource destroyed
</pre><p>Consider how this program and class work. First, we dynamically create a Resource, and pass it as a parameter to our templated Auto_ptr1 class. From that point forward, our Auto_ptr1 variable res owns that Resource object (Auto_ptr1 has a composition relationship with m_ptr). Because res is declared as a local variable and has block scope, it will go out of scope when the block ends, and be destroyed (no worries about forgetting to deallocate it). And because it is a class, when it is destroyed, the Auto_ptr1 destructor will be called. That destructor will ensure that the Resource pointer it is holding gets deleted!</p><p>As long as Auto_ptr1 is defined as a local variable (with automatic duration, hence the “Auto” part of the class name), the Resource will be guaranteed to be destroyed at the end of the block it is declared in, regardless of how the function terminates (even if it terminates early).</p><p>Such a class is called a smart pointer. A <strong>Smart pointer</strong> is a composition class that is designed to manage dynamically allocated memory and ensure that memory gets deleted when the smart pointer object goes out of scope. (Relatedly, built-in pointers are sometimes called “dumb pointers” because they can’t clean up after themselves).</p><p>Now let’s go back to our someFunction() example above, and show how a smart pointer class can solve our challenge:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>class Auto_ptr1</code><code>{</code><code>	T* m_ptr;</code><code>public:</code><code>	// Pass in a pointer to "own" via the constructor</code><code>	Auto_ptr1(T* ptr=nullptr)</code><code>		:m_ptr(ptr)</code><code>	{</code><code>	}</code><code>	</code><code>	// The destructor will make sure it gets deallocated</code><code>	~Auto_ptr1()</code><code>	{</code><code>		delete m_ptr;</code><code>	}</code><code></code><code>	// Overload dereference and operator-&gt; so we can use Auto_ptr1 like m_ptr.</code><code>	T&amp; operator*() const { return *m_ptr; }</code><code>	T* operator-&gt;() const { return m_ptr; }</code><code>};</code><code></code><code>// A sample class to prove the above works</code><code>class Resource</code><code>{</code><code>public:</code><code>    Resource() { std::cout &lt;&lt; "Resource acquired\n"; }</code><code>    ~Resource() { std::cout &lt;&lt; "Resource destroyed\n"; }</code><code>    void sayHi() { std::cout &lt;&lt; "Hi!\n"; }</code><code>};</code><code></code><code>void someFunction()</code><code>{</code><code>    Auto_ptr1<resource> ptr(new Resource()); // ptr now owns the Resource</resource></code><code> </code><code>    int x;</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    std::cin &gt;&gt; x;</code><code> </code><code>    if (x == 0)</code><code>        return; // the function returns early</code><code> </code><code>    // do stuff with ptr here</code><code>    ptr-&gt;sayHi();</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    someFunction();</code><code></code><code>    return 0;</code><code>}</code></pre><p>If the user enters a non-zero integer, the above program will print:</p><pre>Resource acquired
Hi!
Resource destroyed
</pre><p>If the user enters zero, the above program will terminate early, printing:</p><pre>Resource acquired
Resource destroyed
</pre><p>Note that even in the case where the user enters zero and the function terminates early, the Resource is still properly deallocated.</p><p>Because the ptr variable is a local variable, ptr will be destroyed when the function terminates (regardless of how it terminates). And because the Auto_ptr1 destructor will clean up the Resource, we are assured that the Resource will be properly cleaned up.</p><p><strong>A critical flaw</strong></p><p>The Auto_ptr1 class has a critical flaw lurking behind some auto-generated code. Before reading further, see if you can identify what it is. We’ll wait…</p><p>(Hint: consider what parts of a class get auto-generated if you don’t supply them)</p><p>(Jeopardy music)</p><p>Okay, time’s up.</p><p>Rather than tell you, we’ll show you. Consider the following program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>// Same as above</code><code>template <typename t=""></typename></code><code>class Auto_ptr1</code><code>{</code><code>	T* m_ptr;</code><code>public:</code><code>	Auto_ptr1(T* ptr=nullptr)</code><code>		:m_ptr(ptr)</code><code>	{</code><code>	}</code><code>	</code><code>	~Auto_ptr1()</code><code>	{</code><code>		delete m_ptr;</code><code>	}</code><code></code><code>	T&amp; operator*() const { return *m_ptr; }</code><code>	T* operator-&gt;() const { return m_ptr; }</code><code>};</code><code></code><code>class Resource</code><code>{</code><code>public:</code><code>	Resource() { std::cout &lt;&lt; "Resource acquired\n"; }</code><code>	~Resource() { std::cout &lt;&lt; "Resource destroyed\n"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Auto_ptr1<resource> res1(new Resource());</resource></code><code>	Auto_ptr1<resource> res2(res1); // Alternatively, don't initialize res2 and then assign res2 = res1;</resource></code><code></code><code>	return 0;</code><code>}</code></pre><p>This program prints:</p><pre>Resource acquired
Resource destroyed
Resource destroyed
</pre><p>Very likely (but not necessarily) your program will crash at this point. See the problem now? Because we haven’t supplied a copy constructor or an assignment operator, C++ provides one for us. And the functions it provides do shallow copies. So when we initialize res2 with res1, both Auto_ptr1 variables are pointed at the same Resource. When res2 goes out of the scope, it deletes the resource, leaving res1 with a dangling pointer. When res1 goes to delete its (already deleted) Resource, crash!</p><p>You’d run into a similar problem with a function like this:</p><pre class="language-cpp line-numbers"><code>void passByValue(Auto_ptr1<resource> res)</resource></code><code>{</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Auto_ptr1<resource> res1(new Resource());</resource></code><code>	passByValue(res1);</code><code></code><code>	return 0;</code><code>}</code></pre><p>In this program, res1 will be copied by value into passByValue’s parameter res, leading to duplication of the Resource pointer. Crash!</p><p>So clearly this isn’t good. How can we address this?</p><p>Well, one thing we could do would be to explicitly define and delete the copy constructor and assignment operator, thereby preventing any copies from being made in the first place. That would prevent the pass by value case (which is good, we probably shouldn’t be passing these by value anyway).</p><p>But then how would we return an Auto_ptr1 from a function back to the caller?</p><pre class="language-cpp line-numbers"><code>??? generateResource()</code><code>{</code><code>     Resource* r{ new Resource() };</code><code>     return Auto_ptr1(r);</code><code>}</code></pre><p>We can’t return our Auto_ptr1 by reference, because the local Auto_ptr1 will be destroyed at the end of the function, and the caller will be left with a dangling reference. We could return pointer r as <code>Resource*</code>, but then we might forget to delete r later, which is the whole point of using smart pointers in the first place. So that’s out. Returning the Auto_ptr1 by value is the only option that makes sense -- but then we end up with shallow copies, duplicated pointers, and crashes.</p><p>Another option would be to override the copy constructor and assignment operator to make deep copies. In this way, we’d at least guarantee to avoid duplicate pointers to the same object. But copying can be expensive (and may not be desirable or even possible), and we don’t want to make needless copies of objects just to return an Auto_ptr1 from a function. Plus assigning or initializing a dumb pointer doesn’t copy the object being pointed to, so why would we expect smart pointers to behave differently?</p><p>What do we do?</p><p><strong>Move semantics</strong></p><p>What if, instead of having our copy constructor and assignment operator copy the pointer (“copy semantics”), we instead transfer/move ownership of the pointer from the source to the destination object? This is the core idea behind move semantics. <strong>Move semantics</strong> means the class will transfer ownership of the object rather than making a copy.</p><p>Let’s update our Auto_ptr1 class to show how this can be done:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>class Auto_ptr2</code><code>{</code><code>	T* m_ptr;</code><code>public:</code><code>	Auto_ptr2(T* ptr=nullptr)</code><code>		:m_ptr(ptr)</code><code>	{</code><code>	}</code><code>	</code><code>	~Auto_ptr2()</code><code>	{</code><code>		delete m_ptr;</code><code>	}</code><code></code><code>	// A copy constructor that implements move semantics</code><code>	Auto_ptr2(Auto_ptr2&amp; a) // note: not const</code><code>	{</code><code>		m_ptr = a.m_ptr; // transfer our dumb pointer from the source to our local object</code><code>		a.m_ptr = nullptr; // make sure the source no longer owns the pointer</code><code>	}</code><code>	</code><code>	// An assignment operator that implements move semantics</code><code>	Auto_ptr2&amp; operator=(Auto_ptr2&amp; a) // note: not const</code><code>	{</code><code>		if (&amp;a == this)</code><code>			return *this;</code><code></code><code>		delete m_ptr; // make sure we deallocate any pointer the destination is already holding first</code><code>		m_ptr = a.m_ptr; // then transfer our dumb pointer from the source to the local object</code><code>		a.m_ptr = nullptr; // make sure the source no longer owns the pointer</code><code>		return *this;</code><code>	}</code><code></code><code>	T&amp; operator*() const { return *m_ptr; }</code><code>	T* operator-&gt;() const { return m_ptr; }</code><code>	bool isNull() const { return m_ptr == nullptr; }</code><code>};</code><code></code><code>class Resource</code><code>{</code><code>public:</code><code>	Resource() { std::cout &lt;&lt; "Resource acquired\n"; }</code><code>	~Resource() { std::cout &lt;&lt; "Resource destroyed\n"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Auto_ptr2<resource> res1(new Resource());</resource></code><code>	Auto_ptr2<resource> res2; // Start as nullptr</resource></code><code></code><code>	std::cout &lt;&lt; "res1 is " &lt;&lt; (res1.isNull() ? "null\n" : "not null\n");</code><code>	std::cout &lt;&lt; "res2 is " &lt;&lt; (res2.isNull() ? "null\n" : "not null\n");</code><code></code><code>	res2 = res1; // res2 assumes ownership, res1 is set to null</code><code></code><code>	std::cout &lt;&lt; "Ownership transferred\n";</code><code></code><code>	std::cout &lt;&lt; "res1 is " &lt;&lt; (res1.isNull() ? "null\n" : "not null\n");</code><code>	std::cout &lt;&lt; "res2 is " &lt;&lt; (res2.isNull() ? "null\n" : "not null\n");</code><code></code><code>	return 0;</code><code>}</code></pre><p>This program prints:</p><pre>Resource acquired
res1 is not null
res2 is null
Ownership transferred
res1 is null
res2 is not null
Resource destroyed
</pre><p>Note that our overloaded operator= gave ownership of m_ptr from res1 to res2! Consequently, we don’t end up with duplicate copies of the pointer, and everything gets tidily cleaned up.</p><p><strong>std::auto_ptr, and why it was a bad idea</strong></p><p>Now would be an appropriate time to talk about std::auto_ptr. std::auto_ptr, introduced in C++98 and removed in C++17, was C++’s first attempt at a standardized smart pointer. std::auto_ptr opted to implement move semantics just like the Auto_ptr2 class does.</p><p>However, std::auto_ptr (and our Auto_ptr2 class) has a number of problems that makes using it dangerous.</p><p>First, because std::auto_ptr implements move semantics through the copy constructor and assignment operator, passing a std::auto_ptr by value to a function will cause your resource to get moved to the function parameter (and be destroyed at the end of the function when the function parameters go out of scope). Then when you go to access your auto_ptr argument from the caller (not realizing it was transferred and deleted), you’re suddenly dereferencing a null pointer. Crash!</p><p>Second, std::auto_ptr always deletes its contents using non-array delete. This means auto_ptr won’t work correctly with dynamically allocated arrays, because it uses the wrong kind of deallocation. Worse, it won’t prevent you from passing it a dynamic array, which it will then mismanage, leading to memory leaks.</p><p>Finally, auto_ptr doesn’t play nice with a lot of the other classes in the standard library, including most of the containers and algorithms. This occurs because those standard library classes assume that when they copy an item, it actually makes a copy, not a move.</p><p>Because of the above mentioned shortcomings, std::auto_ptr has been deprecated in C++11 and removed in C++17.</p><p><strong>Moving forward</strong></p><p>The core problem with the design of std::auto_ptr is that prior to C++11, the C++ language simply had no mechanism to differentiate “copy semantics” from “move semantics”. Overriding the copy semantics to implement move semantics leads to weird edge cases and inadvertent bugs. For example, you can write <code>res1 = res2</code> and have no idea whether res2 will be changed or not!</p><p>Because of this, in C++11, the concept of “move” was formally defined, and “move semantics” were added to the language to properly differentiate copying from moving. Now that we’ve set the stage for why move semantics can be useful, we’ll explore the topic of move semantics throughout the rest of this chapter. We’ll also fix our Auto_ptr2 class using move semantics.</p><p>In C++11, std::auto_ptr has been replaced by a bunch of other types of “move-aware” smart pointers: std::unique_ptr, std::weak_ptr, and std::shared_ptr. We’ll also explore the two most popular of these: unique_ptr (which is a direct replacement for auto_ptr) and shared_ptr.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">M.2 — R-value references</h1></header><div class="entry-content" itemprop="articleBody"><p>In chapter 9, we introduced the concept of value categories (<a href="https://www.learncpp.com/cpp-tutorial/value-categories-lvalues-and-rvalues/">9.2 -- Value categories (lvalues and rvalues)</a>), which is a property of expressions that helps determine whether an expression resolves to a value, function, or object. We also introduced l-values and r-values so that we could discuss l-value references.</p><p>If you’re hazy on l-values and r-values, now would be a good time to refresh on that topic since we’ll be talking a lot about them in this chapter.</p><p><strong>L-value references recap</strong></p><p>Prior to C++11, only one type of reference existed in C++, and so it was just called a “reference”. However, in C++11, it’s called an l-value reference. L-value references can only be initialized with modifiable l-values.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>L-value reference</th><th>Can be initialized with</th><th>Can modify</th></tr><tr><td>Modifiable l-values</td><td>Yes</td><td>Yes</td></tr><tr><td>Non-modifiable l-values</td><td>No</td><td>No</td></tr><tr><td>R-values</td><td>No</td><td>No</td></tr></tbody></table></div><p>L-value references to const objects can be initialized with modifiable and non-modifiable l-values and r-values alike. However, those values can’t be modified.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>L-value reference to const</th><th>Can be initialized with</th><th>Can modify</th></tr><tr><td>Modifiable l-values</td><td>Yes</td><td>No</td></tr><tr><td>Non-modifiable l-values</td><td>Yes</td><td>No</td></tr><tr><td>R-values</td><td>Yes</td><td>No</td></tr></tbody></table></div><p>L-value references to const objects are particularly useful because they allow us to pass any type of argument (l-value or r-value) into a function without making a copy of the argument.</p><p><strong>R-value references</strong></p><p>C++11 adds a new type of reference called an r-value reference. An r-value reference is a reference that is designed to be initialized with an r-value (only). While an l-value reference is created using a single ampersand, an r-value reference is created using a double ampersand:</p><pre class="language-cpp line-numbers"><code>int x{ 5 };</code><code>int &amp;lref{ x }; // l-value reference initialized with l-value x</code><code>int &amp;&amp;rref{ 5 }; // r-value reference initialized with r-value 5</code></pre><p>R-values references cannot be initialized with l-values.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>R-value reference</th><th>Can be initialized with</th><th>Can modify</th></tr><tr><td>Modifiable l-values</td><td>No</td><td>No</td></tr><tr><td>Non-modifiable l-values</td><td>No</td><td>No</td></tr><tr><td>R-values</td><td>Yes</td><td>Yes</td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>R-value reference to const</th><th>Can be initialized with</th><th>Can modify</th></tr><tr><td>Modifiable l-values</td><td>No</td><td>No</td></tr><tr><td>Non-modifiable l-values</td><td>No</td><td>No</td></tr><tr><td>R-values</td><td>Yes</td><td>No</td></tr></tbody></table></div><p>R-value references have two properties that are useful. First, r-value references extend the lifespan of the object they are initialized with to the lifespan of the r-value reference (l-value references to const objects can do this too). Second, non-const r-value references allow you to modify the r-value!</p><p>Let’s take a look at some examples:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code> </code><code>class Fraction</code><code>{</code><code>private:</code><code>	int m_numerator;</code><code>	int m_denominator;</code><code> </code><code>public:</code><code>	Fraction(int numerator = 0, int denominator = 1) :</code><code>		m_numerator{ numerator }, m_denominator{ denominator }</code><code>	{</code><code>	}</code><code> </code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction &amp;f1)</code><code>	{</code><code>		out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>		return out;</code><code>	}</code><code>};</code><code> </code><code>int main()</code><code>{</code><code>	auto &amp;&amp;rref{ Fraction{ 3, 5 } }; // r-value reference to temporary Fraction</code><code>	</code><code>	// f1 of operator&lt;&lt; binds to the temporary, no copies are created.</code><code>	std::cout &lt;&lt; rref &lt;&lt; '\n';</code><code> </code><code>	return 0;</code><code>} // rref (and the temporary Fraction) goes out of scope here</code></pre><p>This program prints:</p><pre>3/5
</pre><p>As an anonymous object, Fraction(3, 5) would normally go out of scope at the end of the expression in which it is defined. However, since we’re initializing an r-value reference with it, its duration is extended until the end of the block. We can then use that r-value reference to print the Fraction’s value.</p><p>Now let’s take a look at a less intuitive example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    int &amp;&amp;rref{ 5 }; // because we're initializing an r-value reference with a literal, a temporary with value 5 is created here</code><code>    rref = 10;</code><code>    std::cout &lt;&lt; rref &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This program prints:</p><pre>10
</pre><p>While it may seem weird to initialize an r-value reference with a literal value and then be able to change that value, when initializing an r-value reference with a literal, a temporary object is constructed from the literal so that the reference is referencing a temporary object, not a literal value.</p><p>R-value references are not very often used in either of the manners illustrated above.</p><p><strong>R-value references as function parameters</strong></p><p>R-value references are more often used as function parameters. This is most useful for function overloads when you want to have different behavior for l-value and r-value arguments.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>void fun(const int &amp;lref) // l-value arguments will select this function</code><code>{</code><code>	std::cout &lt;&lt; "l-value reference to const\n";</code><code>}</code><code></code><code>void fun(int &amp;&amp;rref) // r-value arguments will select this function</code><code>{</code><code>	std::cout &lt;&lt; "r-value reference\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	int x{ 5 };</code><code>	fun(x); // l-value argument calls l-value version of function</code><code>	fun(5); // r-value argument calls r-value version of function</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>l-value reference to const
r-value reference
</pre><p>As you can see, when passed an l-value, the overloaded function resolved to the version with the l-value reference. When passed an r-value, the overloaded function resolved to the version with the r-value reference (this is considered a better match than a l-value reference to const).</p><p>Why would you ever want to do this? We’ll discuss this in more detail in the next lesson. Needless to say, it’s an important part of move semantics.</p><p>One interesting note:</p><pre class="language-cpp line-numbers"><code>	int &amp;&amp;ref{ 5 };</code><code>	fun(ref);</code></pre><p>actually calls the l-value version of the function! Although variable ref has type <em>r-value reference to an integer</em>, it is actually an l-value itself (as are all named variables). The confusion stems from the use of the term r-value in two different contexts. Think of it this way: Named-objects are l-values. Anonymous objects are r-values. The type of the named object or anonymous object is independent from whether it’s an l-value or r-value. Or, put another way, if r-value reference had been called anything else, this confusion wouldn’t exist.</p><p><strong>Returning an r-value reference</strong></p><p>You should almost never return an r-value reference, for the same reason you should almost never return an l-value reference. In most cases, you’ll end up returning a hanging reference when the referenced object goes out of scope at the end of the function.</p><p><strong>Quiz time</strong></p><ol start="1"><li>State which of the following lettered statements will not compile:</li></ol><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>	int x{};</code><code></code><code>	// l-value references</code><code>	int &amp;ref1{ x }; // A</code><code>	int &amp;ref2{ 5 }; // B</code><code></code><code>	const int &amp;ref3{ x }; // C</code><code>	const int &amp;ref4{ 5 }; // D</code><code></code><code>	// r-value references</code><code>	int &amp;&amp;ref5{ x }; // E</code><code>	int &amp;&amp;ref6{ 5 }; // F</code><code></code><code>	const int &amp;&amp;ref7{ x }; // G</code><code>	const int &amp;&amp;ref8{ 5 }; // H</code><code>	</code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none">B, E, and G won’t compile.</div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">M.3 — Move constructors and move assignment</h1></header><div class="entry-content" itemprop="articleBody"><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-smart-pointers-move-semantics/">M.1 -- Introduction to smart pointers and move semantics</a>, we took a look at std::auto_ptr, discussed the desire for move semantics, and took a look at some of the downsides that occur when functions designed for copy semantics (copy constructors and copy assignment operators) are redefined to implement move semantics.</p><p>In this lesson, we’ll take a deeper look at how C++11 resolves these problems via move constructors and move assignment.</p><p><strong>Copy constructors and copy assignment</strong></p><p>First, let’s take a moment to recap copy semantics.</p><p>Copy constructors are used to initialize a class by making a copy of an object of the same class. Copy assignment is used to copy one class object to another existing class object. By default, C++ will provide a copy constructor and copy assignment operator if one is not explicitly provided. These compiler-provided functions do shallow copies, which may cause problems for classes that allocate dynamic memory. So classes that deal with dynamic memory should override these functions to do deep copies.</p><p>Returning back to our Auto_ptr smart pointer class example from the first lesson in this chapter, let’s look at a version that implements a copy constructor and copy assignment operator that do deep copies, and a sample program that exercises them:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template<typename t=""></typename></code><code>class Auto_ptr3</code><code>{</code><code>	T* m_ptr;</code><code>public:</code><code>	Auto_ptr3(T* ptr = nullptr)</code><code>		:m_ptr(ptr)</code><code>	{</code><code>	}</code><code></code><code>	~Auto_ptr3()</code><code>	{</code><code>		delete m_ptr;</code><code>	}</code><code></code><code>	// Copy constructor</code><code>	// Do deep copy of a.m_ptr to m_ptr</code><code>	Auto_ptr3(const Auto_ptr3&amp; a)</code><code>	{</code><code>		m_ptr = new T;</code><code>		*m_ptr = *a.m_ptr;</code><code>	}</code><code></code><code>	// Copy assignment</code><code>	// Do deep copy of a.m_ptr to m_ptr</code><code>	Auto_ptr3&amp; operator=(const Auto_ptr3&amp; a)</code><code>	{</code><code>		// Self-assignment detection</code><code>		if (&amp;a == this)</code><code>			return *this;</code><code></code><code>		// Release any resource we're holding</code><code>		delete m_ptr;</code><code></code><code>		// Copy the resource</code><code>		m_ptr = new T;</code><code>		*m_ptr = *a.m_ptr;</code><code></code><code>		return *this;</code><code>	}</code><code></code><code>	T&amp; operator*() const { return *m_ptr; }</code><code>	T* operator-&gt;() const { return m_ptr; }</code><code>	bool isNull() const { return m_ptr == nullptr; }</code><code>};</code><code></code><code>class Resource</code><code>{</code><code>public:</code><code>	Resource() { std::cout &lt;&lt; "Resource acquired\n"; }</code><code>	~Resource() { std::cout &lt;&lt; "Resource destroyed\n"; }</code><code>};</code><code></code><code>Auto_ptr3<resource> generateResource()</resource></code><code>{</code><code>	Auto_ptr3<resource> res{new Resource};</resource></code><code>	return res; // this return value will invoke the copy constructor</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Auto_ptr3<resource> mainres;</resource></code><code>	mainres = generateResource(); // this assignment will invoke the copy assignment</code><code></code><code>	return 0;</code><code>}</code></pre><p>In this program, we’re using a function named generateResource() to create a smart pointer encapsulated resource, which is then passed back to function main(). Function main() then assigns that to an existing Auto_ptr3 object.</p><p>When this program is run, it prints:</p><pre>Resource acquired
Resource acquired
Resource destroyed
Resource acquired
Resource destroyed
Resource destroyed
</pre><p>(Note: You may only get 4 outputs if your compiler elides the return value from function generateResource())</p><p>That’s a lot of resource creation and destruction going on for such a simple program! What’s going on here?</p><p>Let’s take a closer look. There are 6 key steps that happen in this program (one for each printed message):</p><ol start="1"><li>Inside generateResource(), local variable res is created and initialized with a dynamically allocated Resource, which causes the first “Resource acquired”.</li><li>Res is returned back to main() by value. We return by value here because res is a local variable -- it can’t be returned by address or reference because res will be destroyed when generateResource() ends. So res is copy constructed into a temporary object. Since our copy constructor does a deep copy, a new Resource is allocated here, which causes the second “Resource acquired”.</li><li>Res goes out of scope, destroying the originally created Resource, which causes the first “Resource destroyed”.</li><li>The temporary object is assigned to mainres by copy assignment. Since our copy assignment also does a deep copy, a new Resource is allocated, causing yet another “Resource acquired”.</li><li>The assignment expression ends, and the temporary object goes out of expression scope and is destroyed, causing a “Resource destroyed”.</li><li>At the end of main(), mainres goes out of scope, and our final “Resource destroyed” is displayed.</li></ol><p>So, in short, because we call the copy constructor once to copy construct res to a temporary, and copy assignment once to copy the temporary into mainres, we end up allocating and destroying 3 separate objects in total.</p><p>Inefficient, but at least it doesn’t crash!</p><p>However, with move semantics, we can do better.</p><p><strong>Move constructors and move assignment</strong></p><p>C++11 defines two new functions in service of move semantics: a move constructor, and a move assignment operator. Whereas the goal of the copy constructor and copy assignment is to make a copy of one object to another, the goal of the move constructor and move assignment is to move ownership of the resources from one object to another (which is typically much less expensive than making a copy).</p><p>Defining a move constructor and move assignment work analogously to their copy counterparts. However, whereas the copy flavors of these functions take a const l-value reference parameter, the move flavors of these functions use non-const r-value reference parameters.</p><p>Here’s the same Auto_ptr3 class as above, with a move constructor and move assignment operator added. We’ve left in the deep-copying copy constructor and copy assignment operator for comparison purposes.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template<typename t=""></typename></code><code>class Auto_ptr4</code><code>{</code><code>	T* m_ptr;</code><code>public:</code><code>	Auto_ptr4(T* ptr = nullptr)</code><code>		:m_ptr(ptr)</code><code>	{</code><code>	}</code><code></code><code>	~Auto_ptr4()</code><code>	{</code><code>		delete m_ptr;</code><code>	}</code><code></code><code>	// Copy constructor</code><code>	// Do deep copy of a.m_ptr to m_ptr</code><code>	Auto_ptr4(const Auto_ptr4&amp; a)</code><code>	{</code><code>		m_ptr = new T;</code><code>		*m_ptr = *a.m_ptr;</code><code>	}</code><code></code><code>	// Move constructor</code><code>	// Transfer ownership of a.m_ptr to m_ptr</code><code>	Auto_ptr4(Auto_ptr4&amp;&amp; a) noexcept</code><code>		: m_ptr(a.m_ptr)</code><code>	{</code><code>		a.m_ptr = nullptr; // we'll talk more about this line below</code><code>	}</code><code></code><code>	// Copy assignment</code><code>	// Do deep copy of a.m_ptr to m_ptr</code><code>	Auto_ptr4&amp; operator=(const Auto_ptr4&amp; a)</code><code>	{</code><code>		// Self-assignment detection</code><code>		if (&amp;a == this)</code><code>			return *this;</code><code></code><code>		// Release any resource we're holding</code><code>		delete m_ptr;</code><code></code><code>		// Copy the resource</code><code>		m_ptr = new T;</code><code>		*m_ptr = *a.m_ptr;</code><code></code><code>		return *this;</code><code>	}</code><code></code><code>	// Move assignment</code><code>	// Transfer ownership of a.m_ptr to m_ptr</code><code>	Auto_ptr4&amp; operator=(Auto_ptr4&amp;&amp; a) noexcept</code><code>	{</code><code>		// Self-assignment detection</code><code>		if (&amp;a == this)</code><code>			return *this;</code><code></code><code>		// Release any resource we're holding</code><code>		delete m_ptr;</code><code></code><code>		// Transfer ownership of a.m_ptr to m_ptr</code><code>		m_ptr = a.m_ptr;</code><code>		a.m_ptr = nullptr; // we'll talk more about this line below</code><code></code><code>		return *this;</code><code>	}</code><code></code><code>	T&amp; operator*() const { return *m_ptr; }</code><code>	T* operator-&gt;() const { return m_ptr; }</code><code>	bool isNull() const { return m_ptr == nullptr; }</code><code>};</code><code></code><code>class Resource</code><code>{</code><code>public:</code><code>	Resource() { std::cout &lt;&lt; "Resource acquired\n"; }</code><code>	~Resource() { std::cout &lt;&lt; "Resource destroyed\n"; }</code><code>};</code><code></code><code>Auto_ptr4<resource> generateResource()</resource></code><code>{</code><code>	Auto_ptr4<resource> res{new Resource};</resource></code><code>	return res; // this return value will invoke the move constructor</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Auto_ptr4<resource> mainres;</resource></code><code>	mainres = generateResource(); // this assignment will invoke the move assignment</code><code></code><code>	return 0;</code><code>}</code></pre><p>The move constructor and move assignment operator are simple. Instead of deep copying the source object (a) into the implicit object, we simply move (steal) the source object’s resources. This involves shallow copying the source pointer into the implicit object, then setting the source pointer to null.</p><p>When run, this program prints:</p><pre>Resource acquired
Resource destroyed
</pre><p>That’s much better!</p><p>The flow of the program is exactly the same as before. However, instead of calling the copy constructor and copy assignment operators, this program calls the move constructor and move assignment operators. Looking a little more deeply:</p><ol start="1"><li>Inside generateResource(), local variable res is created and initialized with a dynamically allocated Resource, which causes the first “Resource acquired”.</li><li>Res is returned back to main() by value. Res is move constructed into a temporary object, transferring the dynamically created object stored in res to the temporary object. We’ll talk about why this happens below.</li><li>Res goes out of scope. Because res no longer manages a pointer (it was moved to the temporary), nothing interesting happens here.</li><li>The temporary object is move assigned to mainres. This transfers the dynamically created object stored in the temporary to mainres.</li><li>The assignment expression ends, and the temporary object goes out of expression scope and is destroyed. However, because the temporary no longer manages a pointer (it was moved to mainres), nothing interesting happens here either.</li><li>At the end of main(), mainres goes out of scope, and our final “Resource destroyed” is displayed.</li></ol><p>So instead of copying our Resource twice (once for the copy constructor and once for the copy assignment), we transfer it twice. This is more efficient, as Resource is only constructed and destroyed once instead of three times.</p><p><strong>When are the move constructor and move assignment called?</strong></p><p>The move constructor and move assignment are called when those functions have been defined, and the argument for construction or assignment is an r-value. Most typically, this r-value will be a literal or temporary value.</p><p>In most cases, a move constructor and move assignment operator will not be provided by default, unless the class does not have any defined copy constructors, copy assignment, move assignment, or destructors.</p><p><strong>The key insight behind move semantics</strong></p><p>You now have enough context to understand the key insight behind move semantics.</p><p>If we construct an object or do an assignment where the argument is an l-value, the only thing we can reasonably do is copy the l-value. We can’t assume it’s safe to alter the l-value, because it may be used again later in the program. If we have an expression “a = b”, we wouldn’t reasonably expect b to be changed in any way.</p><p>However, if we construct an object or do an assignment where the argument is an r-value, then we know that r-value is just a temporary object of some kind. Instead of copying it (which can be expensive), we can simply transfer its resources (which is cheap) to the object we’re constructing or assigning. This is safe to do because the temporary will be destroyed at the end of the expression anyway, so we know it will never be used again!</p><p>C++11, through r-value references, gives us the ability to provide different behaviors when the argument is an r-value vs an l-value, enabling us to make smarter and more efficient decisions about how our objects should behave.</p><p><strong>Move functions should always leave both objects in a well-defined state</strong></p><p>In the above examples, both the move constructor and move assignment functions set a.m_ptr to nullptr. This may seem extraneous -- after all, if “a” is a temporary r-value, why bother doing “cleanup” if parameter “a” is going to be destroyed anyway?</p><p>The answer is simple: When “a” goes out of scope, a’s destructor will be called, and a.m_ptr will be deleted. If at that point, a.m_ptr is still pointing to the same object as m_ptr, then m_ptr will be left as a dangling pointer. When the object containing m_ptr eventually gets used (or destroyed), we’ll get undefined behavior.</p><p>Additionally, in the next lesson we’ll see cases where “a” can be an l-value. In such a case, “a” wouldn’t be destroyed immediately, and could be queried further before its lifetime ends.</p><p><strong>Automatic l-values returned by value may be moved instead of copied</strong></p><p>In the generateResource() function of the Auto_ptr4 example above, when variable res is returned by value, it is moved instead of copied, even though res is an l-value. The C++ specification has a special rule that says automatic objects returned from a function by value can be moved even if they are l-values. This makes sense, since res was going to be destroyed at the end of the function anyway! We might as well steal its resources instead of making an expensive and unnecessary copy.</p><p>Although the compiler can move l-value return values, in some cases it may be able to do even better by simply eliding the copy altogether (which avoids the need to make a copy or do a move at all). In such a case, neither the copy constructor nor move constructor would be called.</p><p><strong>Disabling copying</strong></p><p>In the Auto_ptr4 class above, we left in the copy constructor and assignment operator for comparison purposes. But in move-enabled classes, it is sometimes desirable to delete the copy constructor and copy assignment functions to ensure copies aren’t made. In the case of our Auto_ptr class, we don’t want to copy our templated object T -- both because it’s expensive, and whatever class T is may not even support copying!</p><p>Here’s a version of Auto_ptr that supports move semantics but not copy semantics:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template<typename t=""></typename></code><code>class Auto_ptr5</code><code>{</code><code>	T* m_ptr;</code><code>public:</code><code>	Auto_ptr5(T* ptr = nullptr)</code><code>		:m_ptr(ptr)</code><code>	{</code><code>	}</code><code></code><code>	~Auto_ptr5()</code><code>	{</code><code>		delete m_ptr;</code><code>	}</code><code></code><code>	// Copy constructor -- no copying allowed!</code><code>	Auto_ptr5(const Auto_ptr5&amp; a) = delete;</code><code></code><code>	// Move constructor</code><code>	// Transfer ownership of a.m_ptr to m_ptr</code><code>	Auto_ptr5(Auto_ptr5&amp;&amp; a) noexcept</code><code>		: m_ptr(a.m_ptr)</code><code>	{</code><code>		a.m_ptr = nullptr;</code><code>	}</code><code></code><code>	// Copy assignment -- no copying allowed!</code><code>	Auto_ptr5&amp; operator=(const Auto_ptr5&amp; a) = delete;</code><code></code><code>	// Move assignment</code><code>	// Transfer ownership of a.m_ptr to m_ptr</code><code>	Auto_ptr5&amp; operator=(Auto_ptr5&amp;&amp; a) noexcept</code><code>	{</code><code>		// Self-assignment detection</code><code>		if (&amp;a == this)</code><code>			return *this;</code><code></code><code>		// Release any resource we're holding</code><code>		delete m_ptr;</code><code></code><code>		// Transfer ownership of a.m_ptr to m_ptr</code><code>		m_ptr = a.m_ptr;</code><code>		a.m_ptr = nullptr;</code><code></code><code>		return *this;</code><code>	}</code><code></code><code>	T&amp; operator*() const { return *m_ptr; }</code><code>	T* operator-&gt;() const { return m_ptr; }</code><code>	bool isNull() const { return m_ptr == nullptr; }</code><code>};</code></pre><p>If you were to try to pass an Auto_ptr5 l-value to a function by value, the compiler would complain that the copy constructor required to initialize the function argument has been deleted. This is good, because we should probably be passing Auto_ptr5 by const l-value reference anyway!</p><p>Auto_ptr5 is (finally) a good smart pointer class. And, in fact the standard library contains a class very much like this one (that you should use instead), named std::unique_ptr. We’ll talk more about std::unique_ptr later in this chapter.</p><p><strong>Another example</strong></p><p>Let’s take a look at another class that uses dynamic memory: a simple dynamic templated array. This class contains a deep-copying copy constructor and copy assignment operator.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>template <typename t=""></typename></code><code>class DynamicArray</code><code>{</code><code>private:</code><code>	T* m_array;</code><code>	int m_length;</code><code></code><code>public:</code><code>	DynamicArray(int length)</code><code>		: m_array(new T[length]), m_length(length)</code><code>	{</code><code>	}</code><code></code><code>	~DynamicArray()</code><code>	{</code><code>		delete[] m_array;</code><code>	}</code><code></code><code>	// Copy constructor</code><code>	DynamicArray(const DynamicArray &amp;arr)</code><code>		: m_length(arr.m_length)</code><code>	{</code><code>		m_array = new T[m_length];</code><code>		for (int i = 0; i &lt; m_length; ++i)</code><code>			m_array[i] = arr.m_array[i];</code><code>	}</code><code></code><code>	// Copy assignment</code><code>	DynamicArray&amp; operator=(const DynamicArray &amp;arr)</code><code>	{</code><code>		if (&amp;arr == this)</code><code>			return *this;</code><code></code><code>		delete[] m_array;</code><code>		</code><code>		m_length = arr.m_length;</code><code>		m_array = new T[m_length];</code><code></code><code>		for (int i = 0; i &lt; m_length; ++i)</code><code>			m_array[i] = arr.m_array[i];</code><code></code><code>		return *this;</code><code>	}</code><code></code><code>	int getLength() const { return m_length; }</code><code>	T&amp; operator[](int index) { return m_array[index]; }</code><code>	const T&amp; operator[](int index) const { return m_array[index]; }</code><code></code><code>};</code></pre><p>Now let’s use this class in a program. To show you how this class performs when we allocate a million integers on the heap, we’re going to leverage the Timer class we developed in lesson <a href="https://www.learncpp.com/cpp-tutorial/timing-your-code/">13.18 -- Timing your code</a>. We’ll use the Timer class to time how fast our code runs, and show you the performance difference between copying and moving.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <chrono> // for std::chrono functions</chrono></code><code></code><code>// Uses the above DynamicArray class</code><code></code><code>class Timer</code><code>{</code><code>private:</code><code>	// Type aliases to make accessing nested type easier</code><code>	using Clock = std::chrono::high_resolution_clock;</code><code>	using Second = std::chrono::duration<double, std::ratio<1=""> &gt;;</double,></code><code>	</code><code>	std::chrono::time_point<clock> m_beg { Clock::now() };</clock></code><code></code><code>public:</code><code>	void reset()</code><code>	{</code><code>		m_beg = Clock::now();</code><code>	}</code><code>	</code><code>	double elapsed() const</code><code>	{</code><code>		return std::chrono::duration_cast<second>(Clock::now() - m_beg).count();</second></code><code>	}</code><code>};</code><code></code><code>// Return a copy of arr with all of the values doubled</code><code>DynamicArray<int> cloneArrayAndDouble(const DynamicArray<int> &amp;arr)</int></int></code><code>{</code><code>	DynamicArray<int> dbl(arr.getLength());</int></code><code>	for (int i = 0; i &lt; arr.getLength(); ++i)</code><code>		dbl[i] = arr[i] * 2;</code><code></code><code>	return dbl;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Timer t;</code><code></code><code>	DynamicArray<int> arr(1000000);</int></code><code></code><code>	for (int i = 0; i &lt; arr.getLength(); i++)</code><code>		arr[i] = i;</code><code></code><code>	arr = cloneArrayAndDouble(arr);</code><code></code><code>	std::cout &lt;&lt; t.elapsed();</code><code>}</code></pre><p>On one of the author’s machines, in release mode, this program executed in 0.00825559 seconds.</p><p>Now let’s run the same program again, replacing the copy constructor and copy assignment with a move constructor and move assignment.</p><pre class="language-cpp line-numbers"><code>template <typename t=""></typename></code><code>class DynamicArray</code><code>{</code><code>private:</code><code>	T* m_array;</code><code>	int m_length;</code><code></code><code>public:</code><code>	DynamicArray(int length)</code><code>		: m_array(new T[length]), m_length(length)</code><code>	{</code><code>	}</code><code></code><code>	~DynamicArray()</code><code>	{</code><code>		delete[] m_array;</code><code>	}</code><code></code><code>	// Copy constructor</code><code>	DynamicArray(const DynamicArray &amp;arr) = delete;</code><code></code><code>	// Copy assignment</code><code>	DynamicArray&amp; operator=(const DynamicArray &amp;arr) = delete;</code><code></code><code>	// Move constructor</code><code>	DynamicArray(DynamicArray &amp;&amp;arr) noexcept</code><code>		:  m_array(arr.m_array), m_length(arr.m_length)</code><code>	{</code><code>		arr.m_length = 0;</code><code>		arr.m_array = nullptr;</code><code>	}</code><code></code><code>	// Move assignment</code><code>	DynamicArray&amp; operator=(DynamicArray &amp;&amp;arr) noexcept</code><code>	{</code><code>		if (&amp;arr == this)</code><code>			return *this;</code><code></code><code>		delete[] m_array;</code><code></code><code>		m_length = arr.m_length;</code><code>		m_array = arr.m_array;</code><code>		arr.m_length = 0;</code><code>		arr.m_array = nullptr;</code><code></code><code>		return *this;</code><code>	}</code><code></code><code>	int getLength() const { return m_length; }</code><code>	T&amp; operator[](int index) { return m_array[index]; }</code><code>	const T&amp; operator[](int index) const { return m_array[index]; }</code><code></code><code>};</code><code></code><code>#include <iostream></iostream></code><code>#include <chrono> // for std::chrono functions</chrono></code><code></code><code>class Timer</code><code>{</code><code>private:</code><code>	// Type aliases to make accessing nested type easier</code><code>	using Clock = std::chrono::high_resolution_clock;</code><code>	using Second = std::chrono::duration<double, std::ratio<1=""> &gt;;</double,></code><code>	</code><code>	std::chrono::time_point<clock> m_beg { Clock::now() };</clock></code><code></code><code>public:</code><code>	void reset()</code><code>	{</code><code>		m_beg = Clock::now();</code><code>	}</code><code>	</code><code>	double elapsed() const</code><code>	{</code><code>		return std::chrono::duration_cast<second>(Clock::now() - m_beg).count();</second></code><code>	}</code><code>};</code><code></code><code>// Return a copy of arr with all of the values doubled</code><code>DynamicArray<int> cloneArrayAndDouble(const DynamicArray<int> &amp;arr)</int></int></code><code>{</code><code>	DynamicArray<int> dbl(arr.getLength());</int></code><code>	for (int i = 0; i &lt; arr.getLength(); ++i)</code><code>		dbl[i] = arr[i] * 2;</code><code></code><code>	return dbl;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	Timer t;</code><code></code><code>	DynamicArray<int> arr(1000000);</int></code><code></code><code>	for (int i = 0; i &lt; arr.getLength(); i++)</code><code>		arr[i] = i;</code><code></code><code>	arr = cloneArrayAndDouble(arr);</code><code></code><code>	std::cout &lt;&lt; t.elapsed();</code><code>}</code></pre><p>On the same machine, this program executed in 0.0056 seconds.</p><p>Comparing the runtime of the two programs, 0.0056 / 0.00825559 = 67.8%. The move version was 47.4% faster!</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">M.4 — std::move</h1></header><div class="entry-content" itemprop="articleBody"><p>Once you start using move semantics more regularly, you’ll start to find cases where you want to invoke move semantics, but the objects you have to work with are l-values, not r-values. Consider the following swap function as an example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>template<class t=""></class></code><code>void myswap(T&amp; a, T&amp; b) </code><code>{ </code><code>	T tmp { a }; // invokes copy constructor</code><code>	a = b; // invokes copy assignment</code><code>	b = tmp; // invokes copy assignment</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::string x{ "abc" };</code><code>	std::string y{ "de" };</code><code></code><code>	std::cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; "y: " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>	myswap(x, y);</code><code></code><code>	std::cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; "y: " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>Passed in two objects of type T (in this case, std::string), this function swaps their values by making three copies. Consequently, this program prints:</p><pre>x: abc
y: de
x: de
y: abc
</pre><p>As we showed last lesson, making copies can be inefficient. And this version of swap makes 3 copies. That leads to a lot of excessive string creation and destruction, which is slow.</p><p>However, doing copies isn’t necessary here. All we’re really trying to do is swap the values of a and b, which can be accomplished just as well using 3 moves instead! So if we switch from copy semantics to move semantics, we can make our code more performant.</p><p>But how? The problem here is that parameters a and b are l-value references, not r-value references, so we don’t have a way to invoke the move constructor and move assignment operator instead of copy constructor and copy assignment. By default, we get the copy constructor and copy assignment behaviors. What are we to do?</p><p><strong>std::move</strong></p><p>In C++11, std::move is a standard library function that casts (using static_cast) its argument into an r-value reference, so that move semantics can be invoked. Thus, we can use std::move to cast an l-value into a type that will prefer being moved over being copied. std::move is defined in the utility header.</p><p>Here’s the same program as above, but with a myswap() function that uses std::move to convert our l-values into r-values so we can invoke move semantics:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <utility> // for std::move</utility></code><code></code><code>template<class t=""></class></code><code>void myswap(T&amp; a, T&amp; b) </code><code>{ </code><code>	T tmp { std::move(a) }; // invokes move constructor</code><code>	a = std::move(b); // invokes move assignment</code><code>	b = std::move(tmp); // invokes move assignment</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	std::string x{ "abc" };</code><code>	std::string y{ "de" };</code><code></code><code>	std::cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; "y: " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>	myswap(x, y);</code><code></code><code>	std::cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; "y: " &lt;&lt; y &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints the same result as above:</p><pre>x: abc
y: de
x: de
y: abc
</pre><p>But it’s much more efficient about it. When tmp is initialized, instead of making a copy of x, we use std::move to convert l-value variable x into an r-value. Since the parameter is an r-value, move semantics are invoked, and x is moved into tmp.</p><p>With a couple of more swaps, the value of variable x has been moved to y, and the value of y has been moved to x.</p><p><strong>Another example</strong></p><p>We can also use std::move when filling elements of a container, such as std::vector, with l-values.</p><p>In the following program, we first add an element to a vector using copy semantics. Then we add an element to the vector using move semantics.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <utility> // for std::move</utility></code><code>#include <vector></vector></code><code></code><code>int main()</code><code>{</code><code>	std::vector<std::string> v;</std::string></code><code>	std::string str = "Knock";</code><code></code><code>	std::cout &lt;&lt; "Copying str\n";</code><code>	v.push_back(str); // calls l-value version of push_back, which copies str into the array element</code><code>	</code><code>	std::cout &lt;&lt; "str: " &lt;&lt; str &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; "vector: " &lt;&lt; v[0] &lt;&lt; '\n';</code><code></code><code>	std::cout &lt;&lt; "\nMoving str\n";</code><code></code><code>	v.push_back(std::move(str)); // calls r-value version of push_back, which moves str into the array element</code><code>	</code><code>	std::cout &lt;&lt; "str: " &lt;&lt; str &lt;&lt; '\n';</code><code>	std::cout &lt;&lt; "vector:" &lt;&lt; v[0] &lt;&lt; ' ' &lt;&lt; v[1] &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This program prints:</p><pre>Copying str
str: Knock
vector: Knock

Moving str
str:
vector: Knock Knock
</pre><p>In the first case, we passed push_back() an l-value, so it used copy semantics to add an element to the vector. For this reason, the value in str is left alone.</p><p>In the second case, we passed push_back() an r-value (actually an l-value converted via std::move), so it used move semantics to add an element to the vector. This is more efficient, as the vector element can steal the string’s value rather than having to copy it. In this case, str is left empty.</p><p>At this point, it’s worth reiterating that std::move() gives a hint to the compiler that the programmer doesn’t need this object any more (at least, not in its current state). Consequently, you should not use std::move() on any persistent object you don’t want to modify, and you should not expect the state of any objects that have had std::move() applied to be the same after they are moved!</p><p><strong>Move functions should always leave your objects in a well-defined state</strong></p><p>As we noted in the previous lesson, it’s a good idea to always leave the objects being stolen from in some well-defined (deterministic) state. Ideally, this should be a “null state”, where the object is set back to its uninitialized or zero state. Now we can talk about why: with std::move, the object being stolen from may not be a temporary after all. The user may want to reuse this (now empty) object again, or test it in some way, and can plan accordingly.</p><p>In the above example, string str is set to the empty string after being moved (which is what std::string always does after a successful move). This allows us to reuse variable str if we wish (or we can ignore it, if we no longer have a use for it).</p><p><strong>Where else is std::move useful?</strong></p><p>std::move can also be useful when sorting an array of elements. Many sorting algorithms (such as selection sort and bubble sort) work by swapping pairs of elements. In previous lessons, we’ve had to resort to copy-semantics to do the swapping. Now we can use move semantics, which is more efficient.</p><p>It can also be useful if we want to move the contents managed by one smart pointer to another.</p><p><strong>Conclusion</strong></p><p>std::move can be used whenever we want to treat an l-value like an r-value for the purpose of invoking move semantics instead of copy semantics.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">M.5 — std::move_if_noexcept</h1></header><div class="entry-content" itemprop="articleBody"><p>(h/t to reader Koe for providing the first draft of this lesson!)</p><p>In lesson <a href="https://www.learncpp.com/cpp-tutorial/exception-specifications-and-noexcept/">20.9 -- Exception specifications and noexcept</a>, we covered the <code>noexcept</code> exception specifier and operator, which this lesson builds on.</p><p>We also covered the <code>strong exception guarantee</code>, which guarantees that if a function is interrupted by an exception, no memory will be leaked and the program state will not be changed. In particular, all constructors should uphold the strong exception guarantee, so that the rest of the program won’t be left in an altered state if construction of an object fails.</p><br><h3>The move constructors exception problem</h3><p>Consider the case where we are copying some object, and the copy fails for some reason (e.g. the machine is out of memory). In such a case, the object being copied is not harmed in any way, because the source object doesn’t need to be modified to create a copy. We can discard the failed copy, and move on. The <code>strong exception guarantee</code> is upheld.</p><p>Now consider the case where we are instead moving an object. A move operation transfers ownership of a given resource from the source to the destination object. If the move operation is interrupted by an exception after the transfer of ownership occurs, then our source object will be left in a modified state. This isn’t a problem if the source object is a temporary object and going to be discarded after the move anyway -- but for non-temporary objects, we’ve now damaged the source object. To comply with the <code>strong exception guarantee</code>, we’d need to move the resource back to the source object, but if the move failed the first time, there’s no guarantee the move back will succeed either.</p><p>How can we give move constructors the <code>strong exception guarantee</code>? It is simple enough to avoid throwing exceptions in the body of a move constructor, but a move constructor may invoke other constructors that are <code>potentially throwing</code>. Take for example the move constructor for <code>std::pair</code>, which must try to move each subobject in the source pair into the new pair object.</p><pre class="language-cpp line-numbers"><code>// Example move constructor definition for std::pair</code><code>// Take in an 'old' pair, and then move construct the new pair's 'first' and 'second' subobjects from the 'old' ones</code><code>template <typename t1,="" typename="" t2=""></typename></code><code>pair<t1,t2>::pair(pair&amp;&amp; old)</t1,t2></code><code>  : first(std::move(old.first)),</code><code>    second(std::move(old.second))</code><code>{}</code></pre><p>Now lets use two classes, <code>MoveClass</code> and <code>CopyClass</code>, which we will <code>pair</code> together to demonstrate the <code>strong exception guarantee</code> problem with move constructors:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <utility> // For std::pair, std::make_pair, std::move, std::move_if_noexcept</utility></code><code>#include <stdexcept> // std::runtime_error</stdexcept></code><code></code><code>class MoveClass</code><code>{</code><code>private:</code><code>  int* m_resource{};</code><code></code><code>public:</code><code>  MoveClass() = default;</code><code></code><code>  MoveClass(int resource)</code><code>    : m_resource{ new int{ resource } }</code><code>  {}</code><code></code><code>  // Copy constructor</code><code>  MoveClass(const MoveClass&amp; that)</code><code>  {</code><code>    // deep copy</code><code>    if (that.m_resource != nullptr)</code><code>    {</code><code>      m_resource = new int{ *that.m_resource };</code><code>    }</code><code>  }</code><code></code><code>  // Move constructor</code><code>  MoveClass(MoveClass&amp;&amp; that) noexcept</code><code>    : m_resource{ that.m_resource }</code><code>  {</code><code>    that.m_resource = nullptr;</code><code>  }</code><code></code><code>  ~MoveClass()</code><code>  {</code><code>    std::cout &lt;&lt; "destroying " &lt;&lt; *this &lt;&lt; '\n';</code><code></code><code>    delete m_resource;</code><code>  }</code><code></code><code>  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MoveClass&amp; moveClass)</code><code>  {</code><code>    out &lt;&lt; "MoveClass(";</code><code></code><code>    if (moveClass.m_resource == nullptr)</code><code>    {</code><code>      out &lt;&lt; "empty";</code><code>    }</code><code>    else</code><code>    {</code><code>      out &lt;&lt; *moveClass.m_resource;</code><code>    }</code><code></code><code>    out &lt;&lt; ')';</code><code>    </code><code>    return out;</code><code>  }</code><code>};</code><code></code><code></code><code>class CopyClass</code><code>{</code><code>public:</code><code>  bool m_throw{};</code><code></code><code>  CopyClass() = default;</code><code></code><code>  // Copy constructor throws an exception when copying from a CopyClass object where its m_throw is 'true'</code><code>  CopyClass(const CopyClass&amp; that)</code><code>    : m_throw{ that.m_throw }</code><code>  {</code><code>    if (m_throw)</code><code>    {</code><code>      throw std::runtime_error{ "abort!" };</code><code>    }</code><code>  }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>  // We can make a std::pair without any problems:</code><code>  std::pair my_pair{ MoveClass{ 13 }, CopyClass{} };</code><code></code><code>  std::cout &lt;&lt; "my_pair.first: " &lt;&lt; my_pair.first &lt;&lt; '\n';</code><code></code><code>  // But the problem arises when we try to move that pair into another pair.</code><code>  try</code><code>  {</code><code>    my_pair.second.m_throw = true; // To trigger copy constructor exception</code><code></code><code>    // The following line will throw an exception</code><code>    std::pair moved_pair{ std::move(my_pair) }; // We'll comment out this line later</code><code>    // std::pair moved_pair{ std::move_if_noexcept(my_pair) }; // We'll uncomment this line later</code><code></code><code>    std::cout &lt;&lt; "moved pair exists\n"; // Never prints</code><code>  }</code><code>  catch (const std::exception&amp; ex)</code><code>  {</code><code>      std::cerr &lt;&lt; "Error found: " &lt;&lt; ex.what() &lt;&lt; '\n';</code><code>  }</code><code></code><code>  std::cout &lt;&lt; "my_pair.first: " &lt;&lt; my_pair.first &lt;&lt; '\n';</code><code></code><code>  return 0;</code><code>}</code></pre><p>The above program prints:</p><pre>destroying MoveClass(empty)
my_pair.first: MoveClass(13)
destroying MoveClass(13)
Error found: abort!
my_pair.first: MoveClass(empty)
destroying MoveClass(empty)
</pre><p>Let’s explore what happened. The first printed line shows the temporary <code>MoveClass</code> object used to initialize <code>my_pair</code> gets destroyed as soon as the <code>my_pair</code> instantiation statement has been executed. It is <code>empty</code> since the <code>MoveClass</code> subobject in <code>my_pair</code> was move constructed from it, demonstrated by the next line which shows <code>my_pair.first</code> contains the <code>MoveClass</code> object with value <code>13</code>.</p><p>It gets interesting in the third line. We created <code>moved_pair</code> by copy constructing its <code>CopyClass</code> subobject (it doesn’t have a move constructor), but that copy construction threw an exception since we changed the Boolean flag. Construction of <code>moved_pair</code> was aborted by the exception, and its already-constructed members were destroyed. In this case, the <code>MoveClass</code> member was destroyed, printing <code>destroying MoveClass(13) variable</code>. Next we see the <code>Error found: abort!</code> message printed by <code>main()</code>.</p><p>When we try to print <code>my_pair.first</code> again, it shows the <code>MoveClass</code> member is empty. Since <code>moved_pair</code> was initialized with <code>std::move</code>, the <code>MoveClass</code> member (which has a move constructor) got move constructed and <code>my_pair.first</code> was nulled.</p><p>Finally, <code>my_pair</code> was destroyed at the end of main().</p><p>To summarize the above results: the move constructor of <code>std::pair</code> used the throwing copy constructor of <code>CopyClass</code>. This copy constructor threw an exception, causing the creation of <code>moved_pair</code> to abort, and <code>my_pair.first</code> to be permanently damaged. The <code>strong exception guarantee</code> was not preserved.</p><br><h3>std::move_if_noexcept to the rescue</h3><p>Note that the above problem could have been avoided if <code>std::pair</code> had tried to do a copy instead of a move. In that case, <code>moved_pair</code> would have failed to construct, but <code>my_pair</code> would not have been altered.</p><p>But copying instead of moving has a performance cost that we don’t want to pay for all objects -- ideally we want to do a move if we can do so safely, and a copy otherwise.</p><p>Fortunately, C++ has a two mechanisms that, when used in combination, let us do exactly that. First, because <code>noexcept</code> functions are no-throw/no-fail, they implicitly meet the criteria for the <code>strong exception guarantee</code>. Thus, a <code>noexcept</code> move constructor is guaranteed to succeed.</p><p>Second, we can use the standard library function <code>std::move_if_noexcept()</code> to determine whether a move or a copy should be performed. <code>std::move_if_noexcept</code> is a counterpart to <code>std::move</code>, and is used in the same way.</p><p>If the compiler can tell that an object passed as an argument to <code>std::move_if_noexcept</code> won’t throw an exception when it is move constructed (or if the object is move-only and has no copy constructor), then <code>std::move_if_noexcept</code> will perform identically to <code>std::move()</code> (and return the object converted to an r-value). Otherwise, <code>std::move_if_noexcept</code> will return a normal l-value reference to the object.</p><div class="cpp-note cpp-lightbluebackground"><h4>Key insight</h4><p><code>std::move_if_noexcept</code> will return a movable r-value if the object has a noexcept move constructor, otherwise it will return a copyable l-value. We can use the <code>noexcept</code> specifier in conjunction with <code>std::move_if_noexcept</code> to use move semantics only when a strong exception guarantee exists (and use copy semantics otherwise).</p></div><p>Let’s update the code in the previous example as follows:</p><pre class="language-cpp line-numbers"><code>//std::pair moved_pair{std::move(my_pair)}; // comment out this line now</code><code>std::pair moved_pair{std::move_if_noexcept(my_pair)}; // and uncomment this line</code></pre><p>Running the program again prints:</p><pre>destroying MoveClass(empty)
my_pair.first: MoveClass(13)
destroying MoveClass(13)
Error found: abort!
my_pair.first: MoveClass(13)
destroying MoveClass(13)
</pre><p>As you can see, after the exception was thrown, the subobject <code>my_pair.first</code> still points to the value <code>13</code>.</p><p>The move constructor of <code>std::pair</code> isn’t <code>noexcept</code> (as of C++20), so <code>std::move_if_noexcept</code> returns <code>my_pair</code> as an l-value reference. This causes <code>moved_pair</code> to be created via the copy constructor (rather than the move constructor). The copy constructor can throw safely, because it doesn’t modify the source object.</p><p>The standard library uses <code>std::move_if_noexcept</code> often to optimize for functions that are <code>noexcept</code>. For example, <code>std::vector::resize</code> will use move semantics if the element type has a <code>noexcept</code> move constructor, and copy semantics otherwise. This means <code>std::vector</code> will generally operate faster with objects that have a <code>noexcept</code> move constructor.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>If a type has both potentially throwing move semantics and deleted copy semantics (the copy constructor and copy assignment operator are unavailable), then <code>std::move_if_noexcept</code> will waive the strong guarantee and invoke move semantics. This conditional waiving of the strong guarantee is ubiquitous in the standard library container classes, since they use std::move_if_noexcept often.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">M.6 — std::unique_ptr</h1></header><div class="entry-content" itemprop="articleBody"><p>At the beginning of the chapter, we discussed how the use of pointers can lead to bugs and memory leaks in some situations. For example, this can happen when a function early returns, or throws an exception, and the pointer is not properly deleted.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code> </code><code>void someFunction()</code><code>{</code><code>    auto* ptr{ new Resource() };</code><code> </code><code>    int x{};</code><code>    std::cout &lt;&lt; "Enter an integer: ";</code><code>    std::cin &gt;&gt; x;</code><code> </code><code>    if (x == 0)</code><code>        throw 0; // the function returns early, and ptr won’t be deleted!</code><code> </code><code>    // do stuff with ptr here</code><code> </code><code>    delete ptr;</code><code>}</code></pre><p>Now that we’ve covered the fundamentals of move semantics, we can return to the topic of smart pointer classes. As a reminder, a smart pointer is a class that manages a dynamically allocated object. Although smart pointers can offer other features, the defining characteristic of a smart pointer is that it manages a dynamically allocated resource, and ensures the dynamically allocated object is properly cleaned up at the appropriate time (usually when the smart pointer goes out of scope).</p><p>Because of this, smart pointers should never be dynamically allocated themselves (otherwise, there is the risk that the smart pointer may not be properly deallocated, which means the object it owns would not be deallocated, causing a memory leak). By always allocating smart pointers on the stack (as local variables or composition members of a class), we’re guaranteed that the smart pointer will properly go out of scope when the function or object it is contained within ends, ensuring the object the smart pointer owns is properly deallocated.</p><p>C++11 standard library ships with 4 smart pointer classes: std::auto_ptr (removed in C++17), std::unique_ptr, std::shared_ptr, and std::weak_ptr. std::unique_ptr is by far the most used smart pointer class, so we’ll cover that one first. In the following lessons, we’ll cover std::shared_ptr and std::weak_ptr.</p><br><h3>std::unique_ptr</h3><p>std::unique_ptr is the C++11 replacement for std::auto_ptr. It should be used to manage any dynamically allocated object that is not shared by multiple objects. That is, std::unique_ptr should completely own the object it manages, not share that ownership with other classes. std::unique_ptr lives in the &lt;memory&gt; header.</p><p>Let’s take a look at a simple smart pointer example:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <memory> // for std::unique_ptr</memory></code><code></code><code>class Resource</code><code>{</code><code>public:</code><code>	Resource() { std::cout &lt;&lt; "Resource acquired\n"; }</code><code>	~Resource() { std::cout &lt;&lt; "Resource destroyed\n"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	// allocate a Resource object and have it owned by std::unique_ptr</code><code>	std::unique_ptr<resource> res{ new Resource() };</resource></code><code></code><code>	return 0;</code><code>} // res goes out of scope here, and the allocated Resource is destroyed</code></pre><p>Because the std::unique_ptr is allocated on the stack here, it’s guaranteed to eventually go out of scope, and when it does, it will delete the Resource it is managing.</p><p>Unlike std::auto_ptr, std::unique_ptr properly implements move semantics.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <memory> // for std::unique_ptr</memory></code><code>#include <utility> // for std::move</utility></code><code></code><code>class Resource</code><code>{</code><code>public:</code><code>	Resource() { std::cout &lt;&lt; "Resource acquired\n"; }</code><code>	~Resource() { std::cout &lt;&lt; "Resource destroyed\n"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	std::unique_ptr<resource> res1{ new Resource{} }; // Resource created here</resource></code><code>	std::unique_ptr<resource> res2{}; // Start as nullptr</resource></code><code></code><code>	std::cout &lt;&lt; "res1 is " &lt;&lt; (res1 ? "not null\n" : "null\n");</code><code>	std::cout &lt;&lt; "res2 is " &lt;&lt; (res2 ? "not null\n" : "null\n");</code><code></code><code>	// res2 = res1; // Won't compile: copy assignment is disabled</code><code>	res2 = std::move(res1); // res2 assumes ownership, res1 is set to null</code><code></code><code>	std::cout &lt;&lt; "Ownership transferred\n";</code><code></code><code>	std::cout &lt;&lt; "res1 is " &lt;&lt; (res1 ? "not null\n" : "null\n");</code><code>	std::cout &lt;&lt; "res2 is " &lt;&lt; (res2 ? "not null\n" : "null\n");</code><code></code><code>	return 0;</code><code>} // Resource destroyed here when res2 goes out of scope</code></pre><p>This prints:</p><pre>Resource acquired
res1 is not null
res2 is null
Ownership transferred
res1 is null
res2 is not null
Resource destroyed
</pre><p>Because std::unique_ptr is designed with move semantics in mind, copy initialization and copy assignment are disabled. If you want to transfer the contents managed by std::unique_ptr, you must use move semantics. In the program above, we accomplish this via std::move (which converts res1 into an r-value, which triggers a move assignment instead of a copy assignment).</p><br><h3>Accessing the managed object</h3><p>std::unique_ptr has an overloaded operator* and operator-&gt; that can be used to return the resource being managed. Operator* returns a reference to the managed resource, and operator-&gt; returns a pointer.</p><p>Remember that std::unique_ptr may not always be managing an object -- either because it was created empty (using the default constructor or passing in a nullptr as the parameter), or because the resource it was managing got moved to another std::unique_ptr. So before we use either of these operators, we should check whether the std::unique_ptr actually has a resource. Fortunately, this is easy: std::unique_ptr has a cast to bool that returns true if the std::unique_ptr is managing a resource.</p><p>Here’s an example of this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <memory> // for std::unique_ptr</memory></code><code></code><code>class Resource</code><code>{</code><code>public:</code><code>	Resource() { std::cout &lt;&lt; "Resource acquired\n"; }</code><code>	~Resource() { std::cout &lt;&lt; "Resource destroyed\n"; }</code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Resource &amp;res)</code><code>	{</code><code>		out &lt;&lt; "I am a resource";</code><code>		return out;</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	std::unique_ptr<resource> res{ new Resource{} };</resource></code><code></code><code>	if (res) // use implicit cast to bool to ensure res contains a Resource</code><code>		std::cout &lt;&lt; *res &lt;&lt; '\n'; // print the Resource that res is owning</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>Resource acquired
I am a resource
Resource destroyed
</pre><p>In the above program, we use the overloaded operator* to get the Resource object owned by std::unique_ptr res, which we then send to std::cout for printing.</p><br><h3>std::unique_ptr and arrays</h3><p>Unlike std::auto_ptr, std::unique_ptr is smart enough to know whether to use scalar delete or array delete, so std::unique_ptr is okay to use with both scalar objects and arrays.</p><p>However, std::array or std::vector (or std::string) are almost always better choices than using std::unique_ptr with a fixed array, dynamic array, or C-style string.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Favor std::array, std::vector, or std::string over a smart pointer managing a fixed array, dynamic array, or C-style string.</p></div><p><strong>std::make_unique</strong></p><p>C++14 comes with an additional function named std::make_unique(). This templated function constructs an object of the template type and initializes it with the arguments passed into the function.</p><pre class="language-cpp line-numbers"><code>#include <memory> // for std::unique_ptr and std::make_unique</memory></code><code>#include <iostream></iostream></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>	int m_numerator{ 0 };</code><code>	int m_denominator{ 1 };</code><code></code><code>public:</code><code>	Fraction(int numerator = 0, int denominator = 1) :</code><code>		m_numerator{ numerator }, m_denominator{ denominator }</code><code>	{</code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction &amp;f1)</code><code>	{</code><code>		out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>		return out;</code><code>	}</code><code>};</code><code></code><code></code><code>int main()</code><code>{</code><code>	// Create a single dynamically allocated Fraction with numerator 3 and denominator 5</code><code>	// We can also use automatic type deduction to good effect here</code><code>	auto f1{ std::make_unique<fraction>(3, 5) };</fraction></code><code>	std::cout &lt;&lt; *f1 &lt;&lt; '\n';</code><code></code><code>	// Create a dynamically allocated array of Fractions of length 4</code><code>	auto f2{ std::make_unique<fraction[]>(4) };</fraction[]></code><code>	std::cout &lt;&lt; f2[0] &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>The code above prints:</p><pre>3/5
0/1
</pre><p>Use of std::make_unique() is optional, but is recommended over creating std::unique_ptr yourself. This is because code using std::make_unique is simpler, and it also requires less typing (when used with automatic type deduction). Furthermore it resolves an exception safety issue that can result from C++ leaving the order of evaluation for function arguments unspecified.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Use std::make_unique() instead of creating std::unique_ptr and using new yourself.</p></div><br><h3>The exception safety issue in more detail </h3><p>For those wondering what the “exception safety issue” mentioned above is, here’s a description of the issue.</p><p>Consider an expression like this one:</p><pre class="language-cpp line-numbers"><code>some_function(std::unique_ptr<t>(new T), function_that_can_throw_exception());</t></code></pre><p>The compiler is given a lot of flexibility in terms of how it handles this call. It could create a new T, then call function_that_can_throw_exception(), then create the std::unique_ptr that manages the dynamically allocated T. If function_that_can_throw_exception() throws an exception, then the T that was allocated will not be deallocated, because the smart pointer to do the deallocation hasn’t been created yet. This leads to T being leaked.</p><p>std::make_unique() doesn’t suffer from this problem because the creation of the object T and the creation of the std::unique_ptr happen inside the std::make_unique() function, where there’s no ambiguity about order of execution.</p><br><h3>Returning std::unique_ptr from a function</h3><p>std::unique_ptr can be safely returned from a function by value:</p><pre class="language-cpp line-numbers"><code>#include <memory> // for std::unique_ptr</memory></code><code></code><code>std::unique_ptr<resource> createResource()</resource></code><code>{</code><code>     return std::make_unique<resource>();</resource></code><code>}</code><code></code><code>int main()</code><code>{</code><code>    auto ptr{ createResource() };</code><code></code><code>    // do whatever</code><code></code><code>    return 0;</code><code>}</code></pre><p>In the above code, createResource() returns a std::unique_ptr by value. If this value is not assigned to anything, the temporary return value will go out of scope and the Resource will be cleaned up. If it is assigned (as shown in main()), in C++14 or earlier, move semantics will be employed to transfer the Resource from the return value to the object assigned to (in the above example, ptr), and in C++17 or newer, the return will be elided. This makes returning a resource by std::unique_ptr much safer than returning raw pointers!</p><p>In general, you should not return std::unique_ptr by pointer (ever) or reference (unless you have a specific compelling reason to).</p><br><h3>Passing std::unique_ptr to a function</h3><p>If you want the function to take ownership of the contents of the pointer, pass the std::unique_ptr by value. Note that because copy semantics have been disabled, you’ll need to use std::move to actually pass the variable in.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <memory> // for std::unique_ptr</memory></code><code>#include <utility> // for std::move</utility></code><code></code><code>class Resource</code><code>{</code><code>public:</code><code>	Resource() { std::cout &lt;&lt; "Resource acquired\n"; }</code><code>	~Resource() { std::cout &lt;&lt; "Resource destroyed\n"; }</code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Resource &amp;res)</code><code>	{</code><code>		out &lt;&lt; "I am a resource";</code><code>		return out;</code><code>	}</code><code>};</code><code></code><code>void takeOwnership(std::unique_ptr<resource> res)</resource></code><code>{</code><code>     if (res)</code><code>          std::cout &lt;&lt; *res &lt;&lt; '\n';</code><code>} // the Resource is destroyed here</code><code></code><code>int main()</code><code>{</code><code>    auto ptr{ std::make_unique<resource>() };</resource></code><code></code><code>//    takeOwnership(ptr); // This doesn't work, need to use move semantics</code><code>    takeOwnership(std::move(ptr)); // ok: use move semantics</code><code></code><code>    std::cout &lt;&lt; "Ending program\n";</code><code></code><code>    return 0;</code><code>}</code></pre><p>The above program prints:</p><pre>Resource acquired
I am a resource
Resource destroyed
Ending program
</pre><p>Note that in this case, ownership of the Resource was transferred to takeOwnership(), so the Resource was destroyed at the end of takeOwnership() rather than the end of main().</p><p>However, most of the time, you won’t want the function to take ownership of the resource. Although you can pass a std::unique_ptr by reference (which will allow the function to use the object without assuming ownership), you should only do so when the called function might alter or change the object being managed.</p><p>Instead, it’s better to just pass the resource itself (by pointer or reference, depending on whether null is a valid argument). This allows the function to remain agnostic of how the caller is managing its resources. To get a raw resource pointer from a std::unique_ptr, you can use the get() member function:</p><pre class="language-cpp line-numbers"><code>#include <memory> // for std::unique_ptr</memory></code><code>#include <iostream></iostream></code><code></code><code>class Resource</code><code>{</code><code>public:</code><code>	Resource() { std::cout &lt;&lt; "Resource acquired\n"; }</code><code>	~Resource() { std::cout &lt;&lt; "Resource destroyed\n"; }</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Resource &amp;res)</code><code>	{</code><code>		out &lt;&lt; "I am a resource";</code><code>		return out;</code><code>	}</code><code>};</code><code></code><code>// The function only uses the resource, so we'll accept a pointer to the resource, not a reference to the whole std::unique_ptr<resource></resource></code><code>void useResource(Resource* res)</code><code>{</code><code>	if (res)</code><code>		std::cout &lt;&lt; *res &lt;&lt; '\n';</code><code>	else</code><code>		std::cout &lt;&lt; "No resource\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	auto ptr{ std::make_unique<resource>() };</resource></code><code></code><code>	useResource(ptr.get()); // note: get() used here to get a pointer to the Resource</code><code></code><code>	std::cout &lt;&lt; "Ending program\n";</code><code></code><code>	return 0;</code><code>} // The Resource is destroyed here</code></pre><p>The above program prints:</p><pre>Resource acquired
I am a resource
Ending program
Resource destroyed
</pre><br><h3>std::unique_ptr and classes</h3><p>You can, of course, use std::unique_ptr as a composition member of your class. This way, you don’t have to worry about ensuring your class destructor deletes the dynamic memory, as the std::unique_ptr will be automatically destroyed when the class object is destroyed.</p><p>However, if the class object is not destroyed properly (e.g. it is dynamically allocated and not deallocated properly), then the std::unique_ptr member will not be destroyed either, and the object being managed by the std::unique_ptr will not be deallocated.</p><br><h3>Misusing std::unique_ptr</h3><p>There are two easy ways to misuse std::unique_ptrs, both of which are easily avoided. First, don’t let multiple classes manage the same resource. For example:</p><pre class="language-cpp line-numbers"><code>Resource* res{ new Resource() };</code><code>std::unique_ptr<resource> res1{ res };</resource></code><code>std::unique_ptr<resource> res2{ res };</resource></code></pre><p>While this is legal syntactically, the end result will be that both res1 and res2 will try to delete the Resource, which will lead to undefined behavior.</p><p>Second, don’t manually delete the resource out from underneath the std::unique_ptr.</p><pre class="language-cpp line-numbers"><code>Resource* res{ new Resource() };</code><code>std::unique_ptr<resource> res1{ res };</resource></code><code>delete res;</code></pre><p>If you do, the std::unique_ptr will try to delete an already deleted resource, again leading to undefined behavior.</p><p>Note that std::make_unique() prevents both of the above cases from happening inadvertently.</p><br><h3>Quiz time</h3><div class="quiz" style="clear:both"><p class="quiz-header">Question #1</p><p>Convert the following program from using a normal pointer to using std::unique_ptr where appropriate:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>	int m_numerator{ 0 };</code><code>	int m_denominator{ 1 };</code><code></code><code>public:</code><code>	Fraction(int numerator = 0, int denominator = 1) :</code><code>		m_numerator{ numerator }, m_denominator{ denominator }</code><code>	{</code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction &amp;f1)</code><code>	{</code><code>		out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>		return out;</code><code>	}</code><code>};</code><code></code><code>void printFraction(const Fraction* ptr)</code><code>{</code><code>	if (ptr)</code><code>		std::cout &lt;&lt; *ptr &lt;&lt; '\n';</code><code>	else</code><code>		std::cout &lt;&lt; "No fraction\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	auto* ptr{ new Fraction{ 3, 5 } };</code><code></code><code>	printFraction(ptr);</code><code></code><code>	delete ptr;</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <memory> // for std::unique_ptr</memory></code><code>#include <iostream></iostream></code><code></code><code>class Fraction</code><code>{</code><code>private:</code><code>	int m_numerator{ 0 };</code><code>	int m_denominator{ 1 };</code><code></code><code>public:</code><code>	Fraction(int numerator = 0, int denominator = 1) :</code><code>		m_numerator{ numerator }, m_denominator{ denominator }</code><code>	{</code><code>	}</code><code></code><code>	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction &amp;f1)</code><code>	{</code><code>		out &lt;&lt; f1.m_numerator &lt;&lt; '/' &lt;&lt; f1.m_denominator;</code><code>		return out;</code><code>	}</code><code>};</code><code></code><code>// This function uses a Fraction object, so we just pass the Fraction itself</code><code>// That way we don't have to worry about what kind of smart pointer (if any) the caller may be using</code><code>void printFraction(const Fraction* ptr)</code><code>{</code><code>	if (ptr)</code><code>		std::cout &lt;&lt; *ptr &lt;&lt; '\n';</code><code>	else</code><code>		std::cout &lt;&lt; "No fraction\n";</code><code>}</code><code></code><code>int main()</code><code>{</code><code>	auto ptr{ std::make_unique<fraction>(3, 5) };</fraction></code><code></code><code>	printFraction(ptr.get());</code><code></code><code>	return 0;</code><code>}</code></pre></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">M.7 — std::shared_ptr</h1></header><div class="entry-content" itemprop="articleBody"><p>Unlike std::unique_ptr, which is designed to singly own and manage a resource, std::shared_ptr is meant to solve the case where you need multiple smart pointers co-owning a resource.</p><p>This means that it is fine to have multiple std::shared_ptr pointing to the same resource. Internally, std::shared_ptr keeps track of how many std::shared_ptr are sharing the resource. As long as at least one std::shared_ptr is pointing to the resource, the resource will not be deallocated, even if individual std::shared_ptr are destroyed. As soon as the last std::shared_ptr managing the resource goes out of scope (or is reassigned to point at something else), the resource will be deallocated.</p><p>Like std::unique_ptr, std::shared_ptr lives in the &lt;memory&gt; header.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <memory> // for std::shared_ptr</memory></code><code></code><code>class Resource</code><code>{</code><code>public:</code><code>	Resource() { std::cout &lt;&lt; "Resource acquired\n"; }</code><code>	~Resource() { std::cout &lt;&lt; "Resource destroyed\n"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	// allocate a Resource object and have it owned by std::shared_ptr</code><code>	Resource* res { new Resource };</code><code>	std::shared_ptr<resource> ptr1{ res };</resource></code><code>	{</code><code>		std::shared_ptr<resource> ptr2 { ptr1 }; // make another std::shared_ptr pointing to the same thing</resource></code><code></code><code>		std::cout &lt;&lt; "Killing one shared pointer\n";</code><code>	} // ptr2 goes out of scope here, but nothing happens</code><code></code><code>	std::cout &lt;&lt; "Killing another shared pointer\n";</code><code></code><code>	return 0;</code><code>} // ptr1 goes out of scope here, and the allocated Resource is destroyed</code></pre><p>This prints:</p><pre>Resource acquired
Killing one shared pointer
Killing another shared pointer
Resource destroyed
</pre><p>In the above code, we create a dynamic Resource object, and set a std::shared_ptr named ptr1 to manage it. Inside the nested block, we use the copy constructor to create a second std::shared_ptr (ptr2) that points to the same Resource. When ptr2 goes out of scope, the Resource is not deallocated, because ptr1 is still pointing at the Resource. When ptr1 goes out of scope, ptr1 notices there are no more std::shared_ptr managing the Resource, so it deallocates the Resource.</p><p>Note that we created a second shared pointer from the first shared pointer. This is important. Consider the following similar program:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <memory> // for std::shared_ptr</memory></code><code></code><code>class Resource</code><code>{</code><code>public:</code><code>	Resource() { std::cout &lt;&lt; "Resource acquired\n"; }</code><code>	~Resource() { std::cout &lt;&lt; "Resource destroyed\n"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	Resource* res { new Resource };</code><code>	std::shared_ptr<resource> ptr1 { res };</resource></code><code>	{</code><code>		std::shared_ptr<resource> ptr2 { res }; // create ptr2 directly from res (instead of ptr1)</resource></code><code></code><code>		std::cout &lt;&lt; "Killing one shared pointer\n";</code><code>	} // ptr2 goes out of scope here, and the allocated Resource is destroyed</code><code></code><code>	std::cout &lt;&lt; "Killing another shared pointer\n";</code><code></code><code>	return 0;</code><code>} // ptr1 goes out of scope here, and the allocated Resource is destroyed again</code></pre><p>This program prints:</p><pre>Resource acquired
Killing one shared pointer
Resource destroyed
Killing another shared pointer
Resource destroyed
</pre><p>and then crashes (at least on the author’s machine).</p><p>The difference here is that we created two std::shared_ptr independently from each other. As a consequence, even though they’re both pointing to the same Resource, they aren’t aware of each other. When ptr2 goes out of scope, it thinks it’s the only owner of the Resource, and deallocates it. When ptr1 later goes out of the scope, it thinks the same thing, and tries to delete the Resource again. Then bad things happen.</p><p>Fortunately, this is easily avoided: if you need more than one std::shared_ptr to a given resource, copy an existing std::shared_ptr.</p><div class="cpp-note cpp-lightgreenbackground"><h4>Best practice</h4><p>Always make a copy of an existing std::shared_ptr if you need more than one std::shared_ptr pointing to the same resource.</p></div><br><h3>std::make_shared</h3><p>Much like std::make_unique() can be used to create a std::unique_ptr in C++14, std::make_shared() can (and should) be used to make a std::shared_ptr. std::make_shared() is available in C++11.</p><p>Here’s our original example, using std::make_shared():</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <memory> // for std::shared_ptr</memory></code><code></code><code>class Resource</code><code>{</code><code>public:</code><code>	Resource() { std::cout &lt;&lt; "Resource acquired\n"; }</code><code>	~Resource() { std::cout &lt;&lt; "Resource destroyed\n"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	// allocate a Resource object and have it owned by std::shared_ptr</code><code>	auto ptr1 { std::make_shared<resource>() };</resource></code><code>	{</code><code>		auto ptr2 { ptr1 }; // create ptr2 using copy of ptr1</code><code></code><code>		std::cout &lt;&lt; "Killing one shared pointer\n";</code><code>	} // ptr2 goes out of scope here, but nothing happens</code><code></code><code>	std::cout &lt;&lt; "Killing another shared pointer\n";</code><code></code><code>	return 0;</code><code>} // ptr1 goes out of scope here, and the allocated Resource is destroyed</code></pre><p>The reasons for using std::make_shared() are the same as std::make_unique() -- std::make_shared() is simpler and safer (there’s no way to directly create two std::shared_ptr pointing to the same resource using this method). However, std::make_shared() is also more performant than not using it. The reasons for this lie in the way that std::shared_ptr keeps track of how many pointers are pointing at a given resource.</p><br><h3>Digging into std::shared_ptr</h3><p>Unlike std::unique_ptr, which uses a single pointer internally, std::shared_ptr uses two pointers internally. One pointer points at the resource being managed. The other points at a “control block”, which is a dynamically allocated object that tracks of a bunch of stuff, including how many std::shared_ptr are pointing at the resource. When a std::shared_ptr is created via a std::shared_ptr constructor, the memory for the managed object (which is usually passed in) and control block (which the constructor creates) are allocated separately. However, when using std::make_shared(), this can be optimized into a single memory allocation, which leads to better performance.</p><p>This also explains why independently creating two std::shared_ptr pointed to the same resource gets us into trouble. Each std::shared_ptr will have one pointer pointing at the resource. However, each std::shared_ptr will independently allocate its own control block, which will indicate that it is the only pointer owning that resource. Thus, when that std::shared_ptr goes out of scope, it will deallocate the resource, not realizing there are other std::shared_ptr also trying to manage that resource.</p><p>However, when a std::shared_ptr is cloned using copy assignment, the data in the control block can be appropriately updated to indicate that there are now additional std::shared_ptr co-managing the resource.</p><br><h3>Shared pointers can be created from unique pointers</h3><p>A std::unique_ptr can be converted into a std::shared_ptr via a special std::shared_ptr constructor that accepts a std::unique_ptr r-value. The contents of the std::unique_ptr will be moved to the std::shared_ptr.</p><p>However, std::shared_ptr can not be safely converted to a std::unique_ptr. This means that if you’re creating a function that is going to return a smart pointer, you’re better off returning a std::unique_ptr and assigning it to a std::shared_ptr if and when that’s appropriate.</p><br><h3>The perils of std::shared_ptr</h3><p>std::shared_ptr has some of the same challenges as std::unique_ptr -- if the std::shared_ptr is not properly disposed of (either because it was dynamically allocated and never deleted, or it was part of an object that was dynamically allocated and never deleted) then the resource it is managing won’t be deallocated either. With std::unique_ptr, you only have to worry about one smart pointer being properly disposed of. With std::shared_ptr, you have to worry about them all. If any of the std::shared_ptr managing a resource are not properly destroyed, the resource will not be deallocated properly.</p><br><h3>std::shared_ptr and arrays</h3><p>In C++17 and earlier, std::shared_ptr does not have proper support for managing arrays, and should not be used to manage a C-style array. As of C++20, std::shared_ptr does have support for arrays.</p><br><h3>Conclusion</h3><p>std::shared_ptr is designed for the case where you need multiple smart pointers co-managing the same resource. The resource will be deallocated when the last std::shared_ptr managing the resource is destroyed.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">M.8 — Circular dependency issues with std::shared_ptr, and std::weak_ptr</h1></header><div class="entry-content" itemprop="articleBody"><p>In the previous lesson, we saw how std::shared_ptr allowed us to have multiple smart pointers co-owning the same resource. However, in certain cases, this can become problematic. Consider the following case, where the shared pointers in two separate objects each point at the other object:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <memory> // for std::shared_ptr</memory></code><code>#include <string></string></code><code></code><code>class Person</code><code>{</code><code>	std::string m_name;</code><code>	std::shared_ptr<person> m_partner; // initially created empty</person></code><code></code><code>public:</code><code>		</code><code>	Person(const std::string &amp;name): m_name(name)</code><code>	{ </code><code>		std::cout &lt;&lt; m_name &lt;&lt; " created\n";</code><code>	}</code><code>	~Person()</code><code>	{</code><code>		std::cout &lt;&lt; m_name &lt;&lt; " destroyed\n";</code><code>	}</code><code></code><code>	friend bool partnerUp(std::shared_ptr<person> &amp;p1, std::shared_ptr<person> &amp;p2)</person></person></code><code>	{</code><code>		if (!p1 || !p2)</code><code>			return false;</code><code></code><code>		p1-&gt;m_partner = p2;</code><code>		p2-&gt;m_partner = p1;</code><code></code><code>		std::cout &lt;&lt; p1-&gt;m_name &lt;&lt; " is now partnered with " &lt;&lt; p2-&gt;m_name &lt;&lt; '\n';</code><code></code><code>		return true;</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	auto lucy { std::make_shared<person>("Lucy") }; // create a Person named "Lucy"</person></code><code>	auto ricky { std::make_shared<person>("Ricky") }; // create a Person named "Ricky"</person></code><code></code><code>	partnerUp(lucy, ricky); // Make "Lucy" point to "Ricky" and vice-versa</code><code></code><code>	return 0;</code><code>}</code></pre><p>In the above example, we dynamically allocate two Persons, “Lucy” and “Ricky” using make_shared() (to ensure lucy and ricky are destroyed at the end of main()). Then we partner them up. This sets the std::shared_ptr inside “Lucy” to point at “Ricky”, and the std::shared_ptr inside “Ricky” to point at “Lucy”. Shared pointers are meant to be shared, so it’s fine that both the lucy shared pointer and Rick’s m_partner shared pointer both point at “Lucy” (and vice-versa).</p><p>However, this program doesn’t execute as expected:</p><pre>Lucy created
Ricky created
Lucy is now partnered with Ricky
</pre><p>And that’s it. No deallocations took place. Uh oh. What happened?</p><p>After partnerUp() is called, there are two shared pointers pointing to “Ricky” (ricky, and Lucy’s m_partner) and two shared pointers pointing to “Lucy” (lucy, and Ricky’s m_partner).</p><p>At the end of main(), the ricky shared pointer goes out of scope first. When that happens, ricky checks if there are any other shared pointers that co-own the Person “Ricky”. There are (Lucy’s m_partner). Because of this, it doesn’t deallocate “Ricky” (if it did, then Lucy’s m_partner would end up as a dangling pointer). At this point, we now have one shared pointer to “Ricky” (Lucy’s m_partner) and two shared pointers to “Lucy” (lucy, and Ricky’s m_partner).</p><p>Next the lucy shared pointer goes out of scope, and the same thing happens. The shared pointer lucy checks if there are any other shared pointers co-owning the Person “Lucy”. There are (Ricky’s m_partner), so “Lucy” isn’t deallocated. At this point, there is one shared pointer to “Lucy” (Ricky’s m_partner) and one shared pointer to “Ricky” (Lucy’s m_partner).</p><p>Then the program ends -- and neither Person “Lucy” or “Ricky” have been deallocated! Essentially, “Lucy” ends up keeping “Ricky” from being destroyed, and “Ricky” ends up keeping “Lucy” from being destroyed.</p><p>It turns out that this can happen any time shared pointers form a circular reference.</p><br><h3>Circular references</h3><p>A <strong>Circular reference</strong> (also called a <strong>cyclical reference</strong> or a <strong>cycle</strong>) is a series of references where each object references the next, and the last object references back to the first, causing a referential loop. The references do not need to be actual C++ references -- they can be pointers, unique IDs, or any other means of identifying specific objects.</p><p>In the context of shared pointers, the references will be pointers.</p><p>This is exactly what we see in the case above: “Lucy” points at “Ricky”, and “Ricky” points at “Lucy”. With three pointers, you’d get the same thing when A points at B, B points at C, and C points at A. The practical effect of having shared pointers form a cycle is that each object ends up keeping the next object alive -- with the last object keeping the first object alive. Thus, no objects in the series can be deallocated because they all think some other object still needs it!</p><br><h3>A reductive case</h3><p>It turns out, this cyclical reference issue can even happen with a single std::shared_ptr -- a std::shared_ptr referencing the object that contains it is still a cycle (just a reductive one). Although it’s fairly unlikely that this would ever happen in practice, we’ll show you for additional comprehension:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <memory> // for std::shared_ptr</memory></code><code></code><code>class Resource</code><code>{</code><code>public:</code><code>	std::shared_ptr<resource> m_ptr {}; // initially created empty</resource></code><code>	</code><code>	Resource() { std::cout &lt;&lt; "Resource acquired\n"; }</code><code>	~Resource() { std::cout &lt;&lt; "Resource destroyed\n"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	auto ptr1 { std::make_shared<resource>() };</resource></code><code></code><code>	ptr1-&gt;m_ptr = ptr1; // m_ptr is now sharing the Resource that contains it</code><code></code><code>	return 0;</code><code>}</code></pre><p>In the above example, when ptr1 goes out of scope, the Resource is not deallocated because the Resource’s m_ptr is sharing the Resource. At that point, the only way for the Resource to be released would be to set m_ptr to something else (so nothing is sharing the Resource any longer). But we can’t access m_ptr because ptr1 is out of scope, so we no longer have a way to do this. The Resource has become a memory leak.</p><p>Thus, the program prints:</p><pre>Resource acquired
</pre><p>and that’s it.</p><br><h3>So what is std::weak_ptr for anyway?</h3><p>std::weak_ptr was designed to solve the “cyclical ownership” problem described above. A std::weak_ptr is an observer -- it can observe and access the same object as a std::shared_ptr (or other std::weak_ptrs) but it is not considered an owner. Remember, when a std::shared pointer goes out of scope, it only considers whether other std::shared_ptr are co-owning the object. std::weak_ptr does not count!</p><p>Let’s solve our Person-al issue using a std::weak_ptr:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <memory> // for std::shared_ptr and std::weak_ptr</memory></code><code>#include <string></string></code><code></code><code>class Person</code><code>{</code><code>	std::string m_name;</code><code>	std::weak_ptr<person> m_partner; // note: This is now a std::weak_ptr</person></code><code></code><code>public:</code><code>		</code><code>	Person(const std::string &amp;name): m_name(name)</code><code>	{ </code><code>		std::cout &lt;&lt; m_name &lt;&lt; " created\n";</code><code>	}</code><code>	~Person()</code><code>	{</code><code>		std::cout &lt;&lt; m_name &lt;&lt; " destroyed\n";</code><code>	}</code><code></code><code>	friend bool partnerUp(std::shared_ptr<person> &amp;p1, std::shared_ptr<person> &amp;p2)</person></person></code><code>	{</code><code>		if (!p1 || !p2)</code><code>			return false;</code><code></code><code>		p1-&gt;m_partner = p2;</code><code>		p2-&gt;m_partner = p1;</code><code></code><code>		std::cout &lt;&lt; p1-&gt;m_name &lt;&lt; " is now partnered with " &lt;&lt; p2-&gt;m_name &lt;&lt; '\n';</code><code></code><code>		return true;</code><code>	}</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	auto lucy { std::make_shared<person>("Lucy") };</person></code><code>	auto ricky { std::make_shared<person>("Ricky") };</person></code><code></code><code>	partnerUp(lucy, ricky);</code><code></code><code>	return 0;</code><code>}</code></pre><p>This code behaves properly:</p><pre>Lucy created
Ricky created
Lucy is now partnered with Ricky
Ricky destroyed
Lucy destroyed
</pre><p>Functionally, it works almost identically to the problematic example. However, now when ricky goes out of scope, it sees that there are no other std::shared_ptr pointing at “Ricky” (the std::weak_ptr from “Lucy” doesn’t count). Therefore, it will deallocate “Ricky”. The same occurs for lucy.</p><br><h3>Using std::weak_ptr</h3><p>The downside of std::weak_ptr is that std::weak_ptr are not directly usable (they have no operator-&gt;). To use a std::weak_ptr, you must first convert it into a std::shared_ptr. Then you can use the std::shared_ptr. To convert a std::weak_ptr into a std::shared_ptr, you can use the lock() member function. Here’s the above example, updated to show this off:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <memory> // for std::shared_ptr and std::weak_ptr</memory></code><code>#include <string></string></code><code></code><code>class Person</code><code>{</code><code>	std::string m_name;</code><code>	std::weak_ptr<person> m_partner; // note: This is now a std::weak_ptr</person></code><code></code><code>public:</code><code></code><code>	Person(const std::string &amp;name) : m_name(name)</code><code>	{</code><code>		std::cout &lt;&lt; m_name &lt;&lt; " created\n";</code><code>	}</code><code>	~Person()</code><code>	{</code><code>		std::cout &lt;&lt; m_name &lt;&lt; " destroyed\n";</code><code>	}</code><code></code><code>	friend bool partnerUp(std::shared_ptr<person> &amp;p1, std::shared_ptr<person> &amp;p2)</person></person></code><code>	{</code><code>		if (!p1 || !p2)</code><code>			return false;</code><code></code><code>		p1-&gt;m_partner = p2;</code><code>		p2-&gt;m_partner = p1;</code><code></code><code>		std::cout &lt;&lt; p1-&gt;m_name &lt;&lt; " is now partnered with " &lt;&lt; p2-&gt;m_name &lt;&lt; "\'\n';</code><code></code><code>		return true;</code><code>	}</code><code></code><code>	const std::shared_ptr<person> getPartner() const { return m_partner.lock(); } // use lock() to convert weak_ptr to shared_ptr</person></code><code>	const std::string&amp; getName() const { return m_name; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	auto lucy { std::make_shared<person>("Lucy") };</person></code><code>	auto ricky { std::make_shared<person>("Ricky") };</person></code><code></code><code>	partnerUp(lucy, ricky);</code><code></code><code>	auto partner = ricky-&gt;getPartner(); // get shared_ptr to Ricky's partner</code><code>	std::cout &lt;&lt; ricky-&gt;getName() &lt;&lt; "'s partner is: " &lt;&lt; partner-&gt;getName() &lt;&lt; '\n';</code><code></code><code>	return 0;</code><code>}</code></pre><p>This prints:</p><pre>Lucy created
Ricky created
Lucy is now partnered with Ricky
Ricky's partner is: Lucy
Ricky destroyed
Lucy destroyed
</pre><p>We don’t have to worry about circular dependencies with std::shared_ptr variable “partner” since it’s just a local variable inside the function. It will eventually go out of scope at the end of the function and the reference count will be decremented by 1.</p><br><h3>Dangling pointers with std::weak_ptr</h3><p>Because std::weak_ptr won’t keep an owned resource alive, it’s possible for a std::weak_ptr to be left pointing to a resource that has been deallocated by a std::shared_ptr. Such a std::weak_ptr is dangling, and using it will cause undefined behavior.</p><p>Here’s a simple example showing how this can happen:</p><pre class="language-cpp line-numbers"><code>// h/t to reader Waldo for this example</code><code>#include <iostream></iostream></code><code>#include <memory></memory></code><code></code><code>class Resource</code><code>{</code><code>public:</code><code>	Resource() { std::cerr &lt;&lt; "Resource acquired\n"; }</code><code>	~Resource() { std::cerr &lt;&lt; "Resource destroyed\n"; }</code><code>};</code><code></code><code>auto getWeakPtr()</code><code>{</code><code>	auto ptr{ std::make_shared<resource>() }; // Resource acquired</resource></code><code></code><code>	return std::weak_ptr{ ptr };</code><code>} // ptr goes out of scope, Resource destroyed</code><code></code><code>int main()</code><code>{</code><code>	std::cerr &lt;&lt; "Getting weak_ptr...\n";</code><code></code><code>	auto ptr{ getWeakPtr() }; // dangling</code><code></code><code>	std::cerr &lt;&lt; "Done.\n";</code><code>}</code></pre><p>In the above example, inside <code>getWeakPtr()</code> we use <code>std::make_shared()</code> to create a <code>std::shared_ptr</code> variable named <code>ptr</code> that owns a <code>Resource</code> object. The function returns a <code>std::weak_ptr</code> back to the caller, which does not increment the reference count. Then because <code>ptr</code> is a local variable, it goes out of scope at the end of the function, which decrements the reference count to 0 and deallocates the <code>Resource</code> object. The returned <code>std::weak_ptr</code> is left dangling, pointing to a <code>Resource</code> that was deallocated.</p><br><h3>Conclusion</h3><p>std::shared_ptr can be used when you need multiple smart pointers that can co-own a resource. The resource will be deallocated when the last std::shared_ptr goes out of scope. std::weak_ptr can be used when you want a smart pointer that can see and use a shared resource, but does not participate in the ownership of that resource.</p><p></p><br><h3>Quiz time</h3><p class="cpp-quiz-question" style="clear:both">Question #1</p><ol start="1"><li>Fix the program presented in the section “A reductive case” so that the Resource is properly deallocated. Do not alter the code in <code>main()</code>.</li></ol><p>Here is the program again for ease of reference:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <memory> // for std::shared_ptr</memory></code><code></code><code>class Resource</code><code>{</code><code>public:</code><code>	std::shared_ptr<resource> m_ptr {}; // initially created empty</resource></code><code>	</code><code>	Resource() { std::cout &lt;&lt; "Resource acquired\n"; }</code><code>	~Resource() { std::cout &lt;&lt; "Resource destroyed\n"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	auto ptr1 { std::make_shared<resource>() };</resource></code><code></code><code>	ptr1-&gt;m_ptr = ptr1; // m_ptr is now sharing the Resource that contains it</code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <memory> // for std::shared_ptr and std::weak_ptr</memory></code><code></code><code>class Resource</code><code>{</code><code>public:</code><code>	std::weak_ptr<resource> m_ptr {}; // use std::weak_ptr so m_ptr doesn't keep the Resource alive</resource></code><code>	</code><code>	Resource() { std::cout &lt;&lt; "Resource acquired\n"; }</code><code>	~Resource() { std::cout &lt;&lt; "Resource destroyed\n"; }</code><code>};</code><code></code><code>int main()</code><code>{</code><code>	auto ptr1 { std::make_shared<resource>() };</resource></code><code></code><code>	ptr1-&gt;m_ptr = ptr1; // m_ptr is now sharing the Resource that contains it</code><code></code><code>	return 0;</code><code>}</code></pre></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">M.x — Chapter M comprehensive review</h1></header><div class="entry-content" itemprop="articleBody"><p>A smart pointer class is a composition class that is designed to manage dynamically allocated memory, and ensure that memory gets deleted when the smart pointer object goes out of scope.</p><p>Copy semantics allow our classes to be copied. This is done primarily via the copy constructor and copy assignment operator.</p><p>Move semantics mean a class will transfer ownership of the object rather than making a copy. This is done primarily via the move constructor and move assignment operator.</p><p>std::auto_ptr is deprecated and should be avoided.</p><p>An r-value reference is a reference that is designed to be initialized with an r-value. An r-value reference is created using a double ampersand. It’s fine to write functions that take r-value reference parameters, but you should almost never return an r-value reference.</p><p>If we construct an object or do an assignment where the argument is an l-value, the only thing we can reasonably do is copy the l-value. We can’t assume it’s safe to alter the l-value, because it may be used again later in the program. If we have an expression “a = b”, we wouldn’t reasonably expect b to be changed in any way.</p><p>However, if we construct an object or do an assignment where the argument is an r-value, then we know that r-value is just a temporary object of some kind. Instead of copying it (which can be expensive), we can simply transfer its resources (which is cheap) to the object we’re constructing or assigning. This is safe to do because the temporary will be destroyed at the end of the expression anyway, so we know it will never be used again!</p><p>You can use the delete keyword to disable copy semantics for classes you create by deleting the copy constructor and copy assignment operator.</p><p>std::move allows you to treat an l-value as r-value. This is useful when we want to invoke move semantics instead of copy semantics on an l-value.</p><p>std::move_if_noexcept will return a movable r-value if the object has a noexcept move constructor, otherwise it will return a copyable l-value. We can use the noexcept specifier in conjunction with std::move_if_noexcept to use move semantics only when a strong exception guarantee exists (and use copy semantics otherwise).</p><p>std::unique_ptr is the smart pointer class that you should probably be using. It manages a single non-shareable resource. std::make_unique() (in C++14) should be preferred to create new std::unique_ptr. std::unique_ptr disables copy semantics.</p><p>std::shared_ptr is the smart pointer class used when you need multiple objects accessing the same resource. The resource will not be destroyed until the last std::shared_ptr managing it is destroyed. std::make_shared() should be preferred to create new std::shared_ptr. With std::shared_ptr, copy semantics should be used to create additional std::shared_ptr pointing to the same object.</p><p>std::weak_ptr is the smart pointer class used when you need one or more objects with the ability to view and access a resource managed by a std::shared_ptr, but unlike std::shared_ptr, std::weak_ptr is not considered when determining whether the resource should be destroyed.</p><p><strong>Quiz time</strong></p><ol start="1"><li>Explain when you should use the following types of pointers.</li></ol><p>1a) std::unique_ptr</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_0" style="display:none"><p>std::unique_ptr should be used when you want a smart pointer to manage a dynamic object that is not going to be shared.</p></div><p>1b) std::shared_ptr</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_1" style="display:none"><p>std::shared_ptr should be used when you want a smart pointer to manage a dynamic object that may be shared. The object won’t be deallocated until all std::shared_ptr holding the object are destroyed.</p></div><p>1c) std::weak_ptr</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_2" style="display:none"><p>std::weak_ptr should be used when you want access to an object that is being managed by a std::shared_ptr, but don’t want the lifetime of the std::shared_ptr to be tied to the lifetime of the std::weak_ptr.</p></div><p>1d) std::auto_ptr</p><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_3" style="display:none"><p>std::auto_ptr has been deprecated and was removed in C++17. It should not be used.</p></div><ol start="2"><li>Explain why move semantics is focused around r-values.</li></ol><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_4" style="display:none"><p>Because r-values are temporary, we know they are going to get destroyed after they are used. When passing or returning an r-value by value, it’s wasteful to make a copy and then destroy the original. Instead, we can simply move (steal) the r-value’s resources, which is generally more efficient.</p></div><ol start="3"><li>What’s wrong with the following code? Update the programs to be best practices compliant.</li></ol><p>3a)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <memory> // for std::shared_ptr</memory></code><code> </code><code>class Resource</code><code>{</code><code>public:</code><code>	Resource() { std::cout &lt;&lt; "Resource acquired\n"; }</code><code>	~Resource() { std::cout &lt;&lt; "Resource destroyed\n"; }</code><code>};</code><code> </code><code>int main()</code><code>{</code><code>	auto* res{ new Resource{} };</code><code>	std::shared_ptr<resource> ptr1{ res };</resource></code><code>	std::shared_ptr<resource> ptr2{ res };</resource></code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_5" style="display:none"><p>ptr2 was created from res instead of from ptr1. This means that you now have two std::shared_ptr each independently trying to manage the Resource (they are not aware of each other). When one goes out of scope, the other will be left with a dangling pointer.</p><p>ptr2 should be copied from ptr1 instead of from res, and std::make_shared() should be used</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <memory> // for std::shared_ptr</memory></code><code> </code><code>class Resource</code><code>{</code><code>public:</code><code>	Resource() { std::cout &lt;&lt; "Resource acquired\n"; }</code><code>	~Resource() { std::cout &lt;&lt; "Resource destroyed\n"; }</code><code>};</code><code> </code><code>int main()</code><code>{</code><code>	auto ptr1{ std::make_shared<resource>() };</resource></code><code>	auto ptr2{ ptr1 };</code><code></code><code>	return 0;</code><code>}</code></pre></div><p>3b)</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <memory> // for std::shared_ptr</memory></code><code></code><code>class Foo; // assume Foo is a class that can throw an exception</code><code> </code><code>int main()</code><code>{</code><code>	doSomething(std::shared_ptr<foo>{ new Foo{} }, std::shared_ptr<foo>{ new Foo{} });</foo></foo></code><code></code><code>	return 0;</code><code>}</code></pre><p><a class="solution_link_show" href="javascript:void(0)" onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Show Solution</a></p><div class="wpsolution" id="cpp_solution_id_6" style="display:none"><p>It’s possible that the compiler could dynamically allocate one <code>Foo</code>, then dynamically allocate the other <code>Foo</code>, and then initialize the two <code>std::shared_ptr<foo></foo></code> objects. If the constructor of the <code>Foo</code> allocated second throws an exception, then <code>Foo</code> allocated first will not be deallocated because the smart pointer to do the deallocation hasn’t been created yet.</p><p>The solution is to use <code>std::make_shared</code>:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <memory> // for std::shared_ptr</memory></code><code></code><code>class Foo; // assume Foo is a class that can throw an exception</code><code> </code><code>int main()</code><code>{</code><code>	doSomething(std::make_shared<foo>(), std::make_shared<foo>());</foo></foo></code><code></code><code>	return 0;</code><code>}</code></pre><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>This topic is covered <a href="https://www.learncpp.com/cpp-tutorial/stdunique_ptr/#smartpointerexceptionsafety">here</a></p></div></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">21.1 — The Standard Library</h1></header><div class="entry-content" itemprop="articleBody"><p>Congratulations! You made it all the way through the primary portion of the tutorial! In the preceding lessons, we covered many of the principal C++ language features (including a few from the C++11/14/17 extension to the language).</p><p>So the obvious question is, “what next?”. One thing you’ve probably noticed is that an awful lot of programs use the same concepts over and over again: loops, strings, arrays, sorting, etc… You’ve probably also noticed that programs written using non-class versions of containers and common algorithms are error-prone. The good news is that C++ comes with a library that is chock full of reusable classes for you to build programs out of. This library is called The C++ Standard Library.</p><p><strong>The Standard Library</strong></p><p>The Standard library contains a collection of classes that provide templated containers, algorithms, and iterators. If you need a common class or algorithm, odds are the standard library has it. The upside is that you can take advantage of these classes without having to write and debug the classes yourself, and the standard library does a good job providing reasonably efficient versions of these classes. The downside is that the standard library is complex, and can be a little intimidating since everything is templated.</p><p>Fortunately, you can bite off the standard library in tiny pieces, using only what you need from it, and ignore the rest until you’re ready to tackle it.</p><p>In the next few lessons, we’ll take a high-level look at the types of containers, algorithms, and iterators that the standard library provides. Then in subsequent lessons, we’ll dig into some of the specific classes.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">21.2 — STL containers overview</h1></header><div class="entry-content" itemprop="articleBody"><p>By far the most commonly used functionality of the STL library are the STL container classes. If you need a quick refresher on container classes, check out lesson <a href="https://www.learncpp.com/cpp-tutorial/container-classes/">16.6 -- Container classes</a>.</p><p>The STL contains many different container classes that can be used in different situations. Generally speaking, the container classes fall into three basic categories: Sequence containers, Associative containers, and Container adapters. We’ll just do a quick overview of the containers here.</p><p><strong>Sequence Containers</strong></p><p>Sequence containers are container classes that maintain the ordering of elements in the container. A defining characteristic of sequence containers is that you can choose where to insert your element by position. The most common example of a sequence container is the array: if you insert four elements into an array, the elements will be in the exact order you inserted them.</p><p>As of C++11, the STL contains 6 sequence containers: std::vector, std::deque, std::array, std::list, std::forward_list, and std::basic_string.</p><ul><li>If you’ve ever taken physics, you probably are thinking of a vector as an entity with both magnitude and direction. The unfortunately named <strong>vector</strong> class in the STL is a dynamic array capable of growing as needed to contain its elements. The vector class allows random access to its elements via operator[], and inserting and removing elements from the end of the vector is generally fast.<p>The following program inserts 6 numbers into a vector and uses the overloaded [] operator to access them in order to print them.</p><pre class="language-cpp line-numbers"><code>#include <vector></vector></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code></code><code>    std::vector<int> vect;</int></code><code>    for (int count=0; count &lt; 6; ++count)</code><code>        vect.push_back(10 - count); // insert at end of array</code><code></code><code>    for (int index=0; index &lt; vect.size(); ++index)</code><code>        std::cout &lt;&lt; vect[index] &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code>}</code></pre><p>This program produces the result:<br>10 9 8 7 6 5</p></li><li>The <strong>deque</strong> class (pronounced “deck”) is a double-ended queue class, implemented as a dynamic array that can grow from both ends.<pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <deque></deque></code><code></code><code>int main()</code><code>{</code><code>    std::deque<int> deq;</int></code><code>    for (int count=0; count &lt; 3; ++count)</code><code>    {</code><code>        deq.push_back(count); // insert at end of array</code><code>        deq.push_front(10 - count); // insert at front of array</code><code>    }</code><code></code><code>    for (int index=0; index &lt; deq.size(); ++index)</code><code>        std::cout &lt;&lt; deq[index] &lt;&lt; ' ';</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code>}</code></pre><p>This program produces the result:</p><p>8 9 10 0 1 2</p></li><li>A <strong>list</strong> is a special type of sequence container called a doubly linked list where each element in the container contains pointers that point at the next and previous elements in the list. Lists only provide access to the start and end of the list -- there is no random access provided. If you want to find a value in the middle, you have to start at one end and “walk the list” until you reach the element you want to find. The advantage of lists is that inserting elements into a list is very fast if you already know where you want to insert them. Generally iterators are used to walk through the list.<p>We’ll talk more about both linked lists and iterators in future lessons.</p></li><li>Although the STL <strong>string</strong> (and wstring) class aren’t generally included as a type of sequence container, they essentially are, as they can be thought of as a vector with data elements of type char (or wchar).</li></ul><p><strong>Associative Containers</strong></p><p>Associative containers are containers that automatically sort their inputs when those inputs are inserted into the container. By default, associative containers compare elements using operator&lt;.</p><ul><li>A <strong>set</strong> is a container that stores unique elements, with duplicate elements disallowed. The elements are sorted according to their values.</li><li>A <strong>multiset</strong> is a set where duplicate elements are allowed.</li><li>A <strong>map</strong> (also called an associative array) is a set where each element is a pair, called a key/value pair. The key is used for sorting and indexing the data, and must be unique. The value is the actual data.</li><li>A <strong>multimap</strong> (also called a dictionary) is a map that allows duplicate keys. Real-life dictionaries are multimaps: the key is the word, and the value is the meaning of the word. All the keys are sorted in ascending order, and you can look up the value by key. Some words can have multiple meanings, which is why the dictionary is a multimap rather than a map.</li></ul><p><strong>Container Adapters</strong></p><p>Container adapters are special predefined containers that are adapted to specific uses. The interesting part about container adapters is that you can choose which sequence container you want them to use.</p><ul><li>A <strong>stack</strong> is a container where elements operate in a LIFO (Last In, First Out) context, where elements are inserted (pushed) and removed (popped) from the end of the container. Stacks default to using deque as their default sequence container (which seems odd, since vector seems like a more natural fit), but can use vector or list as well.</li><li>A <strong>queue</strong> is a container where elements operate in a FIFO (First In, First Out) context, where elements are inserted (pushed) to the back of the container and removed (popped) from the front. Queues default to using deque, but can also use list.</li><li>A <strong>priority queue</strong> is a type of queue where the elements are kept sorted (via operator&lt;). When elements are pushed, the element is sorted in the queue. Removing an element from the front returns the highest priority item in the priority queue.</li></ul></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">21.3 — STL iterators overview</h1></header><div class="entry-content" itemprop="articleBody"><p>An <strong>Iterator</strong> is an object that can traverse (iterate over) a container class without the user having to know how the container is implemented. With many classes (particularly lists and the associative classes), iterators are the primary way elements of these classes are accessed.</p><p>An iterator is best visualized as a pointer to a given element in the container, with a set of overloaded operators to provide a set of well-defined functions:</p><ul><li><strong>Operator*</strong> -- Dereferencing the iterator returns the element that the iterator is currently pointing at.</li><li><strong>Operator++</strong> -- Moves the iterator to the next element in the container. Most iterators also provide <code>Operator--</code> to move to the previous element.</li><li><strong>Operator== and Operator!=</strong> -- Basic comparison operators to determine if two iterators point to the same element. To compare the values that two iterators are pointing at, dereference the iterators first, and then use a comparison operator.</li><li><strong>Operator=</strong> -- Assign the iterator to a new position (typically the start or end of the container’s elements). To assign the value of the element the iterator is pointing at, dereference the iterator first, then use the assign operator.</li></ul><p>Each container includes four basic member functions for use with Operator=:</p><ul><li><strong>begin()</strong> returns an iterator representing the beginning of the elements in the container.</li><li><strong>end()</strong> returns an iterator representing the element just past the end of the elements.</li><li><strong>cbegin()</strong> returns a const (read-only) iterator representing the beginning of the elements in the container.</li><li><strong>cend()</strong> returns a const (read-only) iterator representing the element just past the end of the elements.</li></ul><p>It might seem weird that end() doesn’t point to the last element in the list, but this is done primarily to make looping easy: iterating over the elements can continue until the iterator reaches end(), and then you know you’re done.</p><p>Finally, all containers provide (at least) two types of iterators:</p><ul><li><strong>container::iterator</strong> provides a read/write iterator</li><li><strong>container::const_iterator</strong> provides a read-only iterator</li></ul><p>Lets take a look at some examples of using iterators.</p><p><strong>Iterating through a vector</strong></p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <vector></vector></code><code></code><code>int main()</code><code>{</code><code>    std::vector<int> vect;</int></code><code>    for (int count=0; count &lt; 6; ++count)</code><code>        vect.push_back(count);</code><code></code><code>    std::vector<int>::const_iterator it; // declare a read-only iterator</int></code><code>    it = vect.cbegin(); // assign it to the start of the vector</code><code>    while (it != vect.cend()) // while it hasn't reach the end</code><code>        {</code><code>        std::cout &lt;&lt; *it &lt;&lt; ' '; // print the value of the element it points to</code><code>        ++it; // and iterate to the next element</code><code>        }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code>}</code></pre><p>This prints the following:</p><p>0 1 2 3 4 5</p><p><strong>Iterating through a list</strong></p><p>Now let’s do the same thing with a list:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <list></list></code><code></code><code>int main()</code><code>{</code><code></code><code>    std::list<int> li;</int></code><code>    for (int count=0; count &lt; 6; ++count)</code><code>        li.push_back(count);</code><code></code><code>    std::list<int>::const_iterator it; // declare an iterator</int></code><code>    it = li.cbegin(); // assign it to the start of the list</code><code>    while (it != li.cend()) // while it hasn't reach the end</code><code>    {</code><code>        std::cout &lt;&lt; *it &lt;&lt; ' '; // print the value of the element it points to</code><code>        ++it; // and iterate to the next element</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code>}</code></pre><p>This prints:</p><p>0 1 2 3 4 5</p><p>Note the code is almost identical to the vector case, even though vectors and lists have almost completely different internal implementations!</p><p><strong>Iterating through a set</strong></p><p>In the following example, we’re going to create a set from 6 numbers and use an iterator to print the values in the set:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <set></set></code><code></code><code>int main()</code><code>{</code><code>    std::set<int> myset;</int></code><code>    myset.insert(7);</code><code>    myset.insert(2);</code><code>    myset.insert(-6);</code><code>    myset.insert(8);</code><code>    myset.insert(1);</code><code>    myset.insert(-4);</code><code></code><code>    std::set<int>::const_iterator it; // declare an iterator</int></code><code>    it = myset.cbegin(); // assign it to the start of the set</code><code>    while (it != myset.cend()) // while it hasn't reach the end</code><code>    {</code><code>        std::cout &lt;&lt; *it &lt;&lt; ' '; // print the value of the element it points to</code><code>        ++it; // and iterate to the next element</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code>}</code></pre><p>This program produces the following result:</p><p>-6 -4 1 2 7 8</p><p>Note that although populating the set differs from the way we populate the vector and list, the code used to iterate through the elements of the set was essentially identical.</p><p><strong>Iterating through a map</strong></p><p>This one is a little trickier. Maps and multimaps take pairs of elements (defined as a std::pair). We use the make_pair() helper function to easily create pairs. std::pair allows access to the elements of the pair via the first and second members. In our map, we use first as the key, and second as the value.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <map></map></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>	std::map<int, std::string=""> mymap;</int,></code><code>	mymap.insert(std::make_pair(4, "apple"));</code><code>	mymap.insert(std::make_pair(2, "orange"));</code><code>	mymap.insert(std::make_pair(1, "banana"));</code><code>	mymap.insert(std::make_pair(3, "grapes"));</code><code>	mymap.insert(std::make_pair(6, "mango"));</code><code>	mymap.insert(std::make_pair(5, "peach"));</code><code></code><code>	auto it{ mymap.cbegin() }; // declare a const iterator and assign to start of vector</code><code>	while (it != mymap.cend()) // while it hasn't reach the end</code><code>	{</code><code>		std::cout &lt;&lt; it-&gt;first &lt;&lt; '=' &lt;&lt; it-&gt;second &lt;&lt; ' '; // print the value of the element it points to</code><code>		++it; // and iterate to the next element</code><code>	}</code><code></code><code>	std::cout &lt;&lt; '\n';</code><code>}</code></pre><p>This program produces the result:</p><p>1=banana 2=orange 3=grapes 4=apple 5=peach 6=mango</p><p>Notice here how easy iterators make it to step through each of the elements of the container. You don’t have to care at all how map stores its data!</p><p><strong>Conclusion</strong></p><p>Iterators provide an easy way to step through the elements of a container class without having to understand how the container class is implemented. When combined with STL’s algorithms and the member functions of the container classes, iterators become even more powerful. In the next lesson, you’ll see an example of using an iterator to insert elements into a list (which doesn’t provide an overloaded operator[] to access its elements directly).</p><p>One point worth noting: Iterators must be implemented on a per-class basis, because the iterator does need to know how a class is implemented. Thus iterators are always tied to specific container classes.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">21.4 — STL algorithms overview</h1></header><div class="entry-content" itemprop="articleBody"><p>In addition to container classes and iterators, STL also provides a number of generic algorithms for working with the elements of the container classes. These allow you to do things like search, sort, insert, reorder, remove, and copy elements of the container class.</p><p>Note that algorithms are implemented as functions that operate using iterators. This means that each algorithm only needs to be implemented once, and it will generally automatically work for all containers that provides a set of iterators (including your custom container classes). While this is very powerful and can lead to the ability to write complex code very quickly, it’s also got a dark side: some combination of algorithms and container types may not work, may cause infinite loops, or may work but be extremely poor performing. So use these at your risk.</p><p>STL provides quite a few algorithms -- we will only touch on some of the more common and easy to use ones here. The rest (and the full details) will be saved for a chapter on STL algorithms.</p><p>To use any of the STL algorithms, simply include the algorithm header file.</p><p><strong>min_element and max_element</strong></p><p>The <code>std::min_element</code> and <code>std::max_element</code> algorithms find the min and max element in a container class. <code>std::iota</code> generates a contiguous series of values.</p><pre class="language-cpp line-numbers"><code>#include <algorithm> // std::min_element and std::max_element</algorithm></code><code>#include <iostream></iostream></code><code>#include <list></list></code><code>#include <numeric> // std::iota</numeric></code><code></code><code>int main()</code><code>{</code><code>    std::list<int> li(6);</int></code><code>    // Fill li with numbers starting at 0.</code><code>    std::iota(li.begin(), li.end(), 0);</code><code></code><code>    std::cout &lt;&lt; *std::min_element(li.begin(), li.end()) &lt;&lt; ' '</code><code>              &lt;&lt; *std::max_element(li.begin(), li.end()) &lt;&lt; '\n';</code><code>	</code><code>    return 0;</code><code>}</code></pre><p>Prints:</p><p>0 5</p><p><strong>find (and list::insert)</strong></p><p>In this example, we’ll use the <code>std::find()</code> algorithm to find a value in the list class, and then use the list::insert() function to add a new value into the list at that point.</p><pre class="language-cpp line-numbers"><code>#include <algorithm></algorithm></code><code>#include <iostream></iostream></code><code>#include <list></list></code><code>#include <numeric></numeric></code><code></code><code>int main()</code><code>{</code><code>    std::list<int> li(6);</int></code><code>    std::iota(li.begin(), li.end(), 0);</code><code></code><code>    // Find the value 3 in the list</code><code>    auto it{ std::find(li.begin(), li.end(), 3) };</code><code>    </code><code>    // Insert 8 right before 3.</code><code>    li.insert(it, 8);</code><code></code><code>    for (int i : li) // for loop with iterators</code><code>        std::cout &lt;&lt; i &lt;&lt; ' ';</code><code>    	</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This prints the values</p><pre>0 1 2 8 3 4 5
</pre><p>When a searching algorithm doesn’t find what it was looking for, it returns the end iterator.<br>If we didn’t know for sure that 3 is an element of <code>li</code>, we’d have to check if <code>std::find</code> found it before we use the returned iterator for anything else.</p><pre class="language-cpp line-numbers"><code>if (it == li.end())</code><code>{</code><code>  std::cout &lt;&lt; "3 was not found\n";</code><code>}</code><code>else</code><code>{</code><code>  // ...</code><code>}</code></pre><p><strong>sort and reverse</strong></p><p>In this example, we’ll sort a vector and then reverse it.</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <vector></vector></code><code>#include <algorithm></algorithm></code><code></code><code>int main()</code><code>{</code><code>    std::vector<int> vect{ 7, -3, 6, 2, -5, 0, 4 };</int></code><code></code><code>    // sort the vector</code><code>    std::sort(vect.begin(), vect.end());</code><code></code><code>    for (int i : vect)</code><code>    {</code><code>        std::cout &lt;&lt; i &lt;&lt; ' ';</code><code>    }</code><code></code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    // reverse the vector</code><code>    std::reverse(vect.begin(), vect.end());</code><code></code><code>    for (int i : vect)</code><code>    {</code><code>        std::cout &lt;&lt; i &lt;&lt; ' ';</code><code>    }</code><code> 	</code><code>    std::cout &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This produces the result:</p><pre>-5 -3 0 2 4 6 7
7 6 4 2 0 -3 -5
</pre><p>Alternatively, we could pass a custom comparison function as the third argument to <code>std::sort</code>. There are several comparison functions in the &lt;functional&gt; header which we can use so we don’t have to write our own. We can pass <code>std::greater</code> to <code>std::sort</code> and remove the call to <code>std::reverse</code>. The vector will be sorted from high to low right away.</p><p>Note that <code>std::sort()</code> doesn’t work on list container classes -- the list class provides its own <code>sort()</code> member function, which is much more efficient than the generic version would be.</p><p><strong>Conclusion</strong></p><p>Although this is just a taste of the algorithms that STL provides, it should suffice to show how easy these are to use in conjunction with iterators and the basic container classes. There are enough other algorithms to fill up a whole chapter!</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">22.1 — std::string and std::wstring</h1></header><div class="entry-content" itemprop="articleBody"><p>The standard library contains many useful classes -- but perhaps the most useful is std::string. std::string (and std::wstring) is a string class that provides many operations to assign, compare, and modify strings. In this chapter, we’ll look into these string classes in depth.</p><p>Note: C-style strings will be referred to as “C-style strings”, whereas std::string (and std::wstring) will be referred to simply as “strings”.</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>This chapter is somewhat outdated and will likely be condensed in a future update. Feel free to scan the material for ideas and useful examples, but technical reference sites (e.g. <a href="https://en.cppreference.com/w/cpp/string/basic_string">cppreference</a>) should be preferred for the most up-to-date information.</p></div><p><strong>Motivation for a string class</strong></p><p>In a previous lesson, we covered <a href="https://www.learncpp.com/cpp-tutorial/66-c-style-strings/">C-style strings</a>, which uses char arrays to store a string of characters. If you’ve tried to do anything with C-style strings, you’ll very quickly come to the conclusion that they are a pain to work with, easy to mess up, and hard to debug.</p><p>C-style strings have many shortcomings, primarily revolving around the fact that you have to do all the memory management yourself. For example, if you want to assign the string “hello!” into a buffer, you have to first dynamically allocate a buffer of the correct length:</p><pre class="language-cpp line-numbers"><code>char* strHello { new char[7] };</code></pre><p>Don’t forget to account for an extra character for the null terminator!</p><p>Then you have to actually copy the value in:</p><pre class="language-cpp line-numbers"><code>strcpy(strHello, "hello!");</code></pre><p>Hopefully you made your buffer large enough so there’s no buffer overflow!</p><p>And of course, because the string is dynamically allocated, you have to remember to deallocate it properly when you’re done with it:</p><pre class="language-cpp line-numbers"><code>delete[] strHello;</code></pre><p>Don’t forget to use array delete instead of normal delete!</p><p>Furthermore, many of the intuitive operators that C provides to work with numbers, such as assignment and comparisons, simply don’t work with C-style strings. Sometimes these will appear to work but actually produce incorrect results -- for example, comparing two C-style strings using == will actually do a pointer comparison, not a string comparison. Assigning one C-style string to another using operator= will appear to work at first, but is actually doing a pointer copy (shallow copy), which is not generally what you want. These kinds of things can lead to program crashes that are very hard to find and debug!</p><p>The bottom line is that working with C-style strings requires remembering a lot of nit-picky rules about what is safe/unsafe, memorizing a bunch of functions that have funny names like strcat() and strcmp() instead of using intuitive operators, and doing lots of manual memory management.</p><p>Fortunately, C++ and the standard library provide a much better way to deal with strings: the std::string and std::wstring classes. By making use of C++ concepts such as constructors, destructors, and operator overloading, std::string allows you to create and manipulate strings in an intuitive and safe manner! No more memory management, no more weird function names, and a much reduced potential for disaster.</p><p>Sign me up!</p><p><strong>String overview</strong></p><p>All string functionality in the standard library lives in the <string>header file. To use it, simply include the string header:</string></p><pre class="language-cpp line-numbers"><code>    #include <string></string></code></pre><p>There are actually 3 different string classes in the string header. The first is a templated base class named basic_string:</p><pre class="language-cpp line-numbers"><code>namespace std</code><code>{</code><code>    template<class chart,="" class="" traits="char_traits<charT">, class Allocator = allocator<chart> &gt;</chart></class></code><code>        class basic_string;</code><code>}</code></pre><p>You won’t be working with this class directly, so don’t worry about what traits or an Allocator is for the time being. The default values will suffice in almost every imaginable case.</p><p>There are two flavors of basic_string provided by the standard library:</p><pre class="language-cpp line-numbers"><code>namespace std</code><code>{</code><code>    typedef basic_string<char> string;</char></code><code>    typedef basic_string<wchar_t> wstring;</wchar_t></code><code>}</code></pre><p>These are the two classes that you will actually use. std::string is used for standard ascii and utf-8 strings. std::wstring is used for wide-character/unicode (utf-16) strings. There is no built-in class for utf-32 strings (though you should be able to extend your own from basic_string if you need one).</p><p>Although you will directly use std::string and std::wstring, all of the string functionality is implemented in the basic_string class. String and wstring are able to access that functionality directly by virtue of being templated. Consequently, all of the functions presented will work for both string and wstring. However, because basic_string is a templated class, it also means the compiler will produce horrible looking template errors when you do something syntactically incorrect with a string or wstring. Don’t be intimidated by these errors; they look far worse than they are!</p><p>Here’s a list of all the functions in the string class. Most of these functions have multiple flavors to handle different types of inputs, which we will cover in more depth in the next lessons.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Function</th><th>Effect</th></tr><tr><td colspan="2"><center><b>Creation and destruction</b></center></td></tr><tr><td><a href="https://www.learncpp.com/cpp-tutorial/17-2-ststring-construction-and-destruction/">(constructor)</a><br><a href="https://www.learncpp.com/cpp-tutorial/17-2-ststring-construction-and-destruction/">(destructor)</a></td><td>Create or copy a string<br>Destroy a string</td></tr><tr><td colspan="2"><center><b>Size and capacity</b></center></td></tr><tr><td nowrap=""><a href="https://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/">capacity()</a><br><a href="https://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/">empty()</a><br><a href="https://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/">length(), size()</a><br><a href="https://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/">max_size()</a><br><a href="https://www.learncpp.com/cpp-tutorial/17-3-stdstring-length-and-capacity/">reserve()</a></td><td nowrap="">Returns the number of characters that can be held without reallocation<br>Returns a boolean indicating whether the string is empty<br>Returns the number of characters in string<br>Returns the maximum string size that can be allocated<br>Expand or shrink the capacity of the string</td></tr><tr><td colspan="2"><center><b>Element access</b></center></td></tr><tr><td nowrap=""><a href="https://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/">[], at()</a></td><td nowrap="">Accesses the character at a particular index</td></tr><tr><td colspan="2"><center><b>Modification</b></center></td></tr><tr><td nowrap=""><a href="https://www.learncpp.com/cpp-programming/17-5-stdstring-assignment-and-swapping/">=, assign()</a><br><a href="https://www.learncpp.com/uncategorized/17-6-stdstring-appending/">+=, append(), push_back()</a><br><a href="https://www.learncpp.com/cpp-tutorial/17-7-stdstring-inserting/">insert()</a><br>clear()<br>erase()<br>replace()<br>resize()<br><a href="https://www.learncpp.com/cpp-programming/17-5-stdstring-assignment-and-swapping/">swap()</a></td><td nowrap="">Assigns a new value to the string<br>Concatenates characters to end of the string<br>Inserts characters at an arbitrary index in string<br>Delete all characters in the string<br>Erase characters at an arbitrary index in string<br>Replace characters at an arbitrary index with other characters<br>Expand or shrink the string (truncates or adds characters at end of string)<br>Swaps the value of two strings</td></tr><tr><td colspan="2"><center><b>Input and Output</b></center></td></tr><tr><td nowrap="">&gt;&gt;, getline()<br>&lt;&lt;<br><a href="https://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/">c_str()</a><br><a href="https://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/">copy()</a><br><a href="https://www.learncpp.com/cpp-tutorial/17-4-stdstring-character-access-and-conversion-to-c-style-arrays/">data()</a></td><td nowrap="">Reads values from the input stream into the string<br>Writes string value to the output stream<br>Returns the contents of the string as a NULL-terminated C-style string<br>Copies contents (not NULL-terminated) to a character array<br>Same as c_str(). The non-const overload allows writing to the returned string.</td></tr><tr><td colspan="2"><center><b>String comparison</b></center></td></tr><tr><td nowrap="">==, !=<br>&lt;, &lt;=, &gt; &gt;=<br>compare()</td><td nowrap="">Compares whether two strings are equal/unequal (returns bool)<br>Compares whether two strings are less than / greater than each other (returns bool)<br>Compares whether two strings are equal/unequal (returns -1, 0, or 1)</td></tr><tr><td colspan="2"><center><b>Substrings and concatenation</b></center></td></tr><tr><td nowrap="">+<br>substr()</td><td nowrap="">Concatenates two strings<br>Returns a substring</td></tr><tr><td colspan="2"><center><b>Searching</b></center></td></tr><tr><td nowrap="">find()<br>find_first_of()<br>find_first_not_of()<br>find_last_of()<br>find_last_not_of()<br>rfind()</td><td nowrap="">Find index of first character/substring<br>Find index of first character from a set of characters<br>Find index of first character not from a set of characters<br>Find index of last character from a set of characters<br>Find index of last character not from a set of characters<br>Find index of last character/substring</td></tr><tr><td colspan="2"><center><b>Iterator and allocator support</b></center></td></tr><tr><td nowrap="">begin(), end()<br>get_allocator()<br>rbegin(), rend()</td><td nowrap="">Forward-direction iterator support for beginning/end of string<br>Returns the allocator<br>Reverse-direction iterator support for beginning/end of string</td></tr></tbody></table></div><p>While the standard library string classes provide a lot of functionality, there are a few notable omissions:</p><ul><li>Regular expression support</li><li>Constructors for creating strings from numbers</li><li>Capitalization / upper case / lower case functions</li><li>Case-insensitive comparisons</li><li>Tokenization / splitting string into array</li><li>Easy functions for getting the left or right hand portion of string</li><li>Whitespace trimming</li><li>Formatting a string sprintf style</li><li>Conversion from utf-8 to utf-16 or vice-versa</li></ul><p>For most of these, you will have to either write your own functions, or convert your string to a C-style string (using c_str()) and use the C functions that offer this functionality.</p><p>In the next lessons, we will look at the various functions of the string class in more depth. Although we will use string for our examples, everything is equally applicable to wstring.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">22.2 — std::string construction and destruction</h1></header><div class="entry-content" itemprop="articleBody"><p>In this lesson, we’ll take a look at how to construct objects of std::string, as well as how to create strings from numbers and vice-versa.</p><p><strong>String construction</strong></p><p>The string classes have a number of constructors that can be used to create strings. We’ll take a look at each of them here.</p><p>Note: string::size_type resolves to size_t, which is the same unsigned integral type that is returned by the sizeof operator. The actual size of size_t depending on the environment. For the purposes of this tutorial, envision it as an unsigned int.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string::string()</b><ul><li>This is the default constructor. It creates an empty string.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string sSource;</code><code>std::cout &lt;&lt; sSource;</code></pre><p>Output:</p><pre></pre></td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string::string(const string&amp; strString)</b><ul><li>This is the copy constructor. This constructor creates a new string as a copy of strString.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string sSource{ "my string" };</code><code>std::string sOutput{ sSource };</code><code>std::cout &lt;&lt; sOutput;</code></pre><p>Output:</p><pre>my string
</pre></td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string::string(const string&amp; strString, size_type unIndex)</b><br><b>string::string(const string&amp; strString, size_type unIndex, size_type unLength)</b><ul><li>This constructor creates a new string that contains at most unLength characters from strString, starting with index unIndex. If a NULL is encountered, the string copy will end, even if unLength has not been reached.</li><li>If no unLength is supplied, all characters starting from unIndex will be used.</li><li>If unIndex is larger than the size of the string, the out_of_range exception will be thrown.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string sSource{ "my string" };</code><code>std::string sOutput{ sSource, 3 };</code><code>std::cout &lt;&lt; sOutput&lt;&lt; '\n';</code><code>std::string sOutput2(sSource, 3, 4);</code><code>std::cout &lt;&lt; sOutput2 &lt;&lt; '\n';</code></pre><p>Output:</p><pre>string
stri
</pre></td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string::string(const char* szCString)</b><ul><li>This constructor creates a new string from the C-style string szCString, up to but not including the NULL terminator.</li><li>If the resulting size exceeds the maximum string length, the length_error exception will be thrown.</li><li><b>Warning:</b> szCString must not be NULL.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>const char* szSource{ "my string" };</code><code>std::string sOutput{ szSource };</code><code>std::cout &lt;&lt; sOutput &lt;&lt; '\n';</code></pre><p>Output:</p><pre>my string
</pre></td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string::string(const char* szCString, size_type unLength)</b><ul><li>This constructor creates a new string from the first unLength chars from the C-style string szCString.</li><li>If the resulting size exceeds the maximum string length, the length_error exception will be thrown.</li><li><b>Warning:</b> For this function only, NULLs are not treated as end-of-string characters in szCString! This means it is possible to read off the end of your string if unLength is too big. Be careful not to overflow your string buffer!</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>const char* szSource{ "my string" };</code><code>std::string sOutput(szSource, 4);</code><code>std::cout &lt;&lt; sOutput &lt;&lt; '\n';</code></pre><p>Output:</p><pre>my s
</pre></td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string::string(size_type nNum, char chChar)</b><ul><li>This constructor creates a new string initialized by nNum occurances of the character chChar.</li><li>If the resulting size exceeds the maximum string length, the length_error exception will be thrown.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string sOutput(4, 'Q');</code><code>std::cout &lt;&lt; sOutput &lt;&lt; '\n';</code></pre><p>Output:</p><pre>QQQQ
</pre></td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>template<class inputiterator=""> string::string(InputIterator itBeg, InputIterator itEnd)</class></b><ul><li>This constructor creates a new string initialized by the characters of range [itBeg, itEnd).</li><li>If the resulting size exceeds the maximum string length, the length_error exception will be thrown.</li></ul><p>No sample code for this one. It’s obscure enough you’ll probably never use it.</p></td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string::~string()</b><p><strong>String destruction</strong></p><ul><li>This is the destructor. It destroys the string and frees the memory.</li></ul><p>No sample code here either since the destructor isn’t called explicitly.</p></td></tr></tbody></table></div><p><strong>Constructing strings from numbers</strong></p><p>One notable omission in the std::string class is the lack of ability to create strings from numbers. For example:</p><pre class="language-cpp line-numbers"><code>    std::string sFour{ 4 };</code></pre><p>Produces the following error:</p><pre>c:vcprojectstest2test2test.cpp(10) : error C2664: 'std::basic_string&lt;_Elem,_Traits,_Ax&gt;::basic_string(std::basic_string&lt;_Elem,_Traits,_Ax&gt;::_Has_debug_it)' : cannot convert parameter 1 from 'int' to 'std::basic_string&lt;_Elem,_Traits,_Ax&gt;::_Has_debug_it'
</pre><p>Remember what I said about the string classes producing horrible looking errors? The relevant bit of information here is:</p><pre>cannot convert parameter 1 from 'int' to 'std::basic_string</pre><p>In other words, it tried to convert your int into a string but failed.</p><p>The easiest way to convert numbers into strings is to involve the std::ostringstream class. std::ostringstream is already set up to accept input from a variety of sources, including characters, numbers, strings, etc… It is also capable of outputting strings (either via the extraction operator&gt;&gt;, or via the str() function). For more information on std::ostringstream, see <a href="https://www.learncpp.com/cpp-tutorial/stream-classes-for-strings/">23.4 -- Stream classes for strings</a>.</p><p>Here’s a simple solution for creating std::string from various types of inputs:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <sstream></sstream></code><code>#include <string></string></code><code> </code><code>template <typename t=""></typename></code><code>inline std::string ToString(T tX)</code><code>{</code><code>    std::ostringstream oStream;</code><code>    oStream &lt;&lt; tX;</code><code>    return oStream.str();</code><code>}</code></pre><p>Here’s some sample code to test it:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    std::string sFour{ ToString(4) };</code><code>    std::string sSixPointSeven{ ToString(6.7) };</code><code>    std::string sA{ ToString('A') };</code><code>    std::cout &lt;&lt; sFour &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; sSixPointSeven &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; sA &lt;&lt; '\n';</code><code>}</code></pre><p>And the output:</p><pre>4
6.7
A
</pre><p>Note that this solution omits any error checking. It is possible that inserting tX into oStream could fail. An appropriate response would be to throw an exception if the conversion fails.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>The standard library also contains a function named <code>std::to_string()</code> that can be used to convert chars and numbers into a std::string. While this is a simpler solution for basic cases, the output of std::to_string may differ from the output of std::cout or out ToString() function above. Some of these differences are currently documented <a href="https://en.cppreference.com/w/cpp/string/basic_string/to_string">here</a>.</p></div><p><strong>Converting strings to numbers</strong></p><p>Similar to the solution above:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <sstream></sstream></code><code>#include <string></string></code><code> </code><code>template <typename t=""></typename></code><code>inline bool FromString(const std::string&amp; sString, T&amp; tX)</code><code>{</code><code>    std::istringstream iStream(sString);</code><code>    return !(iStream &gt;&gt; tX).fail(); // extract value into tX, return success or not</code><code>}</code></pre><p>Here’s some sample code to test it:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    double dX;</code><code>    if (FromString("3.4", dX))</code><code>        std::cout &lt;&lt; dX &lt;&lt; '\n'; </code><code>    if (FromString("ABC", dX))</code><code>        std::cout &lt;&lt; dX &lt;&lt; '\n'; </code><code>}</code></pre><p>And the output:</p><pre>3.4
</pre><p>Note that the second conversion failed and returned false.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">22.3 — std::string length and capacity</h1></header><div class="entry-content" itemprop="articleBody"><p>Once you’ve created strings, it’s often useful to know how long they are. This is where length and capacity operations come into play. We’ll also discuss various ways to convert std::string back into C-style strings, so you can use them with functions that expect strings of type char*.</p><p><strong>Length of a string</strong></p><p>The length of the string is quite simple -- it’s the number of characters in the string. There are two identical functions for determining string length:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>size_type string::length() const</b><br><b>size_type string::size() const</b><ul><li>Both of these functions return the current number of characters in the string, excluding the null terminator.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string s { "012345678" };</code><code>std::cout &lt;&lt; s.length() &lt;&lt; '\n';</code></pre><p>Output:</p><pre>9
</pre></td></tr></tbody></table></div><p>Although it’s possible to use length() to determine whether a string has any characters or not, it’s more efficient to use the empty() function:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>bool string::empty() const</b><ul><li>Returns true if the string has no characters, false otherwise.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string string1 { "Not Empty" };</code><code>std::cout &lt;&lt; (string1.empty() ? "true" : "false") &lt;&lt; '\n';</code><code>std::string string2; // empty</code><code>std::cout &lt;&lt; (string2.empty() ? "true" : "false")  &lt;&lt; '\n';</code></pre><p>Output:</p><pre>false
true
</pre></td></tr></tbody></table></div><p>There is one more size-related function that you will probably never use, but we’ll include it here for completeness:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>size_type string::max_size() const</b><ul><li>Returns the maximum number of characters that a string is allowed to have.</li><li>This value will vary depending on operating system and system architecture.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string s { "MyString" };</code><code>std::cout &lt;&lt; s.max_size() &lt;&lt; '\n';</code></pre><p>Output:</p><pre>4294967294
</pre></td></tr></tbody></table></div><p><strong>Capacity of a string</strong></p><p>The capacity of a string reflects how much memory the string allocated to hold its contents. This value is measured in string characters, excluding the NULL terminator. For example, a string with capacity 8 could hold 8 characters.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>size_type string::capacity() const</b><ul><li>Returns the number of characters a string can hold without reallocation.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string s { "01234567" };</code><code>std::cout &lt;&lt; "Length: " &lt;&lt; s.length() &lt;&lt; '\n';</code><code>std::cout &lt;&lt; "Capacity: " &lt;&lt; s.capacity() &lt;&lt; '\n';</code></pre><p>Output:</p><pre>Length: 8
Capacity: 15
</pre></td></tr></tbody></table></div><p>Note that the capacity is higher than the length of the string! Although our string was length 8, the string actually allocated enough memory for 15 characters! Why was this done?</p><p>The important thing to recognize here is that if a user wants to put more characters into a string than the string has capacity for, the string has to be reallocated to a larger capacity. For example, if a string had both length and capacity of 8, then adding any characters to the string would force a reallocation. By making the capacity larger than the actual string, this gives the user some buffer room to expand the string before reallocation needs to be done.</p><p>As it turns out, reallocation is bad for several reasons:</p><p>First, reallocating a string is comparatively expensive. First, new memory has to be allocated. Then each character in the string has to be copied to the new memory. This can take a long time if the string is big. Finally, the old memory has to be deallocated. If you are doing many reallocations, this process can slow your program down significantly.</p><p>Second, whenever a string is reallocated, the contents of the string change to a new memory address. This means all references, pointers, and iterators to the string become invalid!</p><p>Note that it’s not always the case that strings will be allocated with capacity greater than length. Consider the following program:</p><pre class="language-cpp line-numbers"><code>std::string s { "0123456789abcde" };</code><code>std::cout &lt;&lt; "Length: " &lt;&lt; s.length() &lt;&lt; '\n';</code><code>std::cout &lt;&lt; "Capacity: " &lt;&lt; s.capacity() &lt;&lt; '\n';</code></pre><p>This program outputs:</p><pre>Length: 15
Capacity: 15
</pre><p>(Results may vary depending on compiler).</p><p>Let’s add one character to the string and watch the capacity change:</p><pre class="language-cpp line-numbers"><code>std::string s("0123456789abcde");</code><code>std::cout &lt;&lt; "Length: " &lt;&lt; s.length() &lt;&lt; '\n';</code><code>std::cout &lt;&lt; "Capacity: " &lt;&lt; s.capacity() &lt;&lt; '\n';</code><code></code><code>// Now add a new character</code><code>s += "f";</code><code>std::cout &lt;&lt; "Length: " &lt;&lt; s.length() &lt;&lt; '\n';</code><code>std::cout &lt;&lt; "Capacity: " &lt;&lt; s.capacity() &lt;&lt; '\n';</code></pre><p>This produces the result:</p><pre>Length: 15
Capacity: 15
Length: 16
Capacity: 31
</pre><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>void string::reserve()</b><br><b>void string::reserve(size_type unSize)</b><ul><li>The second flavor of this function sets the capacity of the string to at least unSize (it can be greater). Note that this may require a reallocation to occur.</li><li>If the first flavor of the function is called, or the second flavor is called with unSize less than the current capacity, the function will try to shrink the capacity to match the length. This request to shrink the capacity may be ignored, depending on implementation.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string s { "01234567" };</code><code>std::cout &lt;&lt; "Length: " &lt;&lt; s.length() &lt;&lt; '\n';</code><code>std::cout &lt;&lt; "Capacity: " &lt;&lt; s.capacity() &lt;&lt; '\n';</code><code></code><code>s.reserve(200);</code><code>std::cout &lt;&lt; "Length: " &lt;&lt; s.length() &lt;&lt; '\n';</code><code>std::cout &lt;&lt; "Capacity: " &lt;&lt; s.capacity() &lt;&lt; '\n';</code><code></code><code>s.reserve();</code><code>std::cout &lt;&lt; "Length: " &lt;&lt; s.length() &lt;&lt; '\n';</code><code>std::cout &lt;&lt; "Capacity: " &lt;&lt; s.capacity() &lt;&lt; '\n';</code></pre><p>Output:</p><pre>Length: 8
Capacity: 15
Length: 8
Capacity: 207
Length: 8
Capacity: 207
</pre></td></tr></tbody></table></div><p>This example shows two interesting things. First, although we requested a capacity of 200, we actually got a capacity of 207. The capacity is always guaranteed to be at least as large as your request, but may be larger. We then requested the capacity change to fit the string. This request was ignored, as the capacity did not change.</p><p>If you know in advance that you’re going to be constructing a large string by doing lots of string operations that will add to the size of the string, you can avoid having the string reallocated multiple times by reserving enough capacity from the outset:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <string></string></code><code>#include <cstdlib> // for rand() and srand()</cstdlib></code><code>#include <ctime> // for time()</ctime></code><code></code><code>int main()</code><code>{</code><code>    std::srand(std::time(nullptr)); // seed random number generator</code><code></code><code>    std::string s{}; // length 0</code><code>    s.reserve(64); // reserve 64 characters</code><code></code><code>    // Fill string up with random lower case characters</code><code>    for (int count{ 0 }; count &lt; 64; ++count)</code><code>        s += 'a' + std::rand() % 26;</code><code></code><code>    std::cout &lt;&lt; s;</code><code>}</code></pre><p>The result of this program will change each time, but here’s the output from one execution:</p><pre>wzpzujwuaokbakgijqdawvzjqlgcipiiuuxhyfkdppxpyycvytvyxwqsbtielxpy
</pre><p>Rather than having to reallocate s multiple times, we set the capacity once and then fill the string up. This can make a huge difference in performance when constructing large strings via concatenation.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">22.4 — std::string character access and conversion to C-style arrays</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>Character access</strong></p><p>There are two almost identical ways to access characters in a string. The easier to use and faster version is the overloaded operator[]:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>char&amp; string::operator[] (size_type nIndex)</b><br><b>const char&amp; string::operator[] (size_type nIndex) const</b><ul><li>Both of these functions return the character with index nIndex</li><li>Passing an invalid index results in undefined behavior</li><li>Because char&amp; is the return type, you can use this to edit characters in the array</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string sSource{ "abcdefg" };</code><code>std::cout &lt;&lt; sSource[5] &lt;&lt; '\n';</code><code>sSource[5] = 'X';</code><code>std::cout &lt;&lt; sSource &lt;&lt; '\n';</code></pre><p>Output:</p><pre>f
abcdeXg
</pre></td></tr></tbody></table></div><p>There is also a non-operator version. This version is slower since it uses exceptions to check if the nIndex is valid. If you are not sure whether nIndex is valid, you should use this version to access the array:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>char&amp; string::at (size_type nIndex)</b><br><b>const char&amp; string::at (size_type nIndex) const</b><ul><li>Both of these functions return the character with index nIndex</li><li>Passing an invalid index results in an out_of_range exception</li><li>Because char&amp; is the return type, you can use this to edit characters in the array</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string sSource{ "abcdefg" };</code><code>std::cout &lt;&lt; sSource.at(5) &lt;&lt; '\n';</code><code>sSource.at(5) = 'X';</code><code>std::cout &lt;&lt; sSource &lt;&lt; '\n';</code></pre><p>Output:</p><pre>f
abcdeXg
</pre></td></tr></tbody></table></div><p><strong>Conversion to C-style arrays</strong></p><p>Many functions (including all C functions) expect strings to be formatted as C-style strings rather than std::string. For this reason, std::string provides 3 different ways to convert std::string to C-style strings.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>const char* string::c_str () const</b><ul><li>Returns the contents of the string as a const C-style string</li><li>A null terminator is appended</li><li>The C-style string is owned by the std::string and should not be deleted</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>#include <cstring></cstring></code><code></code><code>std::string sSource{ "abcdefg" };</code><code>std::cout &lt;&lt; std::strlen(sSource.c_str());</code></pre><p>Output:</p><pre>7
</pre></td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>const char* string::data () const</b><ul><li>Returns the contents of the string as a const C-style string</li><li>A null terminator is appended. This function performs the same action as <code>c_str()</code></li><li>The C-style string is owned by the std::string and should not be deleted</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>#include <cstring></cstring></code><code></code><code>std::string sSource{ "abcdefg" };</code><code>const char* szString{ "abcdefg" };</code><code>// memcmp compares the first n characters of two C-style strings and returns 0 if they are equal</code><code>if (std::memcmp(sSource.data(), szString, sSource.length()) == 0)</code><code>    std::cout &lt;&lt; "The strings are equal";</code><code>else</code><code>    std::cout &lt;&lt; "The strings are not equal";</code></pre><p>Output:</p><pre>The strings are equal
</pre></td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>size_type string::copy(char* szBuf, size_type nLength, size_type nIndex = 0) const</b><ul><li>Both flavors copy at most nLength characters of the string to szBuf, beginning with character nIndex</li><li>The number of characters copied is returned</li><li>No null is appended. It is up to the caller to ensure szBuf is initialized to NULL or terminate the string using the returned length</li><li>The caller is responsible for not overflowing szBuf</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string sSource{ "sphinx of black quartz, judge my vow" };</code><code></code><code>char szBuf[20];</code><code>int nLength{ static_cast<int>(sSource.copy(szBuf, 5, 10)) };</int></code><code>szBuf[nLength] = '\0';  // Make sure we terminate the string in the buffer</code><code></code><code>std::cout &lt;&lt; szBuf &lt;&lt; '\n';</code></pre><p>Output:</p><pre>black
</pre></td></tr></tbody></table></div><p>This function should be avoided where possible as it is relatively dangerous (as it is up to the caller to provide null-termination and avoid buffer overflows).</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">22.5 — std::string assignment and swapping</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>String assignment</strong></p><p>The easiest way to assign a value to a string is to use the overloaded operator= function. There is also an assign() member function that duplicates some of this functionality.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string&amp; string::operator= (const string&amp; str)</b><br><b>string&amp; string::assign (const string&amp; str)</b><br><b>string&amp; string::operator= (const char* str)</b><br><b>string&amp; string::assign (const char* str)</b><br><b>string&amp; string::operator= (char c)</b><br><ul><li>These functions assign values of various types to the string.</li><li>These functions return *this so they can be “chained”.</li><li>Note that there is no assign() function that takes a single char.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string sString;</code><code></code><code>// Assign a string value</code><code>sString = std::string("One");</code><code>std::cout &lt;&lt; sString &lt;&lt; '\n';</code><code></code><code>const std::string sTwo("Two");</code><code>sString.assign(sTwo);</code><code>std::cout &lt;&lt; sString &lt;&lt; '\n';</code><code></code><code>// Assign a C-style string</code><code>sString = "Three";</code><code>std::cout &lt;&lt; sString &lt;&lt; '\n';</code><code></code><code>sString.assign("Four");</code><code>std::cout &lt;&lt; sString &lt;&lt; '\n';</code><code></code><code>// Assign a char</code><code>sString = '5';</code><code>std::cout &lt;&lt; sString &lt;&lt; '\n';</code><code></code><code>// Chain assignment</code><code>std::string sOther;</code><code>sString = sOther = "Six";</code><code>std::cout &lt;&lt; sString &lt;&lt; ' ' &lt;&lt; sOther &lt;&lt; '\n';</code></pre><p>Output:</p><pre>One
Two
Three
Four
5
Six Six
</pre></td></tr></tbody></table></div><p>The assign() member function also comes in a few other flavors:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string&amp; string::assign (const string&amp; str, size_type index, size_type len)</b><ul><li>Assigns a substring of str, starting from index, and of length len</li><li>Throws an out_of_range exception if the index is out of bounds</li><li>Returns *this so it can be “chained”.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>const std::string sSource("abcdefg");</code><code>std::string sDest;</code><code></code><code>sDest.assign(sSource, 2, 4); // assign a substring of source from index 2 of length 4</code><code>std::cout &lt;&lt; sDest &lt;&lt; '\n';</code></pre><p>Output:</p><pre>cdef
</pre></td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string&amp; string::assign (const char* chars, size_type len)</b><ul><li>Assigns len characters from the C-style array chars</li><li>Throws an length_error exception if the result exceeds the maximum number of characters</li><li>Returns *this so it can be “chained”.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string sDest;</code><code></code><code>sDest.assign("abcdefg", 4);</code><code>std::cout &lt;&lt; sDest &lt;&lt; '\n';</code></pre><p>Output:</p><pre>abcd
</pre><p>This function is potentially dangerous and its use is not recommended.</p></td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string&amp; string::assign (size_type len, char c)</b><ul><li>Assigns len occurrences of the character c</li><li>Throws a length_error exception if the result exceeds the maximum number of characters</li><li>Returns *this so it can be “chained”.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string sDest;</code><code></code><code>sDest.assign(4, 'g');</code><code>std::cout &lt;&lt; sDest &lt;&lt; '\n';</code></pre><p>Output:</p><pre>gggg
</pre></td></tr></tbody></table></div><p><strong>Swapping</strong></p><p>If you have two strings and want to swap their values, there are two functions both named swap() that you can use.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>void string::swap (string&amp; str)</b><br><b>void swap (string&amp; str1, string&amp; str2)</b><ul><li>Both functions swap the value of the two strings. The member function swaps *this and str, the global function swaps str1 and str2.</li><li>These functions are efficient and should be used instead of assignments to perform a string swap.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string sStr1("red");</code><code>std::string sStr2("blue");</code><code></code><code>std::cout &lt;&lt; sStr1 &lt;&lt; ' ' &lt;&lt; sStr2 &lt;&lt; '\n';</code><code>swap(sStr1, sStr2);</code><code>std::cout &lt;&lt; sStr1 &lt;&lt; ' ' &lt;&lt; sStr2 &lt;&lt; '\n';</code><code>sStr1.swap(sStr2);</code><code>std::cout &lt;&lt; sStr1 &lt;&lt; ' ' &lt;&lt; sStr2 &lt;&lt; '\n';</code></pre><p>Output:</p><pre>red blue
blue red
red blue
</pre></td></tr></tbody></table></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">22.6 — std::string appending</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>Appending</strong></p><p>Appending strings to the end of an existing string is easy using either operator+=, append(), or push_back().</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string&amp; string::operator+= (const string&amp; str)</b><br><b>string&amp; string::append (const string&amp; str)</b><br><ul><li>Both functions append the characters of str to the string.</li><li>Both functions return *this so they can be “chained”.</li><li>Both functions throw a length_error exception if the result exceeds the maximum number of characters.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string sString{"one"};</code><code></code><code>sString += std::string{" two"};</code><code></code><code>std::string sThree{" three"};</code><code>sString.append(sThree);</code><code></code><code>std::cout &lt;&lt; sString &lt;&lt; '\n';</code></pre><p>Output:</p><pre>one two three
</pre></td></tr></tbody></table></div><p>There’s also a flavor of append() that can append a substring:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string&amp; string::append (const string&amp; str, size_type index, size_type num)</b><ul><li>This function appends num characters from str, starting at index, to the string.</li><li>Returns *this so it can be “chained”.</li><li>Throws an out_of_range if index is out of bounds</li><li>Throws a length_error exception if the result exceeds the maximum number of characters.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string sString{"one "};</code><code></code><code>const std::string sTemp{"twothreefour"};</code><code>sString.append(sTemp, 3, 5); // append substring of sTemp starting at index 3 of length 5</code><code>std::cout &lt;&lt; sString &lt;&lt; '\n';</code></pre><p>Output:</p><pre>one three
</pre></td></tr></tbody></table></div><p>Operator+= and append() also have versions that work on C-style strings:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string&amp; string::operator+= (const char* str)</b><br><b>string&amp; string::append (const char* str)</b><br><ul><li>Both functions append the characters of str to the string.</li><li>Both functions return *this so they can be “chained”.</li><li>Both functions throw a length_error exception if the result exceeds the maximum number of characters.</li><li>str should not be NULL.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string sString{"one"};</code><code></code><code>sString += " two";</code><code>sString.append(" three");</code><code>std::cout &lt;&lt; sString &lt;&lt; '\n';</code></pre><p>Output:</p><pre>one two three
</pre></td></tr></tbody></table></div><p>There is an additional flavor of append() that works on C-style strings:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string&amp; string::append (const char* str, size_type len)</b><br><ul><li>Appends the first len characters of str to the string.</li><li>Returns *this so they can be “chained”.</li><li>Throw a length_error exception if the result exceeds the maximum number of characters.</li><li>Ignores special characters (including ”)</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string sString{"one "};</code><code></code><code>sString.append("threefour", 5);</code><code>std::cout &lt;&lt; sString &lt;&lt; '\n';</code></pre><p>Output:</p><pre>one three
</pre><p>This function is dangerous and its use is not recommended.</p></td></tr></tbody></table></div><p>There is also a set of functions that append characters. Note that the name of the non-operator function to append a character is push_back(), not append()!</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string&amp; string::operator+= (char c)</b><br><b>void string::push_back (char c)</b><br><ul><li>Both functions append the character c to the string.</li><li>Operator += returns *this so it can be “chained”.</li><li>Both functions throw a length_error exception if the result exceeds the maximum number of characters.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string sString{"one"};</code><code></code><code>sString += ' ';</code><code>sString.push_back('2');</code><code>std::cout &lt;&lt; sString &lt;&lt; '\n';</code></pre><p>Output:</p><pre>one 2
</pre></td></tr></tbody></table></div><p>Now you might be wondering why the name of the function is push_back() and not append(). This follows a naming convention used for stacks, where push_back() is the function that adds a single item to the end of the stack. If you envision a string as a stack of characters, using push_back() to add a single character to the end makes sense. However, the lack of an append() function is inconsistent in my view!</p><p>It turns out there is an append() function for characters, that looks like this:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string&amp; string::append (size_type num, char c)</b><br><ul><li>Adds num occurrences of the character c to the string</li><li>Returns *this so it can be “chained”.</li><li>Throws a length_error exception if the result exceeds the maximum number of characters.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>std::string sString{"aaa"};</code><code></code><code>sString.append(4, 'b');</code><code>std::cout &lt;&lt; sString &lt;&lt; '\n';</code></pre><p>Output:</p><pre>aaabbbb
</pre></td></tr></tbody></table></div><p>There’s one final flavor of append() that works with iterators:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string&amp; string::append (InputIterator start, InputIterator end)</b><br><ul><li>Appends all characters from the range [start, end) (including start up to but not including end)</li><li>Returns *this so it can be “chained”.</li><li>Throws a length_error exception if the result exceeds the maximum number of characters.</li></ul></td></tr></tbody></table></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">22.7 — std::string inserting</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>Inserting</strong></p><p>Inserting characters into an existing string can be done via the insert() function.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string&amp; string::insert (size_type index, const string&amp; str)</b><br><b>string&amp; string::insert (size_type index, const char* str)</b><ul><li>Both functions insert the characters of str into the string at index</li><li>Both function return *this so they can be “chained”.</li><li>Both functions throw out_of_range if index is invalid</li><li>Both functions throw a length_error exception if the result exceeds the maximum number of characters.</li><li>In the C-style string version, str must not be NULL.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>string sString("aaaa");</code><code>cout &lt;&lt; sString &lt;&lt; endl;</code><code></code><code>sString.insert(2, string("bbbb"));</code><code>cout &lt;&lt; sString &lt;&lt; endl;</code><code></code><code>sString.insert(4, "cccc");</code><code>cout &lt;&lt; sString &lt;&lt; endl;</code></pre><p>Output:</p><pre>aaaa
aabbbbaa
aabbccccbbaa
</pre></td></tr></tbody></table></div><p>Here’s a crazy version of insert() that allows you to insert a substring into a string at an arbitrary index:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string&amp; string::insert (size_type index, const string&amp; str, size_type startindex, size_type num)</b><ul><li>This function inserts num characters str, starting from startindex, into the string at index.</li><li>Returns *this so it can be “chained”.</li><li>Throws an out_of_range if index or startindex is out of bounds</li><li>Throws a length_error exception if the result exceeds the maximum number of characters.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>string sString("aaaa");</code><code></code><code>const string sInsert("01234567");</code><code>sString.insert(2, sInsert, 3, 4); // insert substring of sInsert from index [3,7) into sString at index 2</code><code>cout &lt;&lt; sString &lt;&lt; endl;</code></pre><p>Output:</p><pre>aa3456aa
</pre></td></tr></tbody></table></div><p>There is a flavor of insert() that inserts the first portion of a C-style string:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string&amp; string::insert(size_type index, const char* str, size_type len)</b><ul><li>Inserts len characters of str into the string at index</li><li>Returns *this so it can be “chained”.</li><li>Throws an out_of_range exception if the index is invalid</li><li>Throws a length_error exception if the result exceeds the maximum number of characters.</li><li>Ignores special characters (such as ”)</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>string sString("aaaa");</code><code></code><code>sString.insert(2, "bcdef", 3);</code><code>cout &lt;&lt; sString &lt;&lt; endl;</code></pre><p>Output:</p><pre>aabcdaa
</pre></td></tr></tbody></table></div><p>There’s also a flavor of insert() that inserts the same character multiple times:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>string&amp; string::insert(size_type index, size_type num, char c)</b><ul><li>Inserts num instances of char c into the string at index</li><li>Returns *this so it can be “chained”.</li><li>Throws an out_of_range exception if the index is invalid</li><li>Throws a length_error exception if the result exceeds the maximum number of characters.</li></ul><p>Sample code:</p><pre class="language-cpp line-numbers"><code>string sString("aaaa");</code><code></code><code>sString.insert(2, 4, 'c');</code><code>cout &lt;&lt; sString &lt;&lt; endl;</code></pre><p>Output:</p><pre>aaccccaa
</pre></td></tr></tbody></table></div><p>And finally, the insert() function also has three different versions that use iterators:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><td><b>void insert(iterator it, size_type num, char c)</b><br><b>iterator string::insert(iterator it, char c)</b><br><b>void string::insert(iterator it, InputIterator begin, InputIterator end)</b><ul><li>The first function inserts num instances of the character c before the iterator it.</li><li>The second inserts a single character c before the iterator it, and returns an iterator to the position of the character inserted.</li><li>The third inserts all characters between [begin,end) before the iterator it.</li><li>All functions throw a length_error exception if the result exceeds the maximum number of characters.</li></ul></td></tr></tbody></table></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">23.1 — Input and output (I/O) streams</h1></header><div class="entry-content" itemprop="articleBody"><p>Input and output functionality is not defined as part of the core C++ language, but rather is provided through the C++ standard library (and thus resides in the std namespace). In previous lessons, you included the iostream library header and made use of the cin and cout objects to do simple I/O. In this lesson, we’ll take a look at the iostream library in more detail.</p><p><strong>The iostream library</strong></p><p>When you include the iostream header, you gain access to a whole hierarchy of classes responsible for providing I/O functionality (including one class that is actually named iostream). You can find a class hierarchy diagram for the non-file-I/O classes <a href="https://en.cppreference.com/w/cpp/io">here</a>.</p><p>The first thing you may notice about this hierarchy is that it uses multiple inheritance (that thing we told you to avoid if at all possible). However, the iostream library has been designed and extensively tested in order to avoid any of the typical multiple inheritance problems, so you can use it freely without worrying.</p><p><strong>Streams</strong></p><p>The second thing you may notice is that the word “stream” is used an awful lot. At its most basic, I/O in C++ is implemented with streams. Abstractly, a <strong>stream</strong> is just a sequence of bytes that can be accessed sequentially. Over time, a stream may produce or consume potentially unlimited amounts of data.</p><p>Typically we deal with two different types of streams. <strong>Input streams</strong> are used to hold input from a data producer, such as a keyboard, a file, or a network. For example, the user may press a key on the keyboard while the program is currently not expecting any input. Rather than ignore the users keypress, the data is put into an input stream, where it will wait until the program is ready for it.</p><p>Conversely, <strong>output streams</strong> are used to hold output for a particular data consumer, such as a monitor, a file, or a printer. When writing data to an output device, the device may not be ready to accept that data yet -- for example, the printer may still be warming up when the program writes data to its output stream. The data will sit in the output stream until the printer begins consuming it.</p><p>Some devices, such as files and networks, are capable of being both input and output sources.</p><p>The nice thing about streams is the programmer only has to learn how to interact with the streams in order to read and write data to many different kinds of devices. The details about how the stream interfaces with the actual devices they are hooked up to is left up to the environment or operating system.</p><p><strong>Input/output in C++</strong></p><p>Although the ios class is generally derived from ios_base, ios is typically the most base class you will be working directly with. The ios class defines a bunch of stuff that is common to both input and output streams. We’ll deal with this stuff in a future lesson.</p><p>The <strong>istream</strong> class is the primary class used when dealing with input streams. With input streams, the <strong>extraction operator (&gt;&gt;)</strong> is used to remove values from the stream. This makes sense: when the user presses a key on the keyboard, the key code is placed in an input stream. Your program then extracts the value from the stream so it can be used.</p><p>The <strong>ostream</strong> class is the primary class used when dealing with output streams. With output streams, the <strong>insertion operator (&lt;&lt;)</strong> is used to put values in the stream. This also makes sense: you insert your values into the stream, and the data consumer (e.g. monitor) uses them.</p><p>The <strong>iostream</strong> class can handle both input and output, allowing bidirectional I/O.</p><p><strong>Standard streams in C++</strong></p><p>A <strong>standard stream</strong> is a pre-connected stream provided to a computer program by its environment. C++ comes with four predefined standard stream objects that have already been set up for your use. The first three, you have seen before:</p><ol><li><b>cin</b> -- an istream class tied to the standard input (typically the keyboard)</li><li><b>cout</b> -- an ostream class tied to the standard output (typically the monitor)</li><li><b>cerr</b> -- an ostream class tied to the standard error (typically the monitor), providing unbuffered output</li><li><b>clog</b> -- an ostream class tied to the standard error (typically the monitor), providing buffered output</li></ol><p>Unbuffered output is typically handled immediately, whereas buffered output is typically stored and written out as a block. Because clog isn’t used very often, it is often omitted from the list of standard streams.</p><p>In the next lesson, we’ll take a look at some more I/O related functionality in more detail.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">23.2 — Input with istream</h1></header><div class="entry-content" itemprop="articleBody"><p>The iostream library is fairly complex -- so we will not be able to cover it in its entirety in these tutorials. However, we will show you the most commonly used functionality. In this section, we will look at various aspects of the input class (istream).</p><p><strong>The extraction operator</strong></p><p>As seen in many lessons now, we can use the extraction operator (&gt;&gt;) to read information from an input stream. C++ has predefined extraction operations for all of the built-in data types, and you’ve already seen how you can <a href="https://www.learncpp.com/cpp-tutorial/93-overloading-the-io-operators/">overload the extraction operator</a> for your own classes.</p><p>When reading strings, one common problem with the extraction operator is how to keep the input from overflowing your buffer. Given the following example:</p><pre class="language-cpp line-numbers"><code>char buf[10];</code><code>std::cin &gt;&gt; buf;</code></pre><p>what happens if the user enters 18 characters? The buffer overflows, and bad stuff happens. Generally speaking, it’s a bad idea to make any assumption about how many characters your user will enter.</p><p>One way to handle this problem is through use of manipulators. A <strong>manipulator</strong> is an object that is used to modify a stream when applied with the extraction (&gt;&gt;) or insertion (setw (in the iomanip header) that can be used to limit the number of characters read in from a stream. To use setw(), simply provide the maximum number of characters to read as a parameter, and insert it into your input statement like such:</p><pre class="language-cpp line-numbers"><code>#include <iomanip></iomanip></code><code>char buf[10];</code><code>std::cin &gt;&gt; std::setw(10) &gt;&gt; buf;</code></pre><p>This program will now only read the first 9 characters out of the stream (leaving room for a terminator). Any remaining characters will be left in the stream until the next extraction.</p><p><strong>Extraction and whitespace</strong></p><p>As a reminder, the extraction operator skips whitespace (blanks, tabs, and newlines).</p><p>Take a look at the following program:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    char ch;</code><code>    while (std::cin &gt;&gt; ch)</code><code>        std::cout &lt;&lt; ch;</code><code></code><code>    return 0;</code><code>}</code></pre><p>When the user inputs the following:</p><pre>Hello my name is Alex
</pre><p>The extraction operator skips the spaces and the newline. Consequently, the output is:</p><pre>HellomynameisAlex
</pre><p>Oftentimes, you’ll want to get user input but not discard whitespace. To do this, the istream class provides many functions that can be used for this purpose.</p><p>One of the most useful is the <strong>get()</strong> function, which simply gets a character from the input stream. Here’s the same program as above using get():</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    char ch;</code><code>    while (std::cin.get(ch))</code><code>        std::cout &lt;&lt; ch;</code><code></code><code>    return 0;</code><code>}</code></pre><p>Now when we use the input:</p><pre>Hello my name is Alex
</pre><p>The output is:</p><pre>Hello my name is Alex
</pre><p>std::get() also has a string version that takes a maximum number of characters to read:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    char strBuf[11];</code><code>    std::cin.get(strBuf, 11);</code><code>    std::cout &lt;&lt; strBuf &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>If we input:</p><pre>Hello my name is Alex
</pre><p>The output is:</p><pre>Hello my n
</pre><p>Note that we only read the first 10 characters (we had to leave one character for a terminator). The remaining characters were left in the input stream.</p><p>One important thing to note about get() is that it does not read in a newline character! This can cause some unexpected results:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    char strBuf[11];</code><code>    // Read up to 10 characters</code><code>    std::cin.get(strBuf, 11);</code><code>    std::cout &lt;&lt; strBuf &lt;&lt; '\n';</code><code></code><code>    // Read up to 10 more characters</code><code>    std::cin.get(strBuf, 11);</code><code>    std::cout &lt;&lt; strBuf &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>If the user enters:</p><pre>Hello!
</pre><p>The program will print:</p><pre>Hello!
</pre><p>and then terminate! Why didn’t it ask for 10 more characters? The answer is because the first get() read up to the newline and then stopped. The second get() saw there was still input in the cin stream and tried to read it. But the first character was the newline, so it stopped immediately.</p><p>Consequently, there is another function called <strong>getline()</strong> that works exactly like get() but reads the newline as well.</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    char strBuf[11];</code><code>    // Read up to 10 characters</code><code>    std::cin.getline(strBuf, 11);</code><code>    std::cout &lt;&lt; strBuf &lt;&lt; '\n';</code><code></code><code>    // Read up to 10 more characters</code><code>    std::cin.getline(strBuf, 11);</code><code>    std::cout &lt;&lt; strBuf &lt;&lt; '\n';</code><code>    return 0;</code><code>}</code></pre><p>This code will perform as you expect, even if the user enters a string with a newline in it.</p><p>If you need to know how many character were extracted by the last call of getline(), use <strong>gcount()</strong>:</p><pre class="language-cpp line-numbers"><code>int main()</code><code>{</code><code>    char strBuf[100];</code><code>    std::cin.getline(strBuf, 100);</code><code>    std::cout &lt;&lt; strBuf &lt;&lt; '\n';</code><code>    std::cout &lt;&lt; std::cin.gcount() &lt;&lt; " characters were read" &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><strong>A special version of getline() for std::string</strong></p><p>There is a special version of getline() that lives outside the istream class that is used for reading in variables of type std::string. This special version is not a member of either ostream or istream, and is included in the string header. Here is an example of its use:</p><pre class="language-cpp line-numbers"><code>#include <string></string></code><code>#include <iostream></iostream></code><code></code><code>int main()</code><code>{</code><code>    std::string strBuf;</code><code>    std::getline(std::cin, strBuf);</code><code>    std::cout &lt;&lt; strBuf &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p><strong>A few more useful istream functions</strong></p><p>There are a few more useful input functions that you might want to make use of:</p><p><strong>ignore()</strong> discards the first character in the stream.<br><strong>ignore(int nCount)</strong> discards the first nCount characters.<br><strong>peek()</strong> allows you to read a character from the stream without removing it from the stream.<br><strong>unget()</strong> returns the last character read back into the stream so it can be read again by the next call.<br><strong>putback(char ch)</strong> allows you to put a character of your choice back into the stream to be read by the next call.</p><p>istream contains many other functions and variants of the above mentioned functions that may be useful, depending on what you need to do. However, those topics are really more suited for a tutorial or book focusing on the standard library (such as the excellent <a href="https://www.amazon.com/Standard-Library-Tutorial-Reference-2nd/dp/0321623215">“The C++ Standard Library”</a> by Nicolai M. Josuttis).</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">23.3 — Output with ostream and ios</h1></header><div class="entry-content" itemprop="articleBody"><p>In this section, we will look at various aspects of the iostream output class (ostream).</p><p><strong>The insertion operator</strong></p><p>The insertion operator (&lt;&lt;) is used to put information into an output stream. C++ has predefined insertion operations for all of the built-in data types, and you’ve already seen how you can <a href="https://www.learncpp.com/cpp-tutorial/93-overloading-the-io-operators/">overload the insertion operator</a> for your own classes.</p><p>In the lesson on <a href="https://www.learncpp.com/cpp-tutorial/131-input-and-output-io-streams/">streams</a>, you saw that both istream and ostream were derived from a class called ios. One of the jobs of ios (and ios_base) is to control the formatting options for output.</p><p><strong>Formatting</strong></p><p>There are two ways to change the formatting options: flags, and manipulators. You can think of <strong>flags</strong> as boolean variables that can be turned on and off. <strong>Manipulators</strong> are objects placed in a stream that affect the way things are input and output.</p><p>To switch a flag on, use the <strong>setf()</strong> function, with the appropriate flag as a parameter. For example, by default, C++ does not print a + sign in front of positive numbers. However, by using the std::ios::showpos flag, we can change this behavior:</p><pre class="language-cpp line-numbers"><code>std::cout.setf(std::ios::showpos); // turn on the std::ios::showpos flag</code><code>std::cout &lt;&lt; 27 &lt;&lt; '\n';</code></pre><p>This results in the following output:</p><pre>+27
</pre><p>It is possible to turn on multiple ios flags at once using the Bitwise OR (|) operator:</p><pre class="language-cpp line-numbers"><code>std::cout.setf(std::ios::showpos | std::ios::uppercase); // turn on the std::ios::showpos and std::ios::uppercase flag</code><code>std::cout &lt;&lt; 1234567.89f &lt;&lt; '\n';</code></pre><p>This outputs:</p><pre>+1.23457E+06
</pre><p>To turn a flag off, use the <strong>unsetf()</strong> function:</p><pre class="language-cpp line-numbers"><code>std::cout.setf(std::ios::showpos); // turn on the std::ios::showpos flag</code><code>std::cout &lt;&lt; 27 &lt;&lt; '\n';</code><code>std::cout.unsetf(std::ios::showpos); // turn off the std::ios::showpos flag</code><code>std::cout &lt;&lt; 28 &lt;&lt; '\n';</code></pre><p>This results in the following output:</p><pre>+27
28
</pre><p>There’s one other bit of trickiness when using setf() that needs to be mentioned. Many flags belong to groups, called format groups. A <strong>format group</strong> is a group of flags that perform similar (sometimes mutually exclusive) formatting options. For example, a format group named “basefield” contains the flags “oct”, “dec”, and “hex”, which controls the base of integral values. By default, the “dec” flag is set. Consequently, if we do this:</p><pre class="language-cpp line-numbers"><code>std::cout.setf(std::ios::hex); // try to turn on hex output</code><code>std::cout &lt;&lt; 27 &lt;&lt; '\n';</code></pre><p>We get the following output:</p><pre>27
</pre><p>It didn’t work! The reason why is because setf() only turns flags on -- it isn’t smart enough to turn mutually exclusive flags off. Consequently, when we turned std::hex on, std::ios::dec was still on, and std::ios::dec apparently takes precedence. There are two ways to get around this problem.</p><p>First, we can turn off std::ios::dec so that only std::hex is set:</p><pre class="language-cpp line-numbers"><code>std::cout.unsetf(std::ios::dec); // turn off decimal output</code><code>std::cout.setf(std::ios::hex); // turn on hexadecimal output</code><code>std::cout &lt;&lt; 27 &lt;&lt; '\n';</code></pre><p>Now we get output as expected:</p><pre>1b
</pre><p>The second way is to use a different form of setf() that takes two parameters: the first parameter is the flag to set, and the second is the formatting group it belongs to. When using this form of setf(), all of the flags belonging to the group are turned off, and only the flag passed in is turned on. For example:</p><pre class="language-cpp line-numbers"><code>// Turn on std::ios::hex as the only std::ios::basefield flag</code><code>std::cout.setf(std::ios::hex, std::ios::basefield);</code><code>std::cout &lt;&lt; 27 &lt;&lt; '\n';</code></pre><p>This also produces the expected output:</p><pre>1b
</pre><p>Using setf() and unsetf() tends to be awkward, so C++ provides a second way to change the formatting options: manipulators. The nice thing about manipulators is that they are smart enough to turn on and off the appropriate flags. Here is an example of using some manipulators to change the base:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; std::hex &lt;&lt; 27 &lt;&lt; '\n'; // print 27 in hex</code><code>std::cout &lt;&lt; 28 &lt;&lt; '\n'; // we're still in hex</code><code>std::cout &lt;&lt; std::dec &lt;&lt; 29 &lt;&lt; '\n'; // back to decimal</code></pre><p>This program produces the output:</p><pre>1b
1c
29
</pre><p>In general, using manipulators is much easier than setting and unsetting flags. Many options are available via both flags and manipulators (such as changing the base), however, other options are only available via flags or via manipulators, so it’s important to know how to use both.</p><p><strong>Useful formatters</strong></p><p>Here is a list of some of the more useful flags, manipulators, and member functions. Flags live in the std::ios class, manipulators live in the std namespace, and the member functions live in the std::ostream class.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Group</th><th>Flag</th><th>Meaning</th></tr><tr><td></td><td>std::ios::boolalpha</td><td>If set, booleans print “true” or “false”. If not set, booleans print 0 or 1</td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Manipulator</th><th>Meaning</th></tr><tr><td>std::boolalpha</td><td>Booleans print “true” or “false”</td></tr><tr><td>std::noboolalpha</td><td>Booleans print 0 or 1 (default)</td></tr></tbody></table></div><p>Example:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; true &lt;&lt; ' ' &lt;&lt; false &lt;&lt; '\n';</code><code></code><code>std::cout.setf(std::ios::boolalpha);</code><code>std::cout &lt;&lt; true &lt;&lt; ' ' &lt;&lt; false &lt;&lt; '\n';</code><code></code><code>std::cout &lt;&lt; std::noboolalpha &lt;&lt; true &lt;&lt; ' ' &lt;&lt; false &lt;&lt; '\n';</code><code></code><code>std::cout &lt;&lt; std::boolalpha &lt;&lt; true &lt;&lt; ' ' &lt;&lt; false &lt;&lt; '\n';</code></pre><p>Result:</p><pre>1 0
true false
1 0
true false
</pre><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Group</th><th>Flag</th><th>Meaning</th></tr><tr><td></td><td>std::ios::showpos</td><td>If set, prefix positive numbers with a +</td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Manipulator</th><th>Meaning</th></tr><tr><td>std::showpos</td><td>Prefixes positive numbers with a +</td></tr><tr><td>std::noshowpos</td><td>Doesn’t prefix positive numbers with a +</td></tr></tbody></table></div><p>Example:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; 5 &lt;&lt; '\n';</code><code></code><code>std::cout.setf(std::ios::showpos);</code><code>std::cout &lt;&lt; 5 &lt;&lt; '\n';</code><code></code><code>std::cout &lt;&lt; std::noshowpos &lt;&lt; 5 &lt;&lt; '\n';</code><code></code><code>std::cout &lt;&lt; std::showpos &lt;&lt; 5 &lt;&lt; '\n';</code></pre><p>Result:</p><pre>5
+5
5
+5
</pre><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Group</th><th>Flag</th><th>Meaning</th></tr><tr><td></td><td>std::ios::uppercase</td><td>If set, uses upper case letters</td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Manipulator</th><th>Meaning</th></tr><tr><td>std::uppercase</td><td>Uses upper case letters</td></tr><tr><td>std::nouppercase</td><td>Uses lower case letters</td></tr></tbody></table></div><p>Example:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; 12345678.9 &lt;&lt; '\n';</code><code></code><code>std::cout.setf(std::ios::uppercase);</code><code>std::cout &lt;&lt; 12345678.9 &lt;&lt; '\n';</code><code></code><code>std::cout &lt;&lt; std::nouppercase &lt;&lt; 12345678.9 &lt;&lt; '\n';</code><code></code><code>std::cout &lt;&lt; std::uppercase &lt;&lt; 12345678.9 &lt;&lt; '\n';</code></pre><p>Result:</p><pre>1.23457e+007
1.23457E+007
1.23457e+007
1.23457E+007
</pre><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Group</th><th>Flag</th><th>Meaning</th></tr><tr><td>std::ios::basefield</td><td>std::ios::dec</td><td>Prints values in decimal (default)</td></tr><tr><td>std::ios::basefield</td><td>std::ios::hex</td><td>Prints values in hexadecimal</td></tr><tr><td>std::ios::basefield</td><td>std::ios::oct</td><td>Prints values in octal</td></tr><tr><td>std::ios::basefield</td><td>(none)</td><td>Prints values according to leading characters of value</td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Manipulator</th><th>Meaning</th></tr><tr><td>std::dec</td><td>Prints values in decimal</td></tr><tr><td>std::hex</td><td>Prints values in hexadecimal</td></tr><tr><td>std::oct</td><td>Prints values in octal</td></tr></tbody></table></div><p>Example:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; 27 &lt;&lt; '\n';</code><code></code><code>std::cout.setf(std::ios::dec, std::ios::basefield);</code><code>std::cout &lt;&lt; 27 &lt;&lt; '\n';</code><code></code><code>std::cout.setf(std::ios::oct, std::ios::basefield);</code><code>std::cout &lt;&lt; 27 &lt;&lt; '\n';</code><code></code><code>std::cout.setf(std::ios::hex, std::ios::basefield);</code><code>std::cout &lt;&lt; 27 &lt;&lt; '\n';</code><code></code><code>std::cout &lt;&lt; std::dec &lt;&lt; 27 &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::oct &lt;&lt; 27 &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::hex &lt;&lt; 27 &lt;&lt; '\n';</code></pre><p>Result:</p><pre>27
27
33
1b
27
33
1b
</pre><p>By now, you should be able to see the relationship between setting formatting via flag and via manipulators. In future examples, we will use manipulators unless they are not available.</p><p><strong>Precision, notation, and decimal points</strong></p><p>Using manipulators (or flags), it is possible to change the precision and format with which floating point numbers are displayed. There are several formatting options that combine in somewhat complex ways, so we will take a closer look at this.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Group</th><th>Flag</th><th>Meaning</th></tr><tr><td>std::ios::floatfield</td><td>std::ios::fixed</td><td>Uses decimal notation for floating-point numbers</td></tr><tr><td>std::ios::floatfield</td><td>std::ios::scientific</td><td>Uses scientific notation for floating-point numbers</td></tr><tr><td>std::ios::floatfield</td><td>(none)</td><td>Uses fixed for numbers with few digits, scientific otherwise</td></tr><tr><td>std::ios::floatfield</td><td>std::ios::showpoint</td><td>Always show a decimal point and trailing 0’s for floating-point values</td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Manipulator</th><th>Meaning</th></tr><tr><td>std::fixed</td><td>Use decimal notation for values</td></tr><tr><td>std::scientific</td><td>Use scientific notation for values</td></tr><tr><td>std::showpoint</td><td>Show a decimal point and trailing 0’s for floating-point values</td></tr><tr><td>std::noshowpoint</td><td>Don’t show a decimal point and trailing 0’s for floating-point values</td></tr><tr><td>std::setprecision(int)</td><td>Sets the precision of floating-point numbers (defined in the iomanip header)</td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Member function</th><th>Meaning</th></tr><tr><td>std::ios_base::precision()</td><td>Returns the current precision of floating-point numbers</td></tr><tr><td>std::ios_base::precision(int)</td><td>Sets the precision of floating-point numbers and returns old precision</td></tr></tbody></table></div><p>If fixed or scientific notation is used, precision determines how many decimal places in the fraction is displayed. Note that if the precision is less than the number of significant digits, the number will be rounded.</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; std::fixed &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::setprecision(3) &lt;&lt; 123.456 &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::setprecision(4) &lt;&lt; 123.456 &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::setprecision(5) &lt;&lt; 123.456 &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::setprecision(6) &lt;&lt; 123.456 &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::setprecision(7) &lt;&lt; 123.456 &lt;&lt; '\n';</code><code></code><code>std::cout &lt;&lt; std::scientific &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::setprecision(3) &lt;&lt; 123.456 &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::setprecision(4) &lt;&lt; 123.456 &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::setprecision(5) &lt;&lt; 123.456 &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::setprecision(6) &lt;&lt; 123.456 &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::setprecision(7) &lt;&lt; 123.456 &lt;&lt; '\n';</code></pre><p>Produces the result:</p><pre>123.456
123.4560
123.45600
123.456000
123.4560000

1.235e+002
1.2346e+002
1.23456e+002
1.234560e+002
1.2345600e+002
</pre><p>If neither fixed nor scientific are being used, precision determines how many significant digits should be displayed. Again, if the precision is less than the number of significant digits, the number will be rounded.</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; std::setprecision(3) &lt;&lt; 123.456 &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::setprecision(4) &lt;&lt; 123.456 &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::setprecision(5) &lt;&lt; 123.456 &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::setprecision(6) &lt;&lt; 123.456 &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::setprecision(7) &lt;&lt; 123.456 &lt;&lt; '\n';</code></pre><p>Produces the following result:</p><pre>123
123.5
123.46
123.456
123.456
</pre><p>Using the showpoint manipulator or flag, you can make the stream write a decimal point and trailing zeros.</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; std::showpoint &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::setprecision(3) &lt;&lt; 123.456 &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::setprecision(4) &lt;&lt; 123.456 &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::setprecision(5) &lt;&lt; 123.456 &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::setprecision(6) &lt;&lt; 123.456 &lt;&lt; '\n';</code><code>std::cout &lt;&lt; std::setprecision(7) &lt;&lt; 123.456 &lt;&lt; '\n';</code></pre><p>Produces the following result:</p><pre>123.
123.5
123.46
123.456
123.4560
</pre><p>Here’s a summary table with some more examples:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Option</th><th>Precision</th><th>12345.0</th><th>0.12345</th></tr><tr><td rowspan="4">Normal</td><td>3</td><td>1.23e+004</td><td>0.123</td></tr><tr><td>4</td><td>1.235e+004</td><td>0.1235</td></tr><tr><td>5</td><td>12345</td><td>0.12345</td></tr><tr><td>6</td><td>12345</td><td>0.12345</td></tr><tr><td rowspan="4">Showpoint</td><td>3</td><td>1.23e+004</td><td>0.123</td></tr><tr><td>4</td><td>1.235e+004</td><td>0.1235</td></tr><tr><td>5</td><td>12345.</td><td>0.12345</td></tr><tr><td>6</td><td>12345.0</td><td>0.123450</td></tr><tr><td rowspan="4">Fixed</td><td>3</td><td>12345.000</td><td>0.123</td></tr><tr><td>4</td><td>12345.0000</td><td>0.1235</td></tr><tr><td>5</td><td>12345.00000</td><td>0.12345</td></tr><tr><td>6</td><td>12345.000000</td><td>0.123450</td></tr><tr><td rowspan="4">Scientific</td><td>3</td><td>1.235e+004</td><td>1.235e-001</td></tr><tr><td>4</td><td>1.2345e+004</td><td>1.2345e-001</td></tr><tr><td>5</td><td>1.23450e+004</td><td>1.23450e-001</td></tr><tr><td>6</td><td>1.234500e+004</td><td>1.234500e-001</td></tr></tbody></table></div><p><strong>Width, fill characters, and justification</strong></p><p>Typically when you print numbers, the numbers are printed without any regard to the space around them. However, it is possible to left or right justify the printing of numbers. In order to do this, we have to first define a field width, which defines the number of output spaces a value will have. If the actual number printed is smaller than the field width, it will be left or right justified (as specified). If the actual number is larger than the field width, it will not be truncated -- it will overflow the field.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Group</th><th>Flag</th><th>Meaning</th></tr><tr><td>std::ios::adjustfield</td><td>std::ios::internal</td><td>Left-justifies the sign of the number, and right-justifies the value</td></tr><tr><td>std::ios::adjustfield</td><td>std::ios::left</td><td>Left-justifies the sign and value</td></tr><tr><td>std::ios::adjustfield</td><td>std::ios::right</td><td>Right-justifies the sign and value (default)</td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Manipulator</th><th>Meaning</th></tr><tr><td>std::internal</td><td>Left-justifies the sign of the number, and right-justifies the value</td></tr><tr><td>std::left</td><td>Left-justifies the sign and value</td></tr><tr><td>std::right</td><td>Right-justifies the sign and value</td></tr><tr><td>std::setfill(char)</td><td>Sets the parameter as the fill character (defined in the iomanip header)</td></tr><tr><td>std::setw(int)</td><td>Sets the field width for input and output to the parameter (defined in the iomanip header)</td></tr></tbody></table></div><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Member function</th><th>Meaning</th></tr><tr><td>std::basic_ostream::fill()</td><td>Returns the current fill character</td></tr><tr><td>std::basic_ostream::fill(char)</td><td>Sets the fill character and returns the old fill character</td></tr><tr><td>std::ios_base::width()</td><td>Returns the current field width</td></tr><tr><td>std::ios_base::width(int)</td><td>Sets the current field width and returns old field width</td></tr></tbody></table></div><p>In order to use any of these formatters, we first have to set a field width. This can be done via the width(int) member function, or the setw() manipulator. Note that right justification is the default.</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; -12345 &lt;&lt; '\n'; // print default value with no field width</code><code>std::cout &lt;&lt; std::setw(10) &lt;&lt; -12345 &lt;&lt; '\n'; // print default with field width</code><code>std::cout &lt;&lt; std::setw(10) &lt;&lt; std::left &lt;&lt; -12345 &lt;&lt; '\n'; // print left justified</code><code>std::cout &lt;&lt; std::setw(10) &lt;&lt; std::right &lt;&lt; -12345 &lt;&lt; '\n'; // print right justified</code><code>std::cout &lt;&lt; std::setw(10) &lt;&lt; std::internal &lt;&lt; -12345 &lt;&lt; '\n'; // print internally justified</code></pre><p>This produces the result:</p><pre>-12345
    -12345
-12345
    -12345
-    12345
</pre><p>One thing to note is that setw() and width() only affect the next output statement. They are not persistent like some other flags/manipulators.</p><p>Now, let’s set a fill character and do the same example:</p><pre class="language-cpp line-numbers"><code>std::cout.fill('*');</code><code>std::cout &lt;&lt; -12345 &lt;&lt; '\n'; // print default value with no field width</code><code>std::cout &lt;&lt; std::setw(10) &lt;&lt; -12345 &lt;&lt; '\n'; // print default with field width</code><code>std::cout &lt;&lt; std::setw(10) &lt;&lt; std::left &lt;&lt; -12345 &lt;&lt; '\n'; // print left justified</code><code>std::cout &lt;&lt; std::setw(10) &lt;&lt; std::right &lt;&lt; -12345 &lt;&lt; '\n'; // print right justified</code><code>std::cout &lt;&lt; std::setw(10) &lt;&lt; std::internal &lt;&lt; -12345 &lt;&lt; '\n'; // print internally justified</code></pre><p>This produces the output:</p><pre>-12345
****-12345
-12345****
****-12345
-****12345
</pre><p>Note that all the blank spaces in the field have been filled up with the fill character.</p><p>The ostream class and iostream library contain other output functions, flags, and manipulators that may be useful, depending on what you need to do. As with the istream class, those topics are really more suited for a tutorial or book focusing on the standard library (such as the excellent book “The C++ Standard Template Library” by Nicolai M. Josuttis).</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">23.4 — Stream classes for strings</h1></header><div class="entry-content" itemprop="articleBody"><p>So far, all of the I/O examples you have seen have been writing to cout or reading from cin. However, there is another set of classes called the stream classes for strings that allow you to use the familiar insertions (&lt;&lt;) and extraction (&gt;&gt;) operators to work with strings. Like istream and ostream, the string streams provide a buffer to hold data. However, unlike cin and cout, these streams are not connected to an I/O channel (such as a keyboard, monitor, etc…). One of the primary uses of string streams is to buffer output for display at a later time, or to process input line-by-line.</p><p>There are six stream classes for strings: istringstream (derived from istream), ostringstream (derived from ostream), and stringstream (derived from iostream) are used for reading and writing normal characters width strings. wistringstream, wostringstream, and wstringstream are used for reading and writing wide character strings. To use the stringstreams, you need to #include the sstream header.</p><p>There are two ways to get data into a stringstream:</p><ol start="1"><li>Use the insertion (&lt;&lt;) operator:</li></ol><pre class="language-cpp line-numbers"><code>std::stringstream os;</code><code>os &lt;&lt; "en garde!\n"; // insert "en garde!" into the stringstream</code></pre><ol start="2"><li>Use the str(string) function to set the value of the buffer:</li></ol><pre class="language-cpp line-numbers"><code>std::stringstream os;</code><code>os.str("en garde!"); // set the stringstream buffer to "en garde!"</code></pre><p>There are similarly two ways to get data out of a stringstream:</p><ol start="1"><li>Use the str() function to retrieve the results of the buffer:</li></ol><pre class="language-cpp line-numbers"><code>std::stringstream os;</code><code>os &lt;&lt; "12345 67.89\n";</code><code>std::cout &lt;&lt; os.str();</code></pre><p>This prints:</p><pre>12345 67.89
</pre><ol start="2"><li>Use the extraction (&gt;&gt;) operator:</li></ol><pre class="language-cpp line-numbers"><code>std::stringstream os;</code><code>os &lt;&lt; "12345 67.89"; // insert a string of numbers into the stream</code><code></code><code>std::string strValue;</code><code>os &gt;&gt; strValue;</code><code></code><code>std::string strValue2;</code><code>os &gt;&gt; strValue2;</code><code></code><code>// print the numbers separated by a dash</code><code>std::cout &lt;&lt; strValue &lt;&lt; " - " &lt;&lt; strValue2 &lt;&lt; '\n';</code></pre><p>This program prints:</p><pre>12345 - 67.89
</pre><p>Note that the &gt;&gt; operator iterates through the string -- each successive use of &gt;&gt; returns the next extractable value in the stream. On the other hand, str() returns the whole value of the stream, even if the &gt;&gt; has already been used on the stream.</p><p><strong>Conversion between strings and numbers</strong></p><p>Because the insertion and extraction operators know how to work with all of the basic data types, we can use them in order to convert strings to numbers or vice versa.</p><p>First, let’s take a look at converting numbers into a string:</p><pre class="language-cpp line-numbers"><code>std::stringstream os;</code><code></code><code>int nValue{ 12345 };</code><code>double dValue{ 67.89 };</code><code>os &lt;&lt; nValue &lt;&lt; ' ' &lt;&lt; dValue;</code><code></code><code>std::string strValue1, strValue2;</code><code>os &gt;&gt; strValue1 &gt;&gt; strValue2;</code><code></code><code>std::cout &lt;&lt; strValue1 &lt;&lt; ' ' &lt;&lt; strValue2 &lt;&lt; '\n';</code></pre><p>This snippet prints:</p><pre>12345 67.89
</pre><p>Now let’s convert a numerical string to a number:</p><pre class="language-cpp line-numbers"><code>std::stringstream os;</code><code>os &lt;&lt; "12345 67.89"; // insert a string of numbers into the stream</code><code>int nValue;</code><code>double dValue;</code><code></code><code>os &gt;&gt; nValue &gt;&gt; dValue;</code><code></code><code>std::cout &lt;&lt; nValue &lt;&lt; ' ' &lt;&lt; dValue &lt;&lt; '\n';</code></pre><p>This program prints:</p><pre>12345 67.89
</pre><p><strong>Clearing a stringstream for reuse</strong></p><p>There are several ways to empty a stringstream’s buffer.</p><ol start="1"><li>Set it to the empty string using str() with a blank C-style string:</li></ol><pre class="language-cpp line-numbers"><code>std::stringstream os;</code><code>os &lt;&lt; "Hello ";</code><code></code><code>os.str(""); // erase the buffer</code><code></code><code>os &lt;&lt; "World!";</code><code>std::cout &lt;&lt; os.str();</code></pre><ol start="2"><li>Set it to the empty string using str() with a blank std::string object:</li></ol><pre class="language-cpp line-numbers"><code>std::stringstream os;</code><code>os &lt;&lt; "Hello ";</code><code></code><code>os.str(std::string{}); // erase the buffer</code><code></code><code>os &lt;&lt; "World!";</code><code>std::cout &lt;&lt; os.str();</code></pre><p>Both of these programs produce the following result:</p><pre>World!
</pre><p>When clearing out a stringstream, it is also generally a good idea to call the clear() function:</p><pre class="language-cpp line-numbers"><code>std::stringstream os;</code><code>os &lt;&lt; "Hello ";</code><code></code><code>os.str(""); // erase the buffer</code><code>os.clear(); // reset error flags</code><code></code><code>os &lt;&lt; "World!";</code><code>std::cout &lt;&lt; os.str();</code></pre><p>clear() resets any error flags that may have been set and returns the stream back to the ok state. We will talk more about the stream state and error flags in the next lesson.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">23.5 — Stream states and input validation</h1></header><div class="entry-content" itemprop="articleBody"><br><h3>Stream states</h3><p>The ios_base class contains several state flags that are used to signal various conditions that may occur when using streams:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Flag</th><th>Meaning</th></tr><tr><td>goodbit</td><td>Everything is okay</td></tr><tr><td>badbit</td><td>Some kind of fatal error occurred (e.g. the program tried to read past the end of a file)</td></tr><tr><td>eofbit</td><td>The stream has reached the end of a file</td></tr><tr><td>failbit</td><td>A non-fatal error occurred (e.g. the user entered letters when the program was expecting an integer)</td></tr></tbody></table></div><p>Although these flags live in ios_base, because ios is derived from ios_base and ios takes less typing than ios_base, they are generally accessed through ios (e.g. as std::ios::failbit).</p><p>ios also provides a number of member functions in order to conveniently access these states:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Member function</th><th>Meaning</th></tr><tr><td>good()</td><td>Returns true if the goodbit is set (the stream is ok)</td></tr><tr><td>bad()</td><td>Returns true if the badbit is set (a fatal error occurred)</td></tr><tr><td>eof()</td><td>Returns true if the eofbit is set (the stream is at the end of a file)</td></tr><tr><td>fail()</td><td>Returns true if the failbit is set (a non-fatal error occurred)</td></tr><tr><td>clear()</td><td>Clears all flags and restores the stream to the goodbit state</td></tr><tr><td>clear(state)</td><td>Clears all flags and sets the state flag passed in</td></tr><tr><td>rdstate()</td><td>Returns the currently set flags</td></tr><tr><td>setstate(state)</td><td>Sets the state flag passed in</td></tr></tbody></table></div><p>The most commonly dealt with bit is the failbit, which is set when the user enters invalid input. For example, consider the following program:</p><pre class="language-cpp line-numbers"><code>std::cout &lt;&lt; "Enter your age: ";</code><code>int age {};</code><code>std::cin &gt;&gt; age;</code></pre><p>Note that this program is expecting the user to enter an integer. However, if the user enters non-numeric data, such as “Alex”, cin will be unable to extract anything to age, and the failbit will be set.</p><p>If an error occurs and a stream is set to anything other than goodbit, further stream operations on that stream will be ignored. This condition can be cleared by calling the clear() function.</p><br><h3>Input validation</h3><p><strong>Input validation</strong> is the process of checking whether the user input meets some set of criteria. Input validation can generally be broken down into two types: string and numeric.</p><p>With string validation, we accept all user input as a string, and then accept or reject that string depending on whether it is formatted appropriately. For example, if we ask the user to enter a telephone number, we may want to ensure the data they enter has ten digits. In most languages (especially scripting languages like Perl and PHP), this is done via regular expressions. The C++ standard library has a <a href="https://en.cppreference.com/w/cpp/regex">regular expression library</a> as well. Because regular expressions are slow compared to manual string validation, they should only be used if performance (compile-time and run-time) is of no concern or manual validation is too cumbersome.</p><p>With numerical validation, we are typically concerned with making sure the number the user enters is within a particular range (e.g. between 0 and 20). However, unlike with string validation, it’s possible for the user to enter things that aren’t numbers at all -- and we need to handle these cases too.</p><p>To help us out, C++ provides a number of useful functions that we can use to determine whether specific characters are numbers or letters. The following functions live in the cctype header:</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Function</th><th>Meaning</th></tr><tr><td>std::isalnum(int)</td><td>Returns non-zero if the parameter is a letter or a digit</td></tr><tr><td>std::isalpha(int)</td><td>Returns non-zero if the parameter is a letter</td></tr><tr><td>std::iscntrl(int)</td><td>Returns non-zero if the parameter is a control character</td></tr><tr><td>std::isdigit(int)</td><td>Returns non-zero if the parameter is a digit</td></tr><tr><td>std::isgraph(int)</td><td>Returns non-zero if the parameter is printable character that is not whitespace</td></tr><tr><td>std::isprint(int)</td><td>Returns non-zero if the parameter is printable character (including whitespace)</td></tr><tr><td>std::ispunct(int)</td><td>Returns non-zero if the parameter is neither alphanumeric nor whitespace</td></tr><tr><td>std::isspace(int)</td><td>Returns non-zero if the parameter is whitespace</td></tr><tr><td>std::isxdigit(int)</td><td>Returns non-zero if the parameter is a hexadecimal digit (0-9, a-f, A-F)</td></tr></tbody></table></div><br><h3>String validation</h3><p>Let’s do a simple case of string validation by asking the user to enter their name. Our validation criteria will be that the user enters only alphabetic characters or spaces. If anything else is encountered, the input will be rejected.</p><p>When it comes to variable length inputs, the best way to validate strings (besides using a regular expression library) is to step through each character of the string and ensure it meets the validation criteria. That’s exactly what we’ll do here, or better, that’s what <code>std::all_of</code> does for us.</p><pre class="language-cpp line-numbers"><code>#include <algorithm> // std::all_of</algorithm></code><code>#include <cctype> // std::isalpha, std::isspace</cctype></code><code>#include <iostream></iostream></code><code>#include <ranges></ranges></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>bool isValidName(std::string_view name)</code><code>{</code><code>  return std::ranges::all_of(name, [](char ch) {</code><code>    return (std::isalpha(ch) || std::isspace(ch));</code><code>  });</code><code></code><code>  // Before C++20, without ranges</code><code>  // return std::all_of(name.begin(), name.end(), [](char ch) {</code><code>  //    return (std::isalpha(ch) || std::isspace(ch));</code><code>  // });</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  std::string name{};</code><code></code><code>  do</code><code>  {</code><code>    std::cout &lt;&lt; "Enter your name: ";</code><code>    std::getline(std::cin, name); // get the entire line, including spaces</code><code>  } while (!isValidName(name));</code><code></code><code>  std::cout &lt;&lt; "Hello " &lt;&lt; name &lt;&lt; "!\n";</code><code>}</code></pre><p>Note that this code isn’t perfect: the user could say their name was “asf w jweo s di we ao” or some other bit of gibberish, or even worse, just a bunch of spaces. We could address this somewhat by refining our validation criteria to only accept strings that contain at least one character and at most one space.</p><div class="cpp-note cpp-lightgraybackground"><h4>Author’s note</h4><p>Reader “Waldo” provides a C++20 solution (using std::ranges) that addresses these shortcomings <a href="#comment-571052">here</a></p></div><p>Now let’s take a look at another example where we are going to ask the user to enter their phone number. Unlike a user’s name, which is variable-length and where the validation criteria are the same for every character, a phone number is a fixed length but the validation criteria differ depending on the position of the character. Consequently, we are going to take a different approach to validating our phone number input. In this case, we’re going to write a function that will check the user’s input against a predetermined template to see whether it matches. The template will work as follows:</p><p>A # will match any digit in the user input.<br>A @ will match any alphabetic character in the user input.<br>A _ will match any whitespace.<br>A ? will match anything.<br>Otherwise, the characters in the user input and the template must match exactly.</p><p>So, if we ask the function to match the template “(###) ###-####”, that means we expect the user to enter a ‘(‘ character, three numbers, a ‘)’ character, a space, three numbers, a dash, and four more numbers. If any of these things doesn’t match, the input will be rejected.</p><p>Here is the code:</p><pre class="language-cpp line-numbers"><code>#include <algorithm> // std::equal</algorithm></code><code>#include <cctype> // std::isdigit, std::isspace, std::isalpha</cctype></code><code>#include <iostream></iostream></code><code>#include <map></map></code><code>#include <ranges></ranges></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>bool inputMatches(std::string_view input, std::string_view pattern)</code><code>{</code><code>    if (input.length() != pattern.length())</code><code>    {</code><code>        return false;</code><code>    }</code><code></code><code>    // This table defines all special symbols that can match a range of user input</code><code>    // Each symbol is mapped to a function that determines whether the input is valid for that symbol</code><code>    static const std::map<char, int="" (*)(int)=""> validators{</char,></code><code>      { '#', &amp;std::isdigit },</code><code>      { '_', &amp;std::isspace },</code><code>      { '@', &amp;std::isalpha },</code><code>      { '?', [](int) { return 1; } }</code><code>    };</code><code></code><code>    // Before C++20, use</code><code>    // return std::equal(input.begin(), input.end(), pattern.begin(), [](char ch, char mask) -&gt; bool {</code><code>    // ...</code><code></code><code>    return std::ranges::equal(input, pattern, [](char ch, char mask) -&gt; bool {</code><code>        if (auto found{ validators.find(mask) }; found != validators.end())</code><code>        {</code><code>            // The pattern's current element was found in the validators. Call the</code><code>            // corresponding function.</code><code>            return (*found-&gt;second)(ch);</code><code>        }</code><code>        else</code><code>        {</code><code>            // The pattern's current element was not found in the validators. The</code><code>            // characters have to be an exact match.</code><code>            return (ch == mask);</code><code>        }</code><code>        });</code><code>}</code><code></code><code>int main()</code><code>{</code><code>    std::string phoneNumber{};</code><code></code><code>    do</code><code>    {</code><code>        std::cout &lt;&lt; "Enter a phone number (###) ###-####: ";</code><code>        std::getline(std::cin, phoneNumber);</code><code>    } while (!inputMatches(phoneNumber, "(###) ###-####"));</code><code></code><code>    std::cout &lt;&lt; "You entered: " &lt;&lt; phoneNumber &lt;&lt; '\n';</code><code>}</code></pre><p>Using this function, we can force the user to match our specific format exactly. However, this function is still subject to several constraints: if #, @, _, and ? are valid characters in the user input, this function won’t work, because those symbols have been given special meanings. Also, unlike with regular expressions, there is no template symbol that means “a variable number of characters can be entered”. Thus, such a template could not be used to ensure the user enters two words separated by a whitespace, because it can not handle the fact that the words are of variable lengths. For such problems, the non-template approach is generally more appropriate.</p><br><h3>Numeric validation</h3><p>When dealing with numeric input, the obvious way to proceed is to use the extraction operator to extract input to a numeric type. By checking the failbit, we can then tell whether the user entered a number or not.</p><p>Let’s try this approach:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <limits></limits></code><code></code><code>int main()</code><code>{</code><code>    int age{};</code><code></code><code>    while (true)</code><code>    {</code><code>        std::cout &lt;&lt; "Enter your age: ";</code><code>        std::cin &gt;&gt; age;</code><code></code><code>        if (std::cin.fail()) // no extraction took place</code><code>        {</code><code>            std::cin.clear(); // reset the state bits back to goodbit so we can use ignore()</code><code>            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // clear out the bad input from the stream</std::streamsize></code><code>            continue; // try again</code><code>        }</code><code></code><code>        if (age &lt;= 0) // make sure age is positive</code><code>            continue;</code><code></code><code>        break;</code><code>    }</code><code></code><code>    std::cout &lt;&lt; "You entered: " &lt;&lt; age &lt;&lt; '\n';</code><code>}</code></pre><p>If the user enters an integer, the extraction will succeed. std::cin.fail() will evaluate to false, skipping the conditional, and (assuming the user entered a positive number), we will hit the break statement, exiting the loop.</p><p>If the user instead enters input starting with a letter, the extraction will fail. std::cin.fail() will evaluate to true, and we will go into the conditional. At the end of the conditional block, we will hit the continue statement, which will jump back to the top of the while loop, and the user will be asked to enter input again.</p><p>However, there’s one more case we haven’t tested for, and that’s when the user enters a string that starts with numbers but then contains letters (e.g. “34abcd56”). In this case, the starting numbers (34) will be extracted into age, the remainder of the string (“abcd56”) will be left in the input stream, and the failbit will NOT be set. This causes two potential problems:</p><ol start="1"><li>If you want this to be valid input, you now have garbage in your stream.</li><li>If you don’t want this to be valid input, it is not rejected (and you have garbage in your stream).</li></ol><p>Let’s fix the first problem. This is easy:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <limits></limits></code><code></code><code>int main()</code><code>{</code><code>    int age{};</code><code></code><code>    while (true)</code><code>    {</code><code>        std::cout &lt;&lt; "Enter your age: ";</code><code>        std::cin &gt;&gt; age;</code><code></code><code>        if (std::cin.fail()) // no extraction took place</code><code>        {</code><code>            std::cin.clear(); // reset the state bits back to goodbit so we can use ignore()</code><code>            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // clear out the bad input from the stream</std::streamsize></code><code>            continue; // try again</code><code>        }</code><code></code><code>        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // clear out any additional input from the stream</std::streamsize></code><code></code><code>        if (age &lt;= 0) // make sure age is positive</code><code>            continue;</code><code></code><code>      break;</code><code>    }</code><code></code><code>    std::cout &lt;&lt; "You entered: " &lt;&lt; age &lt;&lt; '\n';</code><code>}</code></pre><p>If you don’t want such input to be valid, we’ll have to do a little extra work. Fortunately, the previous solution gets us half way there. We can use the gcount() function to determine how many characters were ignored. If our input was valid, gcount() should return 1 (the newline character that was discarded). If it returns more than 1, the user entered something that wasn’t extracted properly, and we should ask them for new input. Here’s an example of this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <limits></limits></code><code></code><code>int main()</code><code>{</code><code>    int age{};</code><code></code><code>    while (true)</code><code>    {</code><code>        std::cout &lt;&lt; "Enter your age: ";</code><code>        std::cin &gt;&gt; age;</code><code></code><code>        if (std::cin.fail()) // no extraction took place</code><code>        {</code><code>            std::cin.clear(); // reset the state bits back to goodbit so we can use ignore()</code><code>            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // clear out the bad input from the stream</std::streamsize></code><code>            continue; // try again</code><code>        }</code><code></code><code>        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // clear out any additional input from the stream</std::streamsize></code><code>        if (std::cin.gcount() &gt; 1) // if we cleared out more than one additional character</code><code>        {</code><code>            continue; // we'll consider this input to be invalid</code><code>        }</code><code></code><code>        if (age &lt;= 0) // make sure age is positive</code><code>        {</code><code>            continue;</code><code>        }</code><code></code><code>        break;</code><code>    }</code><code></code><code>    std::cout &lt;&lt; "You entered: " &lt;&lt; age &lt;&lt; '\n';</code><code>}</code></pre><br><h3>Numeric validation as a string</h3><p>The above example was quite a bit of work simply to get a simple value! Another way to process numeric input is to read it in as a string, then try to convert it to a numeric type. The following program makes use of that methodology:</p><pre class="language-cpp line-numbers"><code>#include <charconv> // std::from_chars</charconv></code><code>#include <iostream></iostream></code><code>#include <optional></optional></code><code>#include <string></string></code><code>#include <string_view></string_view></code><code></code><code>std::optional<int> extractAge(std::string_view age)</int></code><code>{</code><code>  int result{};</code><code>  auto end{ age.data() + age.length() };</code><code></code><code>  // Try to parse an int from age</code><code>  if (std::from_chars(age.data(), end, result).ptr != end)</code><code>  {</code><code>    return {};</code><code>  }</code><code></code><code>  if (result &lt;= 0) // make sure age is positive</code><code>  {</code><code>    return {};</code><code>  }</code><code></code><code>  return result;</code><code>}</code><code></code><code>int main()</code><code>{</code><code>  int age{};</code><code></code><code>  while (true)</code><code>  {</code><code>    std::cout &lt;&lt; "Enter your age: ";</code><code>    std::string strAge{};</code><code>    std::getline(std::cin &gt;&gt; std::ws, strAge);</code><code></code><code>    if (auto extracted{ extractAge(strAge) })</code><code>    {</code><code>      age = *extracted;</code><code>      break;</code><code>    }</code><code>  }</code><code></code><code>  std::cout &lt;&lt; "You entered: " &lt;&lt; age &lt;&lt; '\n';</code><code>}</code></pre><p>Whether this approach is more or less work than straight numeric extraction depends on your validation parameters and restrictions.</p><p>As you can see, doing input validation in C++ is a lot of work. Fortunately, many such tasks (e.g. doing numeric validation as a string) can be easily turned into functions that can be reused in a wide variety of situations.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">23.6 — Basic file I/O</h1></header><div class="entry-content" itemprop="articleBody"><p>File I/O in C++ works very similarly to normal I/O (with a few minor added complexities). There are 3 basic file I/O classes in C++: ifstream (derived from istream), ofstream (derived from ostream), and fstream (derived from iostream). These classes do file input, output, and input/output respectively. To use the file I/O classes, you will need to include the fstream header.</p><p>Unlike the cout, cin, cerr, and clog streams, which are already ready for use, file streams have to be explicitly set up by the programmer. However, this is extremely simple: to open a file for reading and/or writing, simply instantiate an object of the appropriate file I/O class, with the name of the file as a parameter. Then use the insertion (&lt;&lt;) or extraction (&gt;&gt;) operator to write to or read data from the file. Once you are done, there are several ways to close a file: explicitly call the close() function, or just let the file I/O variable go out of scope (the file I/O class destructor will close the file for you).</p><p><strong>File output</strong></p><p>To do file output in the following example, we’re going to use the ofstream class. This is extremely straighforward:</p><pre class="language-cpp line-numbers"><code>#include <fstream></fstream></code><code>#include <iostream></iostream></code><code> </code><code>int main()</code><code>{</code><code>    // ofstream is used for writing files</code><code>    // We'll make a file called Sample.txt</code><code>    std::ofstream outf{ "Sample.txt" };</code><code></code><code>    // If we couldn't open the output file stream for writing</code><code>    if (!outf)</code><code>    {</code><code>        // Print an error and exit</code><code>        std::cerr &lt;&lt; "Uh oh, Sample.txt could not be opened for writing!\n";</code><code>        return 1;</code><code>    }</code><code></code><code>    // We'll write two lines into this file</code><code>    outf &lt;&lt; "This is line 1\n";</code><code>    outf &lt;&lt; "This is line 2\n";</code><code></code><code>    return 0;</code><code>	</code><code>    // When outf goes out of scope, the ofstream</code><code>    // destructor will close the file</code><code>}</code></pre><p>If you look in your project directory, you should see a file called Sample.txt. If you open it with a text editor, you will see that it indeed contains two lines we wrote to the file.</p><p>Note that it is also possible to use the put() function to write a single character to the file.</p><p><strong>File input</strong></p><p>Now, we’ll take the file we wrote in the last example and read it back in from disk. Note that ifstream returns a 0 if we’ve reached the end of the file (EOF). We’ll use this fact to determine how much to read.</p><pre class="language-cpp line-numbers"><code>#include <fstream></fstream></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>    // ifstream is used for reading files</code><code>    // We'll read from a file called Sample.txt</code><code>    std::ifstream inf{ "Sample.txt" };</code><code></code><code>    // If we couldn't open the output file stream for reading</code><code>    if (!inf)</code><code>    {</code><code>        // Print an error and exit</code><code>        std::cerr &lt;&lt; "Uh oh, Sample.txt could not be opened for reading!\n";</code><code>        return 1;</code><code>    }</code><code></code><code>    // While there's still stuff left to read</code><code>    while (inf)</code><code>    {</code><code>        // read stuff from the file into a string and print it</code><code>        std::string strInput;</code><code>        inf &gt;&gt; strInput;</code><code>        std::cout &lt;&lt; strInput &lt;&lt; '\n';</code><code>    }</code><code>    </code><code>    return 0;</code><code>	</code><code>    // When inf goes out of scope, the ifstream</code><code>    // destructor will close the file</code><code>}</code></pre><p>This produces the result:</p><pre>This
is
line
1
This
is
line
2
</pre><p>Hmmm, that wasn’t quite what we wanted. Remember that the extraction operator breaks on whitespace. In order to read in entire lines, we’ll have to use the getline() function.</p><pre class="language-cpp line-numbers"><code>#include <fstream></fstream></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>    // ifstream is used for reading files</code><code>    // We'll read from a file called Sample.txt</code><code>    std::ifstream inf{ "Sample.txt" };</code><code></code><code>    // If we couldn't open the input file stream for reading</code><code>    if (!inf)</code><code>    {</code><code>        // Print an error and exit</code><code>        std::cerr &lt;&lt; "Uh oh, Sample.txt could not be opened for reading!\n";</code><code>        return 1;</code><code>    }</code><code></code><code>    // While there's still stuff left to read</code><code>    while (inf)</code><code>    {</code><code>        // read stuff from the file into a string and print it</code><code>        std::string strInput;</code><code>        std::getline(inf, strInput);</code><code>        std::cout &lt;&lt; strInput &lt;&lt; '\n';</code><code>    }</code><code>    </code><code>    return 0;</code><code>	</code><code>    // When inf goes out of scope, the ifstream</code><code>    // destructor will close the file</code><code>}</code></pre><p>This produces the result:</p><pre>This is line 1
This is line 2
</pre><p><strong>Buffered output</strong></p><p>Output in C++ may be buffered. This means that anything that is output to a file stream may not be written to disk immediately. Instead, several output operations may be batched and handled together. This is done primarily for performance reasons. When a buffer is written to disk, this is called <strong>flushing</strong> the buffer. One way to cause the buffer to be flushed is to close the file -- the contents of the buffer will be flushed to disk, and then the file will be closed.</p><p>Buffering is usually not a problem, but in certain circumstance it can cause complications for the unwary. The main culprit in this case is when there is data in the buffer, and then program terminates immediately (either by crashing, or by calling exit()). In these cases, the destructors for the file stream classes are not executed, which means the files are never closed, which means the buffers are never flushed. In this case, the data in the buffer is not written to disk, and is lost forever. This is why it is always a good idea to explicitly close any open files before calling exit().</p><p>It is possible to flush the buffer manually using the ostream::flush() function or sending std::flush to the output stream. Either of these methods can be useful to ensure the contents of the buffer are written to disk immediately, just in case the program crashes.</p><p>One interesting note is that std::endl; also flushes the output stream. Consequently, overuse of std::endl (causing unnecessary buffer flushes) can have performance impacts when doing buffered I/O where flushes are expensive (such as writing to a file). For this reason, performance conscious programmers will often use ‘\n’ instead of std::endl to insert a newline into the output stream, to avoid unnecessary flushing of the buffer.</p><p><strong>File modes</strong></p><p>What happens if we try to write to a file that already exists? Running the output example again shows that the original file is completely overwritten each time the program is run. What if, instead, we wanted to append some more data to the end of the file? It turns out that the file stream constructors take an optional second parameter that allows you to specify information about how the file should be opened. This parameter is called mode, and the valid flags that it accepts live in the ios class.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Ios file mode</th><th>Meaning</th></tr><tr><td>app</td><td>Opens the file in append mode</td></tr><tr><td>ate</td><td>Seeks to the end of the file before reading/writing</td></tr><tr><td>binary</td><td>Opens the file in binary mode (instead of text mode)</td></tr><tr><td>in</td><td>Opens the file in read mode (default for ifstream)</td></tr><tr><td>out</td><td>Opens the file in write mode (default for ofstream)</td></tr><tr><td>trunc</td><td>Erases the file if it already exists</td></tr></tbody></table></div><p>It is possible to specify multiple flags by bitwise ORing them together (using the | operator). ifstream defaults to std::ios::in file mode. ofstream defaults to std::ios::out file mode. And fstream defaults to std::ios::in | std::ios::out file mode, meaning you can both read and write by default.</p><div class="cpp-note cpp-lightbluebackground"><h4>Tip</h4><p>Due to the way fstream was designed, it may fail if std::ios::in is used and the file being opened does not exist. If you need to create a new file using fstream, use std::ios::out mode only.</p></div><p>Let’s write a program that appends two more lines to the Sample.txt file we previously created:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code>#include <fstream></fstream></code><code></code><code>int main()</code><code>{</code><code>    // We'll pass the ios:app flag to tell the ofstream to append</code><code>    // rather than rewrite the file. We do not need to pass in std::ios::out</code><code>    // because ofstream defaults to std::ios::out</code><code>    std::ofstream outf{ "Sample.txt", std::ios::app };</code><code></code><code>    // If we couldn't open the output file stream for writing</code><code>    if (!outf)</code><code>    {</code><code>        // Print an error and exit</code><code>        std::cerr &lt;&lt; "Uh oh, Sample.txt could not be opened for writing!\n";</code><code>        return 1;</code><code>    }</code><code></code><code>    outf &lt;&lt; "This is line 3\n";</code><code>    outf &lt;&lt; "This is line 4\n";</code><code>    </code><code>    return 0;</code><code>	</code><code>    // When outf goes out of scope, the ofstream</code><code>    // destructor will close the file</code><code>}</code></pre><p>Now if we take a look at Sample.txt (using one of the above sample programs that prints its contents, or loading it in a text editor), we will see the following:</p><pre>This is line 1
This is line 2
This is line 3
This is line 4
</pre><p><strong>Explicitly opening files using open()</strong></p><p>Just like it is possible to explicitly close a file stream using close(), it’s also possible to explicitly open a file stream using open(). open() works just like the file stream constructors -- it takes a file name and an optional file mode.</p><p>For example:</p><pre class="language-cpp line-numbers"><code>std::ofstream outf{ "Sample.txt" };</code><code>outf &lt;&lt; "This is line 1\n";</code><code>outf &lt;&lt; "This is line 2\n"</code><code>outf.close(); // explicitly close the file</code><code></code><code>// Oops, we forgot something</code><code>outf.open("Sample.txt", std::ios::app);</code><code>outf &lt;&lt; "This is line 3\n";</code><code>outf.close();</code></pre><p>You can find more information about the open() function <a href="https://en.cppreference.com/w/cpp/io/basic_filebuf/open">here</a>.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">23.7 — Random file I/O</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>The file pointer</strong></p><p>Each file stream class contains a file pointer that is used to keep track of the current read/write position within the file. When something is read from or written to a file, the reading/writing happens at the file pointer’s current location. By default, when opening a file for reading or writing, the file pointer is set to the beginning of the file. However, if a file is opened in append mode, the file pointer is moved to the end of the file, so that writing does not overwrite any of the current contents of the file.</p><p><strong>Random file access with seekg() and seekp()</strong></p><p>So far, all of the file access we’ve done has been sequential -- that is, we’ve read or written the file contents in order. However, it is also possible to do random file access -- that is, skip around to various points in the file to read its contents. This can be useful when your file is full of records, and you wish to retrieve a specific record. Rather than reading all of the records until you get to the one you want, you can skip directly to the record you wish to retrieve.</p><p>Random file access is done by manipulating the file pointer using either seekg() function (for input) and seekp() function (for output). In case you are wondering, the g stands for “get” and the p for “put”. For some types of streams, seekg() (changing the read position) and seekp() (changing the write position) operate independently -- however, with file streams, the read and write position are always identical, so seekg and seekp can be used interchangeably.</p><p>The seekg() and seekp() functions take two parameters. The first parameter is an offset that determines how many bytes to move the file pointer. The second parameter is an ios flag that specifies what the offset parameter should be offset from.</p><div class="cpp-table-wrapper"><p></p><table class="cpp-table"><tbody><tr><th>Ios seek flag</th><th>Meaning</th></tr><tr><td>beg</td><td>The offset is relative to the beginning of the file (default)</td></tr><tr><td>cur</td><td>The offset is relative to the current location of the file pointer</td></tr><tr><td>end</td><td>The offset is relative to the end of the file</td></tr></tbody></table></div><p>A positive offset means move the file pointer towards the end of the file, whereas a negative offset means move the file pointer towards the beginning of the file.</p><p>Here are some examples:</p><pre class="language-cpp line-numbers"><code>inf.seekg(14, std::ios::cur); // move forward 14 bytes</code><code>inf.seekg(-18, std::ios::cur); // move backwards 18 bytes</code><code>inf.seekg(22, std::ios::beg); // move to 22nd byte in file</code><code>inf.seekg(24); // move to 24th byte in file</code><code>inf.seekg(-28, std::ios::end); // move to the 28th byte before end of the file</code></pre><p>Moving to the beginning or end of the file is easy:</p><pre class="language-cpp line-numbers"><code>inf.seekg(0, std::ios::beg); // move to beginning of file</code><code>inf.seekg(0, std::ios::end); // move to end of file</code></pre><p>Let’s do an example using seekg() and the input file we created in the last lesson. That input file looks like this:</p><pre>This is line 1
This is line 2
This is line 3
This is line 4
</pre><p>Here is the example:</p><pre class="language-cpp line-numbers"><code>#include <fstream></fstream></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>    std::ifstream inf{ "Sample.txt" };</code><code></code><code>    // If we couldn't open the input file stream for reading</code><code>    if (!inf)</code><code>    {</code><code>        // Print an error and exit</code><code>        std::cerr &lt;&lt; "Uh oh, Sample.txt could not be opened for reading!\n";</code><code>        return 1;</code><code>    }</code><code></code><code>    std::string strData;</code><code></code><code>    inf.seekg(5); // move to 5th character</code><code>    // Get the rest of the line and print it, moving to line 2</code><code>    std::getline(inf, strData);</code><code>    std::cout &lt;&lt; strData &lt;&lt; '\n';</code><code></code><code>    inf.seekg(8, std::ios::cur); // move 8 more bytes into file</code><code>    // Get rest of the line and print it</code><code>    std::getline(inf, strData);</code><code>    std::cout &lt;&lt; strData &lt;&lt; '\n';</code><code></code><code>    inf.seekg(-14, std::ios::end); // move 14 bytes before end of file</code><code>    // Get rest of the line and print it</code><code>    std::getline(inf, strData);</code><code>    std::cout &lt;&lt; strData &lt;&lt; '\n';</code><code></code><code>    return 0;</code><code>}</code></pre><p>This produces the result:</p><pre>is line 1
line 2
This is line 4
</pre><p>Note: Some compilers have buggy implementations of seekg() and seekp() when used in conjunction with text files (due to buffering). If your compiler is one of them (and you’ll know because your output will differ from the above), you can try opening the file in binary mode instead:</p><pre class="language-cpp line-numbers"><code>    std::ifstream inf("Sample.txt", std::ifstream::binary);</code></pre><p>Two other useful functions are tellg() and tellp(), which return the absolute position of the file pointer. This can be used to determine the size of a file:</p><pre class="language-cpp line-numbers"><code>std::ifstream inf("Sample.txt");</code><code>inf.seekg(0, std::ios::end); // move to end of file</code><code>std::cout &lt;&lt; inf.tellg();</code></pre><p>This prints:</p><pre>64
</pre><p>which is how long sample.txt is in bytes (assuming a carriage return after the last line).</p><p><strong>Reading and writing a file at the same time using fstream</strong></p><p>The fstream class is capable of both reading and writing a file at the same time -- almost! The big caveat here is that it is not possible to switch between reading and writing arbitrarily. Once a read or write has taken place, the only way to switch between the two is to perform an operation that modifies the file position (e.g. a seek). If you don’t actually want to move the file pointer (because it’s already in the spot you want), you can always seek to the current position:</p><pre class="language-cpp line-numbers"><code>// assume iofile is an object of type fstream</code><code>iofile.seekg(iofile.tellg(), std::ios::beg); // seek to current file position</code></pre><p>If you do not do this, any number of strange and bizarre things may occur.</p><p>(Note: Although it may seem that <code>iofile.seekg(0, std::ios::cur)</code> would also work, it appears some compilers may optimize this away).</p><p>One other bit of trickiness: Unlike ifstream, where we could say <code>while (inf)</code> to determine if there was more to read, this will not work with fstream.</p><p>Let’s do a file I/O example using fstream. We’re going to write a program that opens a file, reads its contents, and changes any vowels it finds to a ‘#’ symbol.</p><pre class="language-cpp line-numbers"><code>#include <fstream></fstream></code><code>#include <iostream></iostream></code><code>#include <string></string></code><code></code><code>int main()</code><code>{</code><code>    // Note we have to specify both in and out because we're using fstream</code><code>    std::fstream iofile{ "Sample.txt", std::ios::in | std::ios::out };</code><code></code><code>    // If we couldn't open iofile, print an error</code><code>    if (!iofile)</code><code>    {</code><code>        // Print an error and exit</code><code>        std::cerr &lt;&lt; "Uh oh, Sample.txt could not be opened!\n";</code><code>        return 1;</code><code>    }</code><code></code><code>    char chChar{}; // we're going to do this character by character</code><code></code><code>    // While there's still data to process</code><code>    while (iofile.get(chChar))</code><code>    {</code><code>        switch (chChar)</code><code>        {</code><code>            // If we find a vowel</code><code>            case 'a':</code><code>            case 'e':</code><code>            case 'i':</code><code>            case 'o':</code><code>            case 'u':</code><code>            case 'A':</code><code>            case 'E':</code><code>            case 'I':</code><code>            case 'O':</code><code>            case 'U':</code><code></code><code>                // Back up one character</code><code>                iofile.seekg(-1, std::ios::cur);</code><code></code><code>                // Because we did a seek, we can now safely do a write, so</code><code>                // let's write a # over the vowel</code><code>                iofile &lt;&lt; '#';</code><code></code><code>                // Now we want to go back to read mode so the next call</code><code>                // to get() will perform correctly.  We'll seekg() to the current</code><code>                // location because we don't want to move the file pointer.</code><code>                iofile.seekg(iofile.tellg(), std::ios::beg);</code><code></code><code>                std::cout &lt;&lt; iofile.rdbuf();</code><code></code><code>                break;</code><code>        }</code><code>    }</code><code></code><code>    return 0;</code><code>}</code></pre><p>After running the above program, our Sample.txt file will look like this:</p><pre>Th#s #s l#n# 1
Th#s #s l#n# 2
Th#s #s l#n# 3
Th#s #s l#n# 4
</pre><p><strong>Other useful file functions</strong></p><p>To delete a file, simply use the remove() function.</p><p>Also, the is_open() function will return true if the stream is currently open, and false otherwise.</p><p><strong>A warning about writing pointers to disk</strong></p><p>While streaming variables to a file is quite easy, things become more complicated when you’re dealing with pointers. Remember that a pointer simply holds the address of the variable it is pointing to. Although it is possible to read and write addresses to disk, it is extremely dangerous to do so. This is because a variable’s address may differ from execution to execution. Consequently, although a variable may have lived at address 0x0012FF7C when you wrote that address to disk, it may not live there any more when you read that address back in!</p><p>For example, let’s say you had an integer named nValue that lived at address 0x0012FF7C. You assigned nValue the value 5. You also declared a pointer named *pnValue that points to nValue. pnValue holds nValue’s address of 0x0012FF7C. You want to save these for later, so you write the value 5 and the address 0x0012FF7C to disk.</p><p>A few weeks later, you run the program again and read these values back from disk. You read the value 5 into another variable named nValue, which lives at 0x0012FF78. You read the address 0x0012FF7C into a new pointer named *pnValue. Because pnValue now points to 0x0012FF7C when the nValue lives at 0x0012FF78, pnValue is no longer pointing to nValue, and trying to access pnValue will lead you into trouble.</p><div class="cpp-note cpp-lightredbackground"><h4>Warning</h4><p>Do not write memory addresses to files. The variables that were originally at those addresses may be at different addresses when you read their values back in from disk, and the addresses will be invalid.</p></div></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">A.1 — Static and dynamic libraries</h1></header><div class="entry-content" itemprop="articleBody"><p>A <strong>library</strong> is a package of code that is meant to be reused by many programs. Typically, a C++ library comes in two pieces:</p><ol start="1"><li>A header file that defines the functionality the library is exposing (offering) to the programs using it.</li><li>A precompiled binary that contains the implementation of that functionality pre-compiled into machine language.</li></ol><p>Some libraries may be split into multiple files and/or have multiple header files.</p><p>Libraries are precompiled for several reasons. First, since libraries rarely change, they do not need to be recompiled often. It would be a waste of time to recompile the library every time you wrote a program that used them. Second, because precompiled objects are in machine language, it prevents people from accessing or changing the source code, which is important to businesses or people who don’t want to make their source code available for intellectual property reasons.</p><p>There are two types of libraries: static libraries and dynamic libraries.</p><p>A <strong>static library</strong> (also known as an <strong>archive</strong>) consists of routines that are compiled and linked directly into your program. When you compile a program that uses a static library, all the functionality of the static library that your program uses becomes part of your executable. On Windows, static libraries typically have a .lib extension, whereas on Linux, static libraries typically have an .a (archive) extension. One advantage of static libraries is that you only have to distribute the executable in order for users to run your program. Because the library becomes part of your program, this ensures that the right version of the library is always used with your program. Also, because static libraries become part of your program, you can use them just like functionality you’ve written for your own program. On the downside, because a copy of the library becomes part of every executable that uses it, this can cause a lot of wasted space. Static libraries also can not be upgraded easy -- to update the library, the entire executable needs to be replaced.</p><p>A <strong>dynamic library</strong> (also called a <strong>shared library</strong>) consists of routines that are loaded into your application at run time. When you compile a program that uses a dynamic library, the library does not become part of your executable -- it remains as a separate unit. On Windows, dynamic libraries typically have a .dll (dynamic link library) extension, whereas on Linux, dynamic libraries typically have a .so (shared object) extension. One advantage of dynamic libraries is that many programs can share one copy, which saves space. Perhaps a bigger advantage is that the dynamic library can be upgraded to a newer version without replacing all of the executables that use it.</p><p>Because dynamic libraries are not linked into your program, programs using dynamic libraries must explicitly load and interface with the dynamic library. This mechanism can be confusing, and makes interfacing with a dynamic library awkward. To make dynamic libraries easier to use, an import library can be used.</p><p>An <strong>import library</strong> is a library that automates the process of loading and using a dynamic library. On Windows, this is typically done via a small static library (.lib) of the same name as the dynamic library (.dll). The static library is linked into the program at compile time, and then the functionality of the dynamic library can effectively be used as if it were a static library. On Linux, the shared object (.so) file doubles as both a dynamic library and an import library. Most linkers can build an import library for a dynamic library when the dynamic library is created.</p><p><strong>Installing and using libraries</strong></p><p>Now that you know about the different kinds of libraries, let’s talk about how to actually use libraries in your program. Installing a library in C++ typically involves 4 steps:</p><ol start="1"><li>Acquire the library. The best option is to download a precompiled package for your operating system (if it exists) so you do not have to compile the library yourself. If there is not one provided for your operating system, you will have to download a source-code-only package and compile it yourself (which is outside of the scope of this lesson). On Windows, libraries are typically distributed as .zip files. On Linux, libraries are typically distributed as packages (e.g. .RPM). Your package manager may have some of the more popular libraries (e.g. SDL) listed already for easy installation, so check there first.</li><li>Install the library. On Linux, this typically involves invoking the package manager and letting it do all the work. On Windows, this typically involves unzipping the library to a directory of your choice. We recommend keeping all your libraries in one location for easy access. For example, use a directory called C:\Libs, and put each library in it’s own subdirectory.</li><li>Make sure the compiler knows where to look for the header file(s) for the library. On Windows, typically this is the include subdirectory of the directory you installed the library files to (e.g. if you installed your library to C:\libs\SDL-1.2.11, the header files are probably in C:\libs\SDL-1.2.11\include). On Linux, header files are typically installed to /usr/include, which should already be part of your include file search path. However, if the files are installed elsewhere, you will have to tell the compiler where to find them.</li><li>Tell the linker where to look for the library file(s). As with step 3, this typically involves adding a directory to the list of places the linker looks for libraries. On Windows, this is typically the /lib subdirectory of the directory you installed the library files to. On Linux, libraries are typically installed to /usr/lib, which should already be a part of your library search path.</li></ol><p>Once the library is installed and the IDE knows where to look for it, the following 3 steps typically need to be performed for each project that wants to use the library:</p><ol start="5"><li>If using static libraries or import libraries, tell the linker which library files to link.</li><li>#include the library’s header file(s) in your program. This tells the compiler about all of the functionality the library is offering so that your program will compile properly.</li><li>If using dynamic libraries, make sure the program knows where to find them. Under Linux, libraries are typically installed to /usr/lib, which is in the default search path after the paths in the <code>LD_LIBRARY_PATH</code> environment variable. On Windows, the default search path includes the directory the program is run from, directories set by calling SetDllDirectory(), the Windows, System, and System32 directories, and directories in the PATH environment variable. The easiest way to use a .dll is to copy the .dll to the location of the executable. Since you’ll typically distribute the .dll with your executable, it makes sense to keep them together anyway.</li></ol><p>Steps 3-5 involve configuring your IDE -- fortunately, almost all IDEs work the same way when it comes to doing these things. Unfortunately, because each IDE has a different interface, the most difficult part of this process is simply locating <em>where</em> the proper place to perform each of these steps is. Consequently, in the next few lessons in this section, we’ll cover how to do all of these steps for both Visual Studio Express 2005 and Code::Blocks. If you are using another IDE, read both -- by the time you’re done, you should have enough information to do the same with your own IDE with a little searching.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">A.2 — Using libraries with Visual Studio</h1></header><div class="entry-content" itemprop="articleBody"><p>To recap the process needed to use a library:</p><p>Once per library:</p><ol start="1"><li>Acquire the library. Download it from the website or via a package manager.</li><li>Install the library. Unzip it to a directory or install it via a package manager.</li></ol><p>Once per project:</p><ol start="3"><li>Tell the compiler where to look for the header file(s) for the library.</li><li>Tell the linker where to look for the library file(s) for the library.</li><li>Tell the linker which static or import library files to link.</li><li>#include the library’s header file(s) in your program.</li><li>Make sure the program know where to find any dynamic libraries being used.</li></ol><p>Note: The examples in this lesson show screenshots from Visual Studio 2005 express, but the process hasn’t changed too substantively since then.</p><p><strong>Steps 1 and 2 -- Acquire and install library</strong></p><p>Download and install the library to your hard disk. See the tutorial on <a href="https://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/">static and dynamic libraries</a> for more information about this step.</p><p><strong>Steps 3 and 4 -- Tell the compiler where to find headers and library files</strong></p><p>A) Go to the Project menu and pick Project -&gt; Properties (it should be at the bottom)</p><p>B) Under the “Configuration” dropdown, make sure that “All configurations” is selected.</p><p>C) In the left window pane, select “Configuration Properties” -&gt; “VC++ Directories”.</p><p>D) On the “Include Directories” line, add the path to the .h files for the library (make sure this is separated from previous entries by a semicolon).</p><p>E) On the “Library Directories”, add the path to the .lib files for the library.</p><p>F) Click “OK”.</p><p><strong>Step 5 -- Tell the linker which libraries your program is using</strong></p><p>For step 5, we need to add .lib files from the library to our project. We do this on an individual project basis.</p><p>A) Go to the Project menu and pick Project -&gt; Properties (it should be at the bottom)</p><p>B) Under the “Configuration” dropdown, make sure that “All configurations” is selected.</p><p>C) In the left window pane, select “Configuration Properties” -&gt; “Linker” -&gt; “Input”.</p><p>D) Add the name of your .lib file to the list of “Additional Dependencies” (separated from previous entries by a semicolon)</p><p>E) Click “OK”.</p><p><strong>Steps 6 and 7 -- #include header files and make sure project can find DLLs</strong></p><p>Simply #include the header file(s) from the library in your project as per usual.</p><p>See the tutorial <a href="https://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/">A1 -- Static and dynamic libraries</a> for more information on step 7.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">A.3 — Using libraries with Code::Blocks</h1></header><div class="entry-content" itemprop="articleBody"><p>To recap the process needed to use a library:</p><p>Once per library:</p><ol start="1"><li>Acquire the library. Download it from the website or via a package manager.</li><li>Install the library. Unzip it to a directory or install it via a package manager.</li><li>Tell the compiler where to look for the header file(s) for the library.</li><li>Tell the linker where to look for the library file(s) for the library.</li></ol><p>Once per project:</p><ol start="5"><li>Tell the linker which static or import library files to link.</li><li>#include the library’s header file(s) in your program.</li><li>Make sure the program know where to find any dynamic libraries being used.</li></ol><p><strong>Steps 1 and 2 -- Acquire and install library</strong></p><p>Download and install the library to your hard disk. See the tutorial on <a href="https://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/">static and dynamic libraries</a> for more information about this step.</p><p><strong>Steps 3 and 4 -- Tell the compiler where to find headers and library files</strong></p><p>We are going to do this on a global basis so the library will be available to all of our projects. Consequently, the following steps only need to be done once per library.</p><p>A) Go to the “Settings menu” and pick “Compiler”.</p><p><img src="https://www.learncpp.com/images/CppTutorial/AppendixA/CB-SettingsMenu.png" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/AppendixA/CB-SettingsMenu.png"></p><p>B) Click the “Directories” tab. The compiler tab will already be selected for you.</p><p>C) Press the “Add” button, and add the path to the .h files for the library. If you are running Linux and installed the library via a package manager, make sure <em>/usr/include</em> is listed here.</p><p><img src="https://www.learncpp.com/images/CppTutorial/AppendixA/CB-CompilerDirectory.png?ezimgfmt=rs%3Adevice%2Frscb2-1" ezimgfmt="rs rscb2 src ng ngcb2" loading="eager" srcset="" sizes="" importance="high"></p><p>D) Click the “Linker” tab. Press the “Add” button, and add the path to the .lib files for the library. If you are running Linux and installed the library via a package manager, make sure <em>/usr/lib</em> is listed here.</p><p><img src="https://www.learncpp.com/images/CppTutorial/AppendixA/CB-LinkerDirectory.png" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/AppendixA/CB-LinkerDirectory.png"></p><p>E) Press the “OK” button.</p><p><strong>Step 5 -- Tell the linker which libraries your program is using</strong></p><p>For step 5, we need to add the library files from the library to our project. We do this on an individual project basis.</p><p>A) Right click on the bolded project name under the default workspace (probably “Console application”, unless you changed it). Choose “Build options” from the menu.</p><p><img src="https://www.learncpp.com/images/CppTutorial/AppendixA/CB-BuildOptions.png" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/AppendixA/CB-BuildOptions.png"></p><p>B) Click the linker tab. Under the “Link libraries” window, press the “Add” button and add the library you wish your project to use.</p><p><img src="https://www.learncpp.com/images/CppTutorial/AppendixA/CB-Library.png" ezimgfmt="rs rscb2 src ng ngcb2" class="ezlazyload" data-ezsrc="https://www.learncpp.com/images/CppTutorial/AppendixA/CB-Library.png"></p><p>C) Press the “OK” button</p><p><strong>Steps 6 and 7 -- #include header files and make sure project can find DLLs</strong></p><p>Simply #include the header file(s) from the library in your project.</p><p>See the tutorial <a href="https://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/">A.1 -- static and dynamic libraries</a> for more information step 7.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">A.4 — C++ FAQ</h1></header><div class="entry-content" itemprop="articleBody"><p><br>There are certain questions that tend to get asked over and over. This FAQ will attempt to answer the most common ones.</p><br><h3>Q: Why shouldn’t we use “using namespace std”? </h3><p>The statement <code>using namespace std;</code> is a <span class="cpp-definition">using directive</span>. Using directives import all of the identifiers from a namespace into the scope of the using directive.</p><p>You may have seen something like this:</p><pre class="language-cpp line-numbers"><code>#include <iostream></iostream></code><code></code><code>using namespace std;</code><code></code><code>int main()</code><code>{</code><code>    cout &lt;&lt; "Hello world!";</code><code></code><code>    return 0;</code><code>}</code></pre><p>This allows us to use names from the <code>std</code> namespace without having to explicitly type <code>std::</code> over and over. In the above program, we can just type <code>cout</code> instead of <code>std::cout</code>. Sounds great, right?</p><p>However, when the compiler encounters <code>using namespace std</code>, it will import every identifier it can find in <code>namespace std</code> into the global scope (since that’s where the using directive has been placed). This introduces 3 key challenges:</p><ul><li>The chance for a naming collision between a name you’ve picked and something that already exists in the <code>std</code> namespace is massively increased.</li><li>New versions of the standard library may break your currently working program. These future versions could introduce names that cause new naming collisions, or in the worst case, the behavior of your program might change silently and unexpectedly!</li><li>The lack of std:: prefixes makes it harder for readers to understand what is a std library name and what is a user-defined name.</li></ul><p>For this reason, we recommend avoiding <code>using namespace std</code> (or any other using directive) entirely. The small savings in typing isn’t worth the additional headaches and future risks.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>See lesson <a href="https://www.learncpp.com/cpp-tutorial/using-declarations-and-using-directives/">6.12 -- Using declarations and using directives</a> for more detail and examples.</p></div><br><h3>Q: Why can I use (some feature) without including header <xxx>? </xxx></h3><p>Headers can #include other headers. So when you include one header, you also get all of the additional headers that it includes (and all of the headers that those headers include too). All of the additional headers that come along for the ride that you didn’t explicitly include are called “transitive includes”.</p><p>For example, your main.cpp file probably #included &lt;iostream&gt;, and on your compiler, &lt;iostream&gt; #included &lt;XXX&gt; (or some other header that #included &lt;XXX&gt;).</p><p>Even though this may compile on your compiler, you should not rely on this. What compiles for you may not compile on another compiler, or even on a future version of your compiler.</p><p>There is no way to warn when this happens, or prevent it from happening. The best you can do is take care to explicitly include the proper headers for all of the things you use. Compiling your program on several different compilers may help identify headers that are being transitively included on other compilers.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>Covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/header-files/">2.11 -- Header files</a>.</p></div><br><h3>Q: Why does (some code that produces undefined behavior) generate a certain result? </h3><p>Undefined behavior occurs when you perform an operation whose behavior is not defined by the C++ language. Code implementing undefined behavior may exhibit any of the following symptoms:</p><ul><li>Your program produces different results every time it is run.</li><li>Your program consistently produces the same incorrect result.</li><li>Your program behaves inconsistently (sometimes produces the correct result, sometimes not).</li><li>Your program seems like its working but produces incorrect results later in the program.</li><li>Your program crashes, either immediately or later.</li><li>Your program works on some compilers but not others.</li><li>Your program works until you change some other seemingly unrelated code.</li></ul><p>Or your code may produce the correct result anyway.</p><p>Readers often ask what is happening to produce a specific result on their system. In most cases, it’s difficult to say, as the result produced may be dependent upon the current program state, your compiler settings, how the compiler implements a feature, the computer’s architecture, and/or the operating system. For example, if you print the value of an uninitialized variable, you might get garbage, or you might always get a particular value. It depends on what type of variable it is, how the compiler lays out the variable in memory, and what’s in that memory beforehand (which might be impacted by the OS or the state of the program prior to that point).</p><p>And while such an answer may be interesting mechanically, it’s rarely useful overall (and likely to change if and when anything else changes). It’s like asking, “When I put my seat belt through the steering wheel and connect it to the accelerator, why does the car pull left when I turn my head on a rainy day?” The best answer isn’t a physical explanation of what’s occurring, it’s “don’t do that”.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>Undefined behavior is covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/uninitialized-variables-and-undefined-behavior/">1.6 -- Uninitialized variables and undefined behavior</a>.</p></div><br><h3>Q: I tried to compile an example that should work, but get a compile error. Why? </h3><p>The most common reason for this is that your project is being compiled using the wrong language standard.</p><p>C++ introduces many new features with each new language standard. If one of our examples uses a feature that was introduced in C++17, but your program is compiling using the C++14 language standard, then it won’t compile because the feature we’re using doesn’t exist. Try setting your language standard to the latest version your compiler supports and see if that resolves the issue.</p><div class="cpp-note cpp-lightgraybackground"><h4>Related content</h4><p>Covered in lesson <a href="https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-choosing-a-language-standard/">0.12 -- Configuring your compiler: Choosing a language standard</a>.</p></div><p>It is also possible that your compiler either doesn’t support a specific feature yet, or has a bug preventing use in some cases. In this case, try updating your compiler to the latest version available.</p></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">B.1 — Introduction to C++11</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>What is C++11?</strong></p><p>On August 12, 2011, the <a href="https://www.iso.org/home.html">ISO (International Organization for Standardization)</a> approved a new version of C++, called C++11. C++11 adds a whole new set of features to the C++ language! Use of these new features is entirely optional -- but you will undoubtedly find some of them helpful. The prior tutorials have all been updated to be C++11 compliant.</p><p><strong>The goals and designs of C++11</strong></p><p>Bjarne Stroustrup characterized the goals of C++11 as such:</p><ul><li>Build on C++’s strengths -- rather than trying to extend C++ to new areas where it may be weaker (eg. Windows applications with heavy GUI), focus on making it do what it does well even better.</li><li>Make C++ easier to learn, use, and teach -- provide functionality that makes the language more consistent and easier to use.</li></ul><p>To that end, the committee that put the language together tried to obey the following general principles:</p><ul><li>Maintain stability and compatibility with older versions of C++ and C wherever possible. Programs that worked under C++03 should generally still work under C++11.</li><li>Keep the number of core language extensions to a minimum, and put the bulk of the changes in the standard library (an objective that wasn’t met very well with this release)</li><li>Focus on improving abstraction mechanisms (classes, templates) rather than adding mechanisms to handle specific, narrow situations.</li><li>Add new functionality for both novices and experts. A little of something for everybody!</li><li>Increase type safety, to prevent inadvertent bugs.</li><li>Improve performance and allow C++ to work directly with hardware.</li><li>Consider usability and ecosystem issues. C++ needs to work well with other tools, be easy to use and teach, etc…</li></ul><p>C++11 isn’t a large departure from C++03 thematically, but it did add a huge amount of new functionality.</p><p><strong>Major new features in C++11</strong></p><p>For your interest, here’s a list of the major features that C++11 adds. Note that this list is not comprehensive, but rather intended to highlight some of the key features of interest.</p><ul><li>auto (<a href="https://www.learncpp.com/cpp-tutorial/type-deduction-for-objects-using-the-auto-keyword/">8.7 -- Type deduction for objects using the auto keyword</a>)</li><li>char16_t and char32_t and new literals to support them (no tutorial yet)</li><li>constexpr (<a href="https://www.learncpp.com/cpp-tutorial/const-variables-and-symbolic-constants/">4.13 -- Const variables and symbolic constants</a>)</li><li>decltype (no tutorial yet)</li><li>default specifier (no tutorial yet)</li><li>Delegating constructors (<a href="https://www.learncpp.com/cpp-tutorial/overlapping-and-delegating-constructors/">13.8 -- Overlapping and delegating constructors</a>)</li><li>delete specifier (<a href="https://www.learncpp.com/cpp-tutorial/converting-constructors-explicit-and-delete/">14.14 -- Converting constructors, explicit, and delete</a>)</li><li>Enum classes (<a href="https://www.learncpp.com/cpp-tutorial/scoped-enumerations-enum-classes/">10.4 -- Scoped enumerations (enum classes)</a>)</li><li>Extern templates (no tutorial yet)</li><li>Lambda expressions (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-lambdas-anonymous-functions/">12.7 -- Introduction to lambdas (anonymous functions)</a>) and captures (<a href="https://www.learncpp.com/cpp-tutorial/lambda-captures/">12.8 -- Lambda captures</a>)</li><li>long long int (<a href="https://www.learncpp.com/cpp-tutorial/object-sizes-and-the-sizeof-operator/">4.3 -- Object sizes and the sizeof operator</a>)</li><li>Move constructor and assignment (<a href="https://www.learncpp.com/cpp-tutorial/move-constructors-and-move-assignment/">M.3 -- Move constructors and move assignment</a>)</li><li>Noexcept specifier (quick mention in <a href="https://www.learncpp.com/cpp-tutorial/uncaught-exceptions-catch-all-handlers/">20.4 -- Uncaught exceptions and catch-all handlers</a>)</li><li>nullptr (<a href="https://www.learncpp.com/cpp-tutorial/null-pointers/">9.7 -- Null pointers</a>)</li><li>override and final specifiers(<a href="https://www.learncpp.com/cpp-tutorial/the-override-and-final-specifiers-and-covariant-return-types/">18.3 -- The override and final specifiers, and covariant return types</a>)</li><li>Range-based for statements (<a href="https://www.learncpp.com/cpp-tutorial/for-each-loops/">11.13 -- For-each loops</a>)</li><li>r-value references (<a href="https://www.learncpp.com/cpp-tutorial/rvalue-references/">M.2 -- R-value references</a>)</li><li>static_assert (<a href="https://www.learncpp.com/cpp-tutorial/assert-and-static_assert/">7.17 -- Assert and static_assert</a>)</li><li>std::initializer_list (<a href="https://www.learncpp.com/cpp-tutorial/stdinitializer_list/">16.7 -- std::initializer_list</a>)</li><li>Trailing return type syntax (<a href="https://www.learncpp.com/cpp-tutorial/type-deduction-for-objects-using-the-auto-keyword/">8.7 -- Type deduction for objects using the auto keyword</a>)</li><li>Type aliases (<a href="https://www.learncpp.com/cpp-tutorial/typedefs-and-type-aliases/">8.6 -- Typedefs and type aliases</a>)</li><li>typedef can now typedef template classes</li><li>Uniform initialization (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-fundamental-data-types/">4.1 -- Introduction to fundamental data types</a>)</li><li>User-defined literals (no tutorial yet)</li><li>Variadic templates (no tutorial yet)</li><li>Two &gt;&gt; symbols without a space between them will now properly be interpreted as closing a template object</li></ul><p>There are also many new classes in the C++ standard library available for use.</p><ul><li>Better support for multi-threading and thread-local storage (no tutorial yet)</li><li>Hash tables (no tutorial yet)</li><li>Random number generation improvements (basic discussion in <a href="https://www.learncpp.com/cpp-tutorial/generating-random-numbers-using-mersenne-twister/">7.19 -- Generating random numbers using Mersenne Twister</a>)</li><li>Reference wrappers (<a href="https://www.learncpp.com/cpp-tutorial/object-slicing/">18.9 -- Object slicing</a>)</li><li>Regular expressions (no tutorial yet)</li><li>std::auto_ptr has been deprecated (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-smart-pointers-move-semantics/">M.1 -- Introduction to smart pointers and move semantics</a>)</li><li>std::tuple (no tutorial yet)</li><li>std::unique_ptr (<a href="https://www.learncpp.com/cpp-tutorial/stdunique_ptr/">M.6 -- std::unique_ptr</a>)</li></ul></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">B.2 — Introduction to C++14</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>What is C++14?</strong></p><p>On August 18, 2014, the <a href="https://www.iso.org/home.html">ISO (International Organization for Standardization)</a> approved a new version of C++, called C++14. Unlike C++11, which added a huge amount of new functionality, C++14 is a comparatively minor update, mainly featuring bug fixes and small improvements.</p><p><strong>New improvements in C++14</strong></p><p>For your interest, here’s a list of the major improvements that C++14 adds. Note that this list is not comprehensive, but rather intended to highlight some of the key improvements of interest.</p><ul><li>Aggregate member initialization (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-structs-members-and-member-selection/">10.5 -- Introduction to structs, members, and member selection</a>)</li><li>Binary literals (<a href="https://www.learncpp.com/cpp-tutorial/literals/">4.15 -- Literals</a>)</li><li>[[deprecated]] attribute (no tutorial yet)</li><li>Digit separators (<a href="https://www.learncpp.com/cpp-tutorial/literals/">4.15 -- Literals</a>)</li><li>Function return type deduction (<a href="https://www.learncpp.com/cpp-tutorial/type-deduction-for-objects-using-the-auto-keyword/">8.7 -- Type deduction for objects using the auto keyword</a>)</li><li>Generic lambdas (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-lambdas-anonymous-functions/">12.7 -- Introduction to lambdas (anonymous functions)</a>)</li><li>Relaxed constexpr functions (<a href="https://www.learncpp.com/cpp-tutorial/constexpr-and-consteval-functions/">6.14 -- Constexpr and consteval functions</a>)</li><li>Variable templates (no tutorial yet)</li><li>std::make_unique (<a href="https://www.learncpp.com/cpp-tutorial/stdunique_ptr/">M.6 -- std::unique_ptr</a>)</li></ul></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">B.3 — Introduction to C++17</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>What is C++17?</strong></p><p>In September of 2017, the <a href="https://www.iso.org/home.html">ISO (International Organization for Standardization)</a> approved a new version of C++, called C++17. C++17 contains a fair amount of new content</p><p><strong>New improvements in C++17</strong></p><p>For your interest, here’s a list of the major improvements that C++17 adds. Note that this list is not comprehensive, but rather intended to highlight some of the key improvements of interest.</p><ul><li>__has_include preprocessor identifier to check if optional header files are available (no tutorial yet)</li><li>if statements that resolve at compile time (no tutorial yet)</li><li>Initializers in if statements and switch statements (no tutorial yet)</li><li>inline variables (<a href="https://www.learncpp.com/cpp-tutorial/sharing-global-constants-across-multiple-files-using-inline-variables/">6.9 -- Sharing global constants across multiple files (using inline variables)</a>)</li><li>Fold expressions (no tutorial yet)</li><li>Nested namespaces can now be defined as namespace X::Y (<a href="https://www.learncpp.com/cpp-tutorial/user-defined-namespaces-and-the-scope-resolution-operator/">6.2 -- User-defined namespaces and the scope resolution operator</a>)</li><li>Removal of std::auto_ptr and some other deprecated types</li><li>static_assert no longer requires a diagnostic text message parameter (<a href="https://www.learncpp.com/cpp-tutorial/assert-and-static_assert/">7.17 -- Assert and static_assert</a>)</li><li>std::any (no tutorial yet)</li><li>std::byte (no tutorial yet)</li><li>std::filesystem (no tutorial yet)</li><li>std::optional (no tutorial yet)</li><li>std::shared_ptr can now manage C-style arrays (but std::make_shared can’t create them yet) (<a href="https://www.learncpp.com/cpp-tutorial/stdshared_ptr/">M.7 -- std::shared_ptr</a>)</li><li>std::size (<a href="https://www.learncpp.com/cpp-tutorial/arrays-part-ii/">11.2 -- Arrays (Part II)</a>)</li><li>std::string_view (<a href="https://www.learncpp.com/cpp-tutorial/introduction-to-stdstring_view/">4.18 -- Introduction to std::string_view</a>)</li><li>Structured binding declarations</li><li>Template deduction for constructors (no tutorial yet)</li><li>Trigraphs have been removed</li><li>typename can now be used (instead of class) in a template template parameter</li><li>UTF-8 (u8) character literals (no tutorial yet)</li></ul></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">B.4 — Introduction to C++20</h1></header><div class="entry-content" itemprop="articleBody"><p><strong>What is C++20?</strong></p><p>In February of 2020, the <a href="https://www.iso.org/home.html">ISO (International Organization for Standardization)</a> approved a new version of C++, called C++20. C++20 contains the most changes to the language since C++11.</p><p><strong>New improvements in C++20</strong></p><p>For your interest, here’s a list of the major improvements that C++20 adds. Note that this list is not comprehensive, but rather intended to highlight some of the key improvements of interest.</p><ul><li>Abbreviated function templates via auto parameters (<a href="https://www.learncpp.com/cpp-tutorial/function-templates-with-multiple-template-types/">8.15 -- Function templates with multiple template types</a>)</li><li>Chrono extensions for calendar and time zone support (no tutorial yet)</li><li>Concepts, which allow you to put constraints on template parameters (no tutorial yet)</li><li>Constexpr virtual functions, unions, try, catch, dynamic_cast, and typeid (no tutorial yet)</li><li>Constinit keyword, to assert that a variable has static initialization (no tutorial yet)</li><li>Coroutines (no tutorial yet)</li><li>Designated initializers (<a href="https://www.learncpp.com/cpp-tutorial/struct-aggregate-initialization/">10.6 -- Struct aggregate initialization</a>)</li><li>Immediate functions using the consteval keyword (<a href="https://www.learncpp.com/cpp-tutorial/constexpr-and-consteval-functions/">6.14 -- Constexpr and consteval functions</a>)</li><li>Modules, a replacement for #include (no tutorial yet)</li><li>Ranges (no tutorial yet)</li><li>std::erase (no tutorial yet)</li><li>std::make_shared for arrays (no tutorial yet)</li><li>std::map::contains() (no tutorial yet)</li><li>std::span (no tutorial yet)</li><li>String formatting library (no tutorial yet, see <a href="https://en.cppreference.com/w/cpp/utility/format">https://en.cppreference.com/w/cpp/utility/format</a>)</li><li>String literals as template parameters (no tutorial yet)</li><li>Three-way comparison using the spaceship operator &lt;=&gt; (no tutorial yet)</li><li>Using scoped enums (no tutorial yet)</li><li>Views (no tutorial yet)</li></ul></div><div style="break-after:page"></div><header><h1 class="entry-title singular-title" itemprop="headline">C.1 — The end?</h1></header><div class="entry-content" itemprop="articleBody"><p>Congratulations! You made it all the way through the tutorials! Take a moment and give yourself a well-deserved (insert something you enjoy here).</p><p>Now, after breathing a long sigh of relief, you’re probably asking the question, “What next?”.</p><p><strong>What next?</strong></p><p>By this point, you should have a solid understanding of the core C++ language. This sets you up well to continue your learning journey into other adjacent areas. So if there’s something you’re really interested in learning about, now’s a good time to see whether you have enough knowledge to jump into that.</p><p>However, for most users, I think there are a few natural next steps.</p><p><strong>Data structures, algorithms, and design patterns</strong></p><p>If you haven’t already learned about these, this is my strongest recommendation.</p><p>A <strong>data structure</strong> is a collection of data and a well defined set of methods to access or manipulate that data. The most common data structure used in programming is the array, which holds a number of elements of the same type in sequential memory. You can manipulate the data inside an array by using array indexing to directly access (or modify) the elements inside the array. In the lessons, we also covered the stack data structure, which provide push, pop, and top functions to access the data on the stack.</p><p>An <strong>algorithm</strong> is a self-contained set of operations that typically manipulate or calculate outputs from the data in a data structure. For example, when you look through an array to find the median value, you’re executing an algorithm. Binary search is an algorithm to determine if a given value exists in a sorted array. Sorting routines (such as selection sort and bubble sort) are algorithms that sort data sets.</p><p>Over the years, mathematicians and computer scientists have come up with a fairly standard set of reusable data structures and algorithms that are useful for constructing more complex programs. These all have various tradeoffs. For example, arrays are fast to access data and sort, but slow to add or remove elements. Linked lists, on the other hand, are slow to access data and sort, but very fast to add or remove elements (if you already know where those elements are).</p><p>Why does it matter? Let’s use an analogy. If you were going to build a house, you could build all of your tools from scratch if you wanted. But it would take a long time, and you’d probably mess quite a few things up and have to start over (ever created a hammer? Me neither). Also, if you use the wrong tool for the job, your quality would suffer (try nailing in nails with a wrench).</p><p>More likely, you’d go to the local hardware store and buy a few tools: a hammer, a level, a carpenter’s square, etc… and then read some internet tutorials on how to use them properly. These would vastly accelerate your house construction efforts.</p><p>Data structures and algorithms serve the same purpose in programming: they are tools that, if you know how to use them, can vastly accelerate how quickly you can get things done at quality.</p><p>The good news is that many of these data structures and algorithms have already been implemented in the standard library. You’ve already encountered some of these in the preceding tutorials: std::array, std::vector, std::stack, std::string, and std::sort, to name a few. Learning to use these effectively and appropriately is a great use of your time.</p><p>If you’re short on time (or patience), learning how to use the most common data structures and algorithms is the minimum you should do. But if you have the inclination, try recreating those data structures yourself, from scratch. It’s really good practice on writing reusable code, and will help you down the road when something you need isn’t in the standard library. But then throw them out, and use the ones in the standard library. :)</p><p>Data structures and algorithms give us good tools for storing and manipulating data. However, there is one more tool that we can add to our toolkit that can help us write better programs. A <strong>design pattern</strong> is a reusable solution to a commonly occurring software design problem.</p><p>For example, we often need to traverse through the elements of some aggregate data structure (like an array or linked list), e.g. to find the largest or smallest value. But having to understand how an aggregate type is implemented to know how to traverse it adds complexity, especially if we have to write separate traversal code for each aggregate type ourselves. Iterators (which we covered earlier in this tutorial series) are a design pattern that provides an interface for traversing different aggregate types in a consistent way, and without having to know how those aggregate types are implemented. And code that is more consistent is easier to understand and less likely to have bugs.</p><p>Here’s another example. Let’s say you are writing an online game, and your program needs to maintain an open connection with a server to send and receive game state updates. Because opening new connections is expensive, you likely will want to ensure your program only has a single global connection object, and prevents the creation of additional server connections (so you do not accidentally create lots of connection objects and overload your server). If you were to look through a reference of common design patterns, you’d discover that there is already a design pattern for ensuring that only a single, global instance of an object can be created (called a singleton). So instead of creating your own (possibly flawed) interface for this, you can implement a battle-tested singleton design pattern that other programmers will likely already be familiar with.</p><p><strong>The C++ standard library</strong></p><p>The bulk of the C++ standard library is data structures and algorithms. However, the standard library contains other things too, and another next step could be to explore those. Among other things, there are numerics (math) libraries, input/output routines, functions to handle localization and regionalization, regular expressions, threading, and file access. Every new release of C++ (which has been happening about every 3 years now) adds a batch of new functionality into the standard library. It isn’t critical that you know how everything in there works, but it’s worth at least being aware of what exists, so that if you happen upon the need for it, you can go learn more as needed. <a href="https://en.cppreference.com/w/cpp">https://cppreference.com/w/cpp</a> is my go-to reference for discovering what exists.</p><p><strong>Graphical applications</strong></p><p>In our tutorial series, we developed console applications, because they’re easy, cross-platform, and don’t require installing additional software. Unlike many modern programming languages, C++ does not come with functionality to create application windows, or to populate those windows with graphical elements or graphical user interface widgets (checkboxes, sliders, etc…). To do those things in C++, you’ll need to enlist the help of a 3rd party library.</p><p>Getting a graphical application up and running requires a few additional steps. First, you’ll need to actually install the 3rd party library and connect it to your IDE, so you can compile it into your program. Most graphical libraries should come with instructions on how to do this for the most popular IDEs. Next, you need to instantiate an OS window, which requires calling certain function from the toolkit. Most, if not all, of the libraries should have sample programs that you can compile and dissect if you’re not sure how to do something basic.</p><p>There are a lot of libraries out there, and which one you should use depends on your requirements (you’ll have to do your own research to determine which one is right for you). Popular choices include Qt, WxWidgets, SDL, and SFML. If you want to do 3d graphics, all of these frameworks support OpenGL, and there are great OpenGL tutorials on the internet.</p><p>Graphical applications typically run differently than console applications. With a console application, the program starts executing at the top of main() and then runs sequentially, usually stopping only for user input. Graphical applications also start executing at the top of main(), typically spawn a window, populate it with graphics or widgets, and then go into an infinite loop waiting for the user to interact with the window (via mouse click or keyboard). This infinite loop is called an event loop, and when a click or keypress happens, that event is routed to the function(s) that handle that type of event. This is called event handling. Once the event is handled, the event loop continues to run, waiting for the next bit of user input.</p><p><strong>TCP/IP / Network programming (aka. the internets)</strong></p><p>These days, it’s pretty rare to find programs that don’t connect to the internet, a back-end server/service, or leverage the cloud in some way. Any program that requires you to have an account and log in is connecting to a server and authenticating a user. Many programs connect to some service to check whether an update is available. Social applications maintain a persistent connection to a social infrastructure, to allow users to communicate with each other on demand. These are examples of networking.</p><p>Networking (broadly) is the concept of having your program connect to other programs, either on your machine, or on network-connected machines, to exchange information. Networking is a powerful tool -- in the past, if you wanted to change the behavior of your application, you had to release an application update. Now, with some good program design, you can simply update information on a server somewhere, and all instances of the program can leverage that change.</p><p>As with many things C++, there are libraries out there to help make your C++ programs network capable. The Asio C++ library is a commonly used one (there are two variants -- a standalone version, and a version that integrates with Boost, which is a library that provides a lot of different functions, much like the standard library).</p><p><strong>Multithreading</strong></p><p>All of the programs we’ve seen in this tutorial series run sequentially. One task is completed, then the next one starts. If a task gets stuck (e.g. you’re asking the user for input and they haven’t entered any yet), the whole program pauses. This is fine for simple academic programs, but not so great for actual applications. Imagine if your program couldn’t handle the user clicking on something because it was busy drawing something on the screen, or if the whole program paused/froze when a network call was happening. The program would feel unresponsive.</p><p>Fortunately, a method exists to allow programs to execute multiple tasks at the same time. This is called threading. Much like how (most of) you can walk and chew bubble gum at the same time, threading allows a program to “split” its attention and do multiple things in parallel.</p><p>For example, some graphical applications (such as web browsers) put the rendering (drawing graphics) portions of the applications on a separate thread, so that updating the screen doesn’t block other things (like accepting user input) while the drawing is happening. Network calls are often done on separate threads, so that if the network call takes a while to resolve, the application doesn’t grind to a halt while it’s waiting.</p><p>Threading is powerful, but it introduces additional complexity, and a lot of room for additional errors. Therefore, I wouldn’t recommend starting here -- but it is a good area to learn about eventually, especially if you want to do complex graphical applications or network programming.</p><p><strong>Improve your fundamentals</strong></p><p>Another option is to spend time improving your understanding of best practices. For this, I highly recommend having a read-through of <a href="https://github.com/isocpp/CppCoreGuidelines">the CPP Core Guidelines</a>, with an optional delving into the <a href="https://github.com/microsoft/GSL">GSL library</a>.</p><p><strong>A good bye!</strong></p><p>At this point, I’d like to take a moment to thank you for stopping by and reading this tutorial series. I hope you enjoyed your time here and have found this site useful. Special thanks to those of you who have helped keep this website a free resource available to everyone by viewing ads that interest you. Please drop by again!</p><p>Good luck (and skill) in your future endeavors, and happy programming! And remember, old programmers never die -- they just go out of scope.</p><p>-Alex</p><p>PS: If you have any feedback or other suggestions for things to explore next, please mention them in the comment section below.</p></div><div style="break-after:page"></div></body></html>